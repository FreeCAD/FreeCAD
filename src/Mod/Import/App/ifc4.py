# This file was generated by fedex_python.  You probably don't want to edit
# it since your modifications will be lost if fedex_plus is used to
# regenerate it.
import sys

from SCL.SCLBase import *
from SCL.SimpleDataTypes import *
from SCL.ConstructedDataTypes import *
from SCL.AggregationDataTypes import *
from SCL.TypeChecker import check_type
from SCL.Builtin import *
from SCL.Rules import *

schema_name = 'ifc4'

schema_scope = sys.modules[__name__]

# Defined datatype ifccardinalpointreference
class ifccardinalpointreference(INTEGER):
	def __init__(self,*kargs):
		pass
		self.greaterthanzero()

	def greaterthanzero(self):
		eval_greaterthanzero_wr = (self  >  0)
		if not eval_greaterthanzero_wr:
			raise AssertionError('Rule greaterthanzero violated')
		else:
			return eval_greaterthanzero_wr

# Defined datatype ifcloadgrouptypeenum
class ifcloadgrouptypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmodulusoflinearsubgradereactionmeasure
class ifcmodulusoflinearsubgradereactionmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdate
class ifcdate(STRING):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifchatchlinedistanceselect
ifchatchlinedistanceselect = SELECT(
	'ifcpositivelengthmeasure',
	'ifcvector',
	scope = schema_scope)
# SELECT TYPE ifcshell
ifcshell = SELECT(
	'ifcclosedshell',
	'ifcopenshell',
	scope = schema_scope)
# Defined datatype ifcprotectivedevicetypeenum
class ifcprotectivedevicetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclanguageid
class ifclanguageid(ifcidentifier):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclinearforcemeasure
class ifclinearforcemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcassemblyplaceenum
class ifcassemblyplaceenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcchimneytypeenum
class ifcchimneytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcroleenum
class ifcroleenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsoundpowermeasure
class ifcsoundpowermeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdistributionporttypeenum
class ifcdistributionporttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsiunitname
class ifcsiunitname(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcairtoairheatrecoverytypeenum
class ifcairtoairheatrecoverytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcsolidorshell
ifcsolidorshell = SELECT(
	'ifcclosedshell',
	'ifcsolidmodel',
	scope = schema_scope)
# Defined datatype ifcanalysistheorytypeenum
class ifcanalysistheorytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcchangeactionenum
class ifcchangeactionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdoorpaneloperationenum
class ifcdoorpaneloperationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctemperaturerateofchangemeasure
class ifctemperaturerateofchangemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwindowpaneloperationenum
class ifcwindowpaneloperationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcslabtypeenum
class ifcslabtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricconductancemeasure
class ifcelectricconductancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifckinematicviscositymeasure
class ifckinematicviscositymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclinearvelocitymeasure
class ifclinearvelocitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsoundpressurelevelmeasure
class ifcsoundpressurelevelmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctimemeasure
class ifctimemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsurfacefeaturetypeenum
class ifcsurfacefeaturetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcfillstyleselect
ifcfillstyleselect = SELECT(
	'ifccolour',
	'ifcexternallydefinedhatchstyle',
	'ifcfillareastylehatching',
	'ifcfillareastyletiles',
	scope = schema_scope)
# SELECT TYPE ifcstructuralactivityassignmentselect
ifcstructuralactivityassignmentselect = SELECT(
	'ifcelement',
	'ifcstructuralitem',
	scope = schema_scope)
# Defined datatype ifcreflectancemethodenum
class ifcreflectancemethodenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctransformertypeenum
class ifctransformertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccsgselect
ifccsgselect = SELECT(
	'ifcbooleanresult',
	'ifccsgprimitive3d',
	scope = schema_scope)
# SELECT TYPE ifcmaterialselect
ifcmaterialselect = SELECT(
	'ifcmaterialdefinition',
	'ifcmateriallist',
	'ifcmaterialusagedefinition',
	scope = schema_scope)
# Defined datatype ifcelectriccapacitancemeasure
class ifcelectriccapacitancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfrequencymeasure
class ifcfrequencymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcidentifier
class ifcidentifier(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdirectionsenseenum
class ifcdirectionsenseenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcvalue
ifcvalue = SELECT(
	'ifcderivedmeasurevalue',
	'ifcmeasurevalue',
	'ifcsimplevalue',
	scope = schema_scope)
# Defined datatype ifcdiscreteaccessorytypeenum
class ifcdiscreteaccessorytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcductsilencertypeenum
class ifcductsilencertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcvoidingfeaturetypeenum
class ifcvoidingfeaturetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclabel
class ifclabel(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcactionsourcetypeenum
class ifcactionsourcetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctendontypeenum
class ifctendontypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpressuremeasure
class ifcpressuremeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctransitioncode
class ifctransitioncode(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcactionrequesttypeenum
class ifcactionrequesttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsystemfurnitureelementtypeenum
class ifcsystemfurnitureelementtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcstyleassignmentselect
ifcstyleassignmentselect = SELECT(
	'ifcpresentationstyle',
	'ifcpresentationstyleassignment',
	scope = schema_scope)
# Defined datatype ifctextalignment
class ifctextalignment(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['left','right','center','justify'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcthermalresistancemeasure
class ifcthermalresistancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricmotortypeenum
class ifcelectricmotortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctanktypeenum
class ifctanktypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcforcemeasure
class ifcforcemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcheatexchangertypeenum
class ifcheatexchangertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccurveonsurface
ifccurveonsurface = SELECT(
	'ifccompositecurveonsurface',
	'ifcpcurve',
	scope = schema_scope)
# Defined datatype ifccoiltypeenum
class ifccoiltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcrotationalmassmeasure
class ifcrotationalmassmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsectionalareaintegralmeasure
class ifcsectionalareaintegralmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclengthmeasure
class ifclengthmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwindowpanelpositionenum
class ifcwindowpanelpositionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcluminousintensitydistributionmeasure
class ifcluminousintensitydistributionmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcrotationalstiffnessmeasure
class ifcrotationalstiffnessmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcanalysismodeltypeenum
class ifcanalysismodeltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsoundpressuremeasure
class ifcsoundpressuremeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccrewresourcetypeenum
class ifccrewresourcetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccolour
ifccolour = SELECT(
	'ifccolourspecification',
	'ifcpredefinedcolour',
	scope = schema_scope)
# Defined datatype ifcspecularroughness
class ifcspecularroughness(REAL):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE ifcappliedvalueselect
ifcappliedvalueselect = SELECT(
	'ifcmeasurewithunit',
	'ifcreference',
	'ifcvalue',
	scope = schema_scope)
# SELECT TYPE ifcclassificationreferenceselect
ifcclassificationreferenceselect = SELECT(
	'ifcclassification',
	'ifcclassificationreference',
	scope = schema_scope)
# Defined datatype ifcproceduretypeenum
class ifcproceduretypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcrecurrencetypeenum
class ifcrecurrencetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcheatingvaluemeasure
class ifcheatingvaluemeasure(REAL):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcinductancemeasure
class ifcinductancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccurtainwalltypeenum
class ifccurtainwalltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmassperlengthmeasure
class ifcmassperlengthmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctexttransformation
class ifctexttransformation(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['capitalize','uppercase','lowercase','none'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcactuatortypeenum
class ifcactuatortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifchumidifiertypeenum
class ifchumidifiertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcconnectiontypeenum
class ifcconnectiontypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccontrollertypeenum
class ifccontrollertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricgeneratortypeenum
class ifcelectricgeneratortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwasteterminaltypeenum
class ifcwasteterminaltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcshearmodulusmeasure
class ifcshearmodulusmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclamptypeenum
class ifclamptypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcresourceobjectselect
ifcresourceobjectselect = SELECT(
	'ifcactorrole',
	'ifcappliedvalue',
	'ifcapproval',
	'ifcconstraint',
	'ifccontextdependentunit',
	'ifcconversionbasedunit',
	'ifcexternalinformation',
	'ifcexternalreference',
	'ifcmaterialdefinition',
	'ifcorganization',
	'ifcperson',
	'ifcpersonandorganization',
	'ifcphysicalquantity',
	'ifcprofiledef',
	'ifcpropertyabstraction',
	'ifctimeseries',
	scope = schema_scope)
# Defined datatype ifcdatetime
class ifcdatetime(STRING):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcpresentationstyleselect
ifcpresentationstyleselect = SELECT(
	'ifccurvestyle',
	'ifcfillareastyle',
	'ifcnullstyle',
	'ifcsurfacestyle',
	'ifctextstyle',
	scope = schema_scope)
# Defined datatype ifcintegercountratemeasure
class ifcintegercountratemeasure(INTEGER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcaddresstypeenum
class ifcaddresstypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcbenchmarkenum
class ifcbenchmarkenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcoccupanttypeenum
class ifcoccupanttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmassdensitymeasure
class ifcmassdensitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccablecarriersegmenttypeenum
class ifccablecarriersegmenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifclightdistributiondatasourceselect
ifclightdistributiondatasourceselect = SELECT(
	'ifcexternalreference',
	'ifclightintensitydistribution',
	scope = schema_scope)
# SELECT TYPE ifcunit
ifcunit = SELECT(
	'ifcderivedunit',
	'ifcmonetaryunit',
	'ifcnamedunit',
	scope = schema_scope)
# Defined datatype ifcmodulusofelasticitymeasure
class ifcmodulusofelasticitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcgridtypeenum
class ifcgridtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcstructuralcurveactivitytypeenum
class ifcstructuralcurveactivitytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcairterminaltypeenum
class ifcairterminaltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcpointorvertexpoint
ifcpointorvertexpoint = SELECT(
	'ifcpoint',
	'ifcvertexpoint',
	scope = schema_scope)
# Defined datatype ifcstructuralsurfaceactivitytypeenum
class ifcstructuralsurfaceactivitytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctransportelementtypeenum
class ifctransportelementtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelementassemblytypeenum
class ifcelementassemblytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdayinweeknumber
class ifcdayinweeknumber(INTEGER):
	def __init__(self,*kargs):
		pass
		self.validrange()

	def validrange(self):
		eval_validrange_wr = ((1  <=  self)  and  (self  <=  7))
		if not eval_validrange_wr:
			raise AssertionError('Rule validrange violated')
		else:
			return eval_validrange_wr

# Defined datatype ifcdocumentstatusenum
class ifcdocumentstatusenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcinterceptortypeenum
class ifcinterceptortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccurvefontorscaledcurvefontselect
ifccurvefontorscaledcurvefontselect = SELECT(
	'ifccurvestylefontandscaling',
	'ifccurvestylefontselect',
	scope = schema_scope)
# Defined datatype ifcspecularexponent
class ifcspecularexponent(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifctextfontselect
ifctextfontselect = SELECT(
	'ifcexternallydefinedtextfont',
	'ifcpredefinedtextfont',
	scope = schema_scope)
# Defined datatype ifcactiontypeenum
class ifcactiontypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdynamicviscositymeasure
class ifcdynamicviscositymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclightemissionsourceenum
class ifclightemissionsourceenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcvolumemeasure
class ifcvolumemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcnullstyle
class ifcnullstyle(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcluminousintensitymeasure
class ifcluminousintensitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmodulusofrotationalsubgradereactionmeasure
class ifcmodulusofrotationalsubgradereactionmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcbuildingelementparttypeenum
class ifcbuildingelementparttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcspaceheatertypeenum
class ifcspaceheatertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmechanicalfastenertypeenum
class ifcmechanicalfastenertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpermittypeenum
class ifcpermittypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpiletypeenum
class ifcpiletypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcstackterminaltypeenum
class ifcstackterminaltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfiltertypeenum
class ifcfiltertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricdistributionboardtypeenum
class ifcelectricdistributionboardtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcabsorbeddosemeasure
class ifcabsorbeddosemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclightdistributioncurveenum
class ifclightdistributioncurveenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcmetricvalueselect
ifcmetricvalueselect = SELECT(
	'ifcappliedvalue',
	'ifcmeasurewithunit',
	'ifcreference',
	'ifctable',
	'ifctimeseries',
	'ifcvalue',
	scope = schema_scope)
# Defined datatype ifcstructuralcurvemembertypeenum
class ifcstructuralcurvemembertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcobjecttypeenum
class ifcobjecttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcgridplacementdirectionselect
ifcgridplacementdirectionselect = SELECT(
	'ifcdirection',
	'ifcvirtualgridintersection',
	scope = schema_scope)
# Defined datatype ifcfantypeenum
class ifcfantypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcgeometricprojectionenum
class ifcgeometricprojectionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcconstructionequipmentresourcetypeenum
class ifcconstructionequipmentresourcetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctrimmingpreference
class ifctrimmingpreference(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcinternalorexternalenum
class ifcinternalorexternalenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcproductrepresentationselect
ifcproductrepresentationselect = SELECT(
	'ifcproductdefinitionshape',
	'ifcrepresentationmap',
	scope = schema_scope)
# Defined datatype ifcthermodynamictemperaturemeasure
class ifcthermodynamictemperaturemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsurfaceside
class ifcsurfaceside(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcenginetypeenum
class ifcenginetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricvoltagemeasure
class ifcelectricvoltagemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwindowstyleconstructionenum
class ifcwindowstyleconstructionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcductfittingtypeenum
class ifcductfittingtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctubebundletypeenum
class ifctubebundletypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccountmeasure
class ifccountmeasure(NUMBER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcrailingtypeenum
class ifcrailingtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcswitchingdevicetypeenum
class ifcswitchingdevicetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcaccelerationmeasure
class ifcaccelerationmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccurvaturemeasure
class ifccurvaturemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcplaneanglemeasure
class ifcplaneanglemeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcsurfaceorfacesurface
ifcsurfaceorfacesurface = SELECT(
	'ifcfacebasedsurfacemodel',
	'ifcfacesurface',
	'ifcsurface',
	scope = schema_scope)
# Defined datatype ifclogicaloperatorenum
class ifclogicaloperatorenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcshadingdevicetypeenum
class ifcshadingdevicetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcmeasurevalue
ifcmeasurevalue = SELECT(
	'ifcamountofsubstancemeasure',
	'ifcareameasure',
	'ifccomplexnumber',
	'ifccontextdependentmeasure',
	'ifccountmeasure',
	'ifcdescriptivemeasure',
	'ifcelectriccurrentmeasure',
	'ifclengthmeasure',
	'ifcluminousintensitymeasure',
	'ifcmassmeasure',
	'ifcnonnegativelengthmeasure',
	'ifcnormalisedratiomeasure',
	'ifcnumericmeasure',
	'ifcparametervalue',
	'ifcplaneanglemeasure',
	'ifcpositivelengthmeasure',
	'ifcpositiveplaneanglemeasure',
	'ifcpositiveratiomeasure',
	'ifcratiomeasure',
	'ifcsolidanglemeasure',
	'ifcthermodynamictemperaturemeasure',
	'ifctimemeasure',
	'ifcvolumemeasure',
	scope = schema_scope)
# SELECT TYPE ifclibraryselect
ifclibraryselect = SELECT(
	'ifclibraryinformation',
	'ifclibraryreference',
	scope = schema_scope)
# Defined datatype ifcparametervalue
class ifcparametervalue(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcthermalconductivitymeasure
class ifcthermalconductivitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccoordinatereferencesystemselect
ifccoordinatereferencesystemselect = SELECT(
	'ifccoordinatereferencesystem',
	'ifcgeometricrepresentationcontext',
	scope = schema_scope)
# Defined datatype ifcsectiontypeenum
class ifcsectiontypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcplanarforcemeasure
class ifcplanarforcemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcprojectionelementtypeenum
class ifcprojectionelementtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcgeometricsetselect
ifcgeometricsetselect = SELECT(
	'ifccurve',
	'ifcpoint',
	'ifcsurface',
	scope = schema_scope)
# Defined datatype ifctaskdurationenum
class ifctaskdurationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcdefinitionselect
ifcdefinitionselect = SELECT(
	'ifcobjectdefinition',
	'ifcpropertydefinition',
	scope = schema_scope)
# Defined datatype ifcmedicaldevicetypeenum
class ifcmedicaldevicetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcareameasure
class ifcareameasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccontextdependentmeasure
class ifccontextdependentmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctextfontname
class ifctextfontname(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclogical
class ifclogical(LOGICAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcthermaladmittancemeasure
class ifcthermaladmittancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcspacetypeenum
class ifcspacetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdoseequivalentmeasure
class ifcdoseequivalentmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcareadensitymeasure
class ifcareadensitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmolecularweightmeasure
class ifcmolecularweightmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccommunicationsappliancetypeenum
class ifccommunicationsappliancetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcobjectreferenceselect
ifcobjectreferenceselect = SELECT(
	'ifcaddress',
	'ifcappliedvalue',
	'ifcexternalreference',
	'ifcmaterialdefinition',
	'ifcorganization',
	'ifcperson',
	'ifcpersonandorganization',
	'ifctable',
	'ifctimeseries',
	scope = schema_scope)
# Defined datatype ifcpowermeasure
class ifcpowermeasure(REAL):
	def __init__(self,*kargs):
		pass

ifcpropertysetdefinitionset = SET(1,None,'ifcpropertysetdefinition', scope = schema_scope)
# Defined datatype ifceventtriggertypeenum
class ifceventtriggertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccurveoredgecurve
ifccurveoredgecurve = SELECT(
	'ifcboundedcurve',
	'ifcedgecurve',
	scope = schema_scope)
# SELECT TYPE ifcmodulusofrotationalsubgradereactionselect
ifcmodulusofrotationalsubgradereactionselect = SELECT(
	'ifcboolean',
	'ifcmodulusofrotationalsubgradereactionmeasure',
	scope = schema_scope)
# Defined datatype ifccoveringtypeenum
class ifccoveringtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcopeningelementtypeenum
class ifcopeningelementtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcunitaryequipmenttypeenum
class ifcunitaryequipmenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcaxis2placement
ifcaxis2placement = SELECT(
	'ifcaxis2placement2d',
	'ifcaxis2placement3d',
	scope = schema_scope)
# Defined datatype ifcbooleanoperator
class ifcbooleanoperator(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccostscheduletypeenum
class ifccostscheduletypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcspatialzonetypeenum
class ifcspatialzonetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfastenertypeenum
class ifcfastenertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpileconstructionenum
class ifcpileconstructionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcderivedunitenum
class ifcderivedunitenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricflowstoragedevicetypeenum
class ifcelectricflowstoragedevicetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcexternalspatialelementtypeenum
class ifcexternalspatialelementtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclightfixturetypeenum
class ifclightfixturetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfontstyle
class ifcfontstyle(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['normal','italic','oblique'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifctime
class ifctime(STRING):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifctrimmingselect
ifctrimmingselect = SELECT(
	'ifccartesianpoint',
	'ifcparametervalue',
	scope = schema_scope)
# Defined datatype ifcamountofsubstancemeasure
class ifcamountofsubstancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcsizeselect
ifcsizeselect = SELECT(
	'ifcdescriptivemeasure',
	'ifclengthmeasure',
	'ifcnormalisedratiomeasure',
	'ifcpositivelengthmeasure',
	'ifcpositiveratiomeasure',
	'ifcratiomeasure',
	scope = schema_scope)
# Defined datatype ifcbeamtypeenum
class ifcbeamtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcnonnegativelengthmeasure
class ifcnonnegativelengthmeasure(ifclengthmeasure):
	def __init__(self,*kargs):
		pass
		self.notnegative()

	def notnegative(self):
		eval_notnegative_wr = (self  >=  0)
		if not eval_notnegative_wr:
			raise AssertionError('Rule notnegative violated')
		else:
			return eval_notnegative_wr

# Defined datatype ifcpumptypeenum
class ifcpumptypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcboxalignment
class ifcboxalignment(ifclabel):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['top-left','top-middle','top-right','middle-left','center','middle-right','bottom-left','bottom-middle','bottom-right'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcelectricchargemeasure
class ifcelectricchargemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcinventorytypeenum
class ifcinventorytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwindowtypepartitioningenum
class ifcwindowtypepartitioningenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwarpingmomentmeasure
class ifcwarpingmomentmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctext
class ifctext(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcairterminalboxtypeenum
class ifcairterminalboxtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcderivedmeasurevalue
ifcderivedmeasurevalue = SELECT(
	'ifcabsorbeddosemeasure',
	'ifcaccelerationmeasure',
	'ifcangularvelocitymeasure',
	'ifcareadensitymeasure',
	'ifccompoundplaneanglemeasure',
	'ifccurvaturemeasure',
	'ifcdoseequivalentmeasure',
	'ifcdynamicviscositymeasure',
	'ifcelectriccapacitancemeasure',
	'ifcelectricchargemeasure',
	'ifcelectricconductancemeasure',
	'ifcelectricresistancemeasure',
	'ifcelectricvoltagemeasure',
	'ifcenergymeasure',
	'ifcforcemeasure',
	'ifcfrequencymeasure',
	'ifcheatfluxdensitymeasure',
	'ifcheatingvaluemeasure',
	'ifcilluminancemeasure',
	'ifcinductancemeasure',
	'ifcintegercountratemeasure',
	'ifcionconcentrationmeasure',
	'ifcisothermalmoisturecapacitymeasure',
	'ifckinematicviscositymeasure',
	'ifclinearforcemeasure',
	'ifclinearmomentmeasure',
	'ifclinearstiffnessmeasure',
	'ifclinearvelocitymeasure',
	'ifcluminousfluxmeasure',
	'ifcluminousintensitydistributionmeasure',
	'ifcmagneticfluxdensitymeasure',
	'ifcmagneticfluxmeasure',
	'ifcmassdensitymeasure',
	'ifcmassflowratemeasure',
	'ifcmassperlengthmeasure',
	'ifcmodulusofelasticitymeasure',
	'ifcmodulusoflinearsubgradereactionmeasure',
	'ifcmodulusofrotationalsubgradereactionmeasure',
	'ifcmodulusofsubgradereactionmeasure',
	'ifcmoisturediffusivitymeasure',
	'ifcmolecularweightmeasure',
	'ifcmomentofinertiameasure',
	'ifcmonetarymeasure',
	'ifcphmeasure',
	'ifcplanarforcemeasure',
	'ifcpowermeasure',
	'ifcpressuremeasure',
	'ifcradioactivitymeasure',
	'ifcrotationalfrequencymeasure',
	'ifcrotationalmassmeasure',
	'ifcrotationalstiffnessmeasure',
	'ifcsectionmodulusmeasure',
	'ifcsectionalareaintegralmeasure',
	'ifcshearmodulusmeasure',
	'ifcsoundpowerlevelmeasure',
	'ifcsoundpowermeasure',
	'ifcsoundpressurelevelmeasure',
	'ifcsoundpressuremeasure',
	'ifcspecificheatcapacitymeasure',
	'ifctemperaturegradientmeasure',
	'ifctemperaturerateofchangemeasure',
	'ifcthermaladmittancemeasure',
	'ifcthermalconductivitymeasure',
	'ifcthermalexpansioncoefficientmeasure',
	'ifcthermalresistancemeasure',
	'ifcthermaltransmittancemeasure',
	'ifctorquemeasure',
	'ifcvaporpermeabilitymeasure',
	'ifcvolumetricflowratemeasure',
	'ifcwarpingconstantmeasure',
	'ifcwarpingmomentmeasure',
	scope = schema_scope)
# Defined datatype ifcgeographicelementtypeenum
class ifcgeographicelementtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcreinforcingbarroleenum
class ifcreinforcingbarroleenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclinearstiffnessmeasure
class ifclinearstiffnessmeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccolourorfactor
ifccolourorfactor = SELECT(
	'ifccolourrgb',
	'ifcnormalisedratiomeasure',
	scope = schema_scope)
# SELECT TYPE ifcvectorordirection
ifcvectorordirection = SELECT(
	'ifcdirection',
	'ifcvector',
	scope = schema_scope)
# Defined datatype ifcisothermalmoisturecapacitymeasure
class ifcisothermalmoisturecapacitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricappliancetypeenum
class ifcelectricappliancetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcworkplantypeenum
class ifcworkplantypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcratiomeasure
class ifcratiomeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfootingtypeenum
class ifcfootingtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfurnituretypeenum
class ifcfurnituretypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcresourceselect
ifcresourceselect = SELECT(
	'ifcresource',
	'ifctyperesource',
	scope = schema_scope)
# Defined datatype ifcplatetypeenum
class ifcplatetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcsimplevalue
ifcsimplevalue = SELECT(
	'ifcboolean',
	'ifcdate',
	'ifcdatetime',
	'ifcduration',
	'ifcidentifier',
	'ifcinteger',
	'ifclabel',
	'ifclogical',
	'ifcreal',
	'ifctext',
	'ifctime',
	'ifctimestamp',
	scope = schema_scope)
# Defined datatype ifcinteger
class ifcinteger(INTEGER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcthermalexpansioncoefficientmeasure
class ifcthermalexpansioncoefficientmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctendonanchortypeenum
class ifctendonanchortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpositiveplaneanglemeasure
class ifcpositiveplaneanglemeasure(ifcplaneanglemeasure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifccooledbeamtypeenum
class ifccooledbeamtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdimensioncount
class ifcdimensioncount(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <  self)  and  (self  <=  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcmassmeasure
class ifcmassmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdataoriginenum
class ifcdataoriginenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcphysicalorvirtualenum
class ifcphysicalorvirtualenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpermeablecoveringoperationenum
class ifcpermeablecoveringoperationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcstairflighttypeenum
class ifcstairflighttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcjunctionboxtypeenum
class ifcjunctionboxtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifctranslationalstiffnessselect
ifctranslationalstiffnessselect = SELECT(
	'ifcboolean',
	'ifclinearstiffnessmeasure',
	scope = schema_scope)
# Defined datatype ifctorquemeasure
class ifctorquemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcglobalorlocalenum
class ifcglobalorlocalenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmoisturediffusivitymeasure
class ifcmoisturediffusivitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdistributionchamberelementtypeenum
class ifcdistributionchamberelementtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcduration
class ifcduration(STRING):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcspaceboundaryselect
ifcspaceboundaryselect = SELECT(
	'ifcexternalspatialelement',
	'ifcspace',
	scope = schema_scope)
# Defined datatype ifctextpath
class ifctextpath(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcunitenum
class ifcunitenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcvalvetypeenum
class ifcvalvetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpresentabletext
class ifcpresentabletext(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccompressortypeenum
class ifccompressortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctimeseriesdatatypeenum
class ifctimeseriesdatatypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcspecularhighlightselect
ifcspecularhighlightselect = SELECT(
	'ifcspecularexponent',
	'ifcspecularroughness',
	scope = schema_scope)
# Defined datatype ifcdayinmonthnumber
class ifcdayinmonthnumber(INTEGER):
	def __init__(self,*kargs):
		pass
		self.validrange()

	def validrange(self):
		eval_validrange_wr = ((1  <=  self)  and  (self  <=  31))
		if not eval_validrange_wr:
			raise AssertionError('Rule validrange violated')
		else:
			return eval_validrange_wr

# Defined datatype ifcconstructionmaterialresourcetypeenum
class ifcconstructionmaterialresourcetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcspecificheatcapacitymeasure
class ifcspecificheatcapacitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcenergymeasure
class ifcenergymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectriccurrentmeasure
class ifcelectriccurrentmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcburnertypeenum
class ifcburnertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifclayereditem
ifclayereditem = SELECT(
	'ifcrepresentation',
	'ifcrepresentationitem',
	scope = schema_scope)
# Defined datatype ifcluminousfluxmeasure
class ifcluminousfluxmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsensortypeenum
class ifcsensortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsequenceenum
class ifcsequenceenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdescriptivemeasure
class ifcdescriptivemeasure(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelementcompositionenum
class ifcelementcompositionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcmodulusofsubgradereactionselect
ifcmodulusofsubgradereactionselect = SELECT(
	'ifcboolean',
	'ifcmodulusofsubgradereactionmeasure',
	scope = schema_scope)
# Defined datatype ifcthermaltransmittancemeasure
class ifcthermaltransmittancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcreinforcingmeshtypeenum
class ifcreinforcingmeshtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcreal
class ifcreal(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcconstraintenum
class ifcconstraintenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdoorpanelpositionenum
class ifcdoorpanelpositionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcflowdirectionenum
class ifcflowdirectionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcbsplinesurfaceform
class ifcbsplinesurfaceform(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsiprefix
class ifcsiprefix(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcboilertypeenum
class ifcboilertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmagneticfluxdensitymeasure
class ifcmagneticfluxdensitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccoolingtowertypeenum
class ifccoolingtowertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcboolean
class ifcboolean(BOOLEAN):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcbuildingelementproxytypeenum
class ifcbuildingelementproxytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcangularvelocitymeasure
class ifcangularvelocitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmonetarymeasure
class ifcmonetarymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmonthinyearnumber
class ifcmonthinyearnumber(INTEGER):
	def __init__(self,*kargs):
		pass
		self.validrange()

	def validrange(self):
		eval_validrange_wr = ((1  <=  self)  and  (self  <=  12))
		if not eval_validrange_wr:
			raise AssertionError('Rule validrange violated')
		else:
			return eval_validrange_wr

# Defined datatype ifcsectionmodulusmeasure
class ifcsectionmodulusmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdistributionsystemenum
class ifcdistributionsystemenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdoorstyleconstructionenum
class ifcdoorstyleconstructionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifceventtypeenum
class ifceventtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcrooftypeenum
class ifcrooftypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsanitaryterminaltypeenum
class ifcsanitaryterminaltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdocumentconfidentialityenum
class ifcdocumentconfidentialityenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfiresuppressionterminaltypeenum
class ifcfiresuppressionterminaltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsubcontractresourcetypeenum
class ifcsubcontractresourcetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcpropertysetdefinitionselect
ifcpropertysetdefinitionselect = SELECT(
	'ifcpropertysetdefinition',
	'ifcpropertysetdefinitionset',
	scope = schema_scope)
# Defined datatype ifcradioactivitymeasure
class ifcradioactivitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmomentofinertiameasure
class ifcmomentofinertiameasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclaborresourcetypeenum
class ifclaborresourcetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwarpingconstantmeasure
class ifcwarpingconstantmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcknottype
class ifcknottype(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcheatfluxdensitymeasure
class ifcheatfluxdensitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcurireference
class ifcurireference(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcbuildingsystemtypeenum
class ifcbuildingsystemtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwindowtypeenum
class ifcwindowtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcvaporpermeabilitymeasure
class ifcvaporpermeabilitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsolardevicetypeenum
class ifcsolardevicetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcvibrationisolatortypeenum
class ifcvibrationisolatortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcbooleanoperand
ifcbooleanoperand = SELECT(
	'ifcbooleanresult',
	'ifccsgprimitive3d',
	'ifchalfspacesolid',
	'ifcsolidmodel',
	scope = schema_scope)
# Defined datatype ifcflowinstrumenttypeenum
class ifcflowinstrumenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfontvariant
class ifcfontvariant(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['normal','small-caps'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifccostitemtypeenum
class ifccostitemtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcprofiletypeenum
class ifcprofiletypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcactorselect
ifcactorselect = SELECT(
	'ifcorganization',
	'ifcperson',
	'ifcpersonandorganization',
	scope = schema_scope)
# Defined datatype ifcmagneticfluxmeasure
class ifcmagneticfluxmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccomplexpropertytemplatetypeenum
class ifccomplexpropertytemplatetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcworkscheduletypeenum
class ifcworkscheduletypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcgloballyuniqueid
class ifcgloballyuniqueid(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcevaporativecoolertypeenum
class ifcevaporativecoolertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcprotectivedevicetrippingunittypeenum
class ifcprotectivedevicetrippingunittypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfontweight
class ifcfontweight(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['normal','small-caps','100','200','300','400','500','600','700','800','900'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcchillertypeenum
class ifcchillertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdoortypeenum
class ifcdoortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcalarmtypeenum
class ifcalarmtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccablecarrierfittingtypeenum
class ifccablecarrierfittingtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctasktypeenum
class ifctasktypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifctimeorratioselect
ifctimeorratioselect = SELECT(
	'ifcduration',
	'ifcratiomeasure',
	scope = schema_scope)
# SELECT TYPE ifcwarpingstiffnessselect
ifcwarpingstiffnessselect = SELECT(
	'ifcboolean',
	'ifcwarpingmomentmeasure',
	scope = schema_scope)
# Defined datatype ifccolumntypeenum
class ifccolumntypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcperformancehistorytypeenum
class ifcperformancehistorytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcprojectordertypeenum
class ifcprojectordertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcramptypeenum
class ifcramptypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcstateenum
class ifcstateenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpipesegmenttypeenum
class ifcpipesegmenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcnormalisedratiomeasure
class ifcnormalisedratiomeasure(ifcratiomeasure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcreinforcingbarsurfaceenum
class ifcreinforcingbarsurfaceenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpositivelengthmeasure
class ifcpositivelengthmeasure(ifclengthmeasure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcdampertypeenum
class ifcdampertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclayersetdirectionenum
class ifclayersetdirectionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpropertysettemplatetypeenum
class ifcpropertysettemplatetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcaudiovisualappliancetypeenum
class ifcaudiovisualappliancetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpipefittingtypeenum
class ifcpipefittingtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccurvestylefontselect
ifccurvestylefontselect = SELECT(
	'ifccurvestylefont',
	'ifcpredefinedcurvefont',
	scope = schema_scope)
# Defined datatype ifcstairtypeenum
class ifcstairtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

ifccomplexnumber = ARRAY(1,2,'REAL', scope = schema_scope)
ifccompoundplaneanglemeasure = LIST(3,4,'INTEGER', scope = schema_scope)
# Defined datatype ifcevaporatortypeenum
class ifcevaporatortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmembertypeenum
class ifcmembertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcbendingparameterselect
ifcbendingparameterselect = SELECT(
	'ifclengthmeasure',
	'ifcplaneanglemeasure',
	scope = schema_scope)
# Defined datatype ifcflowmetertypeenum
class ifcflowmetertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcprojectedortruelengthenum
class ifcprojectedortruelengthenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpositiveratiomeasure
class ifcpositiveratiomeasure(ifcratiomeasure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcobjectiveenum
class ifcobjectiveenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcrotationalstiffnessselect
ifcrotationalstiffnessselect = SELECT(
	'ifcboolean',
	'ifcrotationalstiffnessmeasure',
	scope = schema_scope)
# Defined datatype ifcrotationalfrequencymeasure
class ifcrotationalfrequencymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcvolumetricflowratemeasure
class ifcvolumetricflowratemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcunitarycontrolelementtypeenum
class ifcunitarycontrolelementtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwindowstyleoperationenum
class ifcwindowstyleoperationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcclassificationselect
ifcclassificationselect = SELECT(
	'ifcclassification',
	'ifcclassificationreference',
	scope = schema_scope)
# Defined datatype ifclinearmomentmeasure
class ifclinearmomentmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcphmeasure
class ifcphmeasure(REAL):
	def __init__(self,*kargs):
		pass
		self.wr21()

	def wr21(self):
		eval_wr21_wr = ((0  <=  self)  and  (self  <=  14))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

# Defined datatype ifccondensertypeenum
class ifccondensertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcproductselect
ifcproductselect = SELECT(
	'ifcproduct',
	'ifctypeproduct',
	scope = schema_scope)
# Defined datatype ifcmotorconnectiontypeenum
class ifcmotorconnectiontypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsimplepropertytemplatetypeenum
class ifcsimplepropertytemplatetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcprocessselect
ifcprocessselect = SELECT(
	'ifcprocess',
	'ifctypeprocess',
	scope = schema_scope)
# Defined datatype ifcmodulusofsubgradereactionmeasure
class ifcmodulusofsubgradereactionmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsolidanglemeasure
class ifcsolidanglemeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcmodulusoftranslationalsubgradereactionselect
ifcmodulusoftranslationalsubgradereactionselect = SELECT(
	'ifcboolean',
	'ifcmodulusoflinearsubgradereactionmeasure',
	scope = schema_scope)
# Defined datatype ifcwalltypeenum
class ifcwalltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcdocumentselect
ifcdocumentselect = SELECT(
	'ifcdocumentinformation',
	'ifcdocumentreference',
	scope = schema_scope)
# Defined datatype ifcdoorstyleoperationenum
class ifcdoorstyleoperationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcductsegmenttypeenum
class ifcductsegmenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcionconcentrationmeasure
class ifcionconcentrationmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcnumericmeasure
class ifcnumericmeasure(NUMBER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccablefittingtypeenum
class ifccablefittingtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmassflowratemeasure
class ifcmassflowratemeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcsurfacestyleelementselect
ifcsurfacestyleelementselect = SELECT(
	'ifcexternallydefinedsurfacestyle',
	'ifcsurfacestylelighting',
	'ifcsurfacestylerefraction',
	'ifcsurfacestyleshading',
	'ifcsurfacestylewithtextures',
	scope = schema_scope)
# Defined datatype ifcreinforcingbartypeenum
class ifcreinforcingbartypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcconstructionproductresourcetypeenum
class ifcconstructionproductresourcetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccurveinterpolationenum
class ifccurveinterpolationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcoutlettypeenum
class ifcoutlettypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsoundpowerlevelmeasure
class ifcsoundpowerlevelmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctemperaturegradientmeasure
class ifctemperaturegradientmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctextdecoration
class ifctextdecoration(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['none','underline','overline','line-through','blink'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifctimestamp
class ifctimestamp(INTEGER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccablesegmenttypeenum
class ifccablesegmenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdoortypeoperationenum
class ifcdoortypeoperationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcarithmeticoperatorenum
class ifcarithmeticoperatorenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcworkcalendartypeenum
class ifcworkcalendartypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcstructuralsurfacemembertypeenum
class ifcstructuralsurfacemembertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricresistancemeasure
class ifcelectricresistancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcilluminancemeasure
class ifcilluminancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcrampflighttypeenum
class ifcrampflighttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcbsplinecurveform
class ifcbsplinecurveform(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectrictimecontroltypeenum
class ifcelectrictimecontroltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass


####################
 # ENTITY ifcroot #
####################
class ifcroot(BaseEntityClass):
	'''Entity ifcroot definition.

	:param globalid
	:type globalid:ifcgloballyuniqueid

	:param ownerhistory
	:type ownerhistory:ifcownerhistory

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext
	'''
	def __init__( self , globalid,ownerhistory,name,description, ):
		self.globalid = globalid
		self.ownerhistory = ownerhistory
		self.name = name
		self.description = description

	@apply
	def globalid():
		def fget( self ):
			return self._globalid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument globalid is mantatory and can not be set to None')
			if not check_type(value,ifcgloballyuniqueid):
				self._globalid = ifcgloballyuniqueid(value)
			else:
				self._globalid = value
		return property(**locals())

	@apply
	def ownerhistory():
		def fget( self ):
			return self._ownerhistory
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcownerhistory):
					self._ownerhistory = ifcownerhistory(value)
				else:
					self._ownerhistory = value
			else:
				self._ownerhistory = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY ifcrelationship #
####################
class ifcrelationship(ifcroot):
	'''Entity ifcrelationship definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcroot.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

####################
 # ENTITY ifcrelconnects #
####################
class ifcrelconnects(ifcrelationship):
	'''Entity ifcrelconnects definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcrelationship.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

####################
 # ENTITY ifcrelspaceboundary #
####################
class ifcrelspaceboundary(ifcrelconnects):
	'''Entity ifcrelspaceboundary definition.

	:param relatingspace
	:type relatingspace:ifcspaceboundaryselect

	:param relatedbuildingelement
	:type relatedbuildingelement:ifcelement

	:param connectiongeometry
	:type connectiongeometry:ifcconnectiongeometry

	:param physicalorvirtualboundary
	:type physicalorvirtualboundary:ifcphysicalorvirtualenum

	:param internalorexternalboundary
	:type internalorexternalboundary:ifcinternalorexternalenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingspace,relatedbuildingelement,connectiongeometry,physicalorvirtualboundary,internalorexternalboundary, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingspace = relatingspace
		self.relatedbuildingelement = relatedbuildingelement
		self.connectiongeometry = connectiongeometry
		self.physicalorvirtualboundary = physicalorvirtualboundary
		self.internalorexternalboundary = internalorexternalboundary

	@apply
	def relatingspace():
		def fget( self ):
			return self._relatingspace
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingspace is mantatory and can not be set to None')
			if not check_type(value,ifcspaceboundaryselect):
				self._relatingspace = ifcspaceboundaryselect(value)
			else:
				self._relatingspace = value
		return property(**locals())

	@apply
	def relatedbuildingelement():
		def fget( self ):
			return self._relatedbuildingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedbuildingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatedbuildingelement = ifcelement(value)
			else:
				self._relatedbuildingelement = value
		return property(**locals())

	@apply
	def connectiongeometry():
		def fget( self ):
			return self._connectiongeometry
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcconnectiongeometry):
					self._connectiongeometry = ifcconnectiongeometry(value)
				else:
					self._connectiongeometry = value
			else:
				self._connectiongeometry = value
		return property(**locals())

	@apply
	def physicalorvirtualboundary():
		def fget( self ):
			return self._physicalorvirtualboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument physicalorvirtualboundary is mantatory and can not be set to None')
			if not check_type(value,ifcphysicalorvirtualenum):
				self._physicalorvirtualboundary = ifcphysicalorvirtualenum(value)
			else:
				self._physicalorvirtualboundary = value
		return property(**locals())

	@apply
	def internalorexternalboundary():
		def fget( self ):
			return self._internalorexternalboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument internalorexternalboundary is mantatory and can not be set to None')
			if not check_type(value,ifcinternalorexternalenum):
				self._internalorexternalboundary = ifcinternalorexternalenum(value)
			else:
				self._internalorexternalboundary = value
		return property(**locals())
	def correctphysorvirt(self):
		eval_correctphysorvirt_wr = ((((self.physicalorvirtualboundary  ==  ifcphysicalorvirtualenum.self.physical)  and  ( not ('IFC4.IFCVIRTUALELEMENT'  ==  TYPEOF(self.relatedbuildingelement))))  or  ((self.physicalorvirtualboundary  ==  ifcphysicalorvirtualenum.self.virtual)  and  (('IFC4.IFCVIRTUALELEMENT'  ==  TYPEOF(self.relatedbuildingelement))  or  ('IFC4.IFCOPENINGELEMENT'  ==  TYPEOF(self.relatedbuildingelement)))))  or  (self.physicalorvirtualboundary  ==  ifcphysicalorvirtualenum.self.notdefined))
		if not eval_correctphysorvirt_wr:
			raise AssertionError('Rule correctphysorvirt violated')
		else:
			return eval_correctphysorvirt_wr


####################
 # ENTITY ifcrelspaceboundary1stlevel #
####################
class ifcrelspaceboundary1stlevel(ifcrelspaceboundary):
	'''Entity ifcrelspaceboundary1stlevel definition.

	:param parentboundary
	:type parentboundary:ifcrelspaceboundary1stlevel

	:param innerboundaries
	:type innerboundaries:SET(0,None,'ifcrelspaceboundary1stlevel', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingspace , inherited5__relatedbuildingelement , inherited6__connectiongeometry , inherited7__physicalorvirtualboundary , inherited8__internalorexternalboundary , parentboundary, ):
		ifcrelspaceboundary.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingspace , inherited5__relatedbuildingelement , inherited6__connectiongeometry , inherited7__physicalorvirtualboundary , inherited8__internalorexternalboundary , )
		self.parentboundary = parentboundary

	@apply
	def parentboundary():
		def fget( self ):
			return self._parentboundary
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrelspaceboundary1stlevel):
					self._parentboundary = ifcrelspaceboundary1stlevel(value)
				else:
					self._parentboundary = value
			else:
				self._parentboundary = value
		return property(**locals())

	@apply
	def innerboundaries():
		def fget( self ):
			return self._innerboundaries
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument innerboundaries is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcrelspaceboundary2ndlevel #
####################
class ifcrelspaceboundary2ndlevel(ifcrelspaceboundary1stlevel):
	'''Entity ifcrelspaceboundary2ndlevel definition.

	:param correspondingboundary
	:type correspondingboundary:ifcrelspaceboundary2ndlevel

	:param corresponds
	:type corresponds:SET(0,1,'ifcrelspaceboundary2ndlevel', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingspace , inherited5__relatedbuildingelement , inherited6__connectiongeometry , inherited7__physicalorvirtualboundary , inherited8__internalorexternalboundary , inherited9__parentboundary , correspondingboundary, ):
		ifcrelspaceboundary1stlevel.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingspace , inherited5__relatedbuildingelement , inherited6__connectiongeometry , inherited7__physicalorvirtualboundary , inherited8__internalorexternalboundary , inherited9__parentboundary , )
		self.correspondingboundary = correspondingboundary

	@apply
	def correspondingboundary():
		def fget( self ):
			return self._correspondingboundary
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrelspaceboundary2ndlevel):
					self._correspondingboundary = ifcrelspaceboundary2ndlevel(value)
				else:
					self._correspondingboundary = value
			else:
				self._correspondingboundary = value
		return property(**locals())

	@apply
	def corresponds():
		def fget( self ):
			return self._corresponds
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument corresponds is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcobjectdefinition #
####################
class ifcobjectdefinition(ifcroot):
	'''Entity ifcobjectdefinition definition.

	:param hasassignments
	:type hasassignments:SET(0,None,'ifcrelassigns', scope = schema_scope)

	:param nests
	:type nests:SET(0,1,'ifcrelnests', scope = schema_scope)

	:param isnestedby
	:type isnestedby:SET(0,None,'ifcrelnests', scope = schema_scope)

	:param hascontext
	:type hascontext:SET(0,1,'ifcreldeclares', scope = schema_scope)

	:param isdecomposedby
	:type isdecomposedby:SET(0,None,'ifcrelaggregates', scope = schema_scope)

	:param decomposes
	:type decomposes:SET(0,1,'ifcrelaggregates', scope = schema_scope)

	:param hasassociations
	:type hasassociations:SET(0,None,'ifcrelassociates', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcroot.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

	@apply
	def hasassignments():
		def fget( self ):
			return self._hasassignments
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasassignments is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def nests():
		def fget( self ):
			return self._nests
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument nests is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isnestedby():
		def fget( self ):
			return self._isnestedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isnestedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hascontext():
		def fget( self ):
			return self._hascontext
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hascontext is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isdecomposedby():
		def fget( self ):
			return self._isdecomposedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isdecomposedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def decomposes():
		def fget( self ):
			return self._decomposes
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument decomposes is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasassociations():
		def fget( self ):
			return self._hasassociations
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasassociations is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcobject #
####################
class ifcobject(ifcobjectdefinition):
	'''Entity ifcobject definition.

	:param objecttype
	:type objecttype:ifclabel

	:param isdeclaredby
	:type isdeclaredby:SET(0,1,'ifcreldefinesbyobject', scope = schema_scope)

	:param declares
	:type declares:SET(0,None,'ifcreldefinesbyobject', scope = schema_scope)

	:param istypedby
	:type istypedby:SET(0,1,'ifcreldefinesbytype', scope = schema_scope)

	:param isdefinedby
	:type isdefinedby:SET(0,None,'ifcreldefinesbyproperties', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , objecttype, ):
		ifcobjectdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.objecttype = objecttype

	@apply
	def objecttype():
		def fget( self ):
			return self._objecttype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._objecttype = ifclabel(value)
				else:
					self._objecttype = value
			else:
				self._objecttype = value
		return property(**locals())

	@apply
	def isdeclaredby():
		def fget( self ):
			return self._isdeclaredby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isdeclaredby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def declares():
		def fget( self ):
			return self._declares
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument declares is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def istypedby():
		def fget( self ):
			return self._istypedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument istypedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isdefinedby():
		def fget( self ):
			return self._isdefinedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isdefinedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcproduct #
####################
class ifcproduct(ifcobject):
	'''Entity ifcproduct definition.

	:param objectplacement
	:type objectplacement:ifcobjectplacement

	:param representation
	:type representation:ifcproductrepresentation

	:param referencedby
	:type referencedby:SET(0,None,'ifcrelassignstoproduct', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , objectplacement,representation, ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.objectplacement = objectplacement
		self.representation = representation

	@apply
	def objectplacement():
		def fget( self ):
			return self._objectplacement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcobjectplacement):
					self._objectplacement = ifcobjectplacement(value)
				else:
					self._objectplacement = value
			else:
				self._objectplacement = value
		return property(**locals())

	@apply
	def representation():
		def fget( self ):
			return self._representation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcproductrepresentation):
					self._representation = ifcproductrepresentation(value)
				else:
					self._representation = value
			else:
				self._representation = value
		return property(**locals())

	@apply
	def referencedby():
		def fget( self ):
			return self._referencedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referencedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def placementforshaperepresentation(self):
		eval_placementforshaperepresentation_wr = (((EXISTS(self.representation)  and  EXISTS(self.objectplacement))  or  (EXISTS(self.representation)  and  (SIZEOF(None)  ==  0)))  or  ( not EXISTS(self.representation)))
		if not eval_placementforshaperepresentation_wr:
			raise AssertionError('Rule placementforshaperepresentation violated')
		else:
			return eval_placementforshaperepresentation_wr


####################
 # ENTITY ifcstructuralactivity #
####################
class ifcstructuralactivity(ifcproduct):
	'''Entity ifcstructuralactivity definition.

	:param appliedload
	:type appliedload:ifcstructuralload

	:param globalorlocal
	:type globalorlocal:ifcglobalorlocalenum

	:param assignedtostructuralitem
	:type assignedtostructuralitem:SET(0,1,'ifcrelconnectsstructuralactivity', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , appliedload,globalorlocal, ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.appliedload = appliedload
		self.globalorlocal = globalorlocal

	@apply
	def appliedload():
		def fget( self ):
			return self._appliedload
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument appliedload is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralload):
				self._appliedload = ifcstructuralload(value)
			else:
				self._appliedload = value
		return property(**locals())

	@apply
	def globalorlocal():
		def fget( self ):
			return self._globalorlocal
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument globalorlocal is mantatory and can not be set to None')
			if not check_type(value,ifcglobalorlocalenum):
				self._globalorlocal = ifcglobalorlocalenum(value)
			else:
				self._globalorlocal = value
		return property(**locals())

	@apply
	def assignedtostructuralitem():
		def fget( self ):
			return self._assignedtostructuralitem
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument assignedtostructuralitem is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstructuralreaction #
####################
class ifcstructuralreaction(ifcstructuralactivity):
	'''Entity ifcstructuralreaction definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal ,  ):
		ifcstructuralactivity.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , )

####################
 # ENTITY ifcstructuralcurvereaction #
####################
class ifcstructuralcurvereaction(ifcstructuralreaction):
	'''Entity ifcstructuralcurvereaction definition.

	:param predefinedtype
	:type predefinedtype:ifcstructuralcurveactivitytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , predefinedtype, ):
		ifcstructuralreaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralcurveactivitytypeenum):
				self._predefinedtype = ifcstructuralcurveactivitytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def hasobjecttype(self):
		eval_hasobjecttype_wr = ((self.predefinedtype  !=  ifcstructuralcurveactivitytypeenum.self.userdefined)  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_hasobjecttype_wr:
			raise AssertionError('Rule hasobjecttype violated')
		else:
			return eval_hasobjecttype_wr

	def suitablepredefinedtype(self):
		eval_suitablepredefinedtype_wr = ((self.predefinedtype  !=  ifcstructuralcurveactivitytypeenum.self.sinus)  and  (self.predefinedtype  !=  ifcstructuralcurveactivitytypeenum.self.parabola))
		if not eval_suitablepredefinedtype_wr:
			raise AssertionError('Rule suitablepredefinedtype violated')
		else:
			return eval_suitablepredefinedtype_wr


####################
 # ENTITY ifcelement #
####################
class ifcelement(ifcproduct):
	'''Entity ifcelement definition.

	:param tag
	:type tag:ifcidentifier

	:param fillsvoids
	:type fillsvoids:SET(0,1,'ifcrelfillselement', scope = schema_scope)

	:param connectedto
	:type connectedto:SET(0,None,'ifcrelconnectselements', scope = schema_scope)

	:param isinterferedbyelements
	:type isinterferedbyelements:SET(0,None,'ifcrelinterfereselements', scope = schema_scope)

	:param interfereselements
	:type interfereselements:SET(0,None,'ifcrelinterfereselements', scope = schema_scope)

	:param hasprojections
	:type hasprojections:SET(0,None,'ifcrelprojectselement', scope = schema_scope)

	:param referencedinstructures
	:type referencedinstructures:SET(0,None,'ifcrelreferencedinspatialstructure', scope = schema_scope)

	:param hasopenings
	:type hasopenings:SET(0,None,'ifcrelvoidselement', scope = schema_scope)

	:param isconnectionrealization
	:type isconnectionrealization:SET(0,None,'ifcrelconnectswithrealizingelements', scope = schema_scope)

	:param providesboundaries
	:type providesboundaries:SET(0,None,'ifcrelspaceboundary', scope = schema_scope)

	:param connectedfrom
	:type connectedfrom:SET(0,None,'ifcrelconnectselements', scope = schema_scope)

	:param containedinstructure
	:type containedinstructure:SET(0,1,'ifcrelcontainedinspatialstructure', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , tag, ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.tag = tag

	@apply
	def tag():
		def fget( self ):
			return self._tag
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._tag = ifcidentifier(value)
				else:
					self._tag = value
			else:
				self._tag = value
		return property(**locals())

	@apply
	def fillsvoids():
		def fget( self ):
			return self._fillsvoids
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument fillsvoids is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def connectedto():
		def fget( self ):
			return self._connectedto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectedto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isinterferedbyelements():
		def fget( self ):
			return self._isinterferedbyelements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isinterferedbyelements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def interfereselements():
		def fget( self ):
			return self._interfereselements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument interfereselements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasprojections():
		def fget( self ):
			return self._hasprojections
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasprojections is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def referencedinstructures():
		def fget( self ):
			return self._referencedinstructures
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referencedinstructures is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasopenings():
		def fget( self ):
			return self._hasopenings
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasopenings is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isconnectionrealization():
		def fget( self ):
			return self._isconnectionrealization
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isconnectionrealization is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def providesboundaries():
		def fget( self ):
			return self._providesboundaries
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument providesboundaries is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def connectedfrom():
		def fget( self ):
			return self._connectedfrom
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectedfrom is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def containedinstructure():
		def fget( self ):
			return self._containedinstructure
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument containedinstructure is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcvirtualelement #
####################
class ifcvirtualelement(ifcelement):
	'''Entity ifcvirtualelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcpresentationitem #
####################
class ifcpresentationitem(BaseEntityClass):
	'''Entity ifcpresentationitem definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY ifccurvestylefontpattern #
####################
class ifccurvestylefontpattern(ifcpresentationitem):
	'''Entity ifccurvestylefontpattern definition.

	:param visiblesegmentlength
	:type visiblesegmentlength:ifclengthmeasure

	:param invisiblesegmentlength
	:type invisiblesegmentlength:ifcpositivelengthmeasure
	'''
	def __init__( self , visiblesegmentlength,invisiblesegmentlength, ):
		ifcpresentationitem.__init__(self , )
		self.visiblesegmentlength = visiblesegmentlength
		self.invisiblesegmentlength = invisiblesegmentlength

	@apply
	def visiblesegmentlength():
		def fget( self ):
			return self._visiblesegmentlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument visiblesegmentlength is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._visiblesegmentlength = ifclengthmeasure(value)
			else:
				self._visiblesegmentlength = value
		return property(**locals())

	@apply
	def invisiblesegmentlength():
		def fget( self ):
			return self._invisiblesegmentlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument invisiblesegmentlength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._invisiblesegmentlength = ifcpositivelengthmeasure(value)
			else:
				self._invisiblesegmentlength = value
		return property(**locals())
	def visiblelengthgreaterequalzero(self):
		eval_visiblelengthgreaterequalzero_wr = (self.visiblesegmentlength  >=  0)
		if not eval_visiblelengthgreaterequalzero_wr:
			raise AssertionError('Rule visiblelengthgreaterequalzero violated')
		else:
			return eval_visiblelengthgreaterequalzero_wr


####################
 # ENTITY ifcrelconnectsstructuralactivity #
####################
class ifcrelconnectsstructuralactivity(ifcrelconnects):
	'''Entity ifcrelconnectsstructuralactivity definition.

	:param relatingelement
	:type relatingelement:ifcstructuralactivityassignmentselect

	:param relatedstructuralactivity
	:type relatedstructuralactivity:ifcstructuralactivity
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingelement,relatedstructuralactivity, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingelement = relatingelement
		self.relatedstructuralactivity = relatedstructuralactivity

	@apply
	def relatingelement():
		def fget( self ):
			return self._relatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralactivityassignmentselect):
				self._relatingelement = ifcstructuralactivityassignmentselect(value)
			else:
				self._relatingelement = value
		return property(**locals())

	@apply
	def relatedstructuralactivity():
		def fget( self ):
			return self._relatedstructuralactivity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedstructuralactivity is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralactivity):
				self._relatedstructuralactivity = ifcstructuralactivity(value)
			else:
				self._relatedstructuralactivity = value
		return property(**locals())

####################
 # ENTITY ifcdistributionelement #
####################
class ifcdistributionelement(ifcelement):
	'''Entity ifcdistributionelement definition.

	:param hasports
	:type hasports:SET(0,None,'ifcrelconnectsporttoelement', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

	@apply
	def hasports():
		def fget( self ):
			return self._hasports
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasports is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcdistributionflowelement #
####################
class ifcdistributionflowelement(ifcdistributionelement):
	'''Entity ifcdistributionflowelement definition.

	:param hascontrolelements
	:type hascontrolelements:SET(0,1,'ifcrelflowcontrolelements', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

	@apply
	def hascontrolelements():
		def fget( self ):
			return self._hascontrolelements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hascontrolelements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcflowterminal #
####################
class ifcflowterminal(ifcdistributionflowelement):
	'''Entity ifcflowterminal definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifclightfixture #
####################
class ifclightfixture(ifcflowterminal):
	'''Entity ifclightfixture definition.

	:param predefinedtype
	:type predefinedtype:ifclightfixturetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclightfixturetypeenum):
					self._predefinedtype = ifclightfixturetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifclightfixturetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifclightfixturetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCLIGHTFIXTURETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcresourcelevelrelationship #
####################
class ifcresourcelevelrelationship(BaseEntityClass):
	'''Entity ifcresourcelevelrelationship definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY ifcmaterialrelationship #
####################
class ifcmaterialrelationship(ifcresourcelevelrelationship):
	'''Entity ifcmaterialrelationship definition.

	:param relatingmaterial
	:type relatingmaterial:ifcmaterial

	:param relatedmaterials
	:type relatedmaterials:SET(1,None,'ifcmaterial', scope = schema_scope)

	:param expression
	:type expression:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , relatingmaterial,relatedmaterials,expression, ):
		ifcresourcelevelrelationship.__init__(self , inherited0__name , inherited1__description , )
		self.relatingmaterial = relatingmaterial
		self.relatedmaterials = relatedmaterials
		self.expression = expression

	@apply
	def relatingmaterial():
		def fget( self ):
			return self._relatingmaterial
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingmaterial is mantatory and can not be set to None')
			if not check_type(value,ifcmaterial):
				self._relatingmaterial = ifcmaterial(value)
			else:
				self._relatingmaterial = value
		return property(**locals())

	@apply
	def relatedmaterials():
		def fget( self ):
			return self._relatedmaterials
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedmaterials is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcmaterial', scope = schema_scope)):
				self._relatedmaterials = SET(value)
			else:
				self._relatedmaterials = value
		return property(**locals())

	@apply
	def expression():
		def fget( self ):
			return self._expression
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._expression = ifclabel(value)
				else:
					self._expression = value
			else:
				self._expression = value
		return property(**locals())

####################
 # ENTITY ifccontext #
####################
class ifccontext(ifcobjectdefinition):
	'''Entity ifccontext definition.

	:param objecttype
	:type objecttype:ifclabel

	:param longname
	:type longname:ifclabel

	:param phase
	:type phase:ifclabel

	:param representationcontexts
	:type representationcontexts:SET(1,None,'ifcrepresentationcontext', scope = schema_scope)

	:param unitsincontext
	:type unitsincontext:ifcunitassignment

	:param isdefinedby
	:type isdefinedby:SET(0,None,'ifcreldefinesbyproperties', scope = schema_scope)

	:param declares
	:type declares:SET(0,None,'ifcreldeclares', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , objecttype,longname,phase,representationcontexts,unitsincontext, ):
		ifcobjectdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.objecttype = objecttype
		self.longname = longname
		self.phase = phase
		self.representationcontexts = representationcontexts
		self.unitsincontext = unitsincontext

	@apply
	def objecttype():
		def fget( self ):
			return self._objecttype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._objecttype = ifclabel(value)
				else:
					self._objecttype = value
			else:
				self._objecttype = value
		return property(**locals())

	@apply
	def longname():
		def fget( self ):
			return self._longname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._longname = ifclabel(value)
				else:
					self._longname = value
			else:
				self._longname = value
		return property(**locals())

	@apply
	def phase():
		def fget( self ):
			return self._phase
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._phase = ifclabel(value)
				else:
					self._phase = value
			else:
				self._phase = value
		return property(**locals())

	@apply
	def representationcontexts():
		def fget( self ):
			return self._representationcontexts
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcrepresentationcontext', scope = schema_scope)):
					self._representationcontexts = SET(value)
				else:
					self._representationcontexts = value
			else:
				self._representationcontexts = value
		return property(**locals())

	@apply
	def unitsincontext():
		def fget( self ):
			return self._unitsincontext
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunitassignment):
					self._unitsincontext = ifcunitassignment(value)
				else:
					self._unitsincontext = value
			else:
				self._unitsincontext = value
		return property(**locals())

	@apply
	def isdefinedby():
		def fget( self ):
			return self._isdefinedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isdefinedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def declares():
		def fget( self ):
			return self._declares
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument declares is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcpropertyabstraction #
####################
class ifcpropertyabstraction(BaseEntityClass):
	'''Entity ifcpropertyabstraction definition.

	:param hasexternalreferences
	:type hasexternalreferences:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def hasexternalreferences():
		def fget( self ):
			return self._hasexternalreferences
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasexternalreferences is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcpredefinedproperties #
####################
class ifcpredefinedproperties(ifcpropertyabstraction):
	'''Entity ifcpredefinedproperties definition.
	'''
	def __init__( self ,  ):
		ifcpropertyabstraction.__init__(self , )

####################
 # ENTITY ifcproperty #
####################
class ifcproperty(ifcpropertyabstraction):
	'''Entity ifcproperty definition.

	:param name
	:type name:ifcidentifier

	:param description
	:type description:ifctext

	:param partofpset
	:type partofpset:SET(0,None,'ifcpropertyset', scope = schema_scope)

	:param propertyfordependance
	:type propertyfordependance:SET(0,None,'ifcpropertydependencyrelationship', scope = schema_scope)

	:param propertydependson
	:type propertydependson:SET(0,None,'ifcpropertydependencyrelationship', scope = schema_scope)

	:param partofcomplex
	:type partofcomplex:SET(0,None,'ifccomplexproperty', scope = schema_scope)
	'''
	def __init__( self , name,description, ):
		ifcpropertyabstraction.__init__(self , )
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._name = ifcidentifier(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def partofpset():
		def fget( self ):
			return self._partofpset
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofpset is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def propertyfordependance():
		def fget( self ):
			return self._propertyfordependance
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument propertyfordependance is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def propertydependson():
		def fget( self ):
			return self._propertydependson
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument propertydependson is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def partofcomplex():
		def fget( self ):
			return self._partofcomplex
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofcomplex is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcsimpleproperty #
####################
class ifcsimpleproperty(ifcproperty):
	'''Entity ifcsimpleproperty definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		ifcproperty.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY ifcpropertyenumeratedvalue #
####################
class ifcpropertyenumeratedvalue(ifcsimpleproperty):
	'''Entity ifcpropertyenumeratedvalue definition.

	:param enumerationvalues
	:type enumerationvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param enumerationreference
	:type enumerationreference:ifcpropertyenumeration
	'''
	def __init__( self , inherited0__name , inherited1__description , enumerationvalues,enumerationreference, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.enumerationvalues = enumerationvalues
		self.enumerationreference = enumerationreference

	@apply
	def enumerationvalues():
		def fget( self ):
			return self._enumerationvalues
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
					self._enumerationvalues = LIST(value)
				else:
					self._enumerationvalues = value
			else:
				self._enumerationvalues = value
		return property(**locals())

	@apply
	def enumerationreference():
		def fget( self ):
			return self._enumerationreference
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpropertyenumeration):
					self._enumerationreference = ifcpropertyenumeration(value)
				else:
					self._enumerationreference = value
			else:
				self._enumerationreference = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = ((( not EXISTS(self.enumerationreference))  or  ( not EXISTS(self.enumerationvalues)))  or  (SIZEOF(None)  ==  SIZEOF(self.enumerationvalues)))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcreinforcementbarproperties #
####################
class ifcreinforcementbarproperties(ifcpredefinedproperties):
	'''Entity ifcreinforcementbarproperties definition.

	:param totalcrosssectionarea
	:type totalcrosssectionarea:ifcareameasure

	:param steelgrade
	:type steelgrade:ifclabel

	:param barsurface
	:type barsurface:ifcreinforcingbarsurfaceenum

	:param effectivedepth
	:type effectivedepth:ifclengthmeasure

	:param nominalbardiameter
	:type nominalbardiameter:ifcpositivelengthmeasure

	:param barcount
	:type barcount:ifccountmeasure
	'''
	def __init__( self , totalcrosssectionarea,steelgrade,barsurface,effectivedepth,nominalbardiameter,barcount, ):
		ifcpredefinedproperties.__init__(self , )
		self.totalcrosssectionarea = totalcrosssectionarea
		self.steelgrade = steelgrade
		self.barsurface = barsurface
		self.effectivedepth = effectivedepth
		self.nominalbardiameter = nominalbardiameter
		self.barcount = barcount

	@apply
	def totalcrosssectionarea():
		def fget( self ):
			return self._totalcrosssectionarea
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument totalcrosssectionarea is mantatory and can not be set to None')
			if not check_type(value,ifcareameasure):
				self._totalcrosssectionarea = ifcareameasure(value)
			else:
				self._totalcrosssectionarea = value
		return property(**locals())

	@apply
	def steelgrade():
		def fget( self ):
			return self._steelgrade
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument steelgrade is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._steelgrade = ifclabel(value)
			else:
				self._steelgrade = value
		return property(**locals())

	@apply
	def barsurface():
		def fget( self ):
			return self._barsurface
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreinforcingbarsurfaceenum):
					self._barsurface = ifcreinforcingbarsurfaceenum(value)
				else:
					self._barsurface = value
			else:
				self._barsurface = value
		return property(**locals())

	@apply
	def effectivedepth():
		def fget( self ):
			return self._effectivedepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._effectivedepth = ifclengthmeasure(value)
				else:
					self._effectivedepth = value
			else:
				self._effectivedepth = value
		return property(**locals())

	@apply
	def nominalbardiameter():
		def fget( self ):
			return self._nominalbardiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominalbardiameter = ifcpositivelengthmeasure(value)
				else:
					self._nominalbardiameter = value
			else:
				self._nominalbardiameter = value
		return property(**locals())

	@apply
	def barcount():
		def fget( self ):
			return self._barcount
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccountmeasure):
					self._barcount = ifccountmeasure(value)
				else:
					self._barcount = value
			else:
				self._barcount = value
		return property(**locals())

####################
 # ENTITY ifcrepresentationitem #
####################
class ifcrepresentationitem(BaseEntityClass):
	'''Entity ifcrepresentationitem definition.

	:param layerassignment
	:type layerassignment:SET(0,1,'ifcpresentationlayerassignment', scope = schema_scope)

	:param styledbyitem
	:type styledbyitem:SET(0,1,'ifcstyleditem', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def layerassignment():
		def fget( self ):
			return self._layerassignment
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument layerassignment is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def styledbyitem():
		def fget( self ):
			return self._styledbyitem
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument styledbyitem is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcgeometricrepresentationitem #
####################
class ifcgeometricrepresentationitem(ifcrepresentationitem):
	'''Entity ifcgeometricrepresentationitem definition.
	'''
	def __init__( self ,  ):
		ifcrepresentationitem.__init__(self , )

####################
 # ENTITY ifcsurface #
####################
class ifcsurface(ifcgeometricrepresentationitem):
	'''Entity ifcsurface definition.

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self ,  ):
		ifcgeometricrepresentationitem.__init__(self , )

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcsweptsurface #
####################
class ifcsweptsurface(ifcsurface):
	'''Entity ifcsweptsurface definition.

	:param sweptcurve
	:type sweptcurve:ifcprofiledef

	:param position
	:type position:ifcaxis2placement3d
	'''
	def __init__( self , sweptcurve,position, ):
		ifcsurface.__init__(self , )
		self.sweptcurve = sweptcurve
		self.position = position

	@apply
	def sweptcurve():
		def fget( self ):
			return self._sweptcurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sweptcurve is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._sweptcurve = ifcprofiledef(value)
			else:
				self._sweptcurve = value
		return property(**locals())

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaxis2placement3d):
					self._position = ifcaxis2placement3d(value)
				else:
					self._position = value
			else:
				self._position = value
		return property(**locals())
	def sweptcurvetype(self):
		eval_sweptcurvetype_wr = (self.sweptcurve.self.profiletype  ==  ifcprofiletypeenum.self.curve)
		if not eval_sweptcurvetype_wr:
			raise AssertionError('Rule sweptcurvetype violated')
		else:
			return eval_sweptcurvetype_wr


####################
 # ENTITY ifcsurfaceofrevolution #
####################
class ifcsurfaceofrevolution(ifcsweptsurface):
	'''Entity ifcsurfaceofrevolution definition.

	:param axisposition
	:type axisposition:ifcaxis1placement

	:param axisline
	:type axisline:ifcline
	'''
	def __init__( self , inherited0__sweptcurve , inherited1__position , axisposition, ):
		ifcsweptsurface.__init__(self , inherited0__sweptcurve , inherited1__position , )
		self.axisposition = axisposition

	@apply
	def axisposition():
		def fget( self ):
			return self._axisposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axisposition is mantatory and can not be set to None')
			if not check_type(value,ifcaxis1placement):
				self._axisposition = ifcaxis1placement(value)
			else:
				self._axisposition = value
		return property(**locals())

	@apply
	def axisline():
		def fget( self ):
			attribute_eval = (((ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifccurve())  ==  ifcline(self.axisposition.self.location,(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(self.axisposition.self.z,1)))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument axisline is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcflowtreatmentdevice #
####################
class ifcflowtreatmentdevice(ifcdistributionflowelement):
	'''Entity ifcflowtreatmentdevice definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcinterceptor #
####################
class ifcinterceptor(ifcflowtreatmentdevice):
	'''Entity ifcinterceptor definition.

	:param predefinedtype
	:type predefinedtype:ifcinterceptortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowtreatmentdevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcinterceptortypeenum):
					self._predefinedtype = ifcinterceptortypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcinterceptortypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcinterceptortypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCINTERCEPTORTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifctypeobject #
####################
class ifctypeobject(ifcobjectdefinition):
	'''Entity ifctypeobject definition.

	:param applicableoccurrence
	:type applicableoccurrence:ifcidentifier

	:param haspropertysets
	:type haspropertysets:SET(1,None,'ifcpropertysetdefinition', scope = schema_scope)

	:param types
	:type types:SET(0,1,'ifcreldefinesbytype', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , applicableoccurrence,haspropertysets, ):
		ifcobjectdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.applicableoccurrence = applicableoccurrence
		self.haspropertysets = haspropertysets

	@apply
	def applicableoccurrence():
		def fget( self ):
			return self._applicableoccurrence
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._applicableoccurrence = ifcidentifier(value)
				else:
					self._applicableoccurrence = value
			else:
				self._applicableoccurrence = value
		return property(**locals())

	@apply
	def haspropertysets():
		def fget( self ):
			return self._haspropertysets
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcpropertysetdefinition', scope = schema_scope)):
					self._haspropertysets = SET(value)
				else:
					self._haspropertysets = value
			else:
				self._haspropertysets = value
		return property(**locals())

	@apply
	def types():
		def fget( self ):
			return self._types
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument types is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifctypeproduct #
####################
class ifctypeproduct(ifctypeobject):
	'''Entity ifctypeproduct definition.

	:param representationmaps
	:type representationmaps:LIST(1,None,'ifcrepresentationmap', scope = schema_scope)

	:param tag
	:type tag:ifclabel

	:param referencedby
	:type referencedby:SET(0,None,'ifcrelassignstoproduct', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , representationmaps,tag, ):
		ifctypeobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , )
		self.representationmaps = representationmaps
		self.tag = tag

	@apply
	def representationmaps():
		def fget( self ):
			return self._representationmaps
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcrepresentationmap', scope = schema_scope)):
					self._representationmaps = LIST(value)
				else:
					self._representationmaps = value
			else:
				self._representationmaps = value
		return property(**locals())

	@apply
	def tag():
		def fget( self ):
			return self._tag
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._tag = ifclabel(value)
				else:
					self._tag = value
			else:
				self._tag = value
		return property(**locals())

	@apply
	def referencedby():
		def fget( self ):
			return self._referencedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referencedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def applicableoccurrence(self):
		eval_applicableoccurrence_wr = (( not EXISTS(self.self.ifctypeobject.self.types[1]))  or  (SIZEOF(None)  ==  0))
		if not eval_applicableoccurrence_wr:
			raise AssertionError('Rule applicableoccurrence violated')
		else:
			return eval_applicableoccurrence_wr


####################
 # ENTITY ifcelementtype #
####################
class ifcelementtype(ifctypeproduct):
	'''Entity ifcelementtype definition.

	:param elementtype
	:type elementtype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , elementtype, ):
		ifctypeproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , )
		self.elementtype = elementtype

	@apply
	def elementtype():
		def fget( self ):
			return self._elementtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._elementtype = ifclabel(value)
				else:
					self._elementtype = value
			else:
				self._elementtype = value
		return property(**locals())

####################
 # ENTITY ifcdistributionelementtype #
####################
class ifcdistributionelementtype(ifcelementtype):
	'''Entity ifcdistributionelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcdistributionflowelementtype #
####################
class ifcdistributionflowelementtype(ifcdistributionelementtype):
	'''Entity ifcdistributionflowelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcflowsegmenttype #
####################
class ifcflowsegmenttype(ifcdistributionflowelementtype):
	'''Entity ifcflowsegmenttype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifccablesegmenttype #
####################
class ifccablesegmenttype(ifcflowsegmenttype):
	'''Entity ifccablesegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifccablesegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowsegmenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccablesegmenttypeenum):
				self._predefinedtype = ifccablesegmenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccablesegmenttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccablesegmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifctyperesource #
####################
class ifctyperesource(ifctypeobject):
	'''Entity ifctyperesource definition.

	:param identification
	:type identification:ifcidentifier

	:param longdescription
	:type longdescription:ifctext

	:param resourcetype
	:type resourcetype:ifclabel

	:param resourceof
	:type resourceof:SET(0,None,'ifcrelassignstoresource', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , identification,longdescription,resourcetype, ):
		ifctypeobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , )
		self.identification = identification
		self.longdescription = longdescription
		self.resourcetype = resourcetype

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identification = ifcidentifier(value)
				else:
					self._identification = value
			else:
				self._identification = value
		return property(**locals())

	@apply
	def longdescription():
		def fget( self ):
			return self._longdescription
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._longdescription = ifctext(value)
				else:
					self._longdescription = value
			else:
				self._longdescription = value
		return property(**locals())

	@apply
	def resourcetype():
		def fget( self ):
			return self._resourcetype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._resourcetype = ifclabel(value)
				else:
					self._resourcetype = value
			else:
				self._resourcetype = value
		return property(**locals())

	@apply
	def resourceof():
		def fget( self ):
			return self._resourceof
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument resourceof is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcconstructionresourcetype #
####################
class ifcconstructionresourcetype(ifctyperesource):
	'''Entity ifcconstructionresourcetype definition.

	:param basecosts
	:type basecosts:LIST(1,None,'ifcappliedvalue', scope = schema_scope)

	:param basequantity
	:type basequantity:ifcphysicalquantity
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , basecosts,basequantity, ):
		ifctyperesource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , )
		self.basecosts = basecosts
		self.basequantity = basequantity

	@apply
	def basecosts():
		def fget( self ):
			return self._basecosts
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcappliedvalue', scope = schema_scope)):
					self._basecosts = LIST(value)
				else:
					self._basecosts = value
			else:
				self._basecosts = value
		return property(**locals())

	@apply
	def basequantity():
		def fget( self ):
			return self._basequantity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcphysicalquantity):
					self._basequantity = ifcphysicalquantity(value)
				else:
					self._basequantity = value
			else:
				self._basequantity = value
		return property(**locals())

####################
 # ENTITY ifcconstructionproductresourcetype #
####################
class ifcconstructionproductresourcetype(ifcconstructionresourcetype):
	'''Entity ifcconstructionproductresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionproductresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , predefinedtype, ):
		ifcconstructionresourcetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcconstructionproductresourcetypeenum):
				self._predefinedtype = ifcconstructionproductresourcetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcconstructionproductresourcetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcconstructionproductresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifctyperesource.self.resourcetype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcpropertydefinition #
####################
class ifcpropertydefinition(ifcroot):
	'''Entity ifcpropertydefinition definition.

	:param hascontext
	:type hascontext:SET(0,1,'ifcreldeclares', scope = schema_scope)

	:param hasassociations
	:type hasassociations:SET(0,None,'ifcrelassociates', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcroot.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

	@apply
	def hascontext():
		def fget( self ):
			return self._hascontext
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hascontext is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasassociations():
		def fget( self ):
			return self._hasassociations
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasassociations is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcpropertysetdefinition #
####################
class ifcpropertysetdefinition(ifcpropertydefinition):
	'''Entity ifcpropertysetdefinition definition.

	:param definestype
	:type definestype:SET(0,None,'ifctypeobject', scope = schema_scope)

	:param isdefinedby
	:type isdefinedby:SET(0,None,'ifcreldefinesbytemplate', scope = schema_scope)

	:param definesoccurrence
	:type definesoccurrence:SET(0,1,'ifcreldefinesbyproperties', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcpropertydefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

	@apply
	def definestype():
		def fget( self ):
			return self._definestype
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument definestype is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isdefinedby():
		def fget( self ):
			return self._isdefinedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isdefinedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def definesoccurrence():
		def fget( self ):
			return self._definesoccurrence
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument definesoccurrence is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcquantityset #
####################
class ifcquantityset(ifcpropertysetdefinition):
	'''Entity ifcquantityset definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

####################
 # ENTITY ifcelementquantity #
####################
class ifcelementquantity(ifcquantityset):
	'''Entity ifcelementquantity definition.

	:param methodofmeasurement
	:type methodofmeasurement:ifclabel

	:param quantities
	:type quantities:SET(1,None,'ifcphysicalquantity', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , methodofmeasurement,quantities, ):
		ifcquantityset.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.methodofmeasurement = methodofmeasurement
		self.quantities = quantities

	@apply
	def methodofmeasurement():
		def fget( self ):
			return self._methodofmeasurement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._methodofmeasurement = ifclabel(value)
				else:
					self._methodofmeasurement = value
			else:
				self._methodofmeasurement = value
		return property(**locals())

	@apply
	def quantities():
		def fget( self ):
			return self._quantities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument quantities is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcphysicalquantity', scope = schema_scope)):
				self._quantities = SET(value)
			else:
				self._quantities = value
		return property(**locals())
	def uniquequantitynames(self):
		eval_uniquequantitynames_wr = ifcuniquequantitynames(self.quantities)
		if not eval_uniquequantitynames_wr:
			raise AssertionError('Rule uniquequantitynames violated')
		else:
			return eval_uniquequantitynames_wr


####################
 # ENTITY ifcenergyconversiondevicetype #
####################
class ifcenergyconversiondevicetype(ifcdistributionflowelementtype):
	'''Entity ifcenergyconversiondevicetype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifchumidifiertype #
####################
class ifchumidifiertype(ifcenergyconversiondevicetype):
	'''Entity ifchumidifiertype definition.

	:param predefinedtype
	:type predefinedtype:ifchumidifiertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifchumidifiertypeenum):
				self._predefinedtype = ifchumidifiertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifchumidifiertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifchumidifiertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcstructuralitem #
####################
class ifcstructuralitem(ifcproduct):
	'''Entity ifcstructuralitem definition.

	:param assignedstructuralactivity
	:type assignedstructuralactivity:SET(0,None,'ifcrelconnectsstructuralactivity', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation ,  ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )

	@apply
	def assignedstructuralactivity():
		def fget( self ):
			return self._assignedstructuralactivity
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument assignedstructuralactivity is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstructuralload #
####################
class ifcstructuralload(BaseEntityClass):
	'''Entity ifcstructuralload definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifcstructuralloadorresult #
####################
class ifcstructuralloadorresult(ifcstructuralload):
	'''Entity ifcstructuralloadorresult definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcstructuralload.__init__(self , inherited0__name , )

####################
 # ENTITY ifcstructuralloadstatic #
####################
class ifcstructuralloadstatic(ifcstructuralloadorresult):
	'''Entity ifcstructuralloadstatic definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcstructuralloadorresult.__init__(self , inherited0__name , )

####################
 # ENTITY ifcstructuralloadsingledisplacement #
####################
class ifcstructuralloadsingledisplacement(ifcstructuralloadstatic):
	'''Entity ifcstructuralloadsingledisplacement definition.

	:param displacementx
	:type displacementx:ifclengthmeasure

	:param displacementy
	:type displacementy:ifclengthmeasure

	:param displacementz
	:type displacementz:ifclengthmeasure

	:param rotationaldisplacementrx
	:type rotationaldisplacementrx:ifcplaneanglemeasure

	:param rotationaldisplacementry
	:type rotationaldisplacementry:ifcplaneanglemeasure

	:param rotationaldisplacementrz
	:type rotationaldisplacementrz:ifcplaneanglemeasure
	'''
	def __init__( self , inherited0__name , displacementx,displacementy,displacementz,rotationaldisplacementrx,rotationaldisplacementry,rotationaldisplacementrz, ):
		ifcstructuralloadstatic.__init__(self , inherited0__name , )
		self.displacementx = displacementx
		self.displacementy = displacementy
		self.displacementz = displacementz
		self.rotationaldisplacementrx = rotationaldisplacementrx
		self.rotationaldisplacementry = rotationaldisplacementry
		self.rotationaldisplacementrz = rotationaldisplacementrz

	@apply
	def displacementx():
		def fget( self ):
			return self._displacementx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._displacementx = ifclengthmeasure(value)
				else:
					self._displacementx = value
			else:
				self._displacementx = value
		return property(**locals())

	@apply
	def displacementy():
		def fget( self ):
			return self._displacementy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._displacementy = ifclengthmeasure(value)
				else:
					self._displacementy = value
			else:
				self._displacementy = value
		return property(**locals())

	@apply
	def displacementz():
		def fget( self ):
			return self._displacementz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._displacementz = ifclengthmeasure(value)
				else:
					self._displacementz = value
			else:
				self._displacementz = value
		return property(**locals())

	@apply
	def rotationaldisplacementrx():
		def fget( self ):
			return self._rotationaldisplacementrx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._rotationaldisplacementrx = ifcplaneanglemeasure(value)
				else:
					self._rotationaldisplacementrx = value
			else:
				self._rotationaldisplacementrx = value
		return property(**locals())

	@apply
	def rotationaldisplacementry():
		def fget( self ):
			return self._rotationaldisplacementry
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._rotationaldisplacementry = ifcplaneanglemeasure(value)
				else:
					self._rotationaldisplacementry = value
			else:
				self._rotationaldisplacementry = value
		return property(**locals())

	@apply
	def rotationaldisplacementrz():
		def fget( self ):
			return self._rotationaldisplacementrz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._rotationaldisplacementrz = ifcplaneanglemeasure(value)
				else:
					self._rotationaldisplacementrz = value
			else:
				self._rotationaldisplacementrz = value
		return property(**locals())

####################
 # ENTITY ifctransportelementtype #
####################
class ifctransportelementtype(ifcelementtype):
	'''Entity ifctransportelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifctransportelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctransportelementtypeenum):
				self._predefinedtype = ifctransportelementtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifctransportelementtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifctransportelementtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcprofiledef #
####################
class ifcprofiledef(BaseEntityClass):
	'''Entity ifcprofiledef definition.

	:param profiletype
	:type profiletype:ifcprofiletypeenum

	:param profilename
	:type profilename:ifclabel

	:param hasexternalreference
	:type hasexternalreference:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)

	:param hasproperties
	:type hasproperties:SET(0,None,'ifcprofileproperties', scope = schema_scope)
	'''
	def __init__( self , profiletype,profilename, ):
		self.profiletype = profiletype
		self.profilename = profilename

	@apply
	def profiletype():
		def fget( self ):
			return self._profiletype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument profiletype is mantatory and can not be set to None')
			if not check_type(value,ifcprofiletypeenum):
				self._profiletype = ifcprofiletypeenum(value)
			else:
				self._profiletype = value
		return property(**locals())

	@apply
	def profilename():
		def fget( self ):
			return self._profilename
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._profilename = ifclabel(value)
				else:
					self._profilename = value
			else:
				self._profilename = value
		return property(**locals())

	@apply
	def hasexternalreference():
		def fget( self ):
			return self._hasexternalreference
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasproperties():
		def fget( self ):
			return self._hasproperties
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasproperties is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcparameterizedprofiledef #
####################
class ifcparameterizedprofiledef(ifcprofiledef):
	'''Entity ifcparameterizedprofiledef definition.

	:param position
	:type position:ifcaxis2placement2d
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , position, ):
		ifcprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaxis2placement2d):
					self._position = ifcaxis2placement2d(value)
				else:
					self._position = value
			else:
				self._position = value
		return property(**locals())

####################
 # ENTITY ifctrapeziumprofiledef #
####################
class ifctrapeziumprofiledef(ifcparameterizedprofiledef):
	'''Entity ifctrapeziumprofiledef definition.

	:param bottomxdim
	:type bottomxdim:ifcpositivelengthmeasure

	:param topxdim
	:type topxdim:ifcpositivelengthmeasure

	:param ydim
	:type ydim:ifcpositivelengthmeasure

	:param topxoffset
	:type topxoffset:ifclengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , bottomxdim,topxdim,ydim,topxoffset, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.bottomxdim = bottomxdim
		self.topxdim = topxdim
		self.ydim = ydim
		self.topxoffset = topxoffset

	@apply
	def bottomxdim():
		def fget( self ):
			return self._bottomxdim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bottomxdim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._bottomxdim = ifcpositivelengthmeasure(value)
			else:
				self._bottomxdim = value
		return property(**locals())

	@apply
	def topxdim():
		def fget( self ):
			return self._topxdim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument topxdim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._topxdim = ifcpositivelengthmeasure(value)
			else:
				self._topxdim = value
		return property(**locals())

	@apply
	def ydim():
		def fget( self ):
			return self._ydim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ydim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._ydim = ifcpositivelengthmeasure(value)
			else:
				self._ydim = value
		return property(**locals())

	@apply
	def topxoffset():
		def fget( self ):
			return self._topxoffset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument topxoffset is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._topxoffset = ifclengthmeasure(value)
			else:
				self._topxoffset = value
		return property(**locals())

####################
 # ENTITY ifczshapeprofiledef #
####################
class ifczshapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifczshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param flangewidth
	:type flangewidth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcnonnegativelengthmeasure

	:param edgeradius
	:type edgeradius:ifcnonnegativelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , depth,flangewidth,webthickness,flangethickness,filletradius,edgeradius, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.depth = depth
		self.flangewidth = flangewidth
		self.webthickness = webthickness
		self.flangethickness = flangethickness
		self.filletradius = filletradius
		self.edgeradius = edgeradius

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def flangewidth():
		def fget( self ):
			return self._flangewidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangewidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangewidth = ifcpositivelengthmeasure(value)
			else:
				self._flangewidth = value
		return property(**locals())

	@apply
	def webthickness():
		def fget( self ):
			return self._webthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument webthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._webthickness = ifcpositivelengthmeasure(value)
			else:
				self._webthickness = value
		return property(**locals())

	@apply
	def flangethickness():
		def fget( self ):
			return self._flangethickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangethickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangethickness = ifcpositivelengthmeasure(value)
			else:
				self._flangethickness = value
		return property(**locals())

	@apply
	def filletradius():
		def fget( self ):
			return self._filletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._filletradius = ifcnonnegativelengthmeasure(value)
				else:
					self._filletradius = value
			else:
				self._filletradius = value
		return property(**locals())

	@apply
	def edgeradius():
		def fget( self ):
			return self._edgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._edgeradius = ifcnonnegativelengthmeasure(value)
				else:
					self._edgeradius = value
			else:
				self._edgeradius = value
		return property(**locals())
	def validflangethickness(self):
		eval_validflangethickness_wr = (self.flangethickness  <  (self.depth / 2))
		if not eval_validflangethickness_wr:
			raise AssertionError('Rule validflangethickness violated')
		else:
			return eval_validflangethickness_wr


####################
 # ENTITY ifccontrol #
####################
class ifccontrol(ifcobject):
	'''Entity ifccontrol definition.

	:param identification
	:type identification:ifcidentifier

	:param controls
	:type controls:SET(0,None,'ifcrelassignstocontrol', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , identification, ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.identification = identification

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identification = ifcidentifier(value)
				else:
					self._identification = value
			else:
				self._identification = value
		return property(**locals())

	@apply
	def controls():
		def fget( self ):
			return self._controls
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument controls is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifccostitem #
####################
class ifccostitem(ifccontrol):
	'''Entity ifccostitem definition.

	:param predefinedtype
	:type predefinedtype:ifccostitemtypeenum

	:param costvalues
	:type costvalues:LIST(1,None,'ifccostvalue', scope = schema_scope)

	:param costquantities
	:type costquantities:LIST(1,None,'ifcphysicalquantity', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , predefinedtype,costvalues,costquantities, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , )
		self.predefinedtype = predefinedtype
		self.costvalues = costvalues
		self.costquantities = costquantities

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccostitemtypeenum):
					self._predefinedtype = ifccostitemtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def costvalues():
		def fget( self ):
			return self._costvalues
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifccostvalue', scope = schema_scope)):
					self._costvalues = LIST(value)
				else:
					self._costvalues = value
			else:
				self._costvalues = value
		return property(**locals())

	@apply
	def costquantities():
		def fget( self ):
			return self._costquantities
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcphysicalquantity', scope = schema_scope)):
					self._costquantities = LIST(value)
				else:
					self._costquantities = value
			else:
				self._costquantities = value
		return property(**locals())

####################
 # ENTITY ifclightsource #
####################
class ifclightsource(ifcgeometricrepresentationitem):
	'''Entity ifclightsource definition.

	:param name
	:type name:ifclabel

	:param lightcolour
	:type lightcolour:ifccolourrgb

	:param ambientintensity
	:type ambientintensity:ifcnormalisedratiomeasure

	:param intensity
	:type intensity:ifcnormalisedratiomeasure
	'''
	def __init__( self , name,lightcolour,ambientintensity,intensity, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.name = name
		self.lightcolour = lightcolour
		self.ambientintensity = ambientintensity
		self.intensity = intensity

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def lightcolour():
		def fget( self ):
			return self._lightcolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lightcolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._lightcolour = ifccolourrgb(value)
			else:
				self._lightcolour = value
		return property(**locals())

	@apply
	def ambientintensity():
		def fget( self ):
			return self._ambientintensity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._ambientintensity = ifcnormalisedratiomeasure(value)
				else:
					self._ambientintensity = value
			else:
				self._ambientintensity = value
		return property(**locals())

	@apply
	def intensity():
		def fget( self ):
			return self._intensity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._intensity = ifcnormalisedratiomeasure(value)
				else:
					self._intensity = value
			else:
				self._intensity = value
		return property(**locals())

####################
 # ENTITY ifcsolidmodel #
####################
class ifcsolidmodel(ifcgeometricrepresentationitem):
	'''Entity ifcsolidmodel definition.

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self ,  ):
		ifcgeometricrepresentationitem.__init__(self , )

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcmanifoldsolidbrep #
####################
class ifcmanifoldsolidbrep(ifcsolidmodel):
	'''Entity ifcmanifoldsolidbrep definition.

	:param outer
	:type outer:ifcclosedshell
	'''
	def __init__( self , outer, ):
		ifcsolidmodel.__init__(self , )
		self.outer = outer

	@apply
	def outer():
		def fget( self ):
			return self._outer
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outer is mantatory and can not be set to None')
			if not check_type(value,ifcclosedshell):
				self._outer = ifcclosedshell(value)
			else:
				self._outer = value
		return property(**locals())

####################
 # ENTITY ifcadvancedbrep #
####################
class ifcadvancedbrep(ifcmanifoldsolidbrep):
	'''Entity ifcadvancedbrep definition.
	'''
	def __init__( self , inherited0__outer ,  ):
		ifcmanifoldsolidbrep.__init__(self , inherited0__outer , )
	def hasadvancedfaces(self):
		eval_hasadvancedfaces_wr = (SIZEOF(None)  ==  0)
		if not eval_hasadvancedfaces_wr:
			raise AssertionError('Rule hasadvancedfaces violated')
		else:
			return eval_hasadvancedfaces_wr


####################
 # ENTITY ifcadvancedbrepwithvoids #
####################
class ifcadvancedbrepwithvoids(ifcadvancedbrep):
	'''Entity ifcadvancedbrepwithvoids definition.

	:param voids
	:type voids:SET(1,None,'ifcclosedshell', scope = schema_scope)
	'''
	def __init__( self , inherited0__outer , voids, ):
		ifcadvancedbrep.__init__(self , inherited0__outer , )
		self.voids = voids

	@apply
	def voids():
		def fget( self ):
			return self._voids
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument voids is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcclosedshell', scope = schema_scope)):
				self._voids = SET(value)
			else:
				self._voids = value
		return property(**locals())
	def voidshaveadvancedfaces(self):
		eval_voidshaveadvancedfaces_wr = (SIZEOF(None)  ==  0)
		if not eval_voidshaveadvancedfaces_wr:
			raise AssertionError('Rule voidshaveadvancedfaces violated')
		else:
			return eval_voidshaveadvancedfaces_wr


####################
 # ENTITY ifcfeatureelement #
####################
class ifcfeatureelement(ifcelement):
	'''Entity ifcfeatureelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcfeatureelementaddition #
####################
class ifcfeatureelementaddition(ifcfeatureelement):
	'''Entity ifcfeatureelementaddition definition.

	:param projectselements
	:type projectselements:ifcrelprojectselement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcfeatureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

	@apply
	def projectselements():
		def fget( self ):
			return self._projectselements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument projectselements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstructuralconnectioncondition #
####################
class ifcstructuralconnectioncondition(BaseEntityClass):
	'''Entity ifcstructuralconnectioncondition definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifcpoint #
####################
class ifcpoint(ifcgeometricrepresentationitem):
	'''Entity ifcpoint definition.
	'''
	def __init__( self ,  ):
		ifcgeometricrepresentationitem.__init__(self , )

####################
 # ENTITY ifccartesianpoint #
####################
class ifccartesianpoint(ifcpoint):
	'''Entity ifccartesianpoint definition.

	:param coordinates
	:type coordinates:LIST(1,3,'REAL', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , coordinates, ):
		ifcpoint.__init__(self , )
		self.coordinates = coordinates

	@apply
	def coordinates():
		def fget( self ):
			return self._coordinates
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordinates is mantatory and can not be set to None')
			if not check_type(value,LIST(1,3,'REAL', scope = schema_scope)):
				self._coordinates = LIST(value)
			else:
				self._coordinates = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = HIINDEX(self.coordinates)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def cp2dor3d(self):
		eval_cp2dor3d_wr = (HIINDEX(self.coordinates)  >=  2)
		if not eval_cp2dor3d_wr:
			raise AssertionError('Rule cp2dor3d violated')
		else:
			return eval_cp2dor3d_wr


####################
 # ENTITY ifcexternalreference #
####################
class ifcexternalreference(BaseEntityClass):
	'''Entity ifcexternalreference definition.

	:param location
	:type location:ifcurireference

	:param identification
	:type identification:ifcidentifier

	:param name
	:type name:ifclabel

	:param externalreferenceforresources
	:type externalreferenceforresources:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''
	def __init__( self , location,identification,name, ):
		self.location = location
		self.identification = identification
		self.name = name

	@apply
	def location():
		def fget( self ):
			return self._location
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcurireference):
					self._location = ifcurireference(value)
				else:
					self._location = value
			else:
				self._location = value
		return property(**locals())

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identification = ifcidentifier(value)
				else:
					self._identification = value
			else:
				self._identification = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def externalreferenceforresources():
		def fget( self ):
			return self._externalreferenceforresources
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument externalreferenceforresources is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((EXISTS(self.identification)  or  EXISTS(self.location))  or  EXISTS(self.name))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcclassificationreference #
####################
class ifcclassificationreference(ifcexternalreference):
	'''Entity ifcclassificationreference definition.

	:param referencedsource
	:type referencedsource:ifcclassificationreferenceselect

	:param description
	:type description:ifctext

	:param sort
	:type sort:ifcidentifier

	:param classificationrefforobjects
	:type classificationrefforobjects:SET(0,None,'ifcrelassociatesclassification', scope = schema_scope)

	:param hasreferences
	:type hasreferences:SET(0,None,'ifcclassificationreference', scope = schema_scope)
	'''
	def __init__( self , inherited0__location , inherited1__identification , inherited2__name , referencedsource,description,sort, ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__identification , inherited2__name , )
		self.referencedsource = referencedsource
		self.description = description
		self.sort = sort

	@apply
	def referencedsource():
		def fget( self ):
			return self._referencedsource
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcclassificationreferenceselect):
					self._referencedsource = ifcclassificationreferenceselect(value)
				else:
					self._referencedsource = value
			else:
				self._referencedsource = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def sort():
		def fget( self ):
			return self._sort
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._sort = ifcidentifier(value)
				else:
					self._sort = value
			else:
				self._sort = value
		return property(**locals())

	@apply
	def classificationrefforobjects():
		def fget( self ):
			return self._classificationrefforobjects
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument classificationrefforobjects is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasreferences():
		def fget( self ):
			return self._hasreferences
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasreferences is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcderivedunitelement #
####################
class ifcderivedunitelement(BaseEntityClass):
	'''Entity ifcderivedunitelement definition.

	:param unit
	:type unit:ifcnamedunit

	:param exponent
	:type exponent:INTEGER
	'''
	def __init__( self , unit,exponent, ):
		self.unit = unit
		self.exponent = exponent

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unit is mantatory and can not be set to None')
			if not check_type(value,ifcnamedunit):
				self._unit = ifcnamedunit(value)
			else:
				self._unit = value
		return property(**locals())

	@apply
	def exponent():
		def fget( self ):
			return self._exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument exponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._exponent = INTEGER(value)
			else:
				self._exponent = value
		return property(**locals())

####################
 # ENTITY ifcbuildingelement #
####################
class ifcbuildingelement(ifcelement):
	'''Entity ifcbuildingelement definition.

	:param hascoverings
	:type hascoverings:SET(0,None,'ifcrelcoversbldgelements', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

	@apply
	def hascoverings():
		def fget( self ):
			return self._hascoverings
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hascoverings is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def maxonematerialassociation(self):
		eval_maxonematerialassociation_wr = (SIZEOF(None)  <=  1)
		if not eval_maxonematerialassociation_wr:
			raise AssertionError('Rule maxonematerialassociation violated')
		else:
			return eval_maxonematerialassociation_wr


####################
 # ENTITY ifcrailing #
####################
class ifcrailing(ifcbuildingelement):
	'''Entity ifcrailing definition.

	:param predefinedtype
	:type predefinedtype:ifcrailingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrailingtypeenum):
					self._predefinedtype = ifcrailingtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcrailingtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcrailingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCRAILINGTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcshadingdevice #
####################
class ifcshadingdevice(ifcbuildingelement):
	'''Entity ifcshadingdevice definition.

	:param predefinedtype
	:type predefinedtype:ifcshadingdevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshadingdevicetypeenum):
					self._predefinedtype = ifcshadingdevicetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcshadingdevicetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcshadingdevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSHADINGDEVICETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifccurrencyrelationship #
####################
class ifccurrencyrelationship(ifcresourcelevelrelationship):
	'''Entity ifccurrencyrelationship definition.

	:param relatingmonetaryunit
	:type relatingmonetaryunit:ifcmonetaryunit

	:param relatedmonetaryunit
	:type relatedmonetaryunit:ifcmonetaryunit

	:param exchangerate
	:type exchangerate:ifcpositiveratiomeasure

	:param ratedatetime
	:type ratedatetime:ifcdatetime

	:param ratesource
	:type ratesource:ifclibraryinformation
	'''
	def __init__( self , inherited0__name , inherited1__description , relatingmonetaryunit,relatedmonetaryunit,exchangerate,ratedatetime,ratesource, ):
		ifcresourcelevelrelationship.__init__(self , inherited0__name , inherited1__description , )
		self.relatingmonetaryunit = relatingmonetaryunit
		self.relatedmonetaryunit = relatedmonetaryunit
		self.exchangerate = exchangerate
		self.ratedatetime = ratedatetime
		self.ratesource = ratesource

	@apply
	def relatingmonetaryunit():
		def fget( self ):
			return self._relatingmonetaryunit
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingmonetaryunit is mantatory and can not be set to None')
			if not check_type(value,ifcmonetaryunit):
				self._relatingmonetaryunit = ifcmonetaryunit(value)
			else:
				self._relatingmonetaryunit = value
		return property(**locals())

	@apply
	def relatedmonetaryunit():
		def fget( self ):
			return self._relatedmonetaryunit
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedmonetaryunit is mantatory and can not be set to None')
			if not check_type(value,ifcmonetaryunit):
				self._relatedmonetaryunit = ifcmonetaryunit(value)
			else:
				self._relatedmonetaryunit = value
		return property(**locals())

	@apply
	def exchangerate():
		def fget( self ):
			return self._exchangerate
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument exchangerate is mantatory and can not be set to None')
			if not check_type(value,ifcpositiveratiomeasure):
				self._exchangerate = ifcpositiveratiomeasure(value)
			else:
				self._exchangerate = value
		return property(**locals())

	@apply
	def ratedatetime():
		def fget( self ):
			return self._ratedatetime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._ratedatetime = ifcdatetime(value)
				else:
					self._ratedatetime = value
			else:
				self._ratedatetime = value
		return property(**locals())

	@apply
	def ratesource():
		def fget( self ):
			return self._ratesource
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclibraryinformation):
					self._ratesource = ifclibraryinformation(value)
				else:
					self._ratesource = value
			else:
				self._ratesource = value
		return property(**locals())

####################
 # ENTITY ifcmaterialdefinition #
####################
class ifcmaterialdefinition(BaseEntityClass):
	'''Entity ifcmaterialdefinition definition.

	:param associatedto
	:type associatedto:SET(0,None,'ifcrelassociatesmaterial', scope = schema_scope)

	:param hasexternalreferences
	:type hasexternalreferences:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)

	:param hasproperties
	:type hasproperties:SET(0,None,'ifcmaterialproperties', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def associatedto():
		def fget( self ):
			return self._associatedto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument associatedto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasexternalreferences():
		def fget( self ):
			return self._hasexternalreferences
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasexternalreferences is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasproperties():
		def fget( self ):
			return self._hasproperties
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasproperties is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcmaterial #
####################
class ifcmaterial(ifcmaterialdefinition):
	'''Entity ifcmaterial definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param category
	:type category:ifclabel

	:param hasrepresentation
	:type hasrepresentation:SET(0,1,'ifcmaterialdefinitionrepresentation', scope = schema_scope)

	:param isrelatedwith
	:type isrelatedwith:SET(0,None,'ifcmaterialrelationship', scope = schema_scope)

	:param relatesto
	:type relatesto:SET(0,1,'ifcmaterialrelationship', scope = schema_scope)
	'''
	def __init__( self , name,description,category, ):
		ifcmaterialdefinition.__init__(self , )
		self.name = name
		self.description = description
		self.category = category

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def category():
		def fget( self ):
			return self._category
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._category = ifclabel(value)
				else:
					self._category = value
			else:
				self._category = value
		return property(**locals())

	@apply
	def hasrepresentation():
		def fget( self ):
			return self._hasrepresentation
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasrepresentation is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isrelatedwith():
		def fget( self ):
			return self._isrelatedwith
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isrelatedwith is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def relatesto():
		def fget( self ):
			return self._relatesto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument relatesto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcmember #
####################
class ifcmember(ifcbuildingelement):
	'''Entity ifcmember definition.

	:param predefinedtype
	:type predefinedtype:ifcmembertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmembertypeenum):
					self._predefinedtype = ifcmembertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcmembertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcmembertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCMEMBERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcdistributioncontrolelement #
####################
class ifcdistributioncontrolelement(ifcdistributionelement):
	'''Entity ifcdistributioncontrolelement definition.

	:param assignedtoflowelement
	:type assignedtoflowelement:SET(0,1,'ifcrelflowcontrolelements', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

	@apply
	def assignedtoflowelement():
		def fget( self ):
			return self._assignedtoflowelement
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument assignedtoflowelement is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcflowinstrument #
####################
class ifcflowinstrument(ifcdistributioncontrolelement):
	'''Entity ifcflowinstrument definition.

	:param predefinedtype
	:type predefinedtype:ifcflowinstrumenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcdistributioncontrolelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcflowinstrumenttypeenum):
					self._predefinedtype = ifcflowinstrumenttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcflowinstrumenttypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcflowinstrumenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCFLOWINSTRUMENTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcenergyconversiondevice #
####################
class ifcenergyconversiondevice(ifcdistributionflowelement):
	'''Entity ifcenergyconversiondevice definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifchumidifier #
####################
class ifchumidifier(ifcenergyconversiondevice):
	'''Entity ifchumidifier definition.

	:param predefinedtype
	:type predefinedtype:ifchumidifiertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifchumidifiertypeenum):
					self._predefinedtype = ifchumidifiertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifchumidifiertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifchumidifiertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCHUMIDIFIERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcgroup #
####################
class ifcgroup(ifcobject):
	'''Entity ifcgroup definition.

	:param isgroupedby
	:type isgroupedby:SET(0,None,'ifcrelassignstogroup', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

	@apply
	def isgroupedby():
		def fget( self ):
			return self._isgroupedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isgroupedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcsystem #
####################
class ifcsystem(ifcgroup):
	'''Entity ifcsystem definition.

	:param servicesbuildings
	:type servicesbuildings:SET(0,1,'ifcrelservicesbuildings', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

	@apply
	def servicesbuildings():
		def fget( self ):
			return self._servicesbuildings
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument servicesbuildings is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcworkcalendar #
####################
class ifcworkcalendar(ifccontrol):
	'''Entity ifcworkcalendar definition.

	:param workingtimes
	:type workingtimes:SET(1,None,'ifcworktime', scope = schema_scope)

	:param exceptiontimes
	:type exceptiontimes:SET(1,None,'ifcworktime', scope = schema_scope)

	:param predefinedtype
	:type predefinedtype:ifcworkcalendartypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , workingtimes,exceptiontimes,predefinedtype, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , )
		self.workingtimes = workingtimes
		self.exceptiontimes = exceptiontimes
		self.predefinedtype = predefinedtype

	@apply
	def workingtimes():
		def fget( self ):
			return self._workingtimes
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcworktime', scope = schema_scope)):
					self._workingtimes = SET(value)
				else:
					self._workingtimes = value
			else:
				self._workingtimes = value
		return property(**locals())

	@apply
	def exceptiontimes():
		def fget( self ):
			return self._exceptiontimes
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcworktime', scope = schema_scope)):
					self._exceptiontimes = SET(value)
				else:
					self._exceptiontimes = value
			else:
				self._exceptiontimes = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcworkcalendartypeenum):
					self._predefinedtype = ifcworkcalendartypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcworkcalendartypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcworkcalendartypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcannotationfillarea #
####################
class ifcannotationfillarea(ifcgeometricrepresentationitem):
	'''Entity ifcannotationfillarea definition.

	:param outerboundary
	:type outerboundary:ifccurve

	:param innerboundaries
	:type innerboundaries:SET(1,None,'ifccurve', scope = schema_scope)
	'''
	def __init__( self , outerboundary,innerboundaries, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.outerboundary = outerboundary
		self.innerboundaries = innerboundaries

	@apply
	def outerboundary():
		def fget( self ):
			return self._outerboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outerboundary is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._outerboundary = ifccurve(value)
			else:
				self._outerboundary = value
		return property(**locals())

	@apply
	def innerboundaries():
		def fget( self ):
			return self._innerboundaries
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifccurve', scope = schema_scope)):
					self._innerboundaries = SET(value)
				else:
					self._innerboundaries = value
			else:
				self._innerboundaries = value
		return property(**locals())

####################
 # ENTITY ifcelementcomponenttype #
####################
class ifcelementcomponenttype(ifcelementtype):
	'''Entity ifcelementcomponenttype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcbuildingelementparttype #
####################
class ifcbuildingelementparttype(ifcelementcomponenttype):
	'''Entity ifcbuildingelementparttype definition.

	:param predefinedtype
	:type predefinedtype:ifcbuildingelementparttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcelementcomponenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcbuildingelementparttypeenum):
				self._predefinedtype = ifcbuildingelementparttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcbuildingelementparttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcbuildingelementparttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcelectricmotor #
####################
class ifcelectricmotor(ifcenergyconversiondevice):
	'''Entity ifcelectricmotor definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricmotortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelectricmotortypeenum):
					self._predefinedtype = ifcelectricmotortypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcelectricmotortypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcelectricmotortypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCELECTRICMOTORTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcschedulingtime #
####################
class ifcschedulingtime(BaseEntityClass):
	'''Entity ifcschedulingtime definition.

	:param name
	:type name:ifclabel

	:param dataorigin
	:type dataorigin:ifcdataoriginenum

	:param userdefineddataorigin
	:type userdefineddataorigin:ifclabel
	'''
	def __init__( self , name,dataorigin,userdefineddataorigin, ):
		self.name = name
		self.dataorigin = dataorigin
		self.userdefineddataorigin = userdefineddataorigin

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def dataorigin():
		def fget( self ):
			return self._dataorigin
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdataoriginenum):
					self._dataorigin = ifcdataoriginenum(value)
				else:
					self._dataorigin = value
			else:
				self._dataorigin = value
		return property(**locals())

	@apply
	def userdefineddataorigin():
		def fget( self ):
			return self._userdefineddataorigin
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefineddataorigin = ifclabel(value)
				else:
					self._userdefineddataorigin = value
			else:
				self._userdefineddataorigin = value
		return property(**locals())

####################
 # ENTITY ifceventtime #
####################
class ifceventtime(ifcschedulingtime):
	'''Entity ifceventtime definition.

	:param actualdate
	:type actualdate:ifcdatetime

	:param earlydate
	:type earlydate:ifcdatetime

	:param latedate
	:type latedate:ifcdatetime

	:param scheduledate
	:type scheduledate:ifcdatetime
	'''
	def __init__( self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , actualdate,earlydate,latedate,scheduledate, ):
		ifcschedulingtime.__init__(self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , )
		self.actualdate = actualdate
		self.earlydate = earlydate
		self.latedate = latedate
		self.scheduledate = scheduledate

	@apply
	def actualdate():
		def fget( self ):
			return self._actualdate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._actualdate = ifcdatetime(value)
				else:
					self._actualdate = value
			else:
				self._actualdate = value
		return property(**locals())

	@apply
	def earlydate():
		def fget( self ):
			return self._earlydate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._earlydate = ifcdatetime(value)
				else:
					self._earlydate = value
			else:
				self._earlydate = value
		return property(**locals())

	@apply
	def latedate():
		def fget( self ):
			return self._latedate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._latedate = ifcdatetime(value)
				else:
					self._latedate = value
			else:
				self._latedate = value
		return property(**locals())

	@apply
	def scheduledate():
		def fget( self ):
			return self._scheduledate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._scheduledate = ifcdatetime(value)
				else:
					self._scheduledate = value
			else:
				self._scheduledate = value
		return property(**locals())

####################
 # ENTITY ifcactuator #
####################
class ifcactuator(ifcdistributioncontrolelement):
	'''Entity ifcactuator definition.

	:param predefinedtype
	:type predefinedtype:ifcactuatortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcdistributioncontrolelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactuatortypeenum):
					self._predefinedtype = ifcactuatortypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcactuatortypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcactuatortypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCACTUATORTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcbuildingelementtype #
####################
class ifcbuildingelementtype(ifcelementtype):
	'''Entity ifcbuildingelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcstairtype #
####################
class ifcstairtype(ifcbuildingelementtype):
	'''Entity ifcstairtype definition.

	:param predefinedtype
	:type predefinedtype:ifcstairtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstairtypeenum):
				self._predefinedtype = ifcstairtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcstairtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcstairtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcpredefinedpropertyset #
####################
class ifcpredefinedpropertyset(ifcpropertysetdefinition):
	'''Entity ifcpredefinedpropertyset definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

####################
 # ENTITY ifcdoorpanelproperties #
####################
class ifcdoorpanelproperties(ifcpredefinedpropertyset):
	'''Entity ifcdoorpanelproperties definition.

	:param paneldepth
	:type paneldepth:ifcpositivelengthmeasure

	:param paneloperation
	:type paneloperation:ifcdoorpaneloperationenum

	:param panelwidth
	:type panelwidth:ifcnormalisedratiomeasure

	:param panelposition
	:type panelposition:ifcdoorpanelpositionenum

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , paneldepth,paneloperation,panelwidth,panelposition,shapeaspectstyle, ):
		ifcpredefinedpropertyset.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.paneldepth = paneldepth
		self.paneloperation = paneloperation
		self.panelwidth = panelwidth
		self.panelposition = panelposition
		self.shapeaspectstyle = shapeaspectstyle

	@apply
	def paneldepth():
		def fget( self ):
			return self._paneldepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._paneldepth = ifcpositivelengthmeasure(value)
				else:
					self._paneldepth = value
			else:
				self._paneldepth = value
		return property(**locals())

	@apply
	def paneloperation():
		def fget( self ):
			return self._paneloperation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument paneloperation is mantatory and can not be set to None')
			if not check_type(value,ifcdoorpaneloperationenum):
				self._paneloperation = ifcdoorpaneloperationenum(value)
			else:
				self._paneloperation = value
		return property(**locals())

	@apply
	def panelwidth():
		def fget( self ):
			return self._panelwidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._panelwidth = ifcnormalisedratiomeasure(value)
				else:
					self._panelwidth = value
			else:
				self._panelwidth = value
		return property(**locals())

	@apply
	def panelposition():
		def fget( self ):
			return self._panelposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument panelposition is mantatory and can not be set to None')
			if not check_type(value,ifcdoorpanelpositionenum):
				self._panelposition = ifcdoorpanelpositionenum(value)
			else:
				self._panelposition = value
		return property(**locals())

	@apply
	def shapeaspectstyle():
		def fget( self ):
			return self._shapeaspectstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshapeaspect):
					self._shapeaspectstyle = ifcshapeaspect(value)
				else:
					self._shapeaspectstyle = value
			else:
				self._shapeaspectstyle = value
		return property(**locals())
	def applicabletotype(self):
		eval_applicabletotype_wr = (EXISTS(self.self.ifcpropertysetdefinition.self.definestype[1])  and  (('IFC4.IFCDOORTYPE'  ==  TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))  or  ('IFC4.IFCDOORSTYLE'  ==  TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))))
		if not eval_applicabletotype_wr:
			raise AssertionError('Rule applicabletotype violated')
		else:
			return eval_applicabletotype_wr


####################
 # ENTITY ifcpermeablecoveringproperties #
####################
class ifcpermeablecoveringproperties(ifcpredefinedpropertyset):
	'''Entity ifcpermeablecoveringproperties definition.

	:param operationtype
	:type operationtype:ifcpermeablecoveringoperationenum

	:param panelposition
	:type panelposition:ifcwindowpanelpositionenum

	:param framedepth
	:type framedepth:ifcpositivelengthmeasure

	:param framethickness
	:type framethickness:ifcpositivelengthmeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , operationtype,panelposition,framedepth,framethickness,shapeaspectstyle, ):
		ifcpredefinedpropertyset.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.operationtype = operationtype
		self.panelposition = panelposition
		self.framedepth = framedepth
		self.framethickness = framethickness
		self.shapeaspectstyle = shapeaspectstyle

	@apply
	def operationtype():
		def fget( self ):
			return self._operationtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operationtype is mantatory and can not be set to None')
			if not check_type(value,ifcpermeablecoveringoperationenum):
				self._operationtype = ifcpermeablecoveringoperationenum(value)
			else:
				self._operationtype = value
		return property(**locals())

	@apply
	def panelposition():
		def fget( self ):
			return self._panelposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument panelposition is mantatory and can not be set to None')
			if not check_type(value,ifcwindowpanelpositionenum):
				self._panelposition = ifcwindowpanelpositionenum(value)
			else:
				self._panelposition = value
		return property(**locals())

	@apply
	def framedepth():
		def fget( self ):
			return self._framedepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._framedepth = ifcpositivelengthmeasure(value)
				else:
					self._framedepth = value
			else:
				self._framedepth = value
		return property(**locals())

	@apply
	def framethickness():
		def fget( self ):
			return self._framethickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._framethickness = ifcpositivelengthmeasure(value)
				else:
					self._framethickness = value
			else:
				self._framethickness = value
		return property(**locals())

	@apply
	def shapeaspectstyle():
		def fget( self ):
			return self._shapeaspectstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshapeaspect):
					self._shapeaspectstyle = ifcshapeaspect(value)
				else:
					self._shapeaspectstyle = value
			else:
				self._shapeaspectstyle = value
		return property(**locals())

####################
 # ENTITY ifccompositecurvesegment #
####################
class ifccompositecurvesegment(ifcgeometricrepresentationitem):
	'''Entity ifccompositecurvesegment definition.

	:param transition
	:type transition:ifctransitioncode

	:param samesense
	:type samesense:BOOLEAN

	:param parentcurve
	:type parentcurve:ifccurve

	:param dim
	:type dim:ifcdimensioncount

	:param usingcurves
	:type usingcurves:SET(1,None,'ifccompositecurve', scope = schema_scope)
	'''
	def __init__( self , transition,samesense,parentcurve, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.transition = transition
		self.samesense = samesense
		self.parentcurve = parentcurve

	@apply
	def transition():
		def fget( self ):
			return self._transition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transition is mantatory and can not be set to None')
			if not check_type(value,ifctransitioncode):
				self._transition = ifctransitioncode(value)
			else:
				self._transition = value
		return property(**locals())

	@apply
	def samesense():
		def fget( self ):
			return self._samesense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument samesense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._samesense = BOOLEAN(value)
			else:
				self._samesense = value
		return property(**locals())

	@apply
	def parentcurve():
		def fget( self ):
			return self._parentcurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parentcurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._parentcurve = ifccurve(value)
			else:
				self._parentcurve = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.parentcurve.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def usingcurves():
		def fget( self ):
			return self._usingcurves
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument usingcurves is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def parentisboundedcurve(self):
		eval_parentisboundedcurve_wr = ('IFC4.IFCBOUNDEDCURVE'  ==  TYPEOF(self.parentcurve))
		if not eval_parentisboundedcurve_wr:
			raise AssertionError('Rule parentisboundedcurve violated')
		else:
			return eval_parentisboundedcurve_wr


####################
 # ENTITY ifcreparametrisedcompositecurvesegment #
####################
class ifcreparametrisedcompositecurvesegment(ifccompositecurvesegment):
	'''Entity ifcreparametrisedcompositecurvesegment definition.

	:param paramlength
	:type paramlength:ifcparametervalue
	'''
	def __init__( self , inherited0__transition , inherited1__samesense , inherited2__parentcurve , paramlength, ):
		ifccompositecurvesegment.__init__(self , inherited0__transition , inherited1__samesense , inherited2__parentcurve , )
		self.paramlength = paramlength

	@apply
	def paramlength():
		def fget( self ):
			return self._paramlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument paramlength is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._paramlength = ifcparametervalue(value)
			else:
				self._paramlength = value
		return property(**locals())
	def positivelengthparameter(self):
		eval_positivelengthparameter_wr = (self.paramlength  >  0)
		if not eval_positivelengthparameter_wr:
			raise AssertionError('Rule positivelengthparameter violated')
		else:
			return eval_positivelengthparameter_wr


####################
 # ENTITY ifccurve #
####################
class ifccurve(ifcgeometricrepresentationitem):
	'''Entity ifccurve definition.

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self ,  ):
		ifcgeometricrepresentationitem.__init__(self , )

	@apply
	def dim():
		def fget( self ):
			attribute_eval = ifccurvedim(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcboundedcurve #
####################
class ifcboundedcurve(ifccurve):
	'''Entity ifcboundedcurve definition.
	'''
	def __init__( self ,  ):
		ifccurve.__init__(self , )

####################
 # ENTITY ifcbsplinecurve #
####################
class ifcbsplinecurve(ifcboundedcurve):
	'''Entity ifcbsplinecurve definition.

	:param degree
	:type degree:INTEGER

	:param controlpointslist
	:type controlpointslist:LIST(2,None,'ifccartesianpoint', scope = schema_scope)

	:param curveform
	:type curveform:ifcbsplinecurveform

	:param closedcurve
	:type closedcurve:LOGICAL

	:param selfintersect
	:type selfintersect:LOGICAL

	:param upperindexoncontrolpoints
	:type upperindexoncontrolpoints:INTEGER

	:param controlpoints
	:type controlpoints:ARRAY(0,upperindexoncontrolpoints,'ifccartesianpoint', scope = schema_scope)
	'''
	def __init__( self , degree,controlpointslist,curveform,closedcurve,selfintersect, ):
		ifcboundedcurve.__init__(self , )
		self.degree = degree
		self.controlpointslist = controlpointslist
		self.curveform = curveform
		self.closedcurve = closedcurve
		self.selfintersect = selfintersect

	@apply
	def degree():
		def fget( self ):
			return self._degree
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument degree is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._degree = INTEGER(value)
			else:
				self._degree = value
		return property(**locals())

	@apply
	def controlpointslist():
		def fget( self ):
			return self._controlpointslist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument controlpointslist is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'ifccartesianpoint', scope = schema_scope)):
				self._controlpointslist = LIST(value)
			else:
				self._controlpointslist = value
		return property(**locals())

	@apply
	def curveform():
		def fget( self ):
			return self._curveform
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curveform is mantatory and can not be set to None')
			if not check_type(value,ifcbsplinecurveform):
				self._curveform = ifcbsplinecurveform(value)
			else:
				self._curveform = value
		return property(**locals())

	@apply
	def closedcurve():
		def fget( self ):
			return self._closedcurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument closedcurve is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._closedcurve = LOGICAL(value)
			else:
				self._closedcurve = value
		return property(**locals())

	@apply
	def selfintersect():
		def fget( self ):
			return self._selfintersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument selfintersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._selfintersect = LOGICAL(value)
			else:
				self._selfintersect = value
		return property(**locals())

	@apply
	def upperindexoncontrolpoints():
		def fget( self ):
			attribute_eval = (SIZEOF(self.controlpointslist) - 1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument upperindexoncontrolpoints is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def controlpoints():
		def fget( self ):
			attribute_eval = ifclisttoarray(self.controlpointslist,0,self.upperindexoncontrolpoints)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument controlpoints is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def samedim(self):
		eval_samedim_wr = (SIZEOF(None)  ==  0)
		if not eval_samedim_wr:
			raise AssertionError('Rule samedim violated')
		else:
			return eval_samedim_wr


####################
 # ENTITY ifcstructuralaction #
####################
class ifcstructuralaction(ifcstructuralactivity):
	'''Entity ifcstructuralaction definition.

	:param destabilizingload
	:type destabilizingload:BOOLEAN
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , destabilizingload, ):
		ifcstructuralactivity.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , )
		self.destabilizingload = destabilizingload

	@apply
	def destabilizingload():
		def fget( self ):
			return self._destabilizingload
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._destabilizingload = BOOLEAN(value)
				else:
					self._destabilizingload = value
			else:
				self._destabilizingload = value
		return property(**locals())

####################
 # ENTITY ifcstructuralsurfaceaction #
####################
class ifcstructuralsurfaceaction(ifcstructuralaction):
	'''Entity ifcstructuralsurfaceaction definition.

	:param projectedortrue
	:type projectedortrue:ifcprojectedortruelengthenum

	:param predefinedtype
	:type predefinedtype:ifcstructuralsurfaceactivitytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , projectedortrue,predefinedtype, ):
		ifcstructuralaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , )
		self.projectedortrue = projectedortrue
		self.predefinedtype = predefinedtype

	@apply
	def projectedortrue():
		def fget( self ):
			return self._projectedortrue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcprojectedortruelengthenum):
					self._projectedortrue = ifcprojectedortruelengthenum(value)
				else:
					self._projectedortrue = value
			else:
				self._projectedortrue = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralsurfaceactivitytypeenum):
				self._predefinedtype = ifcstructuralsurfaceactivitytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def projectedisglobal(self):
		eval_projectedisglobal_wr = (( not EXISTS(self.projectedortrue))  or  ((self.projectedortrue  !=  projected_length)  or  (self.self.ifcstructuralactivity.self.globalorlocal  ==  global_coords)))
		if not eval_projectedisglobal_wr:
			raise AssertionError('Rule projectedisglobal violated')
		else:
			return eval_projectedisglobal_wr

	def hasobjecttype(self):
		eval_hasobjecttype_wr = ((self.predefinedtype  !=  ifcstructuralsurfaceactivitytypeenum.self.userdefined)  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_hasobjecttype_wr:
			raise AssertionError('Rule hasobjecttype violated')
		else:
			return eval_hasobjecttype_wr


####################
 # ENTITY ifcflowcontrollertype #
####################
class ifcflowcontrollertype(ifcdistributionflowelementtype):
	'''Entity ifcflowcontrollertype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcvalvetype #
####################
class ifcvalvetype(ifcflowcontrollertype):
	'''Entity ifcvalvetype definition.

	:param predefinedtype
	:type predefinedtype:ifcvalvetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcvalvetypeenum):
				self._predefinedtype = ifcvalvetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcvalvetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcvalvetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcsweptareasolid #
####################
class ifcsweptareasolid(ifcsolidmodel):
	'''Entity ifcsweptareasolid definition.

	:param sweptarea
	:type sweptarea:ifcprofiledef

	:param position
	:type position:ifcaxis2placement3d
	'''
	def __init__( self , sweptarea,position, ):
		ifcsolidmodel.__init__(self , )
		self.sweptarea = sweptarea
		self.position = position

	@apply
	def sweptarea():
		def fget( self ):
			return self._sweptarea
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sweptarea is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._sweptarea = ifcprofiledef(value)
			else:
				self._sweptarea = value
		return property(**locals())

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaxis2placement3d):
					self._position = ifcaxis2placement3d(value)
				else:
					self._position = value
			else:
				self._position = value
		return property(**locals())
	def sweptareatype(self):
		eval_sweptareatype_wr = (self.sweptarea.self.profiletype  ==  ifcprofiletypeenum.self.area)
		if not eval_sweptareatype_wr:
			raise AssertionError('Rule sweptareatype violated')
		else:
			return eval_sweptareatype_wr


####################
 # ENTITY ifcrevolvedareasolid #
####################
class ifcrevolvedareasolid(ifcsweptareasolid):
	'''Entity ifcrevolvedareasolid definition.

	:param axis
	:type axis:ifcaxis1placement

	:param angle
	:type angle:ifcplaneanglemeasure

	:param axisline
	:type axisline:ifcline
	'''
	def __init__( self , inherited0__sweptarea , inherited1__position , axis,angle, ):
		ifcsweptareasolid.__init__(self , inherited0__sweptarea , inherited1__position , )
		self.axis = axis
		self.angle = angle

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axis is mantatory and can not be set to None')
			if not check_type(value,ifcaxis1placement):
				self._axis = ifcaxis1placement(value)
			else:
				self._axis = value
		return property(**locals())

	@apply
	def angle():
		def fget( self ):
			return self._angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle is mantatory and can not be set to None')
			if not check_type(value,ifcplaneanglemeasure):
				self._angle = ifcplaneanglemeasure(value)
			else:
				self._angle = value
		return property(**locals())

	@apply
	def axisline():
		def fget( self ):
			attribute_eval = (((ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifccurve())  ==  ifcline(self.axis.self.location,(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(self.axis.self.z,1)))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument axisline is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def axisstartinxy(self):
		eval_axisstartinxy_wr = (self.axis.self.location.self.coordinates[3]  ==  0)
		if not eval_axisstartinxy_wr:
			raise AssertionError('Rule axisstartinxy violated')
		else:
			return eval_axisstartinxy_wr

	def axisdirectioninxy(self):
		eval_axisdirectioninxy_wr = (self.axis.self.z.self.directionratios[3]  ==  0)
		if not eval_axisdirectioninxy_wr:
			raise AssertionError('Rule axisdirectioninxy violated')
		else:
			return eval_axisdirectioninxy_wr


####################
 # ENTITY ifctexturecoordinate #
####################
class ifctexturecoordinate(ifcpresentationitem):
	'''Entity ifctexturecoordinate definition.

	:param maps
	:type maps:LIST(1,None,'ifcsurfacetexture', scope = schema_scope)
	'''
	def __init__( self , maps, ):
		ifcpresentationitem.__init__(self , )
		self.maps = maps

	@apply
	def maps():
		def fget( self ):
			return self._maps
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument maps is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcsurfacetexture', scope = schema_scope)):
				self._maps = LIST(value)
			else:
				self._maps = value
		return property(**locals())

####################
 # ENTITY ifctexturemap #
####################
class ifctexturemap(ifctexturecoordinate):
	'''Entity ifctexturemap definition.

	:param vertices
	:type vertices:LIST(3,None,'ifctexturevertex', scope = schema_scope)

	:param mappedto
	:type mappedto:ifcface
	'''
	def __init__( self , inherited0__maps , vertices,mappedto, ):
		ifctexturecoordinate.__init__(self , inherited0__maps , )
		self.vertices = vertices
		self.mappedto = mappedto

	@apply
	def vertices():
		def fget( self ):
			return self._vertices
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vertices is mantatory and can not be set to None')
			if not check_type(value,LIST(3,None,'ifctexturevertex', scope = schema_scope)):
				self._vertices = LIST(value)
			else:
				self._vertices = value
		return property(**locals())

	@apply
	def mappedto():
		def fget( self ):
			return self._mappedto
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mappedto is mantatory and can not be set to None')
			if not check_type(value,ifcface):
				self._mappedto = ifcface(value)
			else:
				self._mappedto = value
		return property(**locals())

####################
 # ENTITY ifcairterminalboxtype #
####################
class ifcairterminalboxtype(ifcflowcontrollertype):
	'''Entity ifcairterminalboxtype definition.

	:param predefinedtype
	:type predefinedtype:ifcairterminalboxtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcairterminalboxtypeenum):
				self._predefinedtype = ifcairterminalboxtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcairterminalboxtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcairterminalboxtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcboundarycondition #
####################
class ifcboundarycondition(BaseEntityClass):
	'''Entity ifcboundarycondition definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifcbuildingelementproxytype #
####################
class ifcbuildingelementproxytype(ifcbuildingelementtype):
	'''Entity ifcbuildingelementproxytype definition.

	:param predefinedtype
	:type predefinedtype:ifcbuildingelementproxytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcbuildingelementproxytypeenum):
				self._predefinedtype = ifcbuildingelementproxytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcbuildingelementproxytypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcbuildingelementproxytypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcpresentationstyle #
####################
class ifcpresentationstyle(BaseEntityClass):
	'''Entity ifcpresentationstyle definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifcfillareastyle #
####################
class ifcfillareastyle(ifcpresentationstyle):
	'''Entity ifcfillareastyle definition.

	:param fillstyles
	:type fillstyles:SET(1,None,'ifcfillstyleselect', scope = schema_scope)

	:param modelordraughting
	:type modelordraughting:BOOLEAN
	'''
	def __init__( self , inherited0__name , fillstyles,modelordraughting, ):
		ifcpresentationstyle.__init__(self , inherited0__name , )
		self.fillstyles = fillstyles
		self.modelordraughting = modelordraughting

	@apply
	def fillstyles():
		def fget( self ):
			return self._fillstyles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fillstyles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcfillstyleselect', scope = schema_scope)):
				self._fillstyles = SET(value)
			else:
				self._fillstyles = value
		return property(**locals())

	@apply
	def modelordraughting():
		def fget( self ):
			return self._modelordraughting
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._modelordraughting = BOOLEAN(value)
				else:
					self._modelordraughting = value
			else:
				self._modelordraughting = value
		return property(**locals())
	def maxonecolour(self):
		eval_maxonecolour_wr = (SIZEOF(None)  <=  1)
		if not eval_maxonecolour_wr:
			raise AssertionError('Rule maxonecolour violated')
		else:
			return eval_maxonecolour_wr

	def maxoneexthatchstyle(self):
		eval_maxoneexthatchstyle_wr = (SIZEOF(None)  <=  1)
		if not eval_maxoneexthatchstyle_wr:
			raise AssertionError('Rule maxoneexthatchstyle violated')
		else:
			return eval_maxoneexthatchstyle_wr

	def consistenthatchstyledef(self):
		eval_consistenthatchstyledef_wr = ifccorrectfillareastyle(self.self.fillstyles)
		if not eval_consistenthatchstyledef_wr:
			raise AssertionError('Rule consistenthatchstyledef violated')
		else:
			return eval_consistenthatchstyledef_wr


####################
 # ENTITY ifccsgsolid #
####################
class ifccsgsolid(ifcsolidmodel):
	'''Entity ifccsgsolid definition.

	:param treerootexpression
	:type treerootexpression:ifccsgselect
	'''
	def __init__( self , treerootexpression, ):
		ifcsolidmodel.__init__(self , )
		self.treerootexpression = treerootexpression

	@apply
	def treerootexpression():
		def fget( self ):
			return self._treerootexpression
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument treerootexpression is mantatory and can not be set to None')
			if not check_type(value,ifccsgselect):
				self._treerootexpression = ifccsgselect(value)
			else:
				self._treerootexpression = value
		return property(**locals())

####################
 # ENTITY ifcfurnishingelement #
####################
class ifcfurnishingelement(ifcelement):
	'''Entity ifcfurnishingelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcfurniture #
####################
class ifcfurniture(ifcfurnishingelement):
	'''Entity ifcfurniture definition.

	:param predefinedtype
	:type predefinedtype:ifcfurnituretypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcfurnishingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfurnituretypeenum):
					self._predefinedtype = ifcfurnituretypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcfurnituretypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcfurnituretypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCFURNITURETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcsurfacetexture #
####################
class ifcsurfacetexture(ifcpresentationitem):
	'''Entity ifcsurfacetexture definition.

	:param repeats
	:type repeats:BOOLEAN

	:param repeatt
	:type repeatt:BOOLEAN

	:param mode
	:type mode:ifcidentifier

	:param texturetransform
	:type texturetransform:ifccartesiantransformationoperator2d

	:param parameter
	:type parameter:LIST(1,None,'STRING', scope = schema_scope)

	:param ismappedby
	:type ismappedby:SET(0,None,'ifctexturecoordinate', scope = schema_scope)

	:param usedinstyles
	:type usedinstyles:SET(0,None,'ifcsurfacestylewithtextures', scope = schema_scope)
	'''
	def __init__( self , repeats,repeatt,mode,texturetransform,parameter, ):
		ifcpresentationitem.__init__(self , )
		self.repeats = repeats
		self.repeatt = repeatt
		self.mode = mode
		self.texturetransform = texturetransform
		self.parameter = parameter

	@apply
	def repeats():
		def fget( self ):
			return self._repeats
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument repeats is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._repeats = BOOLEAN(value)
			else:
				self._repeats = value
		return property(**locals())

	@apply
	def repeatt():
		def fget( self ):
			return self._repeatt
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument repeatt is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._repeatt = BOOLEAN(value)
			else:
				self._repeatt = value
		return property(**locals())

	@apply
	def mode():
		def fget( self ):
			return self._mode
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._mode = ifcidentifier(value)
				else:
					self._mode = value
			else:
				self._mode = value
		return property(**locals())

	@apply
	def texturetransform():
		def fget( self ):
			return self._texturetransform
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccartesiantransformationoperator2d):
					self._texturetransform = ifccartesiantransformationoperator2d(value)
				else:
					self._texturetransform = value
			else:
				self._texturetransform = value
		return property(**locals())

	@apply
	def parameter():
		def fget( self ):
			return self._parameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._parameter = LIST(value)
				else:
					self._parameter = value
			else:
				self._parameter = value
		return property(**locals())

	@apply
	def ismappedby():
		def fget( self ):
			return self._ismappedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ismappedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def usedinstyles():
		def fget( self ):
			return self._usedinstyles
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument usedinstyles is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcpixeltexture #
####################
class ifcpixeltexture(ifcsurfacetexture):
	'''Entity ifcpixeltexture definition.

	:param width
	:type width:ifcinteger

	:param height
	:type height:ifcinteger

	:param colourcomponents
	:type colourcomponents:ifcinteger

	:param pixel
	:type pixel:LIST(1,None,'(null)', scope = schema_scope)
	'''
	def __init__( self , inherited0__repeats , inherited1__repeatt , inherited2__mode , inherited3__texturetransform , inherited4__parameter , width,height,colourcomponents,pixel, ):
		ifcsurfacetexture.__init__(self , inherited0__repeats , inherited1__repeatt , inherited2__mode , inherited3__texturetransform , inherited4__parameter , )
		self.width = width
		self.height = height
		self.colourcomponents = colourcomponents
		self.pixel = pixel

	@apply
	def width():
		def fget( self ):
			return self._width
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument width is mantatory and can not be set to None')
			if not check_type(value,ifcinteger):
				self._width = ifcinteger(value)
			else:
				self._width = value
		return property(**locals())

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,ifcinteger):
				self._height = ifcinteger(value)
			else:
				self._height = value
		return property(**locals())

	@apply
	def colourcomponents():
		def fget( self ):
			return self._colourcomponents
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument colourcomponents is mantatory and can not be set to None')
			if not check_type(value,ifcinteger):
				self._colourcomponents = ifcinteger(value)
			else:
				self._colourcomponents = value
		return property(**locals())

	@apply
	def pixel():
		def fget( self ):
			return self._pixel
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pixel is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'(null)', scope = schema_scope)):
				self._pixel = LIST(value)
			else:
				self._pixel = value
		return property(**locals())
	def minpixelins(self):
		eval_minpixelins_wr = (self.width  >=  1)
		if not eval_minpixelins_wr:
			raise AssertionError('Rule minpixelins violated')
		else:
			return eval_minpixelins_wr

	def minpixelint(self):
		eval_minpixelint_wr = (self.height  >=  1)
		if not eval_minpixelint_wr:
			raise AssertionError('Rule minpixelint violated')
		else:
			return eval_minpixelint_wr

	def numberofcolours(self):
		eval_numberofcolours_wr = ((1  <=  self.colourcomponents)  and  (self.colourcomponents  <=  4))
		if not eval_numberofcolours_wr:
			raise AssertionError('Rule numberofcolours violated')
		else:
			return eval_numberofcolours_wr

	def sizeofpixellist(self):
		eval_sizeofpixellist_wr = (SIZEOF(self.pixel)  ==  (self.width  *  self.height))
		if not eval_sizeofpixellist_wr:
			raise AssertionError('Rule sizeofpixellist violated')
		else:
			return eval_sizeofpixellist_wr

	def pixelasbyteandsamelength(self):
		eval_pixelasbyteandsamelength_wr = (SIZEOF(None)  ==  SIZEOF(self.pixel))
		if not eval_pixelasbyteandsamelength_wr:
			raise AssertionError('Rule pixelasbyteandsamelength violated')
		else:
			return eval_pixelasbyteandsamelength_wr


####################
 # ENTITY ifctypeprocess #
####################
class ifctypeprocess(ifctypeobject):
	'''Entity ifctypeprocess definition.

	:param identification
	:type identification:ifcidentifier

	:param longdescription
	:type longdescription:ifctext

	:param processtype
	:type processtype:ifclabel

	:param operateson
	:type operateson:SET(0,None,'ifcrelassignstoprocess', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , identification,longdescription,processtype, ):
		ifctypeobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , )
		self.identification = identification
		self.longdescription = longdescription
		self.processtype = processtype

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identification = ifcidentifier(value)
				else:
					self._identification = value
			else:
				self._identification = value
		return property(**locals())

	@apply
	def longdescription():
		def fget( self ):
			return self._longdescription
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._longdescription = ifctext(value)
				else:
					self._longdescription = value
			else:
				self._longdescription = value
		return property(**locals())

	@apply
	def processtype():
		def fget( self ):
			return self._processtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._processtype = ifclabel(value)
				else:
					self._processtype = value
			else:
				self._processtype = value
		return property(**locals())

	@apply
	def operateson():
		def fget( self ):
			return self._operateson
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument operateson is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcrelassociates #
####################
class ifcrelassociates(ifcrelationship):
	'''Entity ifcrelassociates definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcdefinitionselect', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedobjects, ):
		ifcrelationship.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedobjects = relatedobjects

	@apply
	def relatedobjects():
		def fget( self ):
			return self._relatedobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcdefinitionselect', scope = schema_scope)):
				self._relatedobjects = SET(value)
			else:
				self._relatedobjects = value
		return property(**locals())

####################
 # ENTITY ifcreldecomposes #
####################
class ifcreldecomposes(ifcrelationship):
	'''Entity ifcreldecomposes definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcrelationship.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

####################
 # ENTITY ifcrelnests #
####################
class ifcrelnests(ifcreldecomposes):
	'''Entity ifcrelnests definition.

	:param relatingobject
	:type relatingobject:ifcobjectdefinition

	:param relatedobjects
	:type relatedobjects:LIST(1,None,'ifcobjectdefinition', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingobject,relatedobjects, ):
		ifcreldecomposes.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingobject = relatingobject
		self.relatedobjects = relatedobjects

	@apply
	def relatingobject():
		def fget( self ):
			return self._relatingobject
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingobject is mantatory and can not be set to None')
			if not check_type(value,ifcobjectdefinition):
				self._relatingobject = ifcobjectdefinition(value)
			else:
				self._relatingobject = value
		return property(**locals())

	@apply
	def relatedobjects():
		def fget( self ):
			return self._relatedobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedobjects is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcobjectdefinition', scope = schema_scope)):
				self._relatedobjects = LIST(value)
			else:
				self._relatedobjects = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (SIZEOF(None)  ==  0)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifcspatialelementtype #
####################
class ifcspatialelementtype(ifctypeproduct):
	'''Entity ifcspatialelementtype definition.

	:param elementtype
	:type elementtype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , elementtype, ):
		ifctypeproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , )
		self.elementtype = elementtype

	@apply
	def elementtype():
		def fget( self ):
			return self._elementtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._elementtype = ifclabel(value)
				else:
					self._elementtype = value
			else:
				self._elementtype = value
		return property(**locals())

####################
 # ENTITY ifcspatialstructureelementtype #
####################
class ifcspatialstructureelementtype(ifcspatialelementtype):
	'''Entity ifcspatialstructureelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcspatialelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcspacetype #
####################
class ifcspacetype(ifcspatialstructureelementtype):
	'''Entity ifcspacetype definition.

	:param predefinedtype
	:type predefinedtype:ifcspacetypeenum

	:param longname
	:type longname:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype,longname, ):
		ifcspatialstructureelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype
		self.longname = longname

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcspacetypeenum):
				self._predefinedtype = ifcspacetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def longname():
		def fget( self ):
			return self._longname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._longname = ifclabel(value)
				else:
					self._longname = value
			else:
				self._longname = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcspacetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcspacetypeenum.self.userdefined)  and  EXISTS(self.self.ifcspatialelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcplacement #
####################
class ifcplacement(ifcgeometricrepresentationitem):
	'''Entity ifcplacement definition.

	:param location
	:type location:ifccartesianpoint

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , location, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.location = location

	@apply
	def location():
		def fget( self ):
			return self._location
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument location is mantatory and can not be set to None')
			if not check_type(value,ifccartesianpoint):
				self._location = ifccartesianpoint(value)
			else:
				self._location = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.location.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcaxis1placement #
####################
class ifcaxis1placement(ifcplacement):
	'''Entity ifcaxis1placement definition.

	:param axis
	:type axis:ifcdirection

	:param z
	:type z:ifcdirection
	'''
	def __init__( self , inherited0__location , axis, ):
		ifcplacement.__init__(self , inherited0__location , )
		self.axis = axis

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._axis = ifcdirection(value)
				else:
					self._axis = value
			else:
				self._axis = value
		return property(**locals())

	@apply
	def z():
		def fget( self ):
			attribute_eval = NVL(ifcnormalise(self.axis),(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,0,1]))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument z is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def axisis3d(self):
		eval_axisis3d_wr = (( not EXISTS(self.axis))  or  (self.axis.self.dim  ==  3))
		if not eval_axisis3d_wr:
			raise AssertionError('Rule axisis3d violated')
		else:
			return eval_axisis3d_wr

	def locationis3d(self):
		eval_locationis3d_wr = (self.self.ifcplacement.self.location.self.dim  ==  3)
		if not eval_locationis3d_wr:
			raise AssertionError('Rule locationis3d violated')
		else:
			return eval_locationis3d_wr


####################
 # ENTITY ifcflowfitting #
####################
class ifcflowfitting(ifcdistributionflowelement):
	'''Entity ifcflowfitting definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifccablecarrierfitting #
####################
class ifccablecarrierfitting(ifcflowfitting):
	'''Entity ifccablecarrierfitting definition.

	:param predefinedtype
	:type predefinedtype:ifccablecarrierfittingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowfitting.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccablecarrierfittingtypeenum):
					self._predefinedtype = ifccablecarrierfittingtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccablecarrierfittingtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccablecarrierfittingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCABLECARRIERFITTINGTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcelectricgeneratortype #
####################
class ifcelectricgeneratortype(ifcenergyconversiondevicetype):
	'''Entity ifcelectricgeneratortype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricgeneratortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectricgeneratortypeenum):
				self._predefinedtype = ifcelectricgeneratortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcelectricgeneratortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcelectricgeneratortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcflowfittingtype #
####################
class ifcflowfittingtype(ifcdistributionflowelementtype):
	'''Entity ifcflowfittingtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcpipefittingtype #
####################
class ifcpipefittingtype(ifcflowfittingtype):
	'''Entity ifcpipefittingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcpipefittingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowfittingtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcpipefittingtypeenum):
				self._predefinedtype = ifcpipefittingtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcpipefittingtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcpipefittingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcindexedcolourmap #
####################
class ifcindexedcolourmap(ifcpresentationitem):
	'''Entity ifcindexedcolourmap definition.

	:param mappedto
	:type mappedto:ifctessellatedfaceset

	:param overrides
	:type overrides:ifcsurfacestyleshading

	:param colours
	:type colours:ifccolourrgblist

	:param colourindex
	:type colourindex:LIST(1,None,'INTEGER', scope = schema_scope)
	'''
	def __init__( self , mappedto,overrides,colours,colourindex, ):
		ifcpresentationitem.__init__(self , )
		self.mappedto = mappedto
		self.overrides = overrides
		self.colours = colours
		self.colourindex = colourindex

	@apply
	def mappedto():
		def fget( self ):
			return self._mappedto
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mappedto is mantatory and can not be set to None')
			if not check_type(value,ifctessellatedfaceset):
				self._mappedto = ifctessellatedfaceset(value)
			else:
				self._mappedto = value
		return property(**locals())

	@apply
	def overrides():
		def fget( self ):
			return self._overrides
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsurfacestyleshading):
					self._overrides = ifcsurfacestyleshading(value)
				else:
					self._overrides = value
			else:
				self._overrides = value
		return property(**locals())

	@apply
	def colours():
		def fget( self ):
			return self._colours
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument colours is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgblist):
				self._colours = ifccolourrgblist(value)
			else:
				self._colours = value
		return property(**locals())

	@apply
	def colourindex():
		def fget( self ):
			return self._colourindex
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument colourindex is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'INTEGER', scope = schema_scope)):
				self._colourindex = LIST(value)
			else:
				self._colourindex = value
		return property(**locals())

####################
 # ENTITY ifcstructuralconnection #
####################
class ifcstructuralconnection(ifcstructuralitem):
	'''Entity ifcstructuralconnection definition.

	:param appliedcondition
	:type appliedcondition:ifcboundarycondition

	:param connectsstructuralmembers
	:type connectsstructuralmembers:SET(1,None,'ifcrelconnectsstructuralmember', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , appliedcondition, ):
		ifcstructuralitem.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.appliedcondition = appliedcondition

	@apply
	def appliedcondition():
		def fget( self ):
			return self._appliedcondition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcboundarycondition):
					self._appliedcondition = ifcboundarycondition(value)
				else:
					self._appliedcondition = value
			else:
				self._appliedcondition = value
		return property(**locals())

	@apply
	def connectsstructuralmembers():
		def fget( self ):
			return self._connectsstructuralmembers
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectsstructuralmembers is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcflowterminaltype #
####################
class ifcflowterminaltype(ifcdistributionflowelementtype):
	'''Entity ifcflowterminaltype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcwasteterminaltype #
####################
class ifcwasteterminaltype(ifcflowterminaltype):
	'''Entity ifcwasteterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcwasteterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcwasteterminaltypeenum):
				self._predefinedtype = ifcwasteterminaltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcwasteterminaltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcwasteterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcfastenertype #
####################
class ifcfastenertype(ifcelementcomponenttype):
	'''Entity ifcfastenertype definition.

	:param predefinedtype
	:type predefinedtype:ifcfastenertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcelementcomponenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcfastenertypeenum):
				self._predefinedtype = ifcfastenertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcfastenertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcfastenertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifclamptype #
####################
class ifclamptype(ifcflowterminaltype):
	'''Entity ifclamptype definition.

	:param predefinedtype
	:type predefinedtype:ifclamptypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifclamptypeenum):
				self._predefinedtype = ifclamptypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifclamptypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifclamptypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcpredefineditem #
####################
class ifcpredefineditem(ifcpresentationitem):
	'''Entity ifcpredefineditem definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		ifcpresentationitem.__init__(self , )
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifctrimmedcurve #
####################
class ifctrimmedcurve(ifcboundedcurve):
	'''Entity ifctrimmedcurve definition.

	:param basiscurve
	:type basiscurve:ifccurve

	:param trim1
	:type trim1:SET(1,2,'ifctrimmingselect', scope = schema_scope)

	:param trim2
	:type trim2:SET(1,2,'ifctrimmingselect', scope = schema_scope)

	:param senseagreement
	:type senseagreement:BOOLEAN

	:param masterrepresentation
	:type masterrepresentation:ifctrimmingpreference
	'''
	def __init__( self , basiscurve,trim1,trim2,senseagreement,masterrepresentation, ):
		ifcboundedcurve.__init__(self , )
		self.basiscurve = basiscurve
		self.trim1 = trim1
		self.trim2 = trim2
		self.senseagreement = senseagreement
		self.masterrepresentation = masterrepresentation

	@apply
	def basiscurve():
		def fget( self ):
			return self._basiscurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basiscurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._basiscurve = ifccurve(value)
			else:
				self._basiscurve = value
		return property(**locals())

	@apply
	def trim1():
		def fget( self ):
			return self._trim1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument trim1 is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'ifctrimmingselect', scope = schema_scope)):
				self._trim1 = SET(value)
			else:
				self._trim1 = value
		return property(**locals())

	@apply
	def trim2():
		def fget( self ):
			return self._trim2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument trim2 is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'ifctrimmingselect', scope = schema_scope)):
				self._trim2 = SET(value)
			else:
				self._trim2 = value
		return property(**locals())

	@apply
	def senseagreement():
		def fget( self ):
			return self._senseagreement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument senseagreement is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._senseagreement = BOOLEAN(value)
			else:
				self._senseagreement = value
		return property(**locals())

	@apply
	def masterrepresentation():
		def fget( self ):
			return self._masterrepresentation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument masterrepresentation is mantatory and can not be set to None')
			if not check_type(value,ifctrimmingpreference):
				self._masterrepresentation = ifctrimmingpreference(value)
			else:
				self._masterrepresentation = value
		return property(**locals())
	def trim1valuesconsistent(self):
		eval_trim1valuesconsistent_wr = ((HIINDEX(self.trim1)  ==  1)  or  (TYPEOF(self.trim1[1])  !=  TYPEOF(self.trim1[2])))
		if not eval_trim1valuesconsistent_wr:
			raise AssertionError('Rule trim1valuesconsistent violated')
		else:
			return eval_trim1valuesconsistent_wr

	def trim2valuesconsistent(self):
		eval_trim2valuesconsistent_wr = ((HIINDEX(self.trim2)  ==  1)  or  (TYPEOF(self.trim2[1])  !=  TYPEOF(self.trim2[2])))
		if not eval_trim2valuesconsistent_wr:
			raise AssertionError('Rule trim2valuesconsistent violated')
		else:
			return eval_trim2valuesconsistent_wr

	def notrimofboundedcurves(self):
		eval_notrimofboundedcurves_wr = ( not ('IFC4.IFCBOUNDEDCURVE'  ==  TYPEOF(self.basiscurve)))
		if not eval_notrimofboundedcurves_wr:
			raise AssertionError('Rule notrimofboundedcurves violated')
		else:
			return eval_notrimofboundedcurves_wr


####################
 # ENTITY ifcboundarynodecondition #
####################
class ifcboundarynodecondition(ifcboundarycondition):
	'''Entity ifcboundarynodecondition definition.

	:param translationalstiffnessx
	:type translationalstiffnessx:ifctranslationalstiffnessselect

	:param translationalstiffnessy
	:type translationalstiffnessy:ifctranslationalstiffnessselect

	:param translationalstiffnessz
	:type translationalstiffnessz:ifctranslationalstiffnessselect

	:param rotationalstiffnessx
	:type rotationalstiffnessx:ifcrotationalstiffnessselect

	:param rotationalstiffnessy
	:type rotationalstiffnessy:ifcrotationalstiffnessselect

	:param rotationalstiffnessz
	:type rotationalstiffnessz:ifcrotationalstiffnessselect
	'''
	def __init__( self , inherited0__name , translationalstiffnessx,translationalstiffnessy,translationalstiffnessz,rotationalstiffnessx,rotationalstiffnessy,rotationalstiffnessz, ):
		ifcboundarycondition.__init__(self , inherited0__name , )
		self.translationalstiffnessx = translationalstiffnessx
		self.translationalstiffnessy = translationalstiffnessy
		self.translationalstiffnessz = translationalstiffnessz
		self.rotationalstiffnessx = rotationalstiffnessx
		self.rotationalstiffnessy = rotationalstiffnessy
		self.rotationalstiffnessz = rotationalstiffnessz

	@apply
	def translationalstiffnessx():
		def fget( self ):
			return self._translationalstiffnessx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctranslationalstiffnessselect):
					self._translationalstiffnessx = ifctranslationalstiffnessselect(value)
				else:
					self._translationalstiffnessx = value
			else:
				self._translationalstiffnessx = value
		return property(**locals())

	@apply
	def translationalstiffnessy():
		def fget( self ):
			return self._translationalstiffnessy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctranslationalstiffnessselect):
					self._translationalstiffnessy = ifctranslationalstiffnessselect(value)
				else:
					self._translationalstiffnessy = value
			else:
				self._translationalstiffnessy = value
		return property(**locals())

	@apply
	def translationalstiffnessz():
		def fget( self ):
			return self._translationalstiffnessz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctranslationalstiffnessselect):
					self._translationalstiffnessz = ifctranslationalstiffnessselect(value)
				else:
					self._translationalstiffnessz = value
			else:
				self._translationalstiffnessz = value
		return property(**locals())

	@apply
	def rotationalstiffnessx():
		def fget( self ):
			return self._rotationalstiffnessx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrotationalstiffnessselect):
					self._rotationalstiffnessx = ifcrotationalstiffnessselect(value)
				else:
					self._rotationalstiffnessx = value
			else:
				self._rotationalstiffnessx = value
		return property(**locals())

	@apply
	def rotationalstiffnessy():
		def fget( self ):
			return self._rotationalstiffnessy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrotationalstiffnessselect):
					self._rotationalstiffnessy = ifcrotationalstiffnessselect(value)
				else:
					self._rotationalstiffnessy = value
			else:
				self._rotationalstiffnessy = value
		return property(**locals())

	@apply
	def rotationalstiffnessz():
		def fget( self ):
			return self._rotationalstiffnessz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrotationalstiffnessselect):
					self._rotationalstiffnessz = ifcrotationalstiffnessselect(value)
				else:
					self._rotationalstiffnessz = value
			else:
				self._rotationalstiffnessz = value
		return property(**locals())

####################
 # ENTITY ifcboundarynodeconditionwarping #
####################
class ifcboundarynodeconditionwarping(ifcboundarynodecondition):
	'''Entity ifcboundarynodeconditionwarping definition.

	:param warpingstiffness
	:type warpingstiffness:ifcwarpingstiffnessselect
	'''
	def __init__( self , inherited0__name , inherited1__translationalstiffnessx , inherited2__translationalstiffnessy , inherited3__translationalstiffnessz , inherited4__rotationalstiffnessx , inherited5__rotationalstiffnessy , inherited6__rotationalstiffnessz , warpingstiffness, ):
		ifcboundarynodecondition.__init__(self , inherited0__name , inherited1__translationalstiffnessx , inherited2__translationalstiffnessy , inherited3__translationalstiffnessz , inherited4__rotationalstiffnessx , inherited5__rotationalstiffnessy , inherited6__rotationalstiffnessz , )
		self.warpingstiffness = warpingstiffness

	@apply
	def warpingstiffness():
		def fget( self ):
			return self._warpingstiffness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcwarpingstiffnessselect):
					self._warpingstiffness = ifcwarpingstiffnessselect(value)
				else:
					self._warpingstiffness = value
			else:
				self._warpingstiffness = value
		return property(**locals())

####################
 # ENTITY ifclaborresourcetype #
####################
class ifclaborresourcetype(ifcconstructionresourcetype):
	'''Entity ifclaborresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifclaborresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , predefinedtype, ):
		ifcconstructionresourcetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifclaborresourcetypeenum):
				self._predefinedtype = ifclaborresourcetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifclaborresourcetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifclaborresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifctyperesource.self.resourcetype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifctopologicalrepresentationitem #
####################
class ifctopologicalrepresentationitem(ifcrepresentationitem):
	'''Entity ifctopologicalrepresentationitem definition.
	'''
	def __init__( self ,  ):
		ifcrepresentationitem.__init__(self , )

####################
 # ENTITY ifcedge #
####################
class ifcedge(ifctopologicalrepresentationitem):
	'''Entity ifcedge definition.

	:param edgestart
	:type edgestart:ifcvertex

	:param edgeend
	:type edgeend:ifcvertex
	'''
	def __init__( self , edgestart,edgeend, ):
		ifctopologicalrepresentationitem.__init__(self , )
		self.edgestart = edgestart
		self.edgeend = edgeend

	@apply
	def edgestart():
		def fget( self ):
			return self._edgestart
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgestart is mantatory and can not be set to None')
			if not check_type(value,ifcvertex):
				self._edgestart = ifcvertex(value)
			else:
				self._edgestart = value
		return property(**locals())

	@apply
	def edgeend():
		def fget( self ):
			return self._edgeend
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgeend is mantatory and can not be set to None')
			if not check_type(value,ifcvertex):
				self._edgeend = ifcvertex(value)
			else:
				self._edgeend = value
		return property(**locals())

####################
 # ENTITY ifcsubedge #
####################
class ifcsubedge(ifcedge):
	'''Entity ifcsubedge definition.

	:param parentedge
	:type parentedge:ifcedge
	'''
	def __init__( self , inherited0__edgestart , inherited1__edgeend , parentedge, ):
		ifcedge.__init__(self , inherited0__edgestart , inherited1__edgeend , )
		self.parentedge = parentedge

	@apply
	def parentedge():
		def fget( self ):
			return self._parentedge
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parentedge is mantatory and can not be set to None')
			if not check_type(value,ifcedge):
				self._parentedge = ifcedge(value)
			else:
				self._parentedge = value
		return property(**locals())

####################
 # ENTITY ifcairtoairheatrecoverytype #
####################
class ifcairtoairheatrecoverytype(ifcenergyconversiondevicetype):
	'''Entity ifcairtoairheatrecoverytype definition.

	:param predefinedtype
	:type predefinedtype:ifcairtoairheatrecoverytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcairtoairheatrecoverytypeenum):
				self._predefinedtype = ifcairtoairheatrecoverytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcairtoairheatrecoverytypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcairtoairheatrecoverytypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifccartesiantransformationoperator #
####################
class ifccartesiantransformationoperator(ifcgeometricrepresentationitem):
	'''Entity ifccartesiantransformationoperator definition.

	:param axis1
	:type axis1:ifcdirection

	:param axis2
	:type axis2:ifcdirection

	:param localorigin
	:type localorigin:ifccartesianpoint

	:param scale
	:type scale:REAL

	:param scl
	:type scl:REAL

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , axis1,axis2,localorigin,scale, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.axis1 = axis1
		self.axis2 = axis2
		self.localorigin = localorigin
		self.scale = scale

	@apply
	def axis1():
		def fget( self ):
			return self._axis1
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._axis1 = ifcdirection(value)
				else:
					self._axis1 = value
			else:
				self._axis1 = value
		return property(**locals())

	@apply
	def axis2():
		def fget( self ):
			return self._axis2
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._axis2 = ifcdirection(value)
				else:
					self._axis2 = value
			else:
				self._axis2 = value
		return property(**locals())

	@apply
	def localorigin():
		def fget( self ):
			return self._localorigin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument localorigin is mantatory and can not be set to None')
			if not check_type(value,ifccartesianpoint):
				self._localorigin = ifccartesianpoint(value)
			else:
				self._localorigin = value
		return property(**locals())

	@apply
	def scale():
		def fget( self ):
			return self._scale
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._scale = REAL(value)
				else:
					self._scale = value
			else:
				self._scale = value
		return property(**locals())

	@apply
	def scl():
		def fget( self ):
			attribute_eval = NVL(self.scale,1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scl is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.localorigin.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def scalegreaterzero(self):
		eval_scalegreaterzero_wr = (self.scl  >  0)
		if not eval_scalegreaterzero_wr:
			raise AssertionError('Rule scalegreaterzero violated')
		else:
			return eval_scalegreaterzero_wr


####################
 # ENTITY ifccartesiantransformationoperator3d #
####################
class ifccartesiantransformationoperator3d(ifccartesiantransformationoperator):
	'''Entity ifccartesiantransformationoperator3d definition.

	:param axis3
	:type axis3:ifcdirection

	:param u
	:type u:LIST(3,3,'ifcdirection', scope = schema_scope)
	'''
	def __init__( self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , axis3, ):
		ifccartesiantransformationoperator.__init__(self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , )
		self.axis3 = axis3

	@apply
	def axis3():
		def fget( self ):
			return self._axis3
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._axis3 = ifcdirection(value)
				else:
					self._axis3 = value
			else:
				self._axis3 = value
		return property(**locals())

	@apply
	def u():
		def fget( self ):
			attribute_eval = ifcbaseaxis(3,self.self.ifccartesiantransformationoperator.self.axis1,self.self.ifccartesiantransformationoperator.self.axis2,self.axis3)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument u is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def dimis3d(self):
		eval_dimis3d_wr = (self.self.ifccartesiantransformationoperator.self.dim  ==  3)
		if not eval_dimis3d_wr:
			raise AssertionError('Rule dimis3d violated')
		else:
			return eval_dimis3d_wr

	def axis1is3d(self):
		eval_axis1is3d_wr = (( not EXISTS(self.self.ifccartesiantransformationoperator.self.axis1))  or  (self.self.ifccartesiantransformationoperator.self.axis1.self.dim  ==  3))
		if not eval_axis1is3d_wr:
			raise AssertionError('Rule axis1is3d violated')
		else:
			return eval_axis1is3d_wr

	def axis2is3d(self):
		eval_axis2is3d_wr = (( not EXISTS(self.self.ifccartesiantransformationoperator.self.axis2))  or  (self.self.ifccartesiantransformationoperator.self.axis2.self.dim  ==  3))
		if not eval_axis2is3d_wr:
			raise AssertionError('Rule axis2is3d violated')
		else:
			return eval_axis2is3d_wr

	def axis3is3d(self):
		eval_axis3is3d_wr = (( not EXISTS(self.axis3))  or  (self.axis3.self.dim  ==  3))
		if not eval_axis3is3d_wr:
			raise AssertionError('Rule axis3is3d violated')
		else:
			return eval_axis3is3d_wr


####################
 # ENTITY ifcconnectiongeometry #
####################
class ifcconnectiongeometry(BaseEntityClass):
	'''Entity ifcconnectiongeometry definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY ifcplanarextent #
####################
class ifcplanarextent(ifcgeometricrepresentationitem):
	'''Entity ifcplanarextent definition.

	:param sizeinx
	:type sizeinx:ifclengthmeasure

	:param sizeiny
	:type sizeiny:ifclengthmeasure
	'''
	def __init__( self , sizeinx,sizeiny, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.sizeinx = sizeinx
		self.sizeiny = sizeiny

	@apply
	def sizeinx():
		def fget( self ):
			return self._sizeinx
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sizeinx is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._sizeinx = ifclengthmeasure(value)
			else:
				self._sizeinx = value
		return property(**locals())

	@apply
	def sizeiny():
		def fget( self ):
			return self._sizeiny
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sizeiny is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._sizeiny = ifclengthmeasure(value)
			else:
				self._sizeiny = value
		return property(**locals())

####################
 # ENTITY ifcplanarbox #
####################
class ifcplanarbox(ifcplanarextent):
	'''Entity ifcplanarbox definition.

	:param placement
	:type placement:ifcaxis2placement
	'''
	def __init__( self , inherited0__sizeinx , inherited1__sizeiny , placement, ):
		ifcplanarextent.__init__(self , inherited0__sizeinx , inherited1__sizeiny , )
		self.placement = placement

	@apply
	def placement():
		def fget( self ):
			return self._placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placement is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._placement = ifcaxis2placement(value)
			else:
				self._placement = value
		return property(**locals())

####################
 # ENTITY ifcreinforcingelementtype #
####################
class ifcreinforcingelementtype(ifcelementcomponenttype):
	'''Entity ifcreinforcingelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementcomponenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifctendontype #
####################
class ifctendontype(ifcreinforcingelementtype):
	'''Entity ifctendontype definition.

	:param predefinedtype
	:type predefinedtype:ifctendontypeenum

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param crosssectionarea
	:type crosssectionarea:ifcareameasure

	:param sheethdiameter
	:type sheethdiameter:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype,nominaldiameter,crosssectionarea,sheethdiameter, ):
		ifcreinforcingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype
		self.nominaldiameter = nominaldiameter
		self.crosssectionarea = crosssectionarea
		self.sheethdiameter = sheethdiameter

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctendontypeenum):
				self._predefinedtype = ifctendontypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def nominaldiameter():
		def fget( self ):
			return self._nominaldiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominaldiameter = ifcpositivelengthmeasure(value)
				else:
					self._nominaldiameter = value
			else:
				self._nominaldiameter = value
		return property(**locals())

	@apply
	def crosssectionarea():
		def fget( self ):
			return self._crosssectionarea
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._crosssectionarea = ifcareameasure(value)
				else:
					self._crosssectionarea = value
			else:
				self._crosssectionarea = value
		return property(**locals())

	@apply
	def sheethdiameter():
		def fget( self ):
			return self._sheethdiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._sheethdiameter = ifcpositivelengthmeasure(value)
				else:
					self._sheethdiameter = value
			else:
				self._sheethdiameter = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifctendontypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifctendontypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcfooting #
####################
class ifcfooting(ifcbuildingelement):
	'''Entity ifcfooting definition.

	:param predefinedtype
	:type predefinedtype:ifcfootingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfootingtypeenum):
					self._predefinedtype = ifcfootingtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcfootingtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcfootingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCFOOTINGTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcpredefinedcolour #
####################
class ifcpredefinedcolour(ifcpredefineditem):
	'''Entity ifcpredefinedcolour definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefineditem.__init__(self , inherited0__name , )

####################
 # ENTITY ifcrelaggregates #
####################
class ifcrelaggregates(ifcreldecomposes):
	'''Entity ifcrelaggregates definition.

	:param relatingobject
	:type relatingobject:ifcobjectdefinition

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobjectdefinition', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingobject,relatedobjects, ):
		ifcreldecomposes.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingobject = relatingobject
		self.relatedobjects = relatedobjects

	@apply
	def relatingobject():
		def fget( self ):
			return self._relatingobject
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingobject is mantatory and can not be set to None')
			if not check_type(value,ifcobjectdefinition):
				self._relatingobject = ifcobjectdefinition(value)
			else:
				self._relatingobject = value
		return property(**locals())

	@apply
	def relatedobjects():
		def fget( self ):
			return self._relatedobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcobjectdefinition', scope = schema_scope)):
				self._relatedobjects = SET(value)
			else:
				self._relatedobjects = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (SIZEOF(None)  ==  0)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifctextstyle #
####################
class ifctextstyle(ifcpresentationstyle):
	'''Entity ifctextstyle definition.

	:param textcharacterappearance
	:type textcharacterappearance:ifctextstylefordefinedfont

	:param textstyle
	:type textstyle:ifctextstyletextmodel

	:param textfontstyle
	:type textfontstyle:ifctextfontselect

	:param modelordraughting
	:type modelordraughting:BOOLEAN
	'''
	def __init__( self , inherited0__name , textcharacterappearance,textstyle,textfontstyle,modelordraughting, ):
		ifcpresentationstyle.__init__(self , inherited0__name , )
		self.textcharacterappearance = textcharacterappearance
		self.textstyle = textstyle
		self.textfontstyle = textfontstyle
		self.modelordraughting = modelordraughting

	@apply
	def textcharacterappearance():
		def fget( self ):
			return self._textcharacterappearance
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctextstylefordefinedfont):
					self._textcharacterappearance = ifctextstylefordefinedfont(value)
				else:
					self._textcharacterappearance = value
			else:
				self._textcharacterappearance = value
		return property(**locals())

	@apply
	def textstyle():
		def fget( self ):
			return self._textstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctextstyletextmodel):
					self._textstyle = ifctextstyletextmodel(value)
				else:
					self._textstyle = value
			else:
				self._textstyle = value
		return property(**locals())

	@apply
	def textfontstyle():
		def fget( self ):
			return self._textfontstyle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument textfontstyle is mantatory and can not be set to None')
			if not check_type(value,ifctextfontselect):
				self._textfontstyle = ifctextfontselect(value)
			else:
				self._textfontstyle = value
		return property(**locals())

	@apply
	def modelordraughting():
		def fget( self ):
			return self._modelordraughting
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._modelordraughting = BOOLEAN(value)
				else:
					self._modelordraughting = value
			else:
				self._modelordraughting = value
		return property(**locals())

####################
 # ENTITY ifcwall #
####################
class ifcwall(ifcbuildingelement):
	'''Entity ifcwall definition.

	:param predefinedtype
	:type predefinedtype:ifcwalltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcwalltypeenum):
					self._predefinedtype = ifcwalltypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcwalltypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcwalltypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCWALLTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcdistributioncontrolelementtype #
####################
class ifcdistributioncontrolelementtype(ifcdistributionelementtype):
	'''Entity ifcdistributioncontrolelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcactuatortype #
####################
class ifcactuatortype(ifcdistributioncontrolelementtype):
	'''Entity ifcactuatortype definition.

	:param predefinedtype
	:type predefinedtype:ifcactuatortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcactuatortypeenum):
				self._predefinedtype = ifcactuatortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcactuatortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcactuatortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcfailureconnectioncondition #
####################
class ifcfailureconnectioncondition(ifcstructuralconnectioncondition):
	'''Entity ifcfailureconnectioncondition definition.

	:param tensionfailurex
	:type tensionfailurex:ifcforcemeasure

	:param tensionfailurey
	:type tensionfailurey:ifcforcemeasure

	:param tensionfailurez
	:type tensionfailurez:ifcforcemeasure

	:param compressionfailurex
	:type compressionfailurex:ifcforcemeasure

	:param compressionfailurey
	:type compressionfailurey:ifcforcemeasure

	:param compressionfailurez
	:type compressionfailurez:ifcforcemeasure
	'''
	def __init__( self , inherited0__name , tensionfailurex,tensionfailurey,tensionfailurez,compressionfailurex,compressionfailurey,compressionfailurez, ):
		ifcstructuralconnectioncondition.__init__(self , inherited0__name , )
		self.tensionfailurex = tensionfailurex
		self.tensionfailurey = tensionfailurey
		self.tensionfailurez = tensionfailurez
		self.compressionfailurex = compressionfailurex
		self.compressionfailurey = compressionfailurey
		self.compressionfailurez = compressionfailurez

	@apply
	def tensionfailurex():
		def fget( self ):
			return self._tensionfailurex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._tensionfailurex = ifcforcemeasure(value)
				else:
					self._tensionfailurex = value
			else:
				self._tensionfailurex = value
		return property(**locals())

	@apply
	def tensionfailurey():
		def fget( self ):
			return self._tensionfailurey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._tensionfailurey = ifcforcemeasure(value)
				else:
					self._tensionfailurey = value
			else:
				self._tensionfailurey = value
		return property(**locals())

	@apply
	def tensionfailurez():
		def fget( self ):
			return self._tensionfailurez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._tensionfailurez = ifcforcemeasure(value)
				else:
					self._tensionfailurez = value
			else:
				self._tensionfailurez = value
		return property(**locals())

	@apply
	def compressionfailurex():
		def fget( self ):
			return self._compressionfailurex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._compressionfailurex = ifcforcemeasure(value)
				else:
					self._compressionfailurex = value
			else:
				self._compressionfailurex = value
		return property(**locals())

	@apply
	def compressionfailurey():
		def fget( self ):
			return self._compressionfailurey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._compressionfailurey = ifcforcemeasure(value)
				else:
					self._compressionfailurey = value
			else:
				self._compressionfailurey = value
		return property(**locals())

	@apply
	def compressionfailurez():
		def fget( self ):
			return self._compressionfailurez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._compressionfailurez = ifcforcemeasure(value)
				else:
					self._compressionfailurez = value
			else:
				self._compressionfailurez = value
		return property(**locals())

####################
 # ENTITY ifcflowsegment #
####################
class ifcflowsegment(ifcdistributionflowelement):
	'''Entity ifcflowsegment definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifccablecarriersegment #
####################
class ifccablecarriersegment(ifcflowsegment):
	'''Entity ifccablecarriersegment definition.

	:param predefinedtype
	:type predefinedtype:ifccablecarriersegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowsegment.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccablecarriersegmenttypeenum):
					self._predefinedtype = ifccablecarriersegmenttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccablecarriersegmenttypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccablecarriersegmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCABLECARRIERSEGMENTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcstructuralsurfaceconnection #
####################
class ifcstructuralsurfaceconnection(ifcstructuralconnection):
	'''Entity ifcstructuralsurfaceconnection definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition ,  ):
		ifcstructuralconnection.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition , )

####################
 # ENTITY ifctexturevertexlist #
####################
class ifctexturevertexlist(ifcpresentationitem):
	'''Entity ifctexturevertexlist definition.

	:param texcoordslist
	:type texcoordslist:LIST(1,None,LIST(2,2,'REAL', scope = schema_scope))
	'''
	def __init__( self , texcoordslist, ):
		ifcpresentationitem.__init__(self , )
		self.texcoordslist = texcoordslist

	@apply
	def texcoordslist():
		def fget( self ):
			return self._texcoordslist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument texcoordslist is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,LIST(2,2,'REAL', scope = schema_scope))):
				self._texcoordslist = LIST(value)
			else:
				self._texcoordslist = value
		return property(**locals())

####################
 # ENTITY ifccomplexproperty #
####################
class ifccomplexproperty(ifcproperty):
	'''Entity ifccomplexproperty definition.

	:param usagename
	:type usagename:ifcidentifier

	:param hasproperties
	:type hasproperties:SET(1,None,'ifcproperty', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , usagename,hasproperties, ):
		ifcproperty.__init__(self , inherited0__name , inherited1__description , )
		self.usagename = usagename
		self.hasproperties = hasproperties

	@apply
	def usagename():
		def fget( self ):
			return self._usagename
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument usagename is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._usagename = ifcidentifier(value)
			else:
				self._usagename = value
		return property(**locals())

	@apply
	def hasproperties():
		def fget( self ):
			return self._hasproperties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hasproperties is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproperty', scope = schema_scope)):
				self._hasproperties = SET(value)
			else:
				self._hasproperties = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (SIZEOF(None)  ==  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = ifcuniquepropertyname(self.hasproperties)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcflowcontroller #
####################
class ifcflowcontroller(ifcdistributionflowelement):
	'''Entity ifcflowcontroller definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcdamper #
####################
class ifcdamper(ifcflowcontroller):
	'''Entity ifcdamper definition.

	:param predefinedtype
	:type predefinedtype:ifcdampertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowcontroller.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdampertypeenum):
					self._predefinedtype = ifcdampertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcdampertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcdampertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCDAMPERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcboundedsurface #
####################
class ifcboundedsurface(ifcsurface):
	'''Entity ifcboundedsurface definition.
	'''
	def __init__( self ,  ):
		ifcsurface.__init__(self , )

####################
 # ENTITY ifccurveboundedplane #
####################
class ifccurveboundedplane(ifcboundedsurface):
	'''Entity ifccurveboundedplane definition.

	:param basissurface
	:type basissurface:ifcplane

	:param outerboundary
	:type outerboundary:ifccurve

	:param innerboundaries
	:type innerboundaries:SET(0,None,'ifccurve', scope = schema_scope)
	'''
	def __init__( self , basissurface,outerboundary,innerboundaries, ):
		ifcboundedsurface.__init__(self , )
		self.basissurface = basissurface
		self.outerboundary = outerboundary
		self.innerboundaries = innerboundaries

	@apply
	def basissurface():
		def fget( self ):
			return self._basissurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basissurface is mantatory and can not be set to None')
			if not check_type(value,ifcplane):
				self._basissurface = ifcplane(value)
			else:
				self._basissurface = value
		return property(**locals())

	@apply
	def outerboundary():
		def fget( self ):
			return self._outerboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outerboundary is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._outerboundary = ifccurve(value)
			else:
				self._outerboundary = value
		return property(**locals())

	@apply
	def innerboundaries():
		def fget( self ):
			return self._innerboundaries
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument innerboundaries is mantatory and can not be set to None')
			if not check_type(value,SET(0,None,'ifccurve', scope = schema_scope)):
				self._innerboundaries = SET(value)
			else:
				self._innerboundaries = value
		return property(**locals())

####################
 # ENTITY ifcface #
####################
class ifcface(ifctopologicalrepresentationitem):
	'''Entity ifcface definition.

	:param bounds
	:type bounds:SET(1,None,'ifcfacebound', scope = schema_scope)

	:param hastexturemaps
	:type hastexturemaps:SET(0,None,'ifctexturemap', scope = schema_scope)
	'''
	def __init__( self , bounds, ):
		ifctopologicalrepresentationitem.__init__(self , )
		self.bounds = bounds

	@apply
	def bounds():
		def fget( self ):
			return self._bounds
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bounds is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcfacebound', scope = schema_scope)):
				self._bounds = SET(value)
			else:
				self._bounds = value
		return property(**locals())

	@apply
	def hastexturemaps():
		def fget( self ):
			return self._hastexturemaps
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hastexturemaps is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def hasouterbound(self):
		eval_hasouterbound_wr = (SIZEOF(None)  <=  1)
		if not eval_hasouterbound_wr:
			raise AssertionError('Rule hasouterbound violated')
		else:
			return eval_hasouterbound_wr


####################
 # ENTITY ifcfacesurface #
####################
class ifcfacesurface(ifcface):
	'''Entity ifcfacesurface definition.

	:param facesurface
	:type facesurface:ifcsurface

	:param samesense
	:type samesense:BOOLEAN
	'''
	def __init__( self , inherited0__bounds , facesurface,samesense, ):
		ifcface.__init__(self , inherited0__bounds , )
		self.facesurface = facesurface
		self.samesense = samesense

	@apply
	def facesurface():
		def fget( self ):
			return self._facesurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument facesurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._facesurface = ifcsurface(value)
			else:
				self._facesurface = value
		return property(**locals())

	@apply
	def samesense():
		def fget( self ):
			return self._samesense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument samesense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._samesense = BOOLEAN(value)
			else:
				self._samesense = value
		return property(**locals())

####################
 # ENTITY ifcstructuralanalysismodel #
####################
class ifcstructuralanalysismodel(ifcsystem):
	'''Entity ifcstructuralanalysismodel definition.

	:param predefinedtype
	:type predefinedtype:ifcanalysismodeltypeenum

	:param orientationof2dplane
	:type orientationof2dplane:ifcaxis2placement3d

	:param loadedby
	:type loadedby:SET(1,None,'ifcstructuralloadgroup', scope = schema_scope)

	:param hasresults
	:type hasresults:SET(1,None,'ifcstructuralresultgroup', scope = schema_scope)

	:param sharedplacement
	:type sharedplacement:ifcobjectplacement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , predefinedtype,orientationof2dplane,loadedby,hasresults,sharedplacement, ):
		ifcsystem.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.predefinedtype = predefinedtype
		self.orientationof2dplane = orientationof2dplane
		self.loadedby = loadedby
		self.hasresults = hasresults
		self.sharedplacement = sharedplacement

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcanalysismodeltypeenum):
				self._predefinedtype = ifcanalysismodeltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def orientationof2dplane():
		def fget( self ):
			return self._orientationof2dplane
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaxis2placement3d):
					self._orientationof2dplane = ifcaxis2placement3d(value)
				else:
					self._orientationof2dplane = value
			else:
				self._orientationof2dplane = value
		return property(**locals())

	@apply
	def loadedby():
		def fget( self ):
			return self._loadedby
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcstructuralloadgroup', scope = schema_scope)):
					self._loadedby = SET(value)
				else:
					self._loadedby = value
			else:
				self._loadedby = value
		return property(**locals())

	@apply
	def hasresults():
		def fget( self ):
			return self._hasresults
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcstructuralresultgroup', scope = schema_scope)):
					self._hasresults = SET(value)
				else:
					self._hasresults = value
			else:
				self._hasresults = value
		return property(**locals())

	@apply
	def sharedplacement():
		def fget( self ):
			return self._sharedplacement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcobjectplacement):
					self._sharedplacement = ifcobjectplacement(value)
				else:
					self._sharedplacement = value
			else:
				self._sharedplacement = value
		return property(**locals())
	def hasobjecttype(self):
		eval_hasobjecttype_wr = ((self.predefinedtype  !=  ifcanalysismodeltypeenum.self.userdefined)  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_hasobjecttype_wr:
			raise AssertionError('Rule hasobjecttype violated')
		else:
			return eval_hasobjecttype_wr


####################
 # ENTITY ifcstructuralloadsingleforce #
####################
class ifcstructuralloadsingleforce(ifcstructuralloadstatic):
	'''Entity ifcstructuralloadsingleforce definition.

	:param forcex
	:type forcex:ifcforcemeasure

	:param forcey
	:type forcey:ifcforcemeasure

	:param forcez
	:type forcez:ifcforcemeasure

	:param momentx
	:type momentx:ifctorquemeasure

	:param momenty
	:type momenty:ifctorquemeasure

	:param momentz
	:type momentz:ifctorquemeasure
	'''
	def __init__( self , inherited0__name , forcex,forcey,forcez,momentx,momenty,momentz, ):
		ifcstructuralloadstatic.__init__(self , inherited0__name , )
		self.forcex = forcex
		self.forcey = forcey
		self.forcez = forcez
		self.momentx = momentx
		self.momenty = momenty
		self.momentz = momentz

	@apply
	def forcex():
		def fget( self ):
			return self._forcex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._forcex = ifcforcemeasure(value)
				else:
					self._forcex = value
			else:
				self._forcex = value
		return property(**locals())

	@apply
	def forcey():
		def fget( self ):
			return self._forcey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._forcey = ifcforcemeasure(value)
				else:
					self._forcey = value
			else:
				self._forcey = value
		return property(**locals())

	@apply
	def forcez():
		def fget( self ):
			return self._forcez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._forcez = ifcforcemeasure(value)
				else:
					self._forcez = value
			else:
				self._forcez = value
		return property(**locals())

	@apply
	def momentx():
		def fget( self ):
			return self._momentx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctorquemeasure):
					self._momentx = ifctorquemeasure(value)
				else:
					self._momentx = value
			else:
				self._momentx = value
		return property(**locals())

	@apply
	def momenty():
		def fget( self ):
			return self._momenty
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctorquemeasure):
					self._momenty = ifctorquemeasure(value)
				else:
					self._momenty = value
			else:
				self._momenty = value
		return property(**locals())

	@apply
	def momentz():
		def fget( self ):
			return self._momentz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctorquemeasure):
					self._momentz = ifctorquemeasure(value)
				else:
					self._momentz = value
			else:
				self._momentz = value
		return property(**locals())

####################
 # ENTITY ifcstructuralloadsingleforcewarping #
####################
class ifcstructuralloadsingleforcewarping(ifcstructuralloadsingleforce):
	'''Entity ifcstructuralloadsingleforcewarping definition.

	:param warpingmoment
	:type warpingmoment:ifcwarpingmomentmeasure
	'''
	def __init__( self , inherited0__name , inherited1__forcex , inherited2__forcey , inherited3__forcez , inherited4__momentx , inherited5__momenty , inherited6__momentz , warpingmoment, ):
		ifcstructuralloadsingleforce.__init__(self , inherited0__name , inherited1__forcex , inherited2__forcey , inherited3__forcez , inherited4__momentx , inherited5__momenty , inherited6__momentz , )
		self.warpingmoment = warpingmoment

	@apply
	def warpingmoment():
		def fget( self ):
			return self._warpingmoment
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcwarpingmomentmeasure):
					self._warpingmoment = ifcwarpingmomentmeasure(value)
				else:
					self._warpingmoment = value
			else:
				self._warpingmoment = value
		return property(**locals())

####################
 # ENTITY ifcaudiovisualappliancetype #
####################
class ifcaudiovisualappliancetype(ifcflowterminaltype):
	'''Entity ifcaudiovisualappliancetype definition.

	:param predefinedtype
	:type predefinedtype:ifcaudiovisualappliancetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcaudiovisualappliancetypeenum):
				self._predefinedtype = ifcaudiovisualappliancetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcaudiovisualappliancetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcaudiovisualappliancetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcaxis2placement3d #
####################
class ifcaxis2placement3d(ifcplacement):
	'''Entity ifcaxis2placement3d definition.

	:param axis
	:type axis:ifcdirection

	:param refdirection
	:type refdirection:ifcdirection

	:param p
	:type p:LIST(3,3,'ifcdirection', scope = schema_scope)
	'''
	def __init__( self , inherited0__location , axis,refdirection, ):
		ifcplacement.__init__(self , inherited0__location , )
		self.axis = axis
		self.refdirection = refdirection

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._axis = ifcdirection(value)
				else:
					self._axis = value
			else:
				self._axis = value
		return property(**locals())

	@apply
	def refdirection():
		def fget( self ):
			return self._refdirection
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._refdirection = ifcdirection(value)
				else:
					self._refdirection = value
			else:
				self._refdirection = value
		return property(**locals())

	@apply
	def p():
		def fget( self ):
			attribute_eval = ifcbuildaxes(self.axis,self.refdirection)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def locationis3d(self):
		eval_locationis3d_wr = (self.self.ifcplacement.self.location.self.dim  ==  3)
		if not eval_locationis3d_wr:
			raise AssertionError('Rule locationis3d violated')
		else:
			return eval_locationis3d_wr

	def axisis3d(self):
		eval_axisis3d_wr = (( not EXISTS(self.axis))  or  (self.axis.self.dim  ==  3))
		if not eval_axisis3d_wr:
			raise AssertionError('Rule axisis3d violated')
		else:
			return eval_axisis3d_wr

	def refdiris3d(self):
		eval_refdiris3d_wr = (( not EXISTS(self.refdirection))  or  (self.refdirection.self.dim  ==  3))
		if not eval_refdiris3d_wr:
			raise AssertionError('Rule refdiris3d violated')
		else:
			return eval_refdiris3d_wr

	def axistorefdirposition(self):
		eval_axistorefdirposition_wr = ((( not EXISTS(self.axis))  or  ( not EXISTS(self.refdirection)))  or  (ifccrossproduct(self.axis,self.refdirection).self.magnitude  >  0))
		if not eval_axistorefdirposition_wr:
			raise AssertionError('Rule axistorefdirposition violated')
		else:
			return eval_axistorefdirposition_wr

	def axisandrefdirprovision(self):
		eval_axisandrefdirprovision_wr = ( not (EXISTS(self.axis) XOR EXISTS(self.refdirection)))
		if not eval_axisandrefdirprovision_wr:
			raise AssertionError('Rule axisandrefdirprovision violated')
		else:
			return eval_axisandrefdirprovision_wr


####################
 # ENTITY ifcmaterialusagedefinition #
####################
class ifcmaterialusagedefinition(BaseEntityClass):
	'''Entity ifcmaterialusagedefinition definition.

	:param associatedto
	:type associatedto:SET(1,None,'ifcrelassociatesmaterial', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def associatedto():
		def fget( self ):
			return self._associatedto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument associatedto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcmaterialprofilesetusage #
####################
class ifcmaterialprofilesetusage(ifcmaterialusagedefinition):
	'''Entity ifcmaterialprofilesetusage definition.

	:param forprofileset
	:type forprofileset:ifcmaterialprofileset

	:param cardinalpoint
	:type cardinalpoint:ifccardinalpointreference

	:param referenceextent
	:type referenceextent:ifcpositivelengthmeasure
	'''
	def __init__( self , forprofileset,cardinalpoint,referenceextent, ):
		ifcmaterialusagedefinition.__init__(self , )
		self.forprofileset = forprofileset
		self.cardinalpoint = cardinalpoint
		self.referenceextent = referenceextent

	@apply
	def forprofileset():
		def fget( self ):
			return self._forprofileset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument forprofileset is mantatory and can not be set to None')
			if not check_type(value,ifcmaterialprofileset):
				self._forprofileset = ifcmaterialprofileset(value)
			else:
				self._forprofileset = value
		return property(**locals())

	@apply
	def cardinalpoint():
		def fget( self ):
			return self._cardinalpoint
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccardinalpointreference):
					self._cardinalpoint = ifccardinalpointreference(value)
				else:
					self._cardinalpoint = value
			else:
				self._cardinalpoint = value
		return property(**locals())

	@apply
	def referenceextent():
		def fget( self ):
			return self._referenceextent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._referenceextent = ifcpositivelengthmeasure(value)
				else:
					self._referenceextent = value
			else:
				self._referenceextent = value
		return property(**locals())

####################
 # ENTITY ifcmaterialprofilesetusagetapering #
####################
class ifcmaterialprofilesetusagetapering(ifcmaterialprofilesetusage):
	'''Entity ifcmaterialprofilesetusagetapering definition.

	:param forprofileendset
	:type forprofileendset:ifcmaterialprofileset

	:param cardinalendpoint
	:type cardinalendpoint:ifccardinalpointreference
	'''
	def __init__( self , inherited0__forprofileset , inherited1__cardinalpoint , inherited2__referenceextent , forprofileendset,cardinalendpoint, ):
		ifcmaterialprofilesetusage.__init__(self , inherited0__forprofileset , inherited1__cardinalpoint , inherited2__referenceextent , )
		self.forprofileendset = forprofileendset
		self.cardinalendpoint = cardinalendpoint

	@apply
	def forprofileendset():
		def fget( self ):
			return self._forprofileendset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument forprofileendset is mantatory and can not be set to None')
			if not check_type(value,ifcmaterialprofileset):
				self._forprofileendset = ifcmaterialprofileset(value)
			else:
				self._forprofileendset = value
		return property(**locals())

	@apply
	def cardinalendpoint():
		def fget( self ):
			return self._cardinalendpoint
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccardinalpointreference):
					self._cardinalendpoint = ifccardinalpointreference(value)
				else:
					self._cardinalendpoint = value
			else:
				self._cardinalendpoint = value
		return property(**locals())

####################
 # ENTITY ifchalfspacesolid #
####################
class ifchalfspacesolid(ifcgeometricrepresentationitem):
	'''Entity ifchalfspacesolid definition.

	:param basesurface
	:type basesurface:ifcsurface

	:param agreementflag
	:type agreementflag:BOOLEAN

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , basesurface,agreementflag, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.basesurface = basesurface
		self.agreementflag = agreementflag

	@apply
	def basesurface():
		def fget( self ):
			return self._basesurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basesurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._basesurface = ifcsurface(value)
			else:
				self._basesurface = value
		return property(**locals())

	@apply
	def agreementflag():
		def fget( self ):
			return self._agreementflag
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument agreementflag is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._agreementflag = BOOLEAN(value)
			else:
				self._agreementflag = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcboxedhalfspace #
####################
class ifcboxedhalfspace(ifchalfspacesolid):
	'''Entity ifcboxedhalfspace definition.

	:param enclosure
	:type enclosure:ifcboundingbox
	'''
	def __init__( self , inherited0__basesurface , inherited1__agreementflag , enclosure, ):
		ifchalfspacesolid.__init__(self , inherited0__basesurface , inherited1__agreementflag , )
		self.enclosure = enclosure

	@apply
	def enclosure():
		def fget( self ):
			return self._enclosure
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument enclosure is mantatory and can not be set to None')
			if not check_type(value,ifcboundingbox):
				self._enclosure = ifcboundingbox(value)
			else:
				self._enclosure = value
		return property(**locals())

####################
 # ENTITY ifccompositecurve #
####################
class ifccompositecurve(ifcboundedcurve):
	'''Entity ifccompositecurve definition.

	:param segments
	:type segments:LIST(1,None,'ifccompositecurvesegment', scope = schema_scope)

	:param selfintersect
	:type selfintersect:LOGICAL

	:param nsegments
	:type nsegments:INTEGER

	:param closedcurve
	:type closedcurve:LOGICAL
	'''
	def __init__( self , segments,selfintersect, ):
		ifcboundedcurve.__init__(self , )
		self.segments = segments
		self.selfintersect = selfintersect

	@apply
	def segments():
		def fget( self ):
			return self._segments
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument segments is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifccompositecurvesegment', scope = schema_scope)):
				self._segments = LIST(value)
			else:
				self._segments = value
		return property(**locals())

	@apply
	def selfintersect():
		def fget( self ):
			return self._selfintersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument selfintersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._selfintersect = LOGICAL(value)
			else:
				self._selfintersect = value
		return property(**locals())

	@apply
	def nsegments():
		def fget( self ):
			attribute_eval = SIZEOF(self.segments)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument nsegments is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def closedcurve():
		def fget( self ):
			attribute_eval = (self.segments[self.nsegments].self.transition  !=  discontinuous)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument closedcurve is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def curvecontinuous(self):
		eval_curvecontinuous_wr = ((( not self.closedcurve)  and  (SIZEOF(None)  ==  1))  or  (self.closedcurve  and  (SIZEOF(None)  ==  0)))
		if not eval_curvecontinuous_wr:
			raise AssertionError('Rule curvecontinuous violated')
		else:
			return eval_curvecontinuous_wr

	def samedim(self):
		eval_samedim_wr = (SIZEOF(None)  ==  0)
		if not eval_samedim_wr:
			raise AssertionError('Rule samedim violated')
		else:
			return eval_samedim_wr


####################
 # ENTITY ifcdoortype #
####################
class ifcdoortype(ifcbuildingelementtype):
	'''Entity ifcdoortype definition.

	:param predefinedtype
	:type predefinedtype:ifcdoortypeenum

	:param operationtype
	:type operationtype:ifcdoortypeoperationenum

	:param parametertakesprecedence
	:type parametertakesprecedence:BOOLEAN

	:param userdefinedoperationtype
	:type userdefinedoperationtype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype,operationtype,parametertakesprecedence,userdefinedoperationtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype
		self.operationtype = operationtype
		self.parametertakesprecedence = parametertakesprecedence
		self.userdefinedoperationtype = userdefinedoperationtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcdoortypeenum):
				self._predefinedtype = ifcdoortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def operationtype():
		def fget( self ):
			return self._operationtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operationtype is mantatory and can not be set to None')
			if not check_type(value,ifcdoortypeoperationenum):
				self._operationtype = ifcdoortypeoperationenum(value)
			else:
				self._operationtype = value
		return property(**locals())

	@apply
	def parametertakesprecedence():
		def fget( self ):
			return self._parametertakesprecedence
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._parametertakesprecedence = BOOLEAN(value)
				else:
					self._parametertakesprecedence = value
			else:
				self._parametertakesprecedence = value
		return property(**locals())

	@apply
	def userdefinedoperationtype():
		def fget( self ):
			return self._userdefinedoperationtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedoperationtype = ifclabel(value)
				else:
					self._userdefinedoperationtype = value
			else:
				self._userdefinedoperationtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcdoortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcdoortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcroof #
####################
class ifcroof(ifcbuildingelement):
	'''Entity ifcroof definition.

	:param predefinedtype
	:type predefinedtype:ifcrooftypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrooftypeenum):
					self._predefinedtype = ifcrooftypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctshapedecomposition(self):
		eval_correctshapedecomposition_wr = ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  0)  or  ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  1)  and  (( not EXISTS(self.self.ifcproduct.self.representation))  or  (EXISTS(self.self.ifcproduct.self.representation)  and  (SIZEOF(None)  ==  0)))))
		if not eval_correctshapedecomposition_wr:
			raise AssertionError('Rule correctshapedecomposition violated')
		else:
			return eval_correctshapedecomposition_wr

	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcrooftypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcrooftypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCROOFTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcstructuralloadsingledisplacementdistortion #
####################
class ifcstructuralloadsingledisplacementdistortion(ifcstructuralloadsingledisplacement):
	'''Entity ifcstructuralloadsingledisplacementdistortion definition.

	:param distortion
	:type distortion:ifccurvaturemeasure
	'''
	def __init__( self , inherited0__name , inherited1__displacementx , inherited2__displacementy , inherited3__displacementz , inherited4__rotationaldisplacementrx , inherited5__rotationaldisplacementry , inherited6__rotationaldisplacementrz , distortion, ):
		ifcstructuralloadsingledisplacement.__init__(self , inherited0__name , inherited1__displacementx , inherited2__displacementy , inherited3__displacementz , inherited4__rotationaldisplacementrx , inherited5__rotationaldisplacementry , inherited6__rotationaldisplacementrz , )
		self.distortion = distortion

	@apply
	def distortion():
		def fget( self ):
			return self._distortion
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccurvaturemeasure):
					self._distortion = ifccurvaturemeasure(value)
				else:
					self._distortion = value
			else:
				self._distortion = value
		return property(**locals())

####################
 # ENTITY ifcburner #
####################
class ifcburner(ifcenergyconversiondevice):
	'''Entity ifcburner definition.

	:param predefinedtype
	:type predefinedtype:ifcburnertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcburnertypeenum):
					self._predefinedtype = ifcburnertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcburnertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcburnertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCBURNERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifceventtype #
####################
class ifceventtype(ifctypeprocess):
	'''Entity ifceventtype definition.

	:param predefinedtype
	:type predefinedtype:ifceventtypeenum

	:param eventtriggertype
	:type eventtriggertype:ifceventtriggertypeenum

	:param userdefinedeventtriggertype
	:type userdefinedeventtriggertype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__processtype , predefinedtype,eventtriggertype,userdefinedeventtriggertype, ):
		ifctypeprocess.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__processtype , )
		self.predefinedtype = predefinedtype
		self.eventtriggertype = eventtriggertype
		self.userdefinedeventtriggertype = userdefinedeventtriggertype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifceventtypeenum):
				self._predefinedtype = ifceventtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def eventtriggertype():
		def fget( self ):
			return self._eventtriggertype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument eventtriggertype is mantatory and can not be set to None')
			if not check_type(value,ifceventtriggertypeenum):
				self._eventtriggertype = ifceventtriggertypeenum(value)
			else:
				self._eventtriggertype = value
		return property(**locals())

	@apply
	def userdefinedeventtriggertype():
		def fget( self ):
			return self._userdefinedeventtriggertype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedeventtriggertype = ifclabel(value)
				else:
					self._userdefinedeventtriggertype = value
			else:
				self._userdefinedeventtriggertype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifceventtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifceventtypeenum.self.userdefined)  and  EXISTS(self.self.ifctypeprocess.self.processtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcteventtriggertype(self):
		eval_correcteventtriggertype_wr = ((self.eventtriggertype  !=  ifceventtriggertypeenum.self.userdefined)  or  ((self.eventtriggertype  ==  ifceventtriggertypeenum.self.userdefined)  and  EXISTS(self.userdefinedeventtriggertype)))
		if not eval_correcteventtriggertype_wr:
			raise AssertionError('Rule correcteventtriggertype violated')
		else:
			return eval_correcteventtriggertype_wr


####################
 # ENTITY ifcmaterialprofile #
####################
class ifcmaterialprofile(ifcmaterialdefinition):
	'''Entity ifcmaterialprofile definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param material
	:type material:ifcmaterial

	:param profile
	:type profile:ifcprofiledef

	:param priority
	:type priority:ifcnormalisedratiomeasure

	:param category
	:type category:ifclabel

	:param tomaterialprofileset
	:type tomaterialprofileset:ifcmaterialprofileset
	'''
	def __init__( self , name,description,material,profile,priority,category, ):
		ifcmaterialdefinition.__init__(self , )
		self.name = name
		self.description = description
		self.material = material
		self.profile = profile
		self.priority = priority
		self.category = category

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def material():
		def fget( self ):
			return self._material
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmaterial):
					self._material = ifcmaterial(value)
				else:
					self._material = value
			else:
				self._material = value
		return property(**locals())

	@apply
	def profile():
		def fget( self ):
			return self._profile
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument profile is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._profile = ifcprofiledef(value)
			else:
				self._profile = value
		return property(**locals())

	@apply
	def priority():
		def fget( self ):
			return self._priority
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._priority = ifcnormalisedratiomeasure(value)
				else:
					self._priority = value
			else:
				self._priority = value
		return property(**locals())

	@apply
	def category():
		def fget( self ):
			return self._category
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._category = ifclabel(value)
				else:
					self._category = value
			else:
				self._category = value
		return property(**locals())

	@apply
	def tomaterialprofileset():
		def fget( self ):
			return self._tomaterialprofileset
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument tomaterialprofileset is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcmaterialprofilewithoffsets #
####################
class ifcmaterialprofilewithoffsets(ifcmaterialprofile):
	'''Entity ifcmaterialprofilewithoffsets definition.

	:param offsetvalues
	:type offsetvalues:ARRAY(1,2,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__material , inherited3__profile , inherited4__priority , inherited5__category , offsetvalues, ):
		ifcmaterialprofile.__init__(self , inherited0__name , inherited1__description , inherited2__material , inherited3__profile , inherited4__priority , inherited5__category , )
		self.offsetvalues = offsetvalues

	@apply
	def offsetvalues():
		def fget( self ):
			return self._offsetvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offsetvalues is mantatory and can not be set to None')
			if not check_type(value,ARRAY(1,2,'REAL', scope = schema_scope)):
				self._offsetvalues = ARRAY(value)
			else:
				self._offsetvalues = value
		return property(**locals())

####################
 # ENTITY ifcrepresentation #
####################
class ifcrepresentation(BaseEntityClass):
	'''Entity ifcrepresentation definition.

	:param contextofitems
	:type contextofitems:ifcrepresentationcontext

	:param representationidentifier
	:type representationidentifier:ifclabel

	:param representationtype
	:type representationtype:ifclabel

	:param items
	:type items:SET(1,None,'ifcrepresentationitem', scope = schema_scope)

	:param representationmap
	:type representationmap:SET(0,1,'ifcrepresentationmap', scope = schema_scope)

	:param layerassignments
	:type layerassignments:SET(0,None,'ifcpresentationlayerassignment', scope = schema_scope)

	:param ofproductrepresentation
	:type ofproductrepresentation:SET(0,None,'ifcproductrepresentation', scope = schema_scope)
	'''
	def __init__( self , contextofitems,representationidentifier,representationtype,items, ):
		self.contextofitems = contextofitems
		self.representationidentifier = representationidentifier
		self.representationtype = representationtype
		self.items = items

	@apply
	def contextofitems():
		def fget( self ):
			return self._contextofitems
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument contextofitems is mantatory and can not be set to None')
			if not check_type(value,ifcrepresentationcontext):
				self._contextofitems = ifcrepresentationcontext(value)
			else:
				self._contextofitems = value
		return property(**locals())

	@apply
	def representationidentifier():
		def fget( self ):
			return self._representationidentifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._representationidentifier = ifclabel(value)
				else:
					self._representationidentifier = value
			else:
				self._representationidentifier = value
		return property(**locals())

	@apply
	def representationtype():
		def fget( self ):
			return self._representationtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._representationtype = ifclabel(value)
				else:
					self._representationtype = value
			else:
				self._representationtype = value
		return property(**locals())

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcrepresentationitem', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def representationmap():
		def fget( self ):
			return self._representationmap
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument representationmap is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def layerassignments():
		def fget( self ):
			return self._layerassignments
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument layerassignments is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ofproductrepresentation():
		def fget( self ):
			return self._ofproductrepresentation
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ofproductrepresentation is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcfilter #
####################
class ifcfilter(ifcflowtreatmentdevice):
	'''Entity ifcfilter definition.

	:param predefinedtype
	:type predefinedtype:ifcfiltertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowtreatmentdevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfiltertypeenum):
					self._predefinedtype = ifcfiltertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcfiltertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcfiltertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCFILTERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcresourceapprovalrelationship #
####################
class ifcresourceapprovalrelationship(ifcresourcelevelrelationship):
	'''Entity ifcresourceapprovalrelationship definition.

	:param relatedresourceobjects
	:type relatedresourceobjects:SET(1,None,'ifcresourceobjectselect', scope = schema_scope)

	:param relatingapproval
	:type relatingapproval:ifcapproval
	'''
	def __init__( self , inherited0__name , inherited1__description , relatedresourceobjects,relatingapproval, ):
		ifcresourcelevelrelationship.__init__(self , inherited0__name , inherited1__description , )
		self.relatedresourceobjects = relatedresourceobjects
		self.relatingapproval = relatingapproval

	@apply
	def relatedresourceobjects():
		def fget( self ):
			return self._relatedresourceobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedresourceobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcresourceobjectselect', scope = schema_scope)):
				self._relatedresourceobjects = SET(value)
			else:
				self._relatedresourceobjects = value
		return property(**locals())

	@apply
	def relatingapproval():
		def fget( self ):
			return self._relatingapproval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingapproval is mantatory and can not be set to None')
			if not check_type(value,ifcapproval):
				self._relatingapproval = ifcapproval(value)
			else:
				self._relatingapproval = value
		return property(**locals())

####################
 # ENTITY ifcjunctionbox #
####################
class ifcjunctionbox(ifcflowfitting):
	'''Entity ifcjunctionbox definition.

	:param predefinedtype
	:type predefinedtype:ifcjunctionboxtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowfitting.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcjunctionboxtypeenum):
					self._predefinedtype = ifcjunctionboxtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcjunctionboxtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcjunctionboxtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCJUNCTIONBOXTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcoffsetcurve2d #
####################
class ifcoffsetcurve2d(ifccurve):
	'''Entity ifcoffsetcurve2d definition.

	:param basiscurve
	:type basiscurve:ifccurve

	:param distance
	:type distance:ifclengthmeasure

	:param selfintersect
	:type selfintersect:LOGICAL
	'''
	def __init__( self , basiscurve,distance,selfintersect, ):
		ifccurve.__init__(self , )
		self.basiscurve = basiscurve
		self.distance = distance
		self.selfintersect = selfintersect

	@apply
	def basiscurve():
		def fget( self ):
			return self._basiscurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basiscurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._basiscurve = ifccurve(value)
			else:
				self._basiscurve = value
		return property(**locals())

	@apply
	def distance():
		def fget( self ):
			return self._distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._distance = ifclengthmeasure(value)
			else:
				self._distance = value
		return property(**locals())

	@apply
	def selfintersect():
		def fget( self ):
			return self._selfintersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument selfintersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._selfintersect = LOGICAL(value)
			else:
				self._selfintersect = value
		return property(**locals())
	def dimis2d(self):
		eval_dimis2d_wr = (self.basiscurve.self.dim  ==  2)
		if not eval_dimis2d_wr:
			raise AssertionError('Rule dimis2d violated')
		else:
			return eval_dimis2d_wr


####################
 # ENTITY ifcrelassigns #
####################
class ifcrelassigns(ifcrelationship):
	'''Entity ifcrelassigns definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobjectdefinition', scope = schema_scope)

	:param relatedobjectstype
	:type relatedobjectstype:ifcobjecttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedobjects,relatedobjectstype, ):
		ifcrelationship.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedobjects = relatedobjects
		self.relatedobjectstype = relatedobjectstype

	@apply
	def relatedobjects():
		def fget( self ):
			return self._relatedobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcobjectdefinition', scope = schema_scope)):
				self._relatedobjects = SET(value)
			else:
				self._relatedobjects = value
		return property(**locals())

	@apply
	def relatedobjectstype():
		def fget( self ):
			return self._relatedobjectstype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcobjecttypeenum):
					self._relatedobjectstype = ifcobjecttypeenum(value)
				else:
					self._relatedobjectstype = value
			else:
				self._relatedobjectstype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ifccorrectobjectassignment(self.relatedobjectstype,self.relatedobjects)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcrelassignstogroup #
####################
class ifcrelassignstogroup(ifcrelassigns):
	'''Entity ifcrelassignstogroup definition.

	:param relatinggroup
	:type relatinggroup:ifcgroup
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatinggroup, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatinggroup = relatinggroup

	@apply
	def relatinggroup():
		def fget( self ):
			return self._relatinggroup
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatinggroup is mantatory and can not be set to None')
			if not check_type(value,ifcgroup):
				self._relatinggroup = ifcgroup(value)
			else:
				self._relatinggroup = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (SIZEOF(None)  ==  0)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifcreinforcementdefinitionproperties #
####################
class ifcreinforcementdefinitionproperties(ifcpredefinedpropertyset):
	'''Entity ifcreinforcementdefinitionproperties definition.

	:param definitiontype
	:type definitiontype:ifclabel

	:param reinforcementsectiondefinitions
	:type reinforcementsectiondefinitions:LIST(1,None,'ifcsectionreinforcementproperties', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , definitiontype,reinforcementsectiondefinitions, ):
		ifcpredefinedpropertyset.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.definitiontype = definitiontype
		self.reinforcementsectiondefinitions = reinforcementsectiondefinitions

	@apply
	def definitiontype():
		def fget( self ):
			return self._definitiontype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._definitiontype = ifclabel(value)
				else:
					self._definitiontype = value
			else:
				self._definitiontype = value
		return property(**locals())

	@apply
	def reinforcementsectiondefinitions():
		def fget( self ):
			return self._reinforcementsectiondefinitions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reinforcementsectiondefinitions is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcsectionreinforcementproperties', scope = schema_scope)):
				self._reinforcementsectiondefinitions = LIST(value)
			else:
				self._reinforcementsectiondefinitions = value
		return property(**locals())

####################
 # ENTITY ifcrelassociatesclassification #
####################
class ifcrelassociatesclassification(ifcrelassociates):
	'''Entity ifcrelassociatesclassification definition.

	:param relatingclassification
	:type relatingclassification:ifcclassificationselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingclassification, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingclassification = relatingclassification

	@apply
	def relatingclassification():
		def fget( self ):
			return self._relatingclassification
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingclassification is mantatory and can not be set to None')
			if not check_type(value,ifcclassificationselect):
				self._relatingclassification = ifcclassificationselect(value)
			else:
				self._relatingclassification = value
		return property(**locals())

####################
 # ENTITY ifcrelvoidselement #
####################
class ifcrelvoidselement(ifcreldecomposes):
	'''Entity ifcrelvoidselement definition.

	:param relatingbuildingelement
	:type relatingbuildingelement:ifcelement

	:param relatedopeningelement
	:type relatedopeningelement:ifcfeatureelementsubtraction
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingbuildingelement,relatedopeningelement, ):
		ifcreldecomposes.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingbuildingelement = relatingbuildingelement
		self.relatedopeningelement = relatedopeningelement

	@apply
	def relatingbuildingelement():
		def fget( self ):
			return self._relatingbuildingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingbuildingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatingbuildingelement = ifcelement(value)
			else:
				self._relatingbuildingelement = value
		return property(**locals())

	@apply
	def relatedopeningelement():
		def fget( self ):
			return self._relatedopeningelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedopeningelement is mantatory and can not be set to None')
			if not check_type(value,ifcfeatureelementsubtraction):
				self._relatedopeningelement = ifcfeatureelementsubtraction(value)
			else:
				self._relatedopeningelement = value
		return property(**locals())

####################
 # ENTITY ifcboundaryedgecondition #
####################
class ifcboundaryedgecondition(ifcboundarycondition):
	'''Entity ifcboundaryedgecondition definition.

	:param translationalstiffnessbylengthx
	:type translationalstiffnessbylengthx:ifcmodulusoftranslationalsubgradereactionselect

	:param translationalstiffnessbylengthy
	:type translationalstiffnessbylengthy:ifcmodulusoftranslationalsubgradereactionselect

	:param translationalstiffnessbylengthz
	:type translationalstiffnessbylengthz:ifcmodulusoftranslationalsubgradereactionselect

	:param rotationalstiffnessbylengthx
	:type rotationalstiffnessbylengthx:ifcmodulusofrotationalsubgradereactionselect

	:param rotationalstiffnessbylengthy
	:type rotationalstiffnessbylengthy:ifcmodulusofrotationalsubgradereactionselect

	:param rotationalstiffnessbylengthz
	:type rotationalstiffnessbylengthz:ifcmodulusofrotationalsubgradereactionselect
	'''
	def __init__( self , inherited0__name , translationalstiffnessbylengthx,translationalstiffnessbylengthy,translationalstiffnessbylengthz,rotationalstiffnessbylengthx,rotationalstiffnessbylengthy,rotationalstiffnessbylengthz, ):
		ifcboundarycondition.__init__(self , inherited0__name , )
		self.translationalstiffnessbylengthx = translationalstiffnessbylengthx
		self.translationalstiffnessbylengthy = translationalstiffnessbylengthy
		self.translationalstiffnessbylengthz = translationalstiffnessbylengthz
		self.rotationalstiffnessbylengthx = rotationalstiffnessbylengthx
		self.rotationalstiffnessbylengthy = rotationalstiffnessbylengthy
		self.rotationalstiffnessbylengthz = rotationalstiffnessbylengthz

	@apply
	def translationalstiffnessbylengthx():
		def fget( self ):
			return self._translationalstiffnessbylengthx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusoftranslationalsubgradereactionselect):
					self._translationalstiffnessbylengthx = ifcmodulusoftranslationalsubgradereactionselect(value)
				else:
					self._translationalstiffnessbylengthx = value
			else:
				self._translationalstiffnessbylengthx = value
		return property(**locals())

	@apply
	def translationalstiffnessbylengthy():
		def fget( self ):
			return self._translationalstiffnessbylengthy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusoftranslationalsubgradereactionselect):
					self._translationalstiffnessbylengthy = ifcmodulusoftranslationalsubgradereactionselect(value)
				else:
					self._translationalstiffnessbylengthy = value
			else:
				self._translationalstiffnessbylengthy = value
		return property(**locals())

	@apply
	def translationalstiffnessbylengthz():
		def fget( self ):
			return self._translationalstiffnessbylengthz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusoftranslationalsubgradereactionselect):
					self._translationalstiffnessbylengthz = ifcmodulusoftranslationalsubgradereactionselect(value)
				else:
					self._translationalstiffnessbylengthz = value
			else:
				self._translationalstiffnessbylengthz = value
		return property(**locals())

	@apply
	def rotationalstiffnessbylengthx():
		def fget( self ):
			return self._rotationalstiffnessbylengthx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofrotationalsubgradereactionselect):
					self._rotationalstiffnessbylengthx = ifcmodulusofrotationalsubgradereactionselect(value)
				else:
					self._rotationalstiffnessbylengthx = value
			else:
				self._rotationalstiffnessbylengthx = value
		return property(**locals())

	@apply
	def rotationalstiffnessbylengthy():
		def fget( self ):
			return self._rotationalstiffnessbylengthy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofrotationalsubgradereactionselect):
					self._rotationalstiffnessbylengthy = ifcmodulusofrotationalsubgradereactionselect(value)
				else:
					self._rotationalstiffnessbylengthy = value
			else:
				self._rotationalstiffnessbylengthy = value
		return property(**locals())

	@apply
	def rotationalstiffnessbylengthz():
		def fget( self ):
			return self._rotationalstiffnessbylengthz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofrotationalsubgradereactionselect):
					self._rotationalstiffnessbylengthz = ifcmodulusofrotationalsubgradereactionselect(value)
				else:
					self._rotationalstiffnessbylengthz = value
			else:
				self._rotationalstiffnessbylengthz = value
		return property(**locals())

####################
 # ENTITY ifcenginetype #
####################
class ifcenginetype(ifcenergyconversiondevicetype):
	'''Entity ifcenginetype definition.

	:param predefinedtype
	:type predefinedtype:ifcenginetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcenginetypeenum):
				self._predefinedtype = ifcenginetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcenginetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcenginetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcflowtreatmentdevicetype #
####################
class ifcflowtreatmentdevicetype(ifcdistributionflowelementtype):
	'''Entity ifcflowtreatmentdevicetype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcgeometricset #
####################
class ifcgeometricset(ifcgeometricrepresentationitem):
	'''Entity ifcgeometricset definition.

	:param elements
	:type elements:SET(1,None,'ifcgeometricsetselect', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , elements, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.elements = elements

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument elements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcgeometricsetselect', scope = schema_scope)):
				self._elements = SET(value)
			else:
				self._elements = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.elements[1].self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def consistentdim(self):
		eval_consistentdim_wr = (SIZEOF(None)  ==  0)
		if not eval_consistentdim_wr:
			raise AssertionError('Rule consistentdim violated')
		else:
			return eval_consistentdim_wr


####################
 # ENTITY ifcmaterialclassificationrelationship #
####################
class ifcmaterialclassificationrelationship(BaseEntityClass):
	'''Entity ifcmaterialclassificationrelationship definition.

	:param materialclassifications
	:type materialclassifications:SET(1,None,'ifcclassificationselect', scope = schema_scope)

	:param classifiedmaterial
	:type classifiedmaterial:ifcmaterial
	'''
	def __init__( self , materialclassifications,classifiedmaterial, ):
		self.materialclassifications = materialclassifications
		self.classifiedmaterial = classifiedmaterial

	@apply
	def materialclassifications():
		def fget( self ):
			return self._materialclassifications
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument materialclassifications is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcclassificationselect', scope = schema_scope)):
				self._materialclassifications = SET(value)
			else:
				self._materialclassifications = value
		return property(**locals())

	@apply
	def classifiedmaterial():
		def fget( self ):
			return self._classifiedmaterial
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument classifiedmaterial is mantatory and can not be set to None')
			if not check_type(value,ifcmaterial):
				self._classifiedmaterial = ifcmaterial(value)
			else:
				self._classifiedmaterial = value
		return property(**locals())

####################
 # ENTITY ifcrelconnectselements #
####################
class ifcrelconnectselements(ifcrelconnects):
	'''Entity ifcrelconnectselements definition.

	:param connectiongeometry
	:type connectiongeometry:ifcconnectiongeometry

	:param relatingelement
	:type relatingelement:ifcelement

	:param relatedelement
	:type relatedelement:ifcelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , connectiongeometry,relatingelement,relatedelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.connectiongeometry = connectiongeometry
		self.relatingelement = relatingelement
		self.relatedelement = relatedelement

	@apply
	def connectiongeometry():
		def fget( self ):
			return self._connectiongeometry
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcconnectiongeometry):
					self._connectiongeometry = ifcconnectiongeometry(value)
				else:
					self._connectiongeometry = value
			else:
				self._connectiongeometry = value
		return property(**locals())

	@apply
	def relatingelement():
		def fget( self ):
			return self._relatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatingelement = ifcelement(value)
			else:
				self._relatingelement = value
		return property(**locals())

	@apply
	def relatedelement():
		def fget( self ):
			return self._relatedelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatedelement = ifcelement(value)
			else:
				self._relatedelement = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (self.relatingelement  !=  self.relatedelement)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifcshapeaspect #
####################
class ifcshapeaspect(BaseEntityClass):
	'''Entity ifcshapeaspect definition.

	:param shaperepresentations
	:type shaperepresentations:LIST(1,None,'ifcshapemodel', scope = schema_scope)

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param productdefinitional
	:type productdefinitional:LOGICAL

	:param partofproductdefinitionshape
	:type partofproductdefinitionshape:ifcproductrepresentationselect
	'''
	def __init__( self , shaperepresentations,name,description,productdefinitional,partofproductdefinitionshape, ):
		self.shaperepresentations = shaperepresentations
		self.name = name
		self.description = description
		self.productdefinitional = productdefinitional
		self.partofproductdefinitionshape = partofproductdefinitionshape

	@apply
	def shaperepresentations():
		def fget( self ):
			return self._shaperepresentations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument shaperepresentations is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcshapemodel', scope = schema_scope)):
				self._shaperepresentations = LIST(value)
			else:
				self._shaperepresentations = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def productdefinitional():
		def fget( self ):
			return self._productdefinitional
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument productdefinitional is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._productdefinitional = LOGICAL(value)
			else:
				self._productdefinitional = value
		return property(**locals())

	@apply
	def partofproductdefinitionshape():
		def fget( self ):
			return self._partofproductdefinitionshape
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcproductrepresentationselect):
					self._partofproductdefinitionshape = ifcproductrepresentationselect(value)
				else:
					self._partofproductdefinitionshape = value
			else:
				self._partofproductdefinitionshape = value
		return property(**locals())

####################
 # ENTITY ifcstructuralcurveconnection #
####################
class ifcstructuralcurveconnection(ifcstructuralconnection):
	'''Entity ifcstructuralcurveconnection definition.

	:param axis
	:type axis:ifcdirection
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition , axis, ):
		ifcstructuralconnection.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition , )
		self.axis = axis

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axis is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._axis = ifcdirection(value)
			else:
				self._axis = value
		return property(**locals())

####################
 # ENTITY ifcushapeprofiledef #
####################
class ifcushapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifcushapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param flangewidth
	:type flangewidth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcnonnegativelengthmeasure

	:param edgeradius
	:type edgeradius:ifcnonnegativelengthmeasure

	:param flangeslope
	:type flangeslope:ifcplaneanglemeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , depth,flangewidth,webthickness,flangethickness,filletradius,edgeradius,flangeslope, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.depth = depth
		self.flangewidth = flangewidth
		self.webthickness = webthickness
		self.flangethickness = flangethickness
		self.filletradius = filletradius
		self.edgeradius = edgeradius
		self.flangeslope = flangeslope

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def flangewidth():
		def fget( self ):
			return self._flangewidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangewidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangewidth = ifcpositivelengthmeasure(value)
			else:
				self._flangewidth = value
		return property(**locals())

	@apply
	def webthickness():
		def fget( self ):
			return self._webthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument webthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._webthickness = ifcpositivelengthmeasure(value)
			else:
				self._webthickness = value
		return property(**locals())

	@apply
	def flangethickness():
		def fget( self ):
			return self._flangethickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangethickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangethickness = ifcpositivelengthmeasure(value)
			else:
				self._flangethickness = value
		return property(**locals())

	@apply
	def filletradius():
		def fget( self ):
			return self._filletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._filletradius = ifcnonnegativelengthmeasure(value)
				else:
					self._filletradius = value
			else:
				self._filletradius = value
		return property(**locals())

	@apply
	def edgeradius():
		def fget( self ):
			return self._edgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._edgeradius = ifcnonnegativelengthmeasure(value)
				else:
					self._edgeradius = value
			else:
				self._edgeradius = value
		return property(**locals())

	@apply
	def flangeslope():
		def fget( self ):
			return self._flangeslope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._flangeslope = ifcplaneanglemeasure(value)
				else:
					self._flangeslope = value
			else:
				self._flangeslope = value
		return property(**locals())
	def validflangethickness(self):
		eval_validflangethickness_wr = (self.flangethickness  <  (self.depth / 2))
		if not eval_validflangethickness_wr:
			raise AssertionError('Rule validflangethickness violated')
		else:
			return eval_validflangethickness_wr

	def validwebthickness(self):
		eval_validwebthickness_wr = (self.webthickness  <  self.flangewidth)
		if not eval_validwebthickness_wr:
			raise AssertionError('Rule validwebthickness violated')
		else:
			return eval_validwebthickness_wr


####################
 # ENTITY ifcelectricdistributionboard #
####################
class ifcelectricdistributionboard(ifcflowcontroller):
	'''Entity ifcelectricdistributionboard definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricdistributionboardtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowcontroller.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelectricdistributionboardtypeenum):
					self._predefinedtype = ifcelectricdistributionboardtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcelectricdistributionboardtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcelectricdistributionboardtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCELECTRICDISTRIBUTIONBOARDTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcflowstoragedevice #
####################
class ifcflowstoragedevice(ifcdistributionflowelement):
	'''Entity ifcflowstoragedevice definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcelectricflowstoragedevice #
####################
class ifcelectricflowstoragedevice(ifcflowstoragedevice):
	'''Entity ifcelectricflowstoragedevice definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricflowstoragedevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowstoragedevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelectricflowstoragedevicetypeenum):
					self._predefinedtype = ifcelectricflowstoragedevicetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcelectricflowstoragedevicetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcelectricflowstoragedevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCELECTRICFLOWSTORAGEDEVICETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcexternallydefinedsurfacestyle #
####################
class ifcexternallydefinedsurfacestyle(ifcexternalreference):
	'''Entity ifcexternallydefinedsurfacestyle definition.
	'''
	def __init__( self , inherited0__location , inherited1__identification , inherited2__name ,  ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__identification , inherited2__name , )

####################
 # ENTITY ifcevaporatortype #
####################
class ifcevaporatortype(ifcenergyconversiondevicetype):
	'''Entity ifcevaporatortype definition.

	:param predefinedtype
	:type predefinedtype:ifcevaporatortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcevaporatortypeenum):
				self._predefinedtype = ifcevaporatortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcevaporatortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcevaporatortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcrectangleprofiledef #
####################
class ifcrectangleprofiledef(ifcparameterizedprofiledef):
	'''Entity ifcrectangleprofiledef definition.

	:param xdim
	:type xdim:ifcpositivelengthmeasure

	:param ydim
	:type ydim:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , xdim,ydim, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.xdim = xdim
		self.ydim = ydim

	@apply
	def xdim():
		def fget( self ):
			return self._xdim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument xdim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._xdim = ifcpositivelengthmeasure(value)
			else:
				self._xdim = value
		return property(**locals())

	@apply
	def ydim():
		def fget( self ):
			return self._ydim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ydim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._ydim = ifcpositivelengthmeasure(value)
			else:
				self._ydim = value
		return property(**locals())

####################
 # ENTITY ifcroundedrectangleprofiledef #
####################
class ifcroundedrectangleprofiledef(ifcrectangleprofiledef):
	'''Entity ifcroundedrectangleprofiledef definition.

	:param roundingradius
	:type roundingradius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__xdim , inherited4__ydim , roundingradius, ):
		ifcrectangleprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__xdim , inherited4__ydim , )
		self.roundingradius = roundingradius

	@apply
	def roundingradius():
		def fget( self ):
			return self._roundingradius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument roundingradius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._roundingradius = ifcpositivelengthmeasure(value)
			else:
				self._roundingradius = value
		return property(**locals())
	def validradius(self):
		eval_validradius_wr = ((self.roundingradius  <=  (self.self.ifcrectangleprofiledef.self.xdim / 2))  and  (self.roundingradius  <=  (self.self.ifcrectangleprofiledef.self.ydim / 2)))
		if not eval_validradius_wr:
			raise AssertionError('Rule validradius violated')
		else:
			return eval_validradius_wr


####################
 # ENTITY ifctshapeprofiledef #
####################
class ifctshapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifctshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param flangewidth
	:type flangewidth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcnonnegativelengthmeasure

	:param flangeedgeradius
	:type flangeedgeradius:ifcnonnegativelengthmeasure

	:param webedgeradius
	:type webedgeradius:ifcnonnegativelengthmeasure

	:param webslope
	:type webslope:ifcplaneanglemeasure

	:param flangeslope
	:type flangeslope:ifcplaneanglemeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , depth,flangewidth,webthickness,flangethickness,filletradius,flangeedgeradius,webedgeradius,webslope,flangeslope, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.depth = depth
		self.flangewidth = flangewidth
		self.webthickness = webthickness
		self.flangethickness = flangethickness
		self.filletradius = filletradius
		self.flangeedgeradius = flangeedgeradius
		self.webedgeradius = webedgeradius
		self.webslope = webslope
		self.flangeslope = flangeslope

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def flangewidth():
		def fget( self ):
			return self._flangewidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangewidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangewidth = ifcpositivelengthmeasure(value)
			else:
				self._flangewidth = value
		return property(**locals())

	@apply
	def webthickness():
		def fget( self ):
			return self._webthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument webthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._webthickness = ifcpositivelengthmeasure(value)
			else:
				self._webthickness = value
		return property(**locals())

	@apply
	def flangethickness():
		def fget( self ):
			return self._flangethickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangethickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangethickness = ifcpositivelengthmeasure(value)
			else:
				self._flangethickness = value
		return property(**locals())

	@apply
	def filletradius():
		def fget( self ):
			return self._filletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._filletradius = ifcnonnegativelengthmeasure(value)
				else:
					self._filletradius = value
			else:
				self._filletradius = value
		return property(**locals())

	@apply
	def flangeedgeradius():
		def fget( self ):
			return self._flangeedgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._flangeedgeradius = ifcnonnegativelengthmeasure(value)
				else:
					self._flangeedgeradius = value
			else:
				self._flangeedgeradius = value
		return property(**locals())

	@apply
	def webedgeradius():
		def fget( self ):
			return self._webedgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._webedgeradius = ifcnonnegativelengthmeasure(value)
				else:
					self._webedgeradius = value
			else:
				self._webedgeradius = value
		return property(**locals())

	@apply
	def webslope():
		def fget( self ):
			return self._webslope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._webslope = ifcplaneanglemeasure(value)
				else:
					self._webslope = value
			else:
				self._webslope = value
		return property(**locals())

	@apply
	def flangeslope():
		def fget( self ):
			return self._flangeslope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._flangeslope = ifcplaneanglemeasure(value)
				else:
					self._flangeslope = value
			else:
				self._flangeslope = value
		return property(**locals())
	def validflangethickness(self):
		eval_validflangethickness_wr = (self.flangethickness  <  self.depth)
		if not eval_validflangethickness_wr:
			raise AssertionError('Rule validflangethickness violated')
		else:
			return eval_validflangethickness_wr

	def validwebthickness(self):
		eval_validwebthickness_wr = (self.webthickness  <  self.flangewidth)
		if not eval_validwebthickness_wr:
			raise AssertionError('Rule validwebthickness violated')
		else:
			return eval_validwebthickness_wr


####################
 # ENTITY ifcconstructionequipmentresourcetype #
####################
class ifcconstructionequipmentresourcetype(ifcconstructionresourcetype):
	'''Entity ifcconstructionequipmentresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionequipmentresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , predefinedtype, ):
		ifcconstructionresourcetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcconstructionequipmentresourcetypeenum):
				self._predefinedtype = ifcconstructionequipmentresourcetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcconstructionequipmentresourcetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcconstructionequipmentresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifctyperesource.self.resourcetype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcelectricappliancetype #
####################
class ifcelectricappliancetype(ifcflowterminaltype):
	'''Entity ifcelectricappliancetype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricappliancetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectricappliancetypeenum):
				self._predefinedtype = ifcelectricappliancetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcelectricappliancetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcelectricappliancetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcsystemfurnitureelement #
####################
class ifcsystemfurnitureelement(ifcfurnishingelement):
	'''Entity ifcsystemfurnitureelement definition.

	:param predefinedtype
	:type predefinedtype:ifcsystemfurnitureelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcfurnishingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsystemfurnitureelementtypeenum):
					self._predefinedtype = ifcsystemfurnitureelementtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcsystemfurnitureelementtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcsystemfurnitureelementtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSYSTEMFURNITUREELEMENTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifccondenser #
####################
class ifccondenser(ifcenergyconversiondevice):
	'''Entity ifccondenser definition.

	:param predefinedtype
	:type predefinedtype:ifccondensertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccondensertypeenum):
					self._predefinedtype = ifccondensertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccondensertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccondensertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCONDENSERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcgeographicelement #
####################
class ifcgeographicelement(ifcelement):
	'''Entity ifcgeographicelement definition.

	:param predefinedtype
	:type predefinedtype:ifcgeographicelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcgeographicelementtypeenum):
					self._predefinedtype = ifcgeographicelementtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcgeographicelementtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcgeographicelementtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCGEOGRAPHICELEMENTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifctextliteral #
####################
class ifctextliteral(ifcgeometricrepresentationitem):
	'''Entity ifctextliteral definition.

	:param literal
	:type literal:ifcpresentabletext

	:param placement
	:type placement:ifcaxis2placement

	:param path
	:type path:ifctextpath
	'''
	def __init__( self , literal,placement,path, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.literal = literal
		self.placement = placement
		self.path = path

	@apply
	def literal():
		def fget( self ):
			return self._literal
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument literal is mantatory and can not be set to None')
			if not check_type(value,ifcpresentabletext):
				self._literal = ifcpresentabletext(value)
			else:
				self._literal = value
		return property(**locals())

	@apply
	def placement():
		def fget( self ):
			return self._placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placement is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._placement = ifcaxis2placement(value)
			else:
				self._placement = value
		return property(**locals())

	@apply
	def path():
		def fget( self ):
			return self._path
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument path is mantatory and can not be set to None')
			if not check_type(value,ifctextpath):
				self._path = ifctextpath(value)
			else:
				self._path = value
		return property(**locals())

####################
 # ENTITY ifcexternalinformation #
####################
class ifcexternalinformation(BaseEntityClass):
	'''Entity ifcexternalinformation definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY ifcdocumentinformation #
####################
class ifcdocumentinformation(ifcexternalinformation):
	'''Entity ifcdocumentinformation definition.

	:param identification
	:type identification:ifcidentifier

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param location
	:type location:ifcurireference

	:param purpose
	:type purpose:ifctext

	:param intendeduse
	:type intendeduse:ifctext

	:param scope
	:type scope:ifctext

	:param revision
	:type revision:ifclabel

	:param documentowner
	:type documentowner:ifcactorselect

	:param editors
	:type editors:SET(1,None,'ifcactorselect', scope = schema_scope)

	:param creationtime
	:type creationtime:ifcdatetime

	:param lastrevisiontime
	:type lastrevisiontime:ifcdatetime

	:param electronicformat
	:type electronicformat:ifcidentifier

	:param validfrom
	:type validfrom:ifcdate

	:param validuntil
	:type validuntil:ifcdate

	:param confidentiality
	:type confidentiality:ifcdocumentconfidentialityenum

	:param status
	:type status:ifcdocumentstatusenum

	:param documentinfoforobjects
	:type documentinfoforobjects:SET(0,None,'ifcrelassociatesdocument', scope = schema_scope)

	:param hasdocumentreferences
	:type hasdocumentreferences:SET(0,None,'ifcdocumentreference', scope = schema_scope)

	:param ispointedto
	:type ispointedto:SET(0,None,'ifcdocumentinformationrelationship', scope = schema_scope)

	:param ispointer
	:type ispointer:SET(0,1,'ifcdocumentinformationrelationship', scope = schema_scope)
	'''
	def __init__( self , identification,name,description,location,purpose,intendeduse,scope,revision,documentowner,editors,creationtime,lastrevisiontime,electronicformat,validfrom,validuntil,confidentiality,status, ):
		ifcexternalinformation.__init__(self , )
		self.identification = identification
		self.name = name
		self.description = description
		self.location = location
		self.purpose = purpose
		self.intendeduse = intendeduse
		self.scope = scope
		self.revision = revision
		self.documentowner = documentowner
		self.editors = editors
		self.creationtime = creationtime
		self.lastrevisiontime = lastrevisiontime
		self.electronicformat = electronicformat
		self.validfrom = validfrom
		self.validuntil = validuntil
		self.confidentiality = confidentiality
		self.status = status

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument identification is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._identification = ifcidentifier(value)
			else:
				self._identification = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def location():
		def fget( self ):
			return self._location
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcurireference):
					self._location = ifcurireference(value)
				else:
					self._location = value
			else:
				self._location = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._purpose = ifctext(value)
				else:
					self._purpose = value
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def intendeduse():
		def fget( self ):
			return self._intendeduse
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._intendeduse = ifctext(value)
				else:
					self._intendeduse = value
			else:
				self._intendeduse = value
		return property(**locals())

	@apply
	def scope():
		def fget( self ):
			return self._scope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._scope = ifctext(value)
				else:
					self._scope = value
			else:
				self._scope = value
		return property(**locals())

	@apply
	def revision():
		def fget( self ):
			return self._revision
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._revision = ifclabel(value)
				else:
					self._revision = value
			else:
				self._revision = value
		return property(**locals())

	@apply
	def documentowner():
		def fget( self ):
			return self._documentowner
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._documentowner = ifcactorselect(value)
				else:
					self._documentowner = value
			else:
				self._documentowner = value
		return property(**locals())

	@apply
	def editors():
		def fget( self ):
			return self._editors
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcactorselect', scope = schema_scope)):
					self._editors = SET(value)
				else:
					self._editors = value
			else:
				self._editors = value
		return property(**locals())

	@apply
	def creationtime():
		def fget( self ):
			return self._creationtime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._creationtime = ifcdatetime(value)
				else:
					self._creationtime = value
			else:
				self._creationtime = value
		return property(**locals())

	@apply
	def lastrevisiontime():
		def fget( self ):
			return self._lastrevisiontime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._lastrevisiontime = ifcdatetime(value)
				else:
					self._lastrevisiontime = value
			else:
				self._lastrevisiontime = value
		return property(**locals())

	@apply
	def electronicformat():
		def fget( self ):
			return self._electronicformat
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._electronicformat = ifcidentifier(value)
				else:
					self._electronicformat = value
			else:
				self._electronicformat = value
		return property(**locals())

	@apply
	def validfrom():
		def fget( self ):
			return self._validfrom
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdate):
					self._validfrom = ifcdate(value)
				else:
					self._validfrom = value
			else:
				self._validfrom = value
		return property(**locals())

	@apply
	def validuntil():
		def fget( self ):
			return self._validuntil
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdate):
					self._validuntil = ifcdate(value)
				else:
					self._validuntil = value
			else:
				self._validuntil = value
		return property(**locals())

	@apply
	def confidentiality():
		def fget( self ):
			return self._confidentiality
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdocumentconfidentialityenum):
					self._confidentiality = ifcdocumentconfidentialityenum(value)
				else:
					self._confidentiality = value
			else:
				self._confidentiality = value
		return property(**locals())

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdocumentstatusenum):
					self._status = ifcdocumentstatusenum(value)
				else:
					self._status = value
			else:
				self._status = value
		return property(**locals())

	@apply
	def documentinfoforobjects():
		def fget( self ):
			return self._documentinfoforobjects
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument documentinfoforobjects is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasdocumentreferences():
		def fget( self ):
			return self._hasdocumentreferences
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasdocumentreferences is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ispointedto():
		def fget( self ):
			return self._ispointedto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ispointedto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ispointer():
		def fget( self ):
			return self._ispointer
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ispointer is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcreinforcingbartype #
####################
class ifcreinforcingbartype(ifcreinforcingelementtype):
	'''Entity ifcreinforcingbartype definition.

	:param predefinedtype
	:type predefinedtype:ifcreinforcingbartypeenum

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param crosssectionarea
	:type crosssectionarea:ifcareameasure

	:param barlength
	:type barlength:ifcpositivelengthmeasure

	:param barsurface
	:type barsurface:ifcreinforcingbarsurfaceenum

	:param bendingshapecode
	:type bendingshapecode:ifclabel

	:param bendingparameters
	:type bendingparameters:LIST(1,None,'ifcbendingparameterselect', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype,nominaldiameter,crosssectionarea,barlength,barsurface,bendingshapecode,bendingparameters, ):
		ifcreinforcingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype
		self.nominaldiameter = nominaldiameter
		self.crosssectionarea = crosssectionarea
		self.barlength = barlength
		self.barsurface = barsurface
		self.bendingshapecode = bendingshapecode
		self.bendingparameters = bendingparameters

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcreinforcingbartypeenum):
				self._predefinedtype = ifcreinforcingbartypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def nominaldiameter():
		def fget( self ):
			return self._nominaldiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominaldiameter = ifcpositivelengthmeasure(value)
				else:
					self._nominaldiameter = value
			else:
				self._nominaldiameter = value
		return property(**locals())

	@apply
	def crosssectionarea():
		def fget( self ):
			return self._crosssectionarea
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._crosssectionarea = ifcareameasure(value)
				else:
					self._crosssectionarea = value
			else:
				self._crosssectionarea = value
		return property(**locals())

	@apply
	def barlength():
		def fget( self ):
			return self._barlength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._barlength = ifcpositivelengthmeasure(value)
				else:
					self._barlength = value
			else:
				self._barlength = value
		return property(**locals())

	@apply
	def barsurface():
		def fget( self ):
			return self._barsurface
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreinforcingbarsurfaceenum):
					self._barsurface = ifcreinforcingbarsurfaceenum(value)
				else:
					self._barsurface = value
			else:
				self._barsurface = value
		return property(**locals())

	@apply
	def bendingshapecode():
		def fget( self ):
			return self._bendingshapecode
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._bendingshapecode = ifclabel(value)
				else:
					self._bendingshapecode = value
			else:
				self._bendingshapecode = value
		return property(**locals())

	@apply
	def bendingparameters():
		def fget( self ):
			return self._bendingparameters
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcbendingparameterselect', scope = schema_scope)):
					self._bendingparameters = LIST(value)
				else:
					self._bendingparameters = value
			else:
				self._bendingparameters = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcreinforcingbartypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcreinforcingbartypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def bendingshapecodeprovided(self):
		eval_bendingshapecodeprovided_wr = (( not EXISTS(self.bendingparameters))  or  EXISTS(self.bendingshapecode))
		if not eval_bendingshapecodeprovided_wr:
			raise AssertionError('Rule bendingshapecodeprovided violated')
		else:
			return eval_bendingshapecodeprovided_wr


####################
 # ENTITY ifcstylemodel #
####################
class ifcstylemodel(ifcrepresentation):
	'''Entity ifcstylemodel definition.
	'''
	def __init__( self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items ,  ):
		ifcrepresentation.__init__(self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items , )

####################
 # ENTITY ifcstyledrepresentation #
####################
class ifcstyledrepresentation(ifcstylemodel):
	'''Entity ifcstyledrepresentation definition.
	'''
	def __init__( self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items ,  ):
		ifcstylemodel.__init__(self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items , )
	def onlystyleditems(self):
		eval_onlystyleditems_wr = (SIZEOF(None)  ==  0)
		if not eval_onlystyleditems_wr:
			raise AssertionError('Rule onlystyleditems violated')
		else:
			return eval_onlystyleditems_wr


####################
 # ENTITY ifcellipseprofiledef #
####################
class ifcellipseprofiledef(ifcparameterizedprofiledef):
	'''Entity ifcellipseprofiledef definition.

	:param semiaxis1
	:type semiaxis1:ifcpositivelengthmeasure

	:param semiaxis2
	:type semiaxis2:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , semiaxis1,semiaxis2, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.semiaxis1 = semiaxis1
		self.semiaxis2 = semiaxis2

	@apply
	def semiaxis1():
		def fget( self ):
			return self._semiaxis1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semiaxis1 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._semiaxis1 = ifcpositivelengthmeasure(value)
			else:
				self._semiaxis1 = value
		return property(**locals())

	@apply
	def semiaxis2():
		def fget( self ):
			return self._semiaxis2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semiaxis2 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._semiaxis2 = ifcpositivelengthmeasure(value)
			else:
				self._semiaxis2 = value
		return property(**locals())

####################
 # ENTITY ifcsectionedspine #
####################
class ifcsectionedspine(ifcgeometricrepresentationitem):
	'''Entity ifcsectionedspine definition.

	:param spinecurve
	:type spinecurve:ifccompositecurve

	:param crosssections
	:type crosssections:LIST(2,None,'ifcprofiledef', scope = schema_scope)

	:param crosssectionpositions
	:type crosssectionpositions:LIST(2,None,'ifcaxis2placement3d', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , spinecurve,crosssections,crosssectionpositions, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.spinecurve = spinecurve
		self.crosssections = crosssections
		self.crosssectionpositions = crosssectionpositions

	@apply
	def spinecurve():
		def fget( self ):
			return self._spinecurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument spinecurve is mantatory and can not be set to None')
			if not check_type(value,ifccompositecurve):
				self._spinecurve = ifccompositecurve(value)
			else:
				self._spinecurve = value
		return property(**locals())

	@apply
	def crosssections():
		def fget( self ):
			return self._crosssections
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument crosssections is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'ifcprofiledef', scope = schema_scope)):
				self._crosssections = LIST(value)
			else:
				self._crosssections = value
		return property(**locals())

	@apply
	def crosssectionpositions():
		def fget( self ):
			return self._crosssectionpositions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument crosssectionpositions is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'ifcaxis2placement3d', scope = schema_scope)):
				self._crosssectionpositions = LIST(value)
			else:
				self._crosssectionpositions = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def correspondingsectionpositions(self):
		eval_correspondingsectionpositions_wr = (SIZEOF(self.crosssections)  ==  SIZEOF(self.crosssectionpositions))
		if not eval_correspondingsectionpositions_wr:
			raise AssertionError('Rule correspondingsectionpositions violated')
		else:
			return eval_correspondingsectionpositions_wr

	def consistentprofiletypes(self):
		eval_consistentprofiletypes_wr = (SIZEOF(None)  ==  0)
		if not eval_consistentprofiletypes_wr:
			raise AssertionError('Rule consistentprofiletypes violated')
		else:
			return eval_consistentprofiletypes_wr

	def spinecurvedim(self):
		eval_spinecurvedim_wr = (self.spinecurve.self.dim  ==  3)
		if not eval_spinecurvedim_wr:
			raise AssertionError('Rule spinecurvedim violated')
		else:
			return eval_spinecurvedim_wr


####################
 # ENTITY ifcvertex #
####################
class ifcvertex(ifctopologicalrepresentationitem):
	'''Entity ifcvertex definition.
	'''
	def __init__( self ,  ):
		ifctopologicalrepresentationitem.__init__(self , )

####################
 # ENTITY ifcvertexpoint #
####################
class ifcvertexpoint(ifcvertex):
	'''Entity ifcvertexpoint definition.

	:param vertexgeometry
	:type vertexgeometry:ifcpoint
	'''
	def __init__( self , vertexgeometry, ):
		ifcvertex.__init__(self , )
		self.vertexgeometry = vertexgeometry

	@apply
	def vertexgeometry():
		def fget( self ):
			return self._vertexgeometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vertexgeometry is mantatory and can not be set to None')
			if not check_type(value,ifcpoint):
				self._vertexgeometry = ifcpoint(value)
			else:
				self._vertexgeometry = value
		return property(**locals())

####################
 # ENTITY ifcwallstandardcase #
####################
class ifcwallstandardcase(ifcwall):
	'''Entity ifcwallstandardcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype ,  ):
		ifcwall.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype , )
	def hasmateriallayersetusage(self):
		eval_hasmateriallayersetusage_wr = (SIZEOF(None)  ==  1)
		if not eval_hasmateriallayersetusage_wr:
			raise AssertionError('Rule hasmateriallayersetusage violated')
		else:
			return eval_hasmateriallayersetusage_wr


####################
 # ENTITY ifccoolingtower #
####################
class ifccoolingtower(ifcenergyconversiondevice):
	'''Entity ifccoolingtower definition.

	:param predefinedtype
	:type predefinedtype:ifccoolingtowertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccoolingtowertypeenum):
					self._predefinedtype = ifccoolingtowertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccoolingtowertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccoolingtowertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCOOLINGTOWERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcswitchingdevice #
####################
class ifcswitchingdevice(ifcflowcontroller):
	'''Entity ifcswitchingdevice definition.

	:param predefinedtype
	:type predefinedtype:ifcswitchingdevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowcontroller.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcswitchingdevicetypeenum):
					self._predefinedtype = ifcswitchingdevicetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcswitchingdevicetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcswitchingdevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSWITCHINGDEVICETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcfeatureelementsubtraction #
####################
class ifcfeatureelementsubtraction(ifcfeatureelement):
	'''Entity ifcfeatureelementsubtraction definition.

	:param voidselements
	:type voidselements:ifcrelvoidselement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcfeatureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

	@apply
	def voidselements():
		def fget( self ):
			return self._voidselements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument voidselements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def hasnosubtraction(self):
		eval_hasnosubtraction_wr = (SIZEOF(self.self.ifcelement.self.hasopenings)  ==  0)
		if not eval_hasnosubtraction_wr:
			raise AssertionError('Rule hasnosubtraction violated')
		else:
			return eval_hasnosubtraction_wr

	def isnotfilling(self):
		eval_isnotfilling_wr = (SIZEOF(self.self.ifcelement.self.fillsvoids)  ==  0)
		if not eval_isnotfilling_wr:
			raise AssertionError('Rule isnotfilling violated')
		else:
			return eval_isnotfilling_wr


####################
 # ENTITY ifcvoidingfeature #
####################
class ifcvoidingfeature(ifcfeatureelementsubtraction):
	'''Entity ifcvoidingfeature definition.

	:param predefinedtype
	:type predefinedtype:ifcvoidingfeaturetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcfeatureelementsubtraction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvoidingfeaturetypeenum):
					self._predefinedtype = ifcvoidingfeaturetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def hasobjecttype(self):
		eval_hasobjecttype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcvoidingfeaturetypeenum.self.userdefined))  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_hasobjecttype_wr:
			raise AssertionError('Rule hasobjecttype violated')
		else:
			return eval_hasobjecttype_wr


####################
 # ENTITY ifccablecarriersegmenttype #
####################
class ifccablecarriersegmenttype(ifcflowsegmenttype):
	'''Entity ifccablecarriersegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifccablecarriersegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowsegmenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccablecarriersegmenttypeenum):
				self._predefinedtype = ifccablecarriersegmenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccablecarriersegmenttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccablecarriersegmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcaudiovisualappliance #
####################
class ifcaudiovisualappliance(ifcflowterminal):
	'''Entity ifcaudiovisualappliance definition.

	:param predefinedtype
	:type predefinedtype:ifcaudiovisualappliancetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaudiovisualappliancetypeenum):
					self._predefinedtype = ifcaudiovisualappliancetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcaudiovisualappliancetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcaudiovisualappliancetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCAUDIOVISUALAPPLIANCETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcductsilencertype #
####################
class ifcductsilencertype(ifcflowtreatmentdevicetype):
	'''Entity ifcductsilencertype definition.

	:param predefinedtype
	:type predefinedtype:ifcductsilencertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowtreatmentdevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcductsilencertypeenum):
				self._predefinedtype = ifcductsilencertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcductsilencertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcductsilencertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcasymmetricishapeprofiledef #
####################
class ifcasymmetricishapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifcasymmetricishapeprofiledef definition.

	:param bottomflangewidth
	:type bottomflangewidth:ifcpositivelengthmeasure

	:param overalldepth
	:type overalldepth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param bottomflangethickness
	:type bottomflangethickness:ifcpositivelengthmeasure

	:param bottomflangefilletradius
	:type bottomflangefilletradius:ifcnonnegativelengthmeasure

	:param topflangewidth
	:type topflangewidth:ifcpositivelengthmeasure

	:param topflangethickness
	:type topflangethickness:ifcpositivelengthmeasure

	:param topflangefilletradius
	:type topflangefilletradius:ifcnonnegativelengthmeasure

	:param bottomflangeedgeradius
	:type bottomflangeedgeradius:ifcnonnegativelengthmeasure

	:param bottomflangeslope
	:type bottomflangeslope:ifcplaneanglemeasure

	:param topflangeedgeradius
	:type topflangeedgeradius:ifcnonnegativelengthmeasure

	:param topflangeslope
	:type topflangeslope:ifcplaneanglemeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , bottomflangewidth,overalldepth,webthickness,bottomflangethickness,bottomflangefilletradius,topflangewidth,topflangethickness,topflangefilletradius,bottomflangeedgeradius,bottomflangeslope,topflangeedgeradius,topflangeslope, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.bottomflangewidth = bottomflangewidth
		self.overalldepth = overalldepth
		self.webthickness = webthickness
		self.bottomflangethickness = bottomflangethickness
		self.bottomflangefilletradius = bottomflangefilletradius
		self.topflangewidth = topflangewidth
		self.topflangethickness = topflangethickness
		self.topflangefilletradius = topflangefilletradius
		self.bottomflangeedgeradius = bottomflangeedgeradius
		self.bottomflangeslope = bottomflangeslope
		self.topflangeedgeradius = topflangeedgeradius
		self.topflangeslope = topflangeslope

	@apply
	def bottomflangewidth():
		def fget( self ):
			return self._bottomflangewidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bottomflangewidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._bottomflangewidth = ifcpositivelengthmeasure(value)
			else:
				self._bottomflangewidth = value
		return property(**locals())

	@apply
	def overalldepth():
		def fget( self ):
			return self._overalldepth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument overalldepth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._overalldepth = ifcpositivelengthmeasure(value)
			else:
				self._overalldepth = value
		return property(**locals())

	@apply
	def webthickness():
		def fget( self ):
			return self._webthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument webthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._webthickness = ifcpositivelengthmeasure(value)
			else:
				self._webthickness = value
		return property(**locals())

	@apply
	def bottomflangethickness():
		def fget( self ):
			return self._bottomflangethickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bottomflangethickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._bottomflangethickness = ifcpositivelengthmeasure(value)
			else:
				self._bottomflangethickness = value
		return property(**locals())

	@apply
	def bottomflangefilletradius():
		def fget( self ):
			return self._bottomflangefilletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._bottomflangefilletradius = ifcnonnegativelengthmeasure(value)
				else:
					self._bottomflangefilletradius = value
			else:
				self._bottomflangefilletradius = value
		return property(**locals())

	@apply
	def topflangewidth():
		def fget( self ):
			return self._topflangewidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument topflangewidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._topflangewidth = ifcpositivelengthmeasure(value)
			else:
				self._topflangewidth = value
		return property(**locals())

	@apply
	def topflangethickness():
		def fget( self ):
			return self._topflangethickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._topflangethickness = ifcpositivelengthmeasure(value)
				else:
					self._topflangethickness = value
			else:
				self._topflangethickness = value
		return property(**locals())

	@apply
	def topflangefilletradius():
		def fget( self ):
			return self._topflangefilletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._topflangefilletradius = ifcnonnegativelengthmeasure(value)
				else:
					self._topflangefilletradius = value
			else:
				self._topflangefilletradius = value
		return property(**locals())

	@apply
	def bottomflangeedgeradius():
		def fget( self ):
			return self._bottomflangeedgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._bottomflangeedgeradius = ifcnonnegativelengthmeasure(value)
				else:
					self._bottomflangeedgeradius = value
			else:
				self._bottomflangeedgeradius = value
		return property(**locals())

	@apply
	def bottomflangeslope():
		def fget( self ):
			return self._bottomflangeslope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._bottomflangeslope = ifcplaneanglemeasure(value)
				else:
					self._bottomflangeslope = value
			else:
				self._bottomflangeslope = value
		return property(**locals())

	@apply
	def topflangeedgeradius():
		def fget( self ):
			return self._topflangeedgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._topflangeedgeradius = ifcnonnegativelengthmeasure(value)
				else:
					self._topflangeedgeradius = value
			else:
				self._topflangeedgeradius = value
		return property(**locals())

	@apply
	def topflangeslope():
		def fget( self ):
			return self._topflangeslope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._topflangeslope = ifcplaneanglemeasure(value)
				else:
					self._topflangeslope = value
			else:
				self._topflangeslope = value
		return property(**locals())
	def validflangethickness(self):
		eval_validflangethickness_wr = (( not EXISTS(self.topflangethickness))  or  ((self.bottomflangethickness  +  self.topflangethickness)  <  self.overalldepth))
		if not eval_validflangethickness_wr:
			raise AssertionError('Rule validflangethickness violated')
		else:
			return eval_validflangethickness_wr

	def validwebthickness(self):
		eval_validwebthickness_wr = ((self.webthickness  <  self.bottomflangewidth)  and  (self.webthickness  <  self.topflangewidth))
		if not eval_validwebthickness_wr:
			raise AssertionError('Rule validwebthickness violated')
		else:
			return eval_validwebthickness_wr

	def validbottomfilletradius(self):
		eval_validbottomfilletradius_wr = (( not EXISTS(self.bottomflangefilletradius))  or  (self.bottomflangefilletradius  <=  ((self.bottomflangewidth - self.webthickness) / 2)))
		if not eval_validbottomfilletradius_wr:
			raise AssertionError('Rule validbottomfilletradius violated')
		else:
			return eval_validbottomfilletradius_wr

	def validtopfilletradius(self):
		eval_validtopfilletradius_wr = (( not EXISTS(self.topflangefilletradius))  or  (self.topflangefilletradius  <=  ((self.topflangewidth - self.webthickness) / 2)))
		if not eval_validtopfilletradius_wr:
			raise AssertionError('Rule validtopfilletradius violated')
		else:
			return eval_validtopfilletradius_wr


####################
 # ENTITY ifcstructuralcurveaction #
####################
class ifcstructuralcurveaction(ifcstructuralaction):
	'''Entity ifcstructuralcurveaction definition.

	:param projectedortrue
	:type projectedortrue:ifcprojectedortruelengthenum

	:param predefinedtype
	:type predefinedtype:ifcstructuralcurveactivitytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , projectedortrue,predefinedtype, ):
		ifcstructuralaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , )
		self.projectedortrue = projectedortrue
		self.predefinedtype = predefinedtype

	@apply
	def projectedortrue():
		def fget( self ):
			return self._projectedortrue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcprojectedortruelengthenum):
					self._projectedortrue = ifcprojectedortruelengthenum(value)
				else:
					self._projectedortrue = value
			else:
				self._projectedortrue = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralcurveactivitytypeenum):
				self._predefinedtype = ifcstructuralcurveactivitytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def projectedisglobal(self):
		eval_projectedisglobal_wr = (( not EXISTS(self.projectedortrue))  or  ((self.projectedortrue  !=  projected_length)  or  (self.self.ifcstructuralactivity.self.globalorlocal  ==  global_coords)))
		if not eval_projectedisglobal_wr:
			raise AssertionError('Rule projectedisglobal violated')
		else:
			return eval_projectedisglobal_wr

	def hasobjecttype(self):
		eval_hasobjecttype_wr = ((self.predefinedtype  !=  ifcstructuralcurveactivitytypeenum.self.userdefined)  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_hasobjecttype_wr:
			raise AssertionError('Rule hasobjecttype violated')
		else:
			return eval_hasobjecttype_wr

	def suitablepredefinedtype(self):
		eval_suitablepredefinedtype_wr = (self.predefinedtype  !=  ifcstructuralcurveactivitytypeenum.self.equidistant)
		if not eval_suitablepredefinedtype_wr:
			raise AssertionError('Rule suitablepredefinedtype violated')
		else:
			return eval_suitablepredefinedtype_wr


####################
 # ENTITY ifccartesiantransformationoperator2d #
####################
class ifccartesiantransformationoperator2d(ifccartesiantransformationoperator):
	'''Entity ifccartesiantransformationoperator2d definition.

	:param u
	:type u:LIST(2,2,'ifcdirection', scope = schema_scope)
	'''
	def __init__( self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale ,  ):
		ifccartesiantransformationoperator.__init__(self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , )

	@apply
	def u():
		def fget( self ):
			attribute_eval = ifcbaseaxis(2,self.self.ifccartesiantransformationoperator.self.axis1,self.self.ifccartesiantransformationoperator.self.axis2, None )
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument u is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def dimequal2(self):
		eval_dimequal2_wr = (self.self.ifccartesiantransformationoperator.self.dim  ==  2)
		if not eval_dimequal2_wr:
			raise AssertionError('Rule dimequal2 violated')
		else:
			return eval_dimequal2_wr

	def axis1is2d(self):
		eval_axis1is2d_wr = (( not EXISTS(self.self.ifccartesiantransformationoperator.self.axis1))  or  (self.self.ifccartesiantransformationoperator.self.axis1.self.dim  ==  2))
		if not eval_axis1is2d_wr:
			raise AssertionError('Rule axis1is2d violated')
		else:
			return eval_axis1is2d_wr

	def axis2is2d(self):
		eval_axis2is2d_wr = (( not EXISTS(self.self.ifccartesiantransformationoperator.self.axis2))  or  (self.self.ifccartesiantransformationoperator.self.axis2.self.dim  ==  2))
		if not eval_axis2is2d_wr:
			raise AssertionError('Rule axis2is2d violated')
		else:
			return eval_axis2is2d_wr


####################
 # ENTITY ifccartesiantransformationoperator2dnonuniform #
####################
class ifccartesiantransformationoperator2dnonuniform(ifccartesiantransformationoperator2d):
	'''Entity ifccartesiantransformationoperator2dnonuniform definition.

	:param scale2
	:type scale2:REAL

	:param scl2
	:type scl2:REAL
	'''
	def __init__( self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , scale2, ):
		ifccartesiantransformationoperator2d.__init__(self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , )
		self.scale2 = scale2

	@apply
	def scale2():
		def fget( self ):
			return self._scale2
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._scale2 = REAL(value)
				else:
					self._scale2 = value
			else:
				self._scale2 = value
		return property(**locals())

	@apply
	def scl2():
		def fget( self ):
			attribute_eval = NVL(self.scale2,self.self.ifccartesiantransformationoperator.self.scl)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scl2 is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def scale2greaterzero(self):
		eval_scale2greaterzero_wr = (self.scl2  >  0)
		if not eval_scale2greaterzero_wr:
			raise AssertionError('Rule scale2greaterzero violated')
		else:
			return eval_scale2greaterzero_wr


####################
 # ENTITY ifcelementassembly #
####################
class ifcelementassembly(ifcelement):
	'''Entity ifcelementassembly definition.

	:param assemblyplace
	:type assemblyplace:ifcassemblyplaceenum

	:param predefinedtype
	:type predefinedtype:ifcelementassemblytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , assemblyplace,predefinedtype, ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.assemblyplace = assemblyplace
		self.predefinedtype = predefinedtype

	@apply
	def assemblyplace():
		def fget( self ):
			return self._assemblyplace
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcassemblyplaceenum):
					self._assemblyplace = ifcassemblyplaceenum(value)
				else:
					self._assemblyplace = value
			else:
				self._assemblyplace = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelementassemblytypeenum):
					self._predefinedtype = ifcelementassemblytypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcelementassemblytypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcelementassemblytypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCELEMENTASSEMBLYTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcelementcomponent #
####################
class ifcelementcomponent(ifcelement):
	'''Entity ifcelementcomponent definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcsweptdisksolid #
####################
class ifcsweptdisksolid(ifcsolidmodel):
	'''Entity ifcsweptdisksolid definition.

	:param directrix
	:type directrix:ifccurve

	:param radius
	:type radius:ifcpositivelengthmeasure

	:param innerradius
	:type innerradius:ifcpositivelengthmeasure

	:param startparam
	:type startparam:ifcparametervalue

	:param endparam
	:type endparam:ifcparametervalue
	'''
	def __init__( self , directrix,radius,innerradius,startparam,endparam, ):
		ifcsolidmodel.__init__(self , )
		self.directrix = directrix
		self.radius = radius
		self.innerradius = innerradius
		self.startparam = startparam
		self.endparam = endparam

	@apply
	def directrix():
		def fget( self ):
			return self._directrix
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directrix is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._directrix = ifccurve(value)
			else:
				self._directrix = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def innerradius():
		def fget( self ):
			return self._innerradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._innerradius = ifcpositivelengthmeasure(value)
				else:
					self._innerradius = value
			else:
				self._innerradius = value
		return property(**locals())

	@apply
	def startparam():
		def fget( self ):
			return self._startparam
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcparametervalue):
					self._startparam = ifcparametervalue(value)
				else:
					self._startparam = value
			else:
				self._startparam = value
		return property(**locals())

	@apply
	def endparam():
		def fget( self ):
			return self._endparam
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcparametervalue):
					self._endparam = ifcparametervalue(value)
				else:
					self._endparam = value
			else:
				self._endparam = value
		return property(**locals())
	def directrixdim(self):
		eval_directrixdim_wr = (self.directrix.self.dim  ==  3)
		if not eval_directrixdim_wr:
			raise AssertionError('Rule directrixdim violated')
		else:
			return eval_directrixdim_wr

	def innerradiussize(self):
		eval_innerradiussize_wr = (( not EXISTS(self.innerradius))  or  (self.radius  >  self.innerradius))
		if not eval_innerradiussize_wr:
			raise AssertionError('Rule innerradiussize violated')
		else:
			return eval_innerradiussize_wr

	def directrixbounded(self):
		eval_directrixbounded_wr = ((EXISTS(self.startparam)  and  EXISTS(self.endparam))  or  (SIZEOF(['IFC4.IFCCONIC','IFC4.IFCBOUNDEDCURVE']  *  TYPEOF(self.directrix))  ==  1))
		if not eval_directrixbounded_wr:
			raise AssertionError('Rule directrixbounded violated')
		else:
			return eval_directrixbounded_wr


####################
 # ENTITY ifcsweptdisksolidpolygonal #
####################
class ifcsweptdisksolidpolygonal(ifcsweptdisksolid):
	'''Entity ifcsweptdisksolidpolygonal definition.

	:param filletradius
	:type filletradius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__directrix , inherited1__radius , inherited2__innerradius , inherited3__startparam , inherited4__endparam , filletradius, ):
		ifcsweptdisksolid.__init__(self , inherited0__directrix , inherited1__radius , inherited2__innerradius , inherited3__startparam , inherited4__endparam , )
		self.filletradius = filletradius

	@apply
	def filletradius():
		def fget( self ):
			return self._filletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._filletradius = ifcpositivelengthmeasure(value)
				else:
					self._filletradius = value
			else:
				self._filletradius = value
		return property(**locals())
	def correctradii(self):
		eval_correctradii_wr = (( not EXISTS(self.filletradius))  or  (self.filletradius  >=  self.self.ifcsweptdisksolid.self.radius))
		if not eval_correctradii_wr:
			raise AssertionError('Rule correctradii violated')
		else:
			return eval_correctradii_wr

	def directrixispolyline(self):
		eval_directrixispolyline_wr = ('IFC4.IFCPOLYLINE'  ==  TYPEOF(self.self.ifcsweptdisksolid.self.directrix))
		if not eval_directrixispolyline_wr:
			raise AssertionError('Rule directrixispolyline violated')
		else:
			return eval_directrixispolyline_wr


####################
 # ENTITY ifcaddress #
####################
class ifcaddress(BaseEntityClass):
	'''Entity ifcaddress definition.

	:param purpose
	:type purpose:ifcaddresstypeenum

	:param description
	:type description:ifctext

	:param userdefinedpurpose
	:type userdefinedpurpose:ifclabel

	:param ofperson
	:type ofperson:SET(0,None,'ifcperson', scope = schema_scope)

	:param oforganization
	:type oforganization:SET(0,None,'ifcorganization', scope = schema_scope)
	'''
	def __init__( self , purpose,description,userdefinedpurpose, ):
		self.purpose = purpose
		self.description = description
		self.userdefinedpurpose = userdefinedpurpose

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaddresstypeenum):
					self._purpose = ifcaddresstypeenum(value)
				else:
					self._purpose = value
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def userdefinedpurpose():
		def fget( self ):
			return self._userdefinedpurpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedpurpose = ifclabel(value)
				else:
					self._userdefinedpurpose = value
			else:
				self._userdefinedpurpose = value
		return property(**locals())

	@apply
	def ofperson():
		def fget( self ):
			return self._ofperson
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ofperson is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def oforganization():
		def fget( self ):
			return self._oforganization
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument oforganization is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not EXISTS(self.purpose))  or  ((self.purpose  !=  ifcaddresstypeenum.self.userdefined)  or  ((self.purpose  ==  ifcaddresstypeenum.self.userdefined)  and  EXISTS(self.self.userdefinedpurpose))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifctelecomaddress #
####################
class ifctelecomaddress(ifcaddress):
	'''Entity ifctelecomaddress definition.

	:param telephonenumbers
	:type telephonenumbers:LIST(1,None,'STRING', scope = schema_scope)

	:param facsimilenumbers
	:type facsimilenumbers:LIST(1,None,'STRING', scope = schema_scope)

	:param pagernumber
	:type pagernumber:ifclabel

	:param electronicmailaddresses
	:type electronicmailaddresses:LIST(1,None,'STRING', scope = schema_scope)

	:param wwwhomepageurl
	:type wwwhomepageurl:ifcurireference

	:param messagingids
	:type messagingids:LIST(1,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , inherited0__purpose , inherited1__description , inherited2__userdefinedpurpose , telephonenumbers,facsimilenumbers,pagernumber,electronicmailaddresses,wwwhomepageurl,messagingids, ):
		ifcaddress.__init__(self , inherited0__purpose , inherited1__description , inherited2__userdefinedpurpose , )
		self.telephonenumbers = telephonenumbers
		self.facsimilenumbers = facsimilenumbers
		self.pagernumber = pagernumber
		self.electronicmailaddresses = electronicmailaddresses
		self.wwwhomepageurl = wwwhomepageurl
		self.messagingids = messagingids

	@apply
	def telephonenumbers():
		def fget( self ):
			return self._telephonenumbers
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._telephonenumbers = LIST(value)
				else:
					self._telephonenumbers = value
			else:
				self._telephonenumbers = value
		return property(**locals())

	@apply
	def facsimilenumbers():
		def fget( self ):
			return self._facsimilenumbers
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._facsimilenumbers = LIST(value)
				else:
					self._facsimilenumbers = value
			else:
				self._facsimilenumbers = value
		return property(**locals())

	@apply
	def pagernumber():
		def fget( self ):
			return self._pagernumber
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._pagernumber = ifclabel(value)
				else:
					self._pagernumber = value
			else:
				self._pagernumber = value
		return property(**locals())

	@apply
	def electronicmailaddresses():
		def fget( self ):
			return self._electronicmailaddresses
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._electronicmailaddresses = LIST(value)
				else:
					self._electronicmailaddresses = value
			else:
				self._electronicmailaddresses = value
		return property(**locals())

	@apply
	def wwwhomepageurl():
		def fget( self ):
			return self._wwwhomepageurl
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcurireference):
					self._wwwhomepageurl = ifcurireference(value)
				else:
					self._wwwhomepageurl = value
			else:
				self._wwwhomepageurl = value
		return property(**locals())

	@apply
	def messagingids():
		def fget( self ):
			return self._messagingids
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._messagingids = LIST(value)
				else:
					self._messagingids = value
			else:
				self._messagingids = value
		return property(**locals())
	def minimumdataprovided(self):
		eval_minimumdataprovided_wr = (((((EXISTS(self.telephonenumbers)  or  EXISTS(self.facsimilenumbers))  or  EXISTS(self.pagernumber))  or  EXISTS(self.electronicmailaddresses))  or  EXISTS(self.wwwhomepageurl))  or  EXISTS(self.messagingids))
		if not eval_minimumdataprovided_wr:
			raise AssertionError('Rule minimumdataprovided violated')
		else:
			return eval_minimumdataprovided_wr


####################
 # ENTITY ifccurvestylefontandscaling #
####################
class ifccurvestylefontandscaling(ifcpresentationitem):
	'''Entity ifccurvestylefontandscaling definition.

	:param name
	:type name:ifclabel

	:param curvefont
	:type curvefont:ifccurvestylefontselect

	:param curvefontscaling
	:type curvefontscaling:ifcpositiveratiomeasure
	'''
	def __init__( self , name,curvefont,curvefontscaling, ):
		ifcpresentationitem.__init__(self , )
		self.name = name
		self.curvefont = curvefont
		self.curvefontscaling = curvefontscaling

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def curvefont():
		def fget( self ):
			return self._curvefont
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curvefont is mantatory and can not be set to None')
			if not check_type(value,ifccurvestylefontselect):
				self._curvefont = ifccurvestylefontselect(value)
			else:
				self._curvefont = value
		return property(**locals())

	@apply
	def curvefontscaling():
		def fget( self ):
			return self._curvefontscaling
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curvefontscaling is mantatory and can not be set to None')
			if not check_type(value,ifcpositiveratiomeasure):
				self._curvefontscaling = ifcpositiveratiomeasure(value)
			else:
				self._curvefontscaling = value
		return property(**locals())

####################
 # ENTITY ifcspatialelement #
####################
class ifcspatialelement(ifcproduct):
	'''Entity ifcspatialelement definition.

	:param longname
	:type longname:ifclabel

	:param containselements
	:type containselements:SET(0,None,'ifcrelcontainedinspatialstructure', scope = schema_scope)

	:param servicedbysystems
	:type servicedbysystems:SET(0,None,'ifcrelservicesbuildings', scope = schema_scope)

	:param referenceselements
	:type referenceselements:SET(0,None,'ifcrelreferencedinspatialstructure', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , longname, ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.longname = longname

	@apply
	def longname():
		def fget( self ):
			return self._longname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._longname = ifclabel(value)
				else:
					self._longname = value
			else:
				self._longname = value
		return property(**locals())

	@apply
	def containselements():
		def fget( self ):
			return self._containselements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument containselements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def servicedbysystems():
		def fget( self ):
			return self._servicedbysystems
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument servicedbysystems is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def referenceselements():
		def fget( self ):
			return self._referenceselements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referenceselements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcexternalspatialstructureelement #
####################
class ifcexternalspatialstructureelement(ifcspatialelement):
	'''Entity ifcexternalspatialstructureelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname ,  ):
		ifcspatialelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , )

####################
 # ENTITY ifcexternalspatialelement #
####################
class ifcexternalspatialelement(ifcexternalspatialstructureelement):
	'''Entity ifcexternalspatialelement definition.

	:param predefinedtype
	:type predefinedtype:ifcexternalspatialelementtypeenum

	:param boundedby
	:type boundedby:SET(0,None,'ifcrelspaceboundary', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , predefinedtype, ):
		ifcexternalspatialstructureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcexternalspatialelementtypeenum):
					self._predefinedtype = ifcexternalspatialelementtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def boundedby():
		def fget( self ):
			return self._boundedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument boundedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcsurfaceoflinearextrusion #
####################
class ifcsurfaceoflinearextrusion(ifcsweptsurface):
	'''Entity ifcsurfaceoflinearextrusion definition.

	:param extrudeddirection
	:type extrudeddirection:ifcdirection

	:param depth
	:type depth:ifclengthmeasure

	:param extrusionaxis
	:type extrusionaxis:ifcvector
	'''
	def __init__( self , inherited0__sweptcurve , inherited1__position , extrudeddirection,depth, ):
		ifcsweptsurface.__init__(self , inherited0__sweptcurve , inherited1__position , )
		self.extrudeddirection = extrudeddirection
		self.depth = depth

	@apply
	def extrudeddirection():
		def fget( self ):
			return self._extrudeddirection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extrudeddirection is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._extrudeddirection = ifcdirection(value)
			else:
				self._extrudeddirection = value
		return property(**locals())

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._depth = ifclengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def extrusionaxis():
		def fget( self ):
			attribute_eval = ((ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(self.extrudeddirection,self.depth))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument extrusionaxis is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def depthgreaterzero(self):
		eval_depthgreaterzero_wr = (self.depth  >  0)
		if not eval_depthgreaterzero_wr:
			raise AssertionError('Rule depthgreaterzero violated')
		else:
			return eval_depthgreaterzero_wr


####################
 # ENTITY ifccolumntype #
####################
class ifccolumntype(ifcbuildingelementtype):
	'''Entity ifccolumntype definition.

	:param predefinedtype
	:type predefinedtype:ifccolumntypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccolumntypeenum):
				self._predefinedtype = ifccolumntypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccolumntypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccolumntypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcproductrepresentation #
####################
class ifcproductrepresentation(BaseEntityClass):
	'''Entity ifcproductrepresentation definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param representations
	:type representations:LIST(1,None,'ifcrepresentation', scope = schema_scope)
	'''
	def __init__( self , name,description,representations, ):
		self.name = name
		self.description = description
		self.representations = representations

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def representations():
		def fget( self ):
			return self._representations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representations is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcrepresentation', scope = schema_scope)):
				self._representations = LIST(value)
			else:
				self._representations = value
		return property(**locals())

####################
 # ENTITY ifcmaterialdefinitionrepresentation #
####################
class ifcmaterialdefinitionrepresentation(ifcproductrepresentation):
	'''Entity ifcmaterialdefinitionrepresentation definition.

	:param representedmaterial
	:type representedmaterial:ifcmaterial
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__representations , representedmaterial, ):
		ifcproductrepresentation.__init__(self , inherited0__name , inherited1__description , inherited2__representations , )
		self.representedmaterial = representedmaterial

	@apply
	def representedmaterial():
		def fget( self ):
			return self._representedmaterial
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representedmaterial is mantatory and can not be set to None')
			if not check_type(value,ifcmaterial):
				self._representedmaterial = ifcmaterial(value)
			else:
				self._representedmaterial = value
		return property(**locals())
	def onlystyledrepresentations(self):
		eval_onlystyledrepresentations_wr = (SIZEOF(None)  ==  0)
		if not eval_onlystyledrepresentations_wr:
			raise AssertionError('Rule onlystyledrepresentations violated')
		else:
			return eval_onlystyledrepresentations_wr


####################
 # ENTITY ifcmateriallayersetusage #
####################
class ifcmateriallayersetusage(ifcmaterialusagedefinition):
	'''Entity ifcmateriallayersetusage definition.

	:param forlayerset
	:type forlayerset:ifcmateriallayerset

	:param layersetdirection
	:type layersetdirection:ifclayersetdirectionenum

	:param directionsense
	:type directionsense:ifcdirectionsenseenum

	:param offsetfromreferenceline
	:type offsetfromreferenceline:ifclengthmeasure

	:param referenceextent
	:type referenceextent:ifcpositivelengthmeasure
	'''
	def __init__( self , forlayerset,layersetdirection,directionsense,offsetfromreferenceline,referenceextent, ):
		ifcmaterialusagedefinition.__init__(self , )
		self.forlayerset = forlayerset
		self.layersetdirection = layersetdirection
		self.directionsense = directionsense
		self.offsetfromreferenceline = offsetfromreferenceline
		self.referenceextent = referenceextent

	@apply
	def forlayerset():
		def fget( self ):
			return self._forlayerset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument forlayerset is mantatory and can not be set to None')
			if not check_type(value,ifcmateriallayerset):
				self._forlayerset = ifcmateriallayerset(value)
			else:
				self._forlayerset = value
		return property(**locals())

	@apply
	def layersetdirection():
		def fget( self ):
			return self._layersetdirection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layersetdirection is mantatory and can not be set to None')
			if not check_type(value,ifclayersetdirectionenum):
				self._layersetdirection = ifclayersetdirectionenum(value)
			else:
				self._layersetdirection = value
		return property(**locals())

	@apply
	def directionsense():
		def fget( self ):
			return self._directionsense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directionsense is mantatory and can not be set to None')
			if not check_type(value,ifcdirectionsenseenum):
				self._directionsense = ifcdirectionsenseenum(value)
			else:
				self._directionsense = value
		return property(**locals())

	@apply
	def offsetfromreferenceline():
		def fget( self ):
			return self._offsetfromreferenceline
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offsetfromreferenceline is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._offsetfromreferenceline = ifclengthmeasure(value)
			else:
				self._offsetfromreferenceline = value
		return property(**locals())

	@apply
	def referenceextent():
		def fget( self ):
			return self._referenceextent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._referenceextent = ifcpositivelengthmeasure(value)
				else:
					self._referenceextent = value
			else:
				self._referenceextent = value
		return property(**locals())

####################
 # ENTITY ifcshapemodel #
####################
class ifcshapemodel(ifcrepresentation):
	'''Entity ifcshapemodel definition.

	:param ofshapeaspect
	:type ofshapeaspect:SET(0,1,'ifcshapeaspect', scope = schema_scope)
	'''
	def __init__( self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items ,  ):
		ifcrepresentation.__init__(self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items , )

	@apply
	def ofshapeaspect():
		def fget( self ):
			return self._ofshapeaspect
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ofshapeaspect is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = ((SIZEOF(self.self.ifcrepresentation.self.ofproductrepresentation)  ==  1) XOR (SIZEOF(self.self.ifcrepresentation.self.representationmap)  ==  1) XOR (SIZEOF(self.ofshapeaspect)  ==  1))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcmateriallayerset #
####################
class ifcmateriallayerset(ifcmaterialdefinition):
	'''Entity ifcmateriallayerset definition.

	:param materiallayers
	:type materiallayers:LIST(1,None,'ifcmateriallayer', scope = schema_scope)

	:param layersetname
	:type layersetname:ifclabel

	:param description
	:type description:ifctext

	:param totalthickness
	:type totalthickness:ifclengthmeasure
	'''
	def __init__( self , materiallayers,layersetname,description, ):
		ifcmaterialdefinition.__init__(self , )
		self.materiallayers = materiallayers
		self.layersetname = layersetname
		self.description = description

	@apply
	def materiallayers():
		def fget( self ):
			return self._materiallayers
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument materiallayers is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcmateriallayer', scope = schema_scope)):
				self._materiallayers = LIST(value)
			else:
				self._materiallayers = value
		return property(**locals())

	@apply
	def layersetname():
		def fget( self ):
			return self._layersetname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._layersetname = ifclabel(value)
				else:
					self._layersetname = value
			else:
				self._layersetname = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def totalthickness():
		def fget( self ):
			attribute_eval = ifcmlstotalthickness(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument totalthickness is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcperformancehistory #
####################
class ifcperformancehistory(ifccontrol):
	'''Entity ifcperformancehistory definition.

	:param lifecyclephase
	:type lifecyclephase:ifclabel

	:param predefinedtype
	:type predefinedtype:ifcperformancehistorytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , lifecyclephase,predefinedtype, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , )
		self.lifecyclephase = lifecyclephase
		self.predefinedtype = predefinedtype

	@apply
	def lifecyclephase():
		def fget( self ):
			return self._lifecyclephase
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lifecyclephase is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._lifecyclephase = ifclabel(value)
			else:
				self._lifecyclephase = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcperformancehistorytypeenum):
					self._predefinedtype = ifcperformancehistorytypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcductsegmenttype #
####################
class ifcductsegmenttype(ifcflowsegmenttype):
	'''Entity ifcductsegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcductsegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowsegmenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcductsegmenttypeenum):
				self._predefinedtype = ifcductsegmenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcductsegmenttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcductsegmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifclagtime #
####################
class ifclagtime(ifcschedulingtime):
	'''Entity ifclagtime definition.

	:param lagvalue
	:type lagvalue:ifctimeorratioselect

	:param durationtype
	:type durationtype:ifctaskdurationenum
	'''
	def __init__( self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , lagvalue,durationtype, ):
		ifcschedulingtime.__init__(self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , )
		self.lagvalue = lagvalue
		self.durationtype = durationtype

	@apply
	def lagvalue():
		def fget( self ):
			return self._lagvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lagvalue is mantatory and can not be set to None')
			if not check_type(value,ifctimeorratioselect):
				self._lagvalue = ifctimeorratioselect(value)
			else:
				self._lagvalue = value
		return property(**locals())

	@apply
	def durationtype():
		def fget( self ):
			return self._durationtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument durationtype is mantatory and can not be set to None')
			if not check_type(value,ifctaskdurationenum):
				self._durationtype = ifctaskdurationenum(value)
			else:
				self._durationtype = value
		return property(**locals())

####################
 # ENTITY ifcnamedunit #
####################
class ifcnamedunit(BaseEntityClass):
	'''Entity ifcnamedunit definition.

	:param dimensions
	:type dimensions:ifcdimensionalexponents

	:param unittype
	:type unittype:ifcunitenum
	'''
	def __init__( self , dimensions,unittype, ):
		self.dimensions = dimensions
		self.unittype = unittype

	@apply
	def dimensions():
		def fget( self ):
			return self._dimensions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dimensions is mantatory and can not be set to None')
			if not check_type(value,ifcdimensionalexponents):
				self._dimensions = ifcdimensionalexponents(value)
			else:
				self._dimensions = value
		return property(**locals())

	@apply
	def unittype():
		def fget( self ):
			return self._unittype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unittype is mantatory and can not be set to None')
			if not check_type(value,ifcunitenum):
				self._unittype = ifcunitenum(value)
			else:
				self._unittype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ifccorrectdimensions(self.self.unittype,self.self.dimensions)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcconversionbasedunit #
####################
class ifcconversionbasedunit(ifcnamedunit):
	'''Entity ifcconversionbasedunit definition.

	:param name
	:type name:ifclabel

	:param conversionfactor
	:type conversionfactor:ifcmeasurewithunit

	:param hasexternalreference
	:type hasexternalreference:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__dimensions , inherited1__unittype , name,conversionfactor, ):
		ifcnamedunit.__init__(self , inherited0__dimensions , inherited1__unittype , )
		self.name = name
		self.conversionfactor = conversionfactor

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def conversionfactor():
		def fget( self ):
			return self._conversionfactor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument conversionfactor is mantatory and can not be set to None')
			if not check_type(value,ifcmeasurewithunit):
				self._conversionfactor = ifcmeasurewithunit(value)
			else:
				self._conversionfactor = value
		return property(**locals())

	@apply
	def hasexternalreference():
		def fget( self ):
			return self._hasexternalreference
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcconversionbasedunitwithoffset #
####################
class ifcconversionbasedunitwithoffset(ifcconversionbasedunit):
	'''Entity ifcconversionbasedunitwithoffset definition.

	:param conversionoffset
	:type conversionoffset:ifcreal
	'''
	def __init__( self , inherited0__dimensions , inherited1__unittype , inherited2__name , inherited3__conversionfactor , conversionoffset, ):
		ifcconversionbasedunit.__init__(self , inherited0__dimensions , inherited1__unittype , inherited2__name , inherited3__conversionfactor , )
		self.conversionoffset = conversionoffset

	@apply
	def conversionoffset():
		def fget( self ):
			return self._conversionoffset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument conversionoffset is mantatory and can not be set to None')
			if not check_type(value,ifcreal):
				self._conversionoffset = ifcreal(value)
			else:
				self._conversionoffset = value
		return property(**locals())

####################
 # ENTITY ifcdampertype #
####################
class ifcdampertype(ifcflowcontrollertype):
	'''Entity ifcdampertype definition.

	:param predefinedtype
	:type predefinedtype:ifcdampertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcdampertypeenum):
				self._predefinedtype = ifcdampertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcdampertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcdampertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcphysicalquantity #
####################
class ifcphysicalquantity(BaseEntityClass):
	'''Entity ifcphysicalquantity definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param hasexternalreferences
	:type hasexternalreferences:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)

	:param partofcomplex
	:type partofcomplex:SET(0,1,'ifcphysicalcomplexquantity', scope = schema_scope)
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def hasexternalreferences():
		def fget( self ):
			return self._hasexternalreferences
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasexternalreferences is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def partofcomplex():
		def fget( self ):
			return self._partofcomplex
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofcomplex is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcphysicalsimplequantity #
####################
class ifcphysicalsimplequantity(ifcphysicalquantity):
	'''Entity ifcphysicalsimplequantity definition.

	:param unit
	:type unit:ifcnamedunit
	'''
	def __init__( self , inherited0__name , inherited1__description , unit, ):
		ifcphysicalquantity.__init__(self , inherited0__name , inherited1__description , )
		self.unit = unit

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnamedunit):
					self._unit = ifcnamedunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())

####################
 # ENTITY ifcwindowliningproperties #
####################
class ifcwindowliningproperties(ifcpredefinedpropertyset):
	'''Entity ifcwindowliningproperties definition.

	:param liningdepth
	:type liningdepth:ifcpositivelengthmeasure

	:param liningthickness
	:type liningthickness:ifcnonnegativelengthmeasure

	:param transomthickness
	:type transomthickness:ifcnonnegativelengthmeasure

	:param mullionthickness
	:type mullionthickness:ifcnonnegativelengthmeasure

	:param firsttransomoffset
	:type firsttransomoffset:ifcnormalisedratiomeasure

	:param secondtransomoffset
	:type secondtransomoffset:ifcnormalisedratiomeasure

	:param firstmullionoffset
	:type firstmullionoffset:ifcnormalisedratiomeasure

	:param secondmullionoffset
	:type secondmullionoffset:ifcnormalisedratiomeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect

	:param liningoffset
	:type liningoffset:ifclengthmeasure

	:param liningtopaneloffsetx
	:type liningtopaneloffsetx:ifclengthmeasure

	:param liningtopaneloffsety
	:type liningtopaneloffsety:ifclengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , liningdepth,liningthickness,transomthickness,mullionthickness,firsttransomoffset,secondtransomoffset,firstmullionoffset,secondmullionoffset,shapeaspectstyle,liningoffset,liningtopaneloffsetx,liningtopaneloffsety, ):
		ifcpredefinedpropertyset.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.liningdepth = liningdepth
		self.liningthickness = liningthickness
		self.transomthickness = transomthickness
		self.mullionthickness = mullionthickness
		self.firsttransomoffset = firsttransomoffset
		self.secondtransomoffset = secondtransomoffset
		self.firstmullionoffset = firstmullionoffset
		self.secondmullionoffset = secondmullionoffset
		self.shapeaspectstyle = shapeaspectstyle
		self.liningoffset = liningoffset
		self.liningtopaneloffsetx = liningtopaneloffsetx
		self.liningtopaneloffsety = liningtopaneloffsety

	@apply
	def liningdepth():
		def fget( self ):
			return self._liningdepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._liningdepth = ifcpositivelengthmeasure(value)
				else:
					self._liningdepth = value
			else:
				self._liningdepth = value
		return property(**locals())

	@apply
	def liningthickness():
		def fget( self ):
			return self._liningthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._liningthickness = ifcnonnegativelengthmeasure(value)
				else:
					self._liningthickness = value
			else:
				self._liningthickness = value
		return property(**locals())

	@apply
	def transomthickness():
		def fget( self ):
			return self._transomthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._transomthickness = ifcnonnegativelengthmeasure(value)
				else:
					self._transomthickness = value
			else:
				self._transomthickness = value
		return property(**locals())

	@apply
	def mullionthickness():
		def fget( self ):
			return self._mullionthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._mullionthickness = ifcnonnegativelengthmeasure(value)
				else:
					self._mullionthickness = value
			else:
				self._mullionthickness = value
		return property(**locals())

	@apply
	def firsttransomoffset():
		def fget( self ):
			return self._firsttransomoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._firsttransomoffset = ifcnormalisedratiomeasure(value)
				else:
					self._firsttransomoffset = value
			else:
				self._firsttransomoffset = value
		return property(**locals())

	@apply
	def secondtransomoffset():
		def fget( self ):
			return self._secondtransomoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._secondtransomoffset = ifcnormalisedratiomeasure(value)
				else:
					self._secondtransomoffset = value
			else:
				self._secondtransomoffset = value
		return property(**locals())

	@apply
	def firstmullionoffset():
		def fget( self ):
			return self._firstmullionoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._firstmullionoffset = ifcnormalisedratiomeasure(value)
				else:
					self._firstmullionoffset = value
			else:
				self._firstmullionoffset = value
		return property(**locals())

	@apply
	def secondmullionoffset():
		def fget( self ):
			return self._secondmullionoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._secondmullionoffset = ifcnormalisedratiomeasure(value)
				else:
					self._secondmullionoffset = value
			else:
				self._secondmullionoffset = value
		return property(**locals())

	@apply
	def shapeaspectstyle():
		def fget( self ):
			return self._shapeaspectstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshapeaspect):
					self._shapeaspectstyle = ifcshapeaspect(value)
				else:
					self._shapeaspectstyle = value
			else:
				self._shapeaspectstyle = value
		return property(**locals())

	@apply
	def liningoffset():
		def fget( self ):
			return self._liningoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._liningoffset = ifclengthmeasure(value)
				else:
					self._liningoffset = value
			else:
				self._liningoffset = value
		return property(**locals())

	@apply
	def liningtopaneloffsetx():
		def fget( self ):
			return self._liningtopaneloffsetx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._liningtopaneloffsetx = ifclengthmeasure(value)
				else:
					self._liningtopaneloffsetx = value
			else:
				self._liningtopaneloffsetx = value
		return property(**locals())

	@apply
	def liningtopaneloffsety():
		def fget( self ):
			return self._liningtopaneloffsety
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._liningtopaneloffsety = ifclengthmeasure(value)
				else:
					self._liningtopaneloffsety = value
			else:
				self._liningtopaneloffsety = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = ( not (EXISTS(self.liningdepth)  and  ( not EXISTS(self.liningthickness))))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = ( not (( not EXISTS(self.firsttransomoffset))  and  EXISTS(self.secondtransomoffset)))
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr

	def wr33(self):
		eval_wr33_wr = ( not (( not EXISTS(self.firstmullionoffset))  and  EXISTS(self.secondmullionoffset)))
		if not eval_wr33_wr:
			raise AssertionError('Rule wr33 violated')
		else:
			return eval_wr33_wr

	def wr34(self):
		eval_wr34_wr = (EXISTS(self.self.ifcpropertysetdefinition.self.definestype[1])  and  (('IFC4.IFCWINDOWTYPE'  ==  TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))  or  ('IFC4.IFCWINDOWSTYLE'  ==  TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))))
		if not eval_wr34_wr:
			raise AssertionError('Rule wr34 violated')
		else:
			return eval_wr34_wr


####################
 # ENTITY ifcwindow #
####################
class ifcwindow(ifcbuildingelement):
	'''Entity ifcwindow definition.

	:param overallheight
	:type overallheight:ifcpositivelengthmeasure

	:param overallwidth
	:type overallwidth:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcwindowtypeenum

	:param partitioningtype
	:type partitioningtype:ifcwindowtypepartitioningenum

	:param userdefinedpartitioningtype
	:type userdefinedpartitioningtype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , overallheight,overallwidth,predefinedtype,partitioningtype,userdefinedpartitioningtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.overallheight = overallheight
		self.overallwidth = overallwidth
		self.predefinedtype = predefinedtype
		self.partitioningtype = partitioningtype
		self.userdefinedpartitioningtype = userdefinedpartitioningtype

	@apply
	def overallheight():
		def fget( self ):
			return self._overallheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._overallheight = ifcpositivelengthmeasure(value)
				else:
					self._overallheight = value
			else:
				self._overallheight = value
		return property(**locals())

	@apply
	def overallwidth():
		def fget( self ):
			return self._overallwidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._overallwidth = ifcpositivelengthmeasure(value)
				else:
					self._overallwidth = value
			else:
				self._overallwidth = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcwindowtypeenum):
					self._predefinedtype = ifcwindowtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def partitioningtype():
		def fget( self ):
			return self._partitioningtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcwindowtypepartitioningenum):
					self._partitioningtype = ifcwindowtypepartitioningenum(value)
				else:
					self._partitioningtype = value
			else:
				self._partitioningtype = value
		return property(**locals())

	@apply
	def userdefinedpartitioningtype():
		def fget( self ):
			return self._userdefinedpartitioningtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedpartitioningtype = ifclabel(value)
				else:
					self._userdefinedpartitioningtype = value
			else:
				self._userdefinedpartitioningtype = value
		return property(**locals())
	def correctstyleassigned(self):
		eval_correctstyleassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCWINDOWTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correctstyleassigned_wr:
			raise AssertionError('Rule correctstyleassigned violated')
		else:
			return eval_correctstyleassigned_wr


####################
 # ENTITY ifcwindowstandardcase #
####################
class ifcwindowstandardcase(ifcwindow):
	'''Entity ifcwindowstandardcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__overallheight , inherited9__overallwidth , inherited10__predefinedtype , inherited11__partitioningtype , inherited12__userdefinedpartitioningtype ,  ):
		ifcwindow.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__overallheight , inherited9__overallwidth , inherited10__predefinedtype , inherited11__partitioningtype , inherited12__userdefinedpartitioningtype , )

####################
 # ENTITY ifcboiler #
####################
class ifcboiler(ifcenergyconversiondevice):
	'''Entity ifcboiler definition.

	:param predefinedtype
	:type predefinedtype:ifcboilertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcboilertypeenum):
					self._predefinedtype = ifcboilertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcboilertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcboilertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCBOILERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcorganization #
####################
class ifcorganization(BaseEntityClass):
	'''Entity ifcorganization definition.

	:param identification
	:type identification:ifcidentifier

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param roles
	:type roles:LIST(1,None,'ifcactorrole', scope = schema_scope)

	:param addresses
	:type addresses:LIST(1,None,'ifcaddress', scope = schema_scope)

	:param isrelatedby
	:type isrelatedby:SET(0,None,'ifcorganizationrelationship', scope = schema_scope)

	:param relates
	:type relates:SET(0,None,'ifcorganizationrelationship', scope = schema_scope)

	:param engages
	:type engages:SET(0,None,'ifcpersonandorganization', scope = schema_scope)
	'''
	def __init__( self , identification,name,description,roles,addresses, ):
		self.identification = identification
		self.name = name
		self.description = description
		self.roles = roles
		self.addresses = addresses

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identification = ifcidentifier(value)
				else:
					self._identification = value
			else:
				self._identification = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def roles():
		def fget( self ):
			return self._roles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcactorrole', scope = schema_scope)):
					self._roles = LIST(value)
				else:
					self._roles = value
			else:
				self._roles = value
		return property(**locals())

	@apply
	def addresses():
		def fget( self ):
			return self._addresses
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcaddress', scope = schema_scope)):
					self._addresses = LIST(value)
				else:
					self._addresses = value
			else:
				self._addresses = value
		return property(**locals())

	@apply
	def isrelatedby():
		def fget( self ):
			return self._isrelatedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isrelatedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def relates():
		def fget( self ):
			return self._relates
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument relates is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def engages():
		def fget( self ):
			return self._engages
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument engages is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcquantitycount #
####################
class ifcquantitycount(ifcphysicalsimplequantity):
	'''Entity ifcquantitycount definition.

	:param countvalue
	:type countvalue:ifccountmeasure

	:param formula
	:type formula:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , countvalue,formula, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.countvalue = countvalue
		self.formula = formula

	@apply
	def countvalue():
		def fget( self ):
			return self._countvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument countvalue is mantatory and can not be set to None')
			if not check_type(value,ifccountmeasure):
				self._countvalue = ifccountmeasure(value)
			else:
				self._countvalue = value
		return property(**locals())

	@apply
	def formula():
		def fget( self ):
			return self._formula
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._formula = ifclabel(value)
				else:
					self._formula = value
			else:
				self._formula = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (self.countvalue  >=  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcspaceheater #
####################
class ifcspaceheater(ifcflowterminal):
	'''Entity ifcspaceheater definition.

	:param predefinedtype
	:type predefinedtype:ifcspaceheatertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcspaceheatertypeenum):
					self._predefinedtype = ifcspaceheatertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcspaceheatertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcspaceheatertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSPACEHEATERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcannotation #
####################
class ifcannotation(ifcproduct):
	'''Entity ifcannotation definition.

	:param containedinstructure
	:type containedinstructure:SET(0,1,'ifcrelcontainedinspatialstructure', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation ,  ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )

	@apply
	def containedinstructure():
		def fget( self ):
			return self._containedinstructure
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument containedinstructure is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcfacebasedsurfacemodel #
####################
class ifcfacebasedsurfacemodel(ifcgeometricrepresentationitem):
	'''Entity ifcfacebasedsurfacemodel definition.

	:param fbsmfaces
	:type fbsmfaces:SET(1,None,'ifcconnectedfaceset', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , fbsmfaces, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.fbsmfaces = fbsmfaces

	@apply
	def fbsmfaces():
		def fget( self ):
			return self._fbsmfaces
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fbsmfaces is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcconnectedfaceset', scope = schema_scope)):
				self._fbsmfaces = SET(value)
			else:
				self._fbsmfaces = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcpropertyenumeration #
####################
class ifcpropertyenumeration(ifcpropertyabstraction):
	'''Entity ifcpropertyenumeration definition.

	:param name
	:type name:ifclabel

	:param enumerationvalues
	:type enumerationvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param unit
	:type unit:ifcunit
	'''
	def __init__( self , name,enumerationvalues,unit, ):
		ifcpropertyabstraction.__init__(self , )
		self.name = name
		self.enumerationvalues = enumerationvalues
		self.unit = unit

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def enumerationvalues():
		def fget( self ):
			return self._enumerationvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument enumerationvalues is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
				self._enumerationvalues = LIST(value)
			else:
				self._enumerationvalues = value
		return property(**locals())

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._unit = ifcunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())
	def wr01(self):
		eval_wr01_wr = (SIZEOF(None)  ==  0)
		if not eval_wr01_wr:
			raise AssertionError('Rule wr01 violated')
		else:
			return eval_wr01_wr


####################
 # ENTITY ifcrelconnectsports #
####################
class ifcrelconnectsports(ifcrelconnects):
	'''Entity ifcrelconnectsports definition.

	:param relatingport
	:type relatingport:ifcport

	:param relatedport
	:type relatedport:ifcport

	:param realizingelement
	:type realizingelement:ifcelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingport,relatedport,realizingelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingport = relatingport
		self.relatedport = relatedport
		self.realizingelement = realizingelement

	@apply
	def relatingport():
		def fget( self ):
			return self._relatingport
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingport is mantatory and can not be set to None')
			if not check_type(value,ifcport):
				self._relatingport = ifcport(value)
			else:
				self._relatingport = value
		return property(**locals())

	@apply
	def relatedport():
		def fget( self ):
			return self._relatedport
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedport is mantatory and can not be set to None')
			if not check_type(value,ifcport):
				self._relatedport = ifcport(value)
			else:
				self._relatedport = value
		return property(**locals())

	@apply
	def realizingelement():
		def fget( self ):
			return self._realizingelement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelement):
					self._realizingelement = ifcelement(value)
				else:
					self._realizingelement = value
			else:
				self._realizingelement = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (self.relatingport  !=  self.relatedport)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifcdoor #
####################
class ifcdoor(ifcbuildingelement):
	'''Entity ifcdoor definition.

	:param overallheight
	:type overallheight:ifcpositivelengthmeasure

	:param overallwidth
	:type overallwidth:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcdoortypeenum

	:param operationtype
	:type operationtype:ifcdoortypeoperationenum

	:param userdefinedoperationtype
	:type userdefinedoperationtype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , overallheight,overallwidth,predefinedtype,operationtype,userdefinedoperationtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.overallheight = overallheight
		self.overallwidth = overallwidth
		self.predefinedtype = predefinedtype
		self.operationtype = operationtype
		self.userdefinedoperationtype = userdefinedoperationtype

	@apply
	def overallheight():
		def fget( self ):
			return self._overallheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._overallheight = ifcpositivelengthmeasure(value)
				else:
					self._overallheight = value
			else:
				self._overallheight = value
		return property(**locals())

	@apply
	def overallwidth():
		def fget( self ):
			return self._overallwidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._overallwidth = ifcpositivelengthmeasure(value)
				else:
					self._overallwidth = value
			else:
				self._overallwidth = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdoortypeenum):
					self._predefinedtype = ifcdoortypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def operationtype():
		def fget( self ):
			return self._operationtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdoortypeoperationenum):
					self._operationtype = ifcdoortypeoperationenum(value)
				else:
					self._operationtype = value
			else:
				self._operationtype = value
		return property(**locals())

	@apply
	def userdefinedoperationtype():
		def fget( self ):
			return self._userdefinedoperationtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedoperationtype = ifclabel(value)
				else:
					self._userdefinedoperationtype = value
			else:
				self._userdefinedoperationtype = value
		return property(**locals())
	def correctstyleassigned(self):
		eval_correctstyleassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCDOORTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correctstyleassigned_wr:
			raise AssertionError('Rule correctstyleassigned violated')
		else:
			return eval_correctstyleassigned_wr


####################
 # ENTITY ifcdoorstandardcase #
####################
class ifcdoorstandardcase(ifcdoor):
	'''Entity ifcdoorstandardcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__overallheight , inherited9__overallwidth , inherited10__predefinedtype , inherited11__operationtype , inherited12__userdefinedoperationtype ,  ):
		ifcdoor.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__overallheight , inherited9__overallwidth , inherited10__predefinedtype , inherited11__operationtype , inherited12__userdefinedoperationtype , )

####################
 # ENTITY ifcrectangulartrimmedsurface #
####################
class ifcrectangulartrimmedsurface(ifcboundedsurface):
	'''Entity ifcrectangulartrimmedsurface definition.

	:param basissurface
	:type basissurface:ifcsurface

	:param u1
	:type u1:ifcparametervalue

	:param v1
	:type v1:ifcparametervalue

	:param u2
	:type u2:ifcparametervalue

	:param v2
	:type v2:ifcparametervalue

	:param usense
	:type usense:BOOLEAN

	:param vsense
	:type vsense:BOOLEAN
	'''
	def __init__( self , basissurface,u1,v1,u2,v2,usense,vsense, ):
		ifcboundedsurface.__init__(self , )
		self.basissurface = basissurface
		self.u1 = u1
		self.v1 = v1
		self.u2 = u2
		self.v2 = v2
		self.usense = usense
		self.vsense = vsense

	@apply
	def basissurface():
		def fget( self ):
			return self._basissurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basissurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._basissurface = ifcsurface(value)
			else:
				self._basissurface = value
		return property(**locals())

	@apply
	def u1():
		def fget( self ):
			return self._u1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u1 is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._u1 = ifcparametervalue(value)
			else:
				self._u1 = value
		return property(**locals())

	@apply
	def v1():
		def fget( self ):
			return self._v1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v1 is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._v1 = ifcparametervalue(value)
			else:
				self._v1 = value
		return property(**locals())

	@apply
	def u2():
		def fget( self ):
			return self._u2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u2 is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._u2 = ifcparametervalue(value)
			else:
				self._u2 = value
		return property(**locals())

	@apply
	def v2():
		def fget( self ):
			return self._v2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v2 is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._v2 = ifcparametervalue(value)
			else:
				self._v2 = value
		return property(**locals())

	@apply
	def usense():
		def fget( self ):
			return self._usense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument usense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._usense = BOOLEAN(value)
			else:
				self._usense = value
		return property(**locals())

	@apply
	def vsense():
		def fget( self ):
			return self._vsense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vsense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._vsense = BOOLEAN(value)
			else:
				self._vsense = value
		return property(**locals())
	def u1andu2different(self):
		eval_u1andu2different_wr = (self.u1  !=  self.u2)
		if not eval_u1andu2different_wr:
			raise AssertionError('Rule u1andu2different violated')
		else:
			return eval_u1andu2different_wr

	def v1andv2different(self):
		eval_v1andv2different_wr = (self.v1  !=  self.v2)
		if not eval_v1andv2different_wr:
			raise AssertionError('Rule v1andv2different violated')
		else:
			return eval_v1andv2different_wr

	def usensecompatible(self):
		eval_usensecompatible_wr = (((('IFC4.IFCELEMENTARYSURFACE'  ==  TYPEOF(self.basissurface))  and  ( not ('IFC4.IFCPLANE'  ==  TYPEOF(self.basissurface))))  or  ('IFC4.IFCSURFACEOFREVOLUTION'  ==  TYPEOF(self.basissurface)))  or  (self.usense  ==  (self.u2  >  self.u1)))
		if not eval_usensecompatible_wr:
			raise AssertionError('Rule usensecompatible violated')
		else:
			return eval_usensecompatible_wr

	def vsensecompatible(self):
		eval_vsensecompatible_wr = (self.vsense  ==  (self.v2  >  self.v1))
		if not eval_vsensecompatible_wr:
			raise AssertionError('Rule vsensecompatible violated')
		else:
			return eval_vsensecompatible_wr


####################
 # ENTITY ifcspatialstructureelement #
####################
class ifcspatialstructureelement(ifcspatialelement):
	'''Entity ifcspatialstructureelement definition.

	:param compositiontype
	:type compositiontype:ifcelementcompositionenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , compositiontype, ):
		ifcspatialelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , )
		self.compositiontype = compositiontype

	@apply
	def compositiontype():
		def fget( self ):
			return self._compositiontype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelementcompositionenum):
					self._compositiontype = ifcelementcompositionenum(value)
				else:
					self._compositiontype = value
			else:
				self._compositiontype = value
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = (((HIINDEX(self.self.ifcobjectdefinition.self.decomposes)  ==  1)  and  ('IFC4.IFCRELAGGREGATES'  ==  TYPEOF(self.self.ifcobjectdefinition.self.decomposes[1])))  and  (('IFC4.IFCPROJECT'  ==  TYPEOF(self.self.ifcobjectdefinition.self.decomposes[1].self.relatingobject))  or  ('IFC4.IFCSPATIALSTRUCTUREELEMENT'  ==  TYPEOF(self.self.ifcobjectdefinition.self.decomposes[1].self.relatingobject))))
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr


####################
 # ENTITY ifcbuilding #
####################
class ifcbuilding(ifcspatialstructureelement):
	'''Entity ifcbuilding definition.

	:param elevationofrefheight
	:type elevationofrefheight:ifclengthmeasure

	:param elevationofterrain
	:type elevationofterrain:ifclengthmeasure

	:param buildingaddress
	:type buildingaddress:ifcpostaladdress
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , elevationofrefheight,elevationofterrain,buildingaddress, ):
		ifcspatialstructureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , )
		self.elevationofrefheight = elevationofrefheight
		self.elevationofterrain = elevationofterrain
		self.buildingaddress = buildingaddress

	@apply
	def elevationofrefheight():
		def fget( self ):
			return self._elevationofrefheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._elevationofrefheight = ifclengthmeasure(value)
				else:
					self._elevationofrefheight = value
			else:
				self._elevationofrefheight = value
		return property(**locals())

	@apply
	def elevationofterrain():
		def fget( self ):
			return self._elevationofterrain
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._elevationofterrain = ifclengthmeasure(value)
				else:
					self._elevationofterrain = value
			else:
				self._elevationofterrain = value
		return property(**locals())

	@apply
	def buildingaddress():
		def fget( self ):
			return self._buildingaddress
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpostaladdress):
					self._buildingaddress = ifcpostaladdress(value)
				else:
					self._buildingaddress = value
			else:
				self._buildingaddress = value
		return property(**locals())

####################
 # ENTITY ifcpropertytemplatedefinition #
####################
class ifcpropertytemplatedefinition(ifcpropertydefinition):
	'''Entity ifcpropertytemplatedefinition definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcpropertydefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

####################
 # ENTITY ifcpropertytemplate #
####################
class ifcpropertytemplate(ifcpropertytemplatedefinition):
	'''Entity ifcpropertytemplate definition.

	:param partofcomplextemplate
	:type partofcomplextemplate:SET(0,None,'ifccomplexpropertytemplate', scope = schema_scope)

	:param partofpsettemplate
	:type partofpsettemplate:SET(0,None,'ifcpropertysettemplate', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcpropertytemplatedefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

	@apply
	def partofcomplextemplate():
		def fget( self ):
			return self._partofcomplextemplate
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofcomplextemplate is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def partofpsettemplate():
		def fget( self ):
			return self._partofpsettemplate
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofpsettemplate is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifccolumn #
####################
class ifccolumn(ifcbuildingelement):
	'''Entity ifccolumn definition.

	:param predefinedtype
	:type predefinedtype:ifccolumntypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolumntypeenum):
					self._predefinedtype = ifccolumntypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccolumntypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccolumntypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCOLUMNTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcextrudedareasolid #
####################
class ifcextrudedareasolid(ifcsweptareasolid):
	'''Entity ifcextrudedareasolid definition.

	:param extrudeddirection
	:type extrudeddirection:ifcdirection

	:param depth
	:type depth:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__sweptarea , inherited1__position , extrudeddirection,depth, ):
		ifcsweptareasolid.__init__(self , inherited0__sweptarea , inherited1__position , )
		self.extrudeddirection = extrudeddirection
		self.depth = depth

	@apply
	def extrudeddirection():
		def fget( self ):
			return self._extrudeddirection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extrudeddirection is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._extrudeddirection = ifcdirection(value)
			else:
				self._extrudeddirection = value
		return property(**locals())

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())
	def validextrusiondirection(self):
		eval_validextrusiondirection_wr = (ifcdotproduct((ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,0,1]),self.self.extrudeddirection)  !=  0)
		if not eval_validextrusiondirection_wr:
			raise AssertionError('Rule validextrusiondirection violated')
		else:
			return eval_validextrusiondirection_wr


####################
 # ENTITY ifcfurnishingelementtype #
####################
class ifcfurnishingelementtype(ifcelementtype):
	'''Entity ifcfurnishingelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcsystemfurnitureelementtype #
####################
class ifcsystemfurnitureelementtype(ifcfurnishingelementtype):
	'''Entity ifcsystemfurnitureelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifcsystemfurnitureelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcfurnishingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsystemfurnitureelementtypeenum):
					self._predefinedtype = ifcsystemfurnitureelementtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcsystemfurnitureelementtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcsystemfurnitureelementtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifccsgprimitive3d #
####################
class ifccsgprimitive3d(ifcgeometricrepresentationitem):
	'''Entity ifccsgprimitive3d definition.

	:param position
	:type position:ifcaxis2placement3d

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , position, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement3d):
				self._position = ifcaxis2placement3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcrightcircularcylinder #
####################
class ifcrightcircularcylinder(ifccsgprimitive3d):
	'''Entity ifcrightcircularcylinder definition.

	:param height
	:type height:ifcpositivelengthmeasure

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , height,radius, ):
		ifccsgprimitive3d.__init__(self , inherited0__position , )
		self.height = height
		self.radius = radius

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._height = ifcpositivelengthmeasure(value)
			else:
				self._height = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY ifctextliteralwithextent #
####################
class ifctextliteralwithextent(ifctextliteral):
	'''Entity ifctextliteralwithextent definition.

	:param extent
	:type extent:ifcplanarextent

	:param boxalignment
	:type boxalignment:ifcboxalignment
	'''
	def __init__( self , inherited0__literal , inherited1__placement , inherited2__path , extent,boxalignment, ):
		ifctextliteral.__init__(self , inherited0__literal , inherited1__placement , inherited2__path , )
		self.extent = extent
		self.boxalignment = boxalignment

	@apply
	def extent():
		def fget( self ):
			return self._extent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extent is mantatory and can not be set to None')
			if not check_type(value,ifcplanarextent):
				self._extent = ifcplanarextent(value)
			else:
				self._extent = value
		return property(**locals())

	@apply
	def boxalignment():
		def fget( self ):
			return self._boxalignment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument boxalignment is mantatory and can not be set to None')
			if not check_type(value,ifcboxalignment):
				self._boxalignment = ifcboxalignment(value)
			else:
				self._boxalignment = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = ( not ('IFC4.IFCPLANARBOX'  ==  TYPEOF(self.extent)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcconstraint #
####################
class ifcconstraint(BaseEntityClass):
	'''Entity ifcconstraint definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param constraintgrade
	:type constraintgrade:ifcconstraintenum

	:param constraintsource
	:type constraintsource:ifclabel

	:param creatingactor
	:type creatingactor:ifcactorselect

	:param creationtime
	:type creationtime:ifcdatetime

	:param userdefinedgrade
	:type userdefinedgrade:ifclabel

	:param hasexternalreferences
	:type hasexternalreferences:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)

	:param propertiesforconstraint
	:type propertiesforconstraint:SET(0,None,'ifcresourceconstraintrelationship', scope = schema_scope)
	'''
	def __init__( self , name,description,constraintgrade,constraintsource,creatingactor,creationtime,userdefinedgrade, ):
		self.name = name
		self.description = description
		self.constraintgrade = constraintgrade
		self.constraintsource = constraintsource
		self.creatingactor = creatingactor
		self.creationtime = creationtime
		self.userdefinedgrade = userdefinedgrade

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def constraintgrade():
		def fget( self ):
			return self._constraintgrade
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constraintgrade is mantatory and can not be set to None')
			if not check_type(value,ifcconstraintenum):
				self._constraintgrade = ifcconstraintenum(value)
			else:
				self._constraintgrade = value
		return property(**locals())

	@apply
	def constraintsource():
		def fget( self ):
			return self._constraintsource
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._constraintsource = ifclabel(value)
				else:
					self._constraintsource = value
			else:
				self._constraintsource = value
		return property(**locals())

	@apply
	def creatingactor():
		def fget( self ):
			return self._creatingactor
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._creatingactor = ifcactorselect(value)
				else:
					self._creatingactor = value
			else:
				self._creatingactor = value
		return property(**locals())

	@apply
	def creationtime():
		def fget( self ):
			return self._creationtime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._creationtime = ifcdatetime(value)
				else:
					self._creationtime = value
			else:
				self._creationtime = value
		return property(**locals())

	@apply
	def userdefinedgrade():
		def fget( self ):
			return self._userdefinedgrade
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedgrade = ifclabel(value)
				else:
					self._userdefinedgrade = value
			else:
				self._userdefinedgrade = value
		return property(**locals())

	@apply
	def hasexternalreferences():
		def fget( self ):
			return self._hasexternalreferences
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasexternalreferences is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def propertiesforconstraint():
		def fget( self ):
			return self._propertiesforconstraint
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument propertiesforconstraint is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = ((self.constraintgrade  !=  ifcconstraintenum.self.userdefined)  or  ((self.constraintgrade  ==  ifcconstraintenum.self.userdefined)  and  EXISTS(self.self.ifcconstraint.self.userdefinedgrade)))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcobjective #
####################
class ifcobjective(ifcconstraint):
	'''Entity ifcobjective definition.

	:param benchmarkvalues
	:type benchmarkvalues:LIST(1,None,'ifcconstraint', scope = schema_scope)

	:param logicalaggregator
	:type logicalaggregator:ifclogicaloperatorenum

	:param objectivequalifier
	:type objectivequalifier:ifcobjectiveenum

	:param userdefinedqualifier
	:type userdefinedqualifier:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__constraintgrade , inherited3__constraintsource , inherited4__creatingactor , inherited5__creationtime , inherited6__userdefinedgrade , benchmarkvalues,logicalaggregator,objectivequalifier,userdefinedqualifier, ):
		ifcconstraint.__init__(self , inherited0__name , inherited1__description , inherited2__constraintgrade , inherited3__constraintsource , inherited4__creatingactor , inherited5__creationtime , inherited6__userdefinedgrade , )
		self.benchmarkvalues = benchmarkvalues
		self.logicalaggregator = logicalaggregator
		self.objectivequalifier = objectivequalifier
		self.userdefinedqualifier = userdefinedqualifier

	@apply
	def benchmarkvalues():
		def fget( self ):
			return self._benchmarkvalues
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcconstraint', scope = schema_scope)):
					self._benchmarkvalues = LIST(value)
				else:
					self._benchmarkvalues = value
			else:
				self._benchmarkvalues = value
		return property(**locals())

	@apply
	def logicalaggregator():
		def fget( self ):
			return self._logicalaggregator
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclogicaloperatorenum):
					self._logicalaggregator = ifclogicaloperatorenum(value)
				else:
					self._logicalaggregator = value
			else:
				self._logicalaggregator = value
		return property(**locals())

	@apply
	def objectivequalifier():
		def fget( self ):
			return self._objectivequalifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument objectivequalifier is mantatory and can not be set to None')
			if not check_type(value,ifcobjectiveenum):
				self._objectivequalifier = ifcobjectiveenum(value)
			else:
				self._objectivequalifier = value
		return property(**locals())

	@apply
	def userdefinedqualifier():
		def fget( self ):
			return self._userdefinedqualifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedqualifier = ifclabel(value)
				else:
					self._userdefinedqualifier = value
			else:
				self._userdefinedqualifier = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = ((self.objectivequalifier  !=  ifcobjectiveenum.self.userdefined)  or  ((self.objectivequalifier  ==  ifcobjectiveenum.self.userdefined)  and  EXISTS(self.self.ifcobjective.self.userdefinedqualifier)))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcreinforcingelement #
####################
class ifcreinforcingelement(ifcelementcomponent):
	'''Entity ifcreinforcingelement definition.

	:param steelgrade
	:type steelgrade:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , steelgrade, ):
		ifcelementcomponent.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.steelgrade = steelgrade

	@apply
	def steelgrade():
		def fget( self ):
			return self._steelgrade
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._steelgrade = ifclabel(value)
				else:
					self._steelgrade = value
			else:
				self._steelgrade = value
		return property(**locals())

####################
 # ENTITY ifcreinforcingmesh #
####################
class ifcreinforcingmesh(ifcreinforcingelement):
	'''Entity ifcreinforcingmesh definition.

	:param meshlength
	:type meshlength:ifcpositivelengthmeasure

	:param meshwidth
	:type meshwidth:ifcpositivelengthmeasure

	:param longitudinalbarnominaldiameter
	:type longitudinalbarnominaldiameter:ifcpositivelengthmeasure

	:param transversebarnominaldiameter
	:type transversebarnominaldiameter:ifcpositivelengthmeasure

	:param longitudinalbarcrosssectionarea
	:type longitudinalbarcrosssectionarea:ifcareameasure

	:param transversebarcrosssectionarea
	:type transversebarcrosssectionarea:ifcareameasure

	:param longitudinalbarspacing
	:type longitudinalbarspacing:ifcpositivelengthmeasure

	:param transversebarspacing
	:type transversebarspacing:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcreinforcingmeshtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , meshlength,meshwidth,longitudinalbarnominaldiameter,transversebarnominaldiameter,longitudinalbarcrosssectionarea,transversebarcrosssectionarea,longitudinalbarspacing,transversebarspacing,predefinedtype, ):
		ifcreinforcingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , )
		self.meshlength = meshlength
		self.meshwidth = meshwidth
		self.longitudinalbarnominaldiameter = longitudinalbarnominaldiameter
		self.transversebarnominaldiameter = transversebarnominaldiameter
		self.longitudinalbarcrosssectionarea = longitudinalbarcrosssectionarea
		self.transversebarcrosssectionarea = transversebarcrosssectionarea
		self.longitudinalbarspacing = longitudinalbarspacing
		self.transversebarspacing = transversebarspacing
		self.predefinedtype = predefinedtype

	@apply
	def meshlength():
		def fget( self ):
			return self._meshlength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._meshlength = ifcpositivelengthmeasure(value)
				else:
					self._meshlength = value
			else:
				self._meshlength = value
		return property(**locals())

	@apply
	def meshwidth():
		def fget( self ):
			return self._meshwidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._meshwidth = ifcpositivelengthmeasure(value)
				else:
					self._meshwidth = value
			else:
				self._meshwidth = value
		return property(**locals())

	@apply
	def longitudinalbarnominaldiameter():
		def fget( self ):
			return self._longitudinalbarnominaldiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._longitudinalbarnominaldiameter = ifcpositivelengthmeasure(value)
				else:
					self._longitudinalbarnominaldiameter = value
			else:
				self._longitudinalbarnominaldiameter = value
		return property(**locals())

	@apply
	def transversebarnominaldiameter():
		def fget( self ):
			return self._transversebarnominaldiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._transversebarnominaldiameter = ifcpositivelengthmeasure(value)
				else:
					self._transversebarnominaldiameter = value
			else:
				self._transversebarnominaldiameter = value
		return property(**locals())

	@apply
	def longitudinalbarcrosssectionarea():
		def fget( self ):
			return self._longitudinalbarcrosssectionarea
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._longitudinalbarcrosssectionarea = ifcareameasure(value)
				else:
					self._longitudinalbarcrosssectionarea = value
			else:
				self._longitudinalbarcrosssectionarea = value
		return property(**locals())

	@apply
	def transversebarcrosssectionarea():
		def fget( self ):
			return self._transversebarcrosssectionarea
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._transversebarcrosssectionarea = ifcareameasure(value)
				else:
					self._transversebarcrosssectionarea = value
			else:
				self._transversebarcrosssectionarea = value
		return property(**locals())

	@apply
	def longitudinalbarspacing():
		def fget( self ):
			return self._longitudinalbarspacing
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._longitudinalbarspacing = ifcpositivelengthmeasure(value)
				else:
					self._longitudinalbarspacing = value
			else:
				self._longitudinalbarspacing = value
		return property(**locals())

	@apply
	def transversebarspacing():
		def fget( self ):
			return self._transversebarspacing
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._transversebarspacing = ifcpositivelengthmeasure(value)
				else:
					self._transversebarspacing = value
			else:
				self._transversebarspacing = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreinforcingmeshtypeenum):
					self._predefinedtype = ifcreinforcingmeshtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcreinforcingmeshtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcreinforcingmeshtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCREINFORCINGMESHTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifctubebundletype #
####################
class ifctubebundletype(ifcenergyconversiondevicetype):
	'''Entity ifctubebundletype definition.

	:param predefinedtype
	:type predefinedtype:ifctubebundletypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctubebundletypeenum):
				self._predefinedtype = ifctubebundletypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifctubebundletypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifctubebundletypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcdoorliningproperties #
####################
class ifcdoorliningproperties(ifcpredefinedpropertyset):
	'''Entity ifcdoorliningproperties definition.

	:param liningdepth
	:type liningdepth:ifcpositivelengthmeasure

	:param liningthickness
	:type liningthickness:ifcnonnegativelengthmeasure

	:param thresholddepth
	:type thresholddepth:ifcpositivelengthmeasure

	:param thresholdthickness
	:type thresholdthickness:ifcnonnegativelengthmeasure

	:param transomthickness
	:type transomthickness:ifcnonnegativelengthmeasure

	:param transomoffset
	:type transomoffset:ifclengthmeasure

	:param liningoffset
	:type liningoffset:ifclengthmeasure

	:param thresholdoffset
	:type thresholdoffset:ifclengthmeasure

	:param casingthickness
	:type casingthickness:ifcpositivelengthmeasure

	:param casingdepth
	:type casingdepth:ifcpositivelengthmeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect

	:param liningtopaneloffsetx
	:type liningtopaneloffsetx:ifclengthmeasure

	:param liningtopaneloffsety
	:type liningtopaneloffsety:ifclengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , liningdepth,liningthickness,thresholddepth,thresholdthickness,transomthickness,transomoffset,liningoffset,thresholdoffset,casingthickness,casingdepth,shapeaspectstyle,liningtopaneloffsetx,liningtopaneloffsety, ):
		ifcpredefinedpropertyset.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.liningdepth = liningdepth
		self.liningthickness = liningthickness
		self.thresholddepth = thresholddepth
		self.thresholdthickness = thresholdthickness
		self.transomthickness = transomthickness
		self.transomoffset = transomoffset
		self.liningoffset = liningoffset
		self.thresholdoffset = thresholdoffset
		self.casingthickness = casingthickness
		self.casingdepth = casingdepth
		self.shapeaspectstyle = shapeaspectstyle
		self.liningtopaneloffsetx = liningtopaneloffsetx
		self.liningtopaneloffsety = liningtopaneloffsety

	@apply
	def liningdepth():
		def fget( self ):
			return self._liningdepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._liningdepth = ifcpositivelengthmeasure(value)
				else:
					self._liningdepth = value
			else:
				self._liningdepth = value
		return property(**locals())

	@apply
	def liningthickness():
		def fget( self ):
			return self._liningthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._liningthickness = ifcnonnegativelengthmeasure(value)
				else:
					self._liningthickness = value
			else:
				self._liningthickness = value
		return property(**locals())

	@apply
	def thresholddepth():
		def fget( self ):
			return self._thresholddepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._thresholddepth = ifcpositivelengthmeasure(value)
				else:
					self._thresholddepth = value
			else:
				self._thresholddepth = value
		return property(**locals())

	@apply
	def thresholdthickness():
		def fget( self ):
			return self._thresholdthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._thresholdthickness = ifcnonnegativelengthmeasure(value)
				else:
					self._thresholdthickness = value
			else:
				self._thresholdthickness = value
		return property(**locals())

	@apply
	def transomthickness():
		def fget( self ):
			return self._transomthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._transomthickness = ifcnonnegativelengthmeasure(value)
				else:
					self._transomthickness = value
			else:
				self._transomthickness = value
		return property(**locals())

	@apply
	def transomoffset():
		def fget( self ):
			return self._transomoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._transomoffset = ifclengthmeasure(value)
				else:
					self._transomoffset = value
			else:
				self._transomoffset = value
		return property(**locals())

	@apply
	def liningoffset():
		def fget( self ):
			return self._liningoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._liningoffset = ifclengthmeasure(value)
				else:
					self._liningoffset = value
			else:
				self._liningoffset = value
		return property(**locals())

	@apply
	def thresholdoffset():
		def fget( self ):
			return self._thresholdoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._thresholdoffset = ifclengthmeasure(value)
				else:
					self._thresholdoffset = value
			else:
				self._thresholdoffset = value
		return property(**locals())

	@apply
	def casingthickness():
		def fget( self ):
			return self._casingthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._casingthickness = ifcpositivelengthmeasure(value)
				else:
					self._casingthickness = value
			else:
				self._casingthickness = value
		return property(**locals())

	@apply
	def casingdepth():
		def fget( self ):
			return self._casingdepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._casingdepth = ifcpositivelengthmeasure(value)
				else:
					self._casingdepth = value
			else:
				self._casingdepth = value
		return property(**locals())

	@apply
	def shapeaspectstyle():
		def fget( self ):
			return self._shapeaspectstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshapeaspect):
					self._shapeaspectstyle = ifcshapeaspect(value)
				else:
					self._shapeaspectstyle = value
			else:
				self._shapeaspectstyle = value
		return property(**locals())

	@apply
	def liningtopaneloffsetx():
		def fget( self ):
			return self._liningtopaneloffsetx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._liningtopaneloffsetx = ifclengthmeasure(value)
				else:
					self._liningtopaneloffsetx = value
			else:
				self._liningtopaneloffsetx = value
		return property(**locals())

	@apply
	def liningtopaneloffsety():
		def fget( self ):
			return self._liningtopaneloffsety
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._liningtopaneloffsety = ifclengthmeasure(value)
				else:
					self._liningtopaneloffsety = value
			else:
				self._liningtopaneloffsety = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = ( not (EXISTS(self.liningdepth)  and  ( not EXISTS(self.liningthickness))))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = ( not (EXISTS(self.thresholddepth)  and  ( not EXISTS(self.thresholdthickness))))
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr

	def wr33(self):
		eval_wr33_wr = ((EXISTS(self.transomoffset)  and  EXISTS(self.transomthickness)) XOR (( not EXISTS(self.transomoffset))  and  ( not EXISTS(self.transomthickness))))
		if not eval_wr33_wr:
			raise AssertionError('Rule wr33 violated')
		else:
			return eval_wr33_wr

	def wr34(self):
		eval_wr34_wr = ((EXISTS(self.casingdepth)  and  EXISTS(self.casingthickness)) XOR (( not EXISTS(self.casingdepth))  and  ( not EXISTS(self.casingthickness))))
		if not eval_wr34_wr:
			raise AssertionError('Rule wr34 violated')
		else:
			return eval_wr34_wr

	def wr35(self):
		eval_wr35_wr = (EXISTS(self.self.ifcpropertysetdefinition.self.definestype[1])  and  (('IFC4.IFCDOORTYPE'  ==  TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))  or  ('IFC4.IFCDOORSTYLE'  ==  TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))))
		if not eval_wr35_wr:
			raise AssertionError('Rule wr35 violated')
		else:
			return eval_wr35_wr


####################
 # ENTITY ifcstructuralmember #
####################
class ifcstructuralmember(ifcstructuralitem):
	'''Entity ifcstructuralmember definition.

	:param connectedby
	:type connectedby:SET(0,None,'ifcrelconnectsstructuralmember', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation ,  ):
		ifcstructuralitem.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )

	@apply
	def connectedby():
		def fget( self ):
			return self._connectedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstructuralsurfacemember #
####################
class ifcstructuralsurfacemember(ifcstructuralmember):
	'''Entity ifcstructuralsurfacemember definition.

	:param predefinedtype
	:type predefinedtype:ifcstructuralsurfacemembertypeenum

	:param thickness
	:type thickness:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , predefinedtype,thickness, ):
		ifcstructuralmember.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.predefinedtype = predefinedtype
		self.thickness = thickness

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralsurfacemembertypeenum):
				self._predefinedtype = ifcstructuralsurfacemembertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def thickness():
		def fget( self ):
			return self._thickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._thickness = ifcpositivelengthmeasure(value)
				else:
					self._thickness = value
			else:
				self._thickness = value
		return property(**locals())
	def hasobjecttype(self):
		eval_hasobjecttype_wr = ((self.predefinedtype  !=  ifcstructuralsurfacemembertypeenum.self.userdefined)  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_hasobjecttype_wr:
			raise AssertionError('Rule hasobjecttype violated')
		else:
			return eval_hasobjecttype_wr


####################
 # ENTITY ifcedgecurve #
####################
class ifcedgecurve(ifcedge):
	'''Entity ifcedgecurve definition.

	:param edgegeometry
	:type edgegeometry:ifccurve

	:param samesense
	:type samesense:BOOLEAN
	'''
	def __init__( self , inherited0__edgestart , inherited1__edgeend , edgegeometry,samesense, ):
		ifcedge.__init__(self , inherited0__edgestart , inherited1__edgeend , )
		self.edgegeometry = edgegeometry
		self.samesense = samesense

	@apply
	def edgegeometry():
		def fget( self ):
			return self._edgegeometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgegeometry is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._edgegeometry = ifccurve(value)
			else:
				self._edgegeometry = value
		return property(**locals())

	@apply
	def samesense():
		def fget( self ):
			return self._samesense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument samesense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._samesense = BOOLEAN(value)
			else:
				self._samesense = value
		return property(**locals())

####################
 # ENTITY ifclightfixturetype #
####################
class ifclightfixturetype(ifcflowterminaltype):
	'''Entity ifclightfixturetype definition.

	:param predefinedtype
	:type predefinedtype:ifclightfixturetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifclightfixturetypeenum):
				self._predefinedtype = ifclightfixturetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifclightfixturetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifclightfixturetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcline #
####################
class ifcline(ifccurve):
	'''Entity ifcline definition.

	:param pnt
	:type pnt:ifccartesianpoint

	:param dir
	:type dir:ifcvector
	'''
	def __init__( self , pnt,dir, ):
		ifccurve.__init__(self , )
		self.pnt = pnt
		self.dir = dir

	@apply
	def pnt():
		def fget( self ):
			return self._pnt
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pnt is mantatory and can not be set to None')
			if not check_type(value,ifccartesianpoint):
				self._pnt = ifccartesianpoint(value)
			else:
				self._pnt = value
		return property(**locals())

	@apply
	def dir():
		def fget( self ):
			return self._dir
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dir is mantatory and can not be set to None')
			if not check_type(value,ifcvector):
				self._dir = ifcvector(value)
			else:
				self._dir = value
		return property(**locals())
	def samedim(self):
		eval_samedim_wr = (self.dir.self.dim  ==  self.pnt.self.dim)
		if not eval_samedim_wr:
			raise AssertionError('Rule samedim violated')
		else:
			return eval_samedim_wr


####################
 # ENTITY ifcalarm #
####################
class ifcalarm(ifcdistributioncontrolelement):
	'''Entity ifcalarm definition.

	:param predefinedtype
	:type predefinedtype:ifcalarmtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcdistributioncontrolelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcalarmtypeenum):
					self._predefinedtype = ifcalarmtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcalarmtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcalarmtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCALARMTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcconic #
####################
class ifcconic(ifccurve):
	'''Entity ifcconic definition.

	:param position
	:type position:ifcaxis2placement
	'''
	def __init__( self , position, ):
		ifccurve.__init__(self , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._position = ifcaxis2placement(value)
			else:
				self._position = value
		return property(**locals())

####################
 # ENTITY ifcrelconnectsporttoelement #
####################
class ifcrelconnectsporttoelement(ifcrelconnects):
	'''Entity ifcrelconnectsporttoelement definition.

	:param relatingport
	:type relatingport:ifcport

	:param relatedelement
	:type relatedelement:ifcdistributionelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingport,relatedelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingport = relatingport
		self.relatedelement = relatedelement

	@apply
	def relatingport():
		def fget( self ):
			return self._relatingport
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingport is mantatory and can not be set to None')
			if not check_type(value,ifcport):
				self._relatingport = ifcport(value)
			else:
				self._relatingport = value
		return property(**locals())

	@apply
	def relatedelement():
		def fget( self ):
			return self._relatedelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedelement is mantatory and can not be set to None')
			if not check_type(value,ifcdistributionelement):
				self._relatedelement = ifcdistributionelement(value)
			else:
				self._relatedelement = value
		return property(**locals())

####################
 # ENTITY ifcflowmetertype #
####################
class ifcflowmetertype(ifcflowcontrollertype):
	'''Entity ifcflowmetertype definition.

	:param predefinedtype
	:type predefinedtype:ifcflowmetertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcflowmetertypeenum):
				self._predefinedtype = ifcflowmetertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcflowmetertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcflowmetertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcquantityarea #
####################
class ifcquantityarea(ifcphysicalsimplequantity):
	'''Entity ifcquantityarea definition.

	:param areavalue
	:type areavalue:ifcareameasure

	:param formula
	:type formula:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , areavalue,formula, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.areavalue = areavalue
		self.formula = formula

	@apply
	def areavalue():
		def fget( self ):
			return self._areavalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument areavalue is mantatory and can not be set to None')
			if not check_type(value,ifcareameasure):
				self._areavalue = ifcareameasure(value)
			else:
				self._areavalue = value
		return property(**locals())

	@apply
	def formula():
		def fget( self ):
			return self._formula
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._formula = ifclabel(value)
				else:
					self._formula = value
			else:
				self._formula = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.self.ifcphysicalsimplequantity.self.unit))  or  (self.self.ifcphysicalsimplequantity.self.unit.self.unittype  ==  ifcunitenum.self.areaunit))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.areavalue  >=  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcrelassignstocontrol #
####################
class ifcrelassignstocontrol(ifcrelassigns):
	'''Entity ifcrelassignstocontrol definition.

	:param relatingcontrol
	:type relatingcontrol:ifccontrol
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatingcontrol, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatingcontrol = relatingcontrol

	@apply
	def relatingcontrol():
		def fget( self ):
			return self._relatingcontrol
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingcontrol is mantatory and can not be set to None')
			if not check_type(value,ifccontrol):
				self._relatingcontrol = ifccontrol(value)
			else:
				self._relatingcontrol = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (SIZEOF(None)  ==  0)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifcworkcontrol #
####################
class ifcworkcontrol(ifccontrol):
	'''Entity ifcworkcontrol definition.

	:param creationdate
	:type creationdate:ifcdatetime

	:param creators
	:type creators:SET(1,None,'ifcperson', scope = schema_scope)

	:param purpose
	:type purpose:ifclabel

	:param duration
	:type duration:ifcduration

	:param totalfloat
	:type totalfloat:ifcduration

	:param starttime
	:type starttime:ifcdatetime

	:param finishtime
	:type finishtime:ifcdatetime
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , creationdate,creators,purpose,duration,totalfloat,starttime,finishtime, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , )
		self.creationdate = creationdate
		self.creators = creators
		self.purpose = purpose
		self.duration = duration
		self.totalfloat = totalfloat
		self.starttime = starttime
		self.finishtime = finishtime

	@apply
	def creationdate():
		def fget( self ):
			return self._creationdate
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument creationdate is mantatory and can not be set to None')
			if not check_type(value,ifcdatetime):
				self._creationdate = ifcdatetime(value)
			else:
				self._creationdate = value
		return property(**locals())

	@apply
	def creators():
		def fget( self ):
			return self._creators
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcperson', scope = schema_scope)):
					self._creators = SET(value)
				else:
					self._creators = value
			else:
				self._creators = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._purpose = ifclabel(value)
				else:
					self._purpose = value
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def duration():
		def fget( self ):
			return self._duration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcduration):
					self._duration = ifcduration(value)
				else:
					self._duration = value
			else:
				self._duration = value
		return property(**locals())

	@apply
	def totalfloat():
		def fget( self ):
			return self._totalfloat
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcduration):
					self._totalfloat = ifcduration(value)
				else:
					self._totalfloat = value
			else:
				self._totalfloat = value
		return property(**locals())

	@apply
	def starttime():
		def fget( self ):
			return self._starttime
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument starttime is mantatory and can not be set to None')
			if not check_type(value,ifcdatetime):
				self._starttime = ifcdatetime(value)
			else:
				self._starttime = value
		return property(**locals())

	@apply
	def finishtime():
		def fget( self ):
			return self._finishtime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._finishtime = ifcdatetime(value)
				else:
					self._finishtime = value
			else:
				self._finishtime = value
		return property(**locals())

####################
 # ENTITY ifcworkplan #
####################
class ifcworkplan(ifcworkcontrol):
	'''Entity ifcworkplan definition.

	:param predefinedtype
	:type predefinedtype:ifcworkplantypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__creationdate , inherited7__creators , inherited8__purpose , inherited9__duration , inherited10__totalfloat , inherited11__starttime , inherited12__finishtime , predefinedtype, ):
		ifcworkcontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__creationdate , inherited7__creators , inherited8__purpose , inherited9__duration , inherited10__totalfloat , inherited11__starttime , inherited12__finishtime , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcworkplantypeenum):
					self._predefinedtype = ifcworkplantypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcworkplantypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcworkplantypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcpropertydependencyrelationship #
####################
class ifcpropertydependencyrelationship(ifcresourcelevelrelationship):
	'''Entity ifcpropertydependencyrelationship definition.

	:param dependingproperty
	:type dependingproperty:ifcproperty

	:param dependantproperty
	:type dependantproperty:ifcproperty

	:param expression
	:type expression:ifctext
	'''
	def __init__( self , inherited0__name , inherited1__description , dependingproperty,dependantproperty,expression, ):
		ifcresourcelevelrelationship.__init__(self , inherited0__name , inherited1__description , )
		self.dependingproperty = dependingproperty
		self.dependantproperty = dependantproperty
		self.expression = expression

	@apply
	def dependingproperty():
		def fget( self ):
			return self._dependingproperty
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dependingproperty is mantatory and can not be set to None')
			if not check_type(value,ifcproperty):
				self._dependingproperty = ifcproperty(value)
			else:
				self._dependingproperty = value
		return property(**locals())

	@apply
	def dependantproperty():
		def fget( self ):
			return self._dependantproperty
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dependantproperty is mantatory and can not be set to None')
			if not check_type(value,ifcproperty):
				self._dependantproperty = ifcproperty(value)
			else:
				self._dependantproperty = value
		return property(**locals())

	@apply
	def expression():
		def fget( self ):
			return self._expression
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._expression = ifctext(value)
				else:
					self._expression = value
			else:
				self._expression = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (self.dependingproperty  !=  self.dependantproperty)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifcprotectivedevice #
####################
class ifcprotectivedevice(ifcflowcontroller):
	'''Entity ifcprotectivedevice definition.

	:param predefinedtype
	:type predefinedtype:ifcprotectivedevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowcontroller.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcprotectivedevicetypeenum):
					self._predefinedtype = ifcprotectivedevicetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcprotectivedevicetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcprotectivedevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCPROTECTIVEDEVICETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcappliedvalue #
####################
class ifcappliedvalue(BaseEntityClass):
	'''Entity ifcappliedvalue definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param appliedvalue
	:type appliedvalue:ifcappliedvalueselect

	:param unitbasis
	:type unitbasis:ifcmeasurewithunit

	:param applicabledate
	:type applicabledate:ifcdate

	:param fixeduntildate
	:type fixeduntildate:ifcdate

	:param category
	:type category:ifclabel

	:param condition
	:type condition:ifclabel

	:param arithmeticoperator
	:type arithmeticoperator:ifcarithmeticoperatorenum

	:param components
	:type components:LIST(1,None,'ifcappliedvalue', scope = schema_scope)

	:param hasexternalreference
	:type hasexternalreference:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''
	def __init__( self , name,description,appliedvalue,unitbasis,applicabledate,fixeduntildate,category,condition,arithmeticoperator,components, ):
		self.name = name
		self.description = description
		self.appliedvalue = appliedvalue
		self.unitbasis = unitbasis
		self.applicabledate = applicabledate
		self.fixeduntildate = fixeduntildate
		self.category = category
		self.condition = condition
		self.arithmeticoperator = arithmeticoperator
		self.components = components

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def appliedvalue():
		def fget( self ):
			return self._appliedvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcappliedvalueselect):
					self._appliedvalue = ifcappliedvalueselect(value)
				else:
					self._appliedvalue = value
			else:
				self._appliedvalue = value
		return property(**locals())

	@apply
	def unitbasis():
		def fget( self ):
			return self._unitbasis
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmeasurewithunit):
					self._unitbasis = ifcmeasurewithunit(value)
				else:
					self._unitbasis = value
			else:
				self._unitbasis = value
		return property(**locals())

	@apply
	def applicabledate():
		def fget( self ):
			return self._applicabledate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdate):
					self._applicabledate = ifcdate(value)
				else:
					self._applicabledate = value
			else:
				self._applicabledate = value
		return property(**locals())

	@apply
	def fixeduntildate():
		def fget( self ):
			return self._fixeduntildate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdate):
					self._fixeduntildate = ifcdate(value)
				else:
					self._fixeduntildate = value
			else:
				self._fixeduntildate = value
		return property(**locals())

	@apply
	def category():
		def fget( self ):
			return self._category
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._category = ifclabel(value)
				else:
					self._category = value
			else:
				self._category = value
		return property(**locals())

	@apply
	def condition():
		def fget( self ):
			return self._condition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._condition = ifclabel(value)
				else:
					self._condition = value
			else:
				self._condition = value
		return property(**locals())

	@apply
	def arithmeticoperator():
		def fget( self ):
			return self._arithmeticoperator
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcarithmeticoperatorenum):
					self._arithmeticoperator = ifcarithmeticoperatorenum(value)
				else:
					self._arithmeticoperator = value
			else:
				self._arithmeticoperator = value
		return property(**locals())

	@apply
	def components():
		def fget( self ):
			return self._components
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcappliedvalue', scope = schema_scope)):
					self._components = LIST(value)
				else:
					self._components = value
			else:
				self._components = value
		return property(**locals())

	@apply
	def hasexternalreference():
		def fget( self ):
			return self._hasexternalreference
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcfillareastylehatching #
####################
class ifcfillareastylehatching(ifcgeometricrepresentationitem):
	'''Entity ifcfillareastylehatching definition.

	:param hatchlineappearance
	:type hatchlineappearance:ifccurvestyle

	:param startofnexthatchline
	:type startofnexthatchline:ifchatchlinedistanceselect

	:param pointofreferencehatchline
	:type pointofreferencehatchline:ifccartesianpoint

	:param patternstart
	:type patternstart:ifccartesianpoint

	:param hatchlineangle
	:type hatchlineangle:ifcplaneanglemeasure
	'''
	def __init__( self , hatchlineappearance,startofnexthatchline,pointofreferencehatchline,patternstart,hatchlineangle, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.hatchlineappearance = hatchlineappearance
		self.startofnexthatchline = startofnexthatchline
		self.pointofreferencehatchline = pointofreferencehatchline
		self.patternstart = patternstart
		self.hatchlineangle = hatchlineangle

	@apply
	def hatchlineappearance():
		def fget( self ):
			return self._hatchlineappearance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hatchlineappearance is mantatory and can not be set to None')
			if not check_type(value,ifccurvestyle):
				self._hatchlineappearance = ifccurvestyle(value)
			else:
				self._hatchlineappearance = value
		return property(**locals())

	@apply
	def startofnexthatchline():
		def fget( self ):
			return self._startofnexthatchline
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument startofnexthatchline is mantatory and can not be set to None')
			if not check_type(value,ifchatchlinedistanceselect):
				self._startofnexthatchline = ifchatchlinedistanceselect(value)
			else:
				self._startofnexthatchline = value
		return property(**locals())

	@apply
	def pointofreferencehatchline():
		def fget( self ):
			return self._pointofreferencehatchline
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccartesianpoint):
					self._pointofreferencehatchline = ifccartesianpoint(value)
				else:
					self._pointofreferencehatchline = value
			else:
				self._pointofreferencehatchline = value
		return property(**locals())

	@apply
	def patternstart():
		def fget( self ):
			return self._patternstart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccartesianpoint):
					self._patternstart = ifccartesianpoint(value)
				else:
					self._patternstart = value
			else:
				self._patternstart = value
		return property(**locals())

	@apply
	def hatchlineangle():
		def fget( self ):
			return self._hatchlineangle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hatchlineangle is mantatory and can not be set to None')
			if not check_type(value,ifcplaneanglemeasure):
				self._hatchlineangle = ifcplaneanglemeasure(value)
			else:
				self._hatchlineangle = value
		return property(**locals())
	def patternstart2d(self):
		eval_patternstart2d_wr = (( not EXISTS(self.patternstart))  or  (self.patternstart.self.dim  ==  2))
		if not eval_patternstart2d_wr:
			raise AssertionError('Rule patternstart2d violated')
		else:
			return eval_patternstart2d_wr

	def refhatchline2d(self):
		eval_refhatchline2d_wr = (( not EXISTS(self.pointofreferencehatchline))  or  (self.pointofreferencehatchline.self.dim  ==  2))
		if not eval_refhatchline2d_wr:
			raise AssertionError('Rule refhatchline2d violated')
		else:
			return eval_refhatchline2d_wr


####################
 # ENTITY ifcheatexchangertype #
####################
class ifcheatexchangertype(ifcenergyconversiondevicetype):
	'''Entity ifcheatexchangertype definition.

	:param predefinedtype
	:type predefinedtype:ifcheatexchangertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcheatexchangertypeenum):
				self._predefinedtype = ifcheatexchangertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcheatexchangertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcheatexchangertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcmateriallayer #
####################
class ifcmateriallayer(ifcmaterialdefinition):
	'''Entity ifcmateriallayer definition.

	:param material
	:type material:ifcmaterial

	:param layerthickness
	:type layerthickness:ifcnonnegativelengthmeasure

	:param isventilated
	:type isventilated:ifclogical

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param category
	:type category:ifclabel

	:param priority
	:type priority:ifcnormalisedratiomeasure

	:param tomateriallayerset
	:type tomateriallayerset:ifcmateriallayerset
	'''
	def __init__( self , material,layerthickness,isventilated,name,description,category,priority, ):
		ifcmaterialdefinition.__init__(self , )
		self.material = material
		self.layerthickness = layerthickness
		self.isventilated = isventilated
		self.name = name
		self.description = description
		self.category = category
		self.priority = priority

	@apply
	def material():
		def fget( self ):
			return self._material
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmaterial):
					self._material = ifcmaterial(value)
				else:
					self._material = value
			else:
				self._material = value
		return property(**locals())

	@apply
	def layerthickness():
		def fget( self ):
			return self._layerthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layerthickness is mantatory and can not be set to None')
			if not check_type(value,ifcnonnegativelengthmeasure):
				self._layerthickness = ifcnonnegativelengthmeasure(value)
			else:
				self._layerthickness = value
		return property(**locals())

	@apply
	def isventilated():
		def fget( self ):
			return self._isventilated
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclogical):
					self._isventilated = ifclogical(value)
				else:
					self._isventilated = value
			else:
				self._isventilated = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def category():
		def fget( self ):
			return self._category
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._category = ifclabel(value)
				else:
					self._category = value
			else:
				self._category = value
		return property(**locals())

	@apply
	def priority():
		def fget( self ):
			return self._priority
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._priority = ifcnormalisedratiomeasure(value)
				else:
					self._priority = value
			else:
				self._priority = value
		return property(**locals())

	@apply
	def tomateriallayerset():
		def fget( self ):
			return self._tomateriallayerset
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument tomateriallayerset is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcmateriallayerwithoffsets #
####################
class ifcmateriallayerwithoffsets(ifcmateriallayer):
	'''Entity ifcmateriallayerwithoffsets definition.

	:param offsetdirection
	:type offsetdirection:ifclayersetdirectionenum

	:param offsetvalues
	:type offsetvalues:ARRAY(1,2,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__material , inherited1__layerthickness , inherited2__isventilated , inherited3__name , inherited4__description , inherited5__category , inherited6__priority , offsetdirection,offsetvalues, ):
		ifcmateriallayer.__init__(self , inherited0__material , inherited1__layerthickness , inherited2__isventilated , inherited3__name , inherited4__description , inherited5__category , inherited6__priority , )
		self.offsetdirection = offsetdirection
		self.offsetvalues = offsetvalues

	@apply
	def offsetdirection():
		def fget( self ):
			return self._offsetdirection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offsetdirection is mantatory and can not be set to None')
			if not check_type(value,ifclayersetdirectionenum):
				self._offsetdirection = ifclayersetdirectionenum(value)
			else:
				self._offsetdirection = value
		return property(**locals())

	@apply
	def offsetvalues():
		def fget( self ):
			return self._offsetvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offsetvalues is mantatory and can not be set to None')
			if not check_type(value,ARRAY(1,2,'REAL', scope = schema_scope)):
				self._offsetvalues = ARRAY(value)
			else:
				self._offsetvalues = value
		return property(**locals())

####################
 # ENTITY ifcextendedproperties #
####################
class ifcextendedproperties(ifcpropertyabstraction):
	'''Entity ifcextendedproperties definition.

	:param name
	:type name:ifcidentifier

	:param description
	:type description:ifctext

	:param properties
	:type properties:SET(1,None,'ifcproperty', scope = schema_scope)
	'''
	def __init__( self , name,description,properties, ):
		ifcpropertyabstraction.__init__(self , )
		self.name = name
		self.description = description
		self.properties = properties

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._name = ifcidentifier(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def properties():
		def fget( self ):
			return self._properties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument properties is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproperty', scope = schema_scope)):
				self._properties = SET(value)
			else:
				self._properties = value
		return property(**locals())

####################
 # ENTITY ifcmaterialproperties #
####################
class ifcmaterialproperties(ifcextendedproperties):
	'''Entity ifcmaterialproperties definition.

	:param material
	:type material:ifcmaterialdefinition
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__properties , material, ):
		ifcextendedproperties.__init__(self , inherited0__name , inherited1__description , inherited2__properties , )
		self.material = material

	@apply
	def material():
		def fget( self ):
			return self._material
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument material is mantatory and can not be set to None')
			if not check_type(value,ifcmaterialdefinition):
				self._material = ifcmaterialdefinition(value)
			else:
				self._material = value
		return property(**locals())

####################
 # ENTITY ifcpolygonalboundedhalfspace #
####################
class ifcpolygonalboundedhalfspace(ifchalfspacesolid):
	'''Entity ifcpolygonalboundedhalfspace definition.

	:param position
	:type position:ifcaxis2placement3d

	:param polygonalboundary
	:type polygonalboundary:ifcboundedcurve
	'''
	def __init__( self , inherited0__basesurface , inherited1__agreementflag , position,polygonalboundary, ):
		ifchalfspacesolid.__init__(self , inherited0__basesurface , inherited1__agreementflag , )
		self.position = position
		self.polygonalboundary = polygonalboundary

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement3d):
				self._position = ifcaxis2placement3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def polygonalboundary():
		def fget( self ):
			return self._polygonalboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument polygonalboundary is mantatory and can not be set to None')
			if not check_type(value,ifcboundedcurve):
				self._polygonalboundary = ifcboundedcurve(value)
			else:
				self._polygonalboundary = value
		return property(**locals())
	def boundarydim(self):
		eval_boundarydim_wr = (self.polygonalboundary.self.dim  ==  2)
		if not eval_boundarydim_wr:
			raise AssertionError('Rule boundarydim violated')
		else:
			return eval_boundarydim_wr

	def boundarytype(self):
		eval_boundarytype_wr = (SIZEOF(TYPEOF(self.polygonalboundary)  *  ['IFC4.IFCPOLYLINE','IFC4.IFCCOMPOSITECURVE'])  ==  1)
		if not eval_boundarytype_wr:
			raise AssertionError('Rule boundarytype violated')
		else:
			return eval_boundarytype_wr


####################
 # ENTITY ifcshadingdevicetype #
####################
class ifcshadingdevicetype(ifcbuildingelementtype):
	'''Entity ifcshadingdevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcshadingdevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcshadingdevicetypeenum):
				self._predefinedtype = ifcshadingdevicetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcshadingdevicetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcshadingdevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifccommunicationsappliance #
####################
class ifccommunicationsappliance(ifcflowterminal):
	'''Entity ifccommunicationsappliance definition.

	:param predefinedtype
	:type predefinedtype:ifccommunicationsappliancetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccommunicationsappliancetypeenum):
					self._predefinedtype = ifccommunicationsappliancetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccommunicationsappliancetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccommunicationsappliancetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCOMMUNICATIONSAPPLIANCETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcflowmovingdevice #
####################
class ifcflowmovingdevice(ifcdistributionflowelement):
	'''Entity ifcflowmovingdevice definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifccompressor #
####################
class ifccompressor(ifcflowmovingdevice):
	'''Entity ifccompressor definition.

	:param predefinedtype
	:type predefinedtype:ifccompressortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowmovingdevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccompressortypeenum):
					self._predefinedtype = ifccompressortypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccompressortypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccompressortypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCOMPRESSORTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifccondensertype #
####################
class ifccondensertype(ifcenergyconversiondevicetype):
	'''Entity ifccondensertype definition.

	:param predefinedtype
	:type predefinedtype:ifccondensertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccondensertypeenum):
				self._predefinedtype = ifccondensertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccondensertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccondensertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcheatexchanger #
####################
class ifcheatexchanger(ifcenergyconversiondevice):
	'''Entity ifcheatexchanger definition.

	:param predefinedtype
	:type predefinedtype:ifcheatexchangertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcheatexchangertypeenum):
					self._predefinedtype = ifcheatexchangertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcheatexchangertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcheatexchangertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCHEATEXCHANGERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcslab #
####################
class ifcslab(ifcbuildingelement):
	'''Entity ifcslab definition.

	:param predefinedtype
	:type predefinedtype:ifcslabtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcslabtypeenum):
					self._predefinedtype = ifcslabtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcslabtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcslabtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSLABTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcconstructionmaterialresourcetype #
####################
class ifcconstructionmaterialresourcetype(ifcconstructionresourcetype):
	'''Entity ifcconstructionmaterialresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionmaterialresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , predefinedtype, ):
		ifcconstructionresourcetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcconstructionmaterialresourcetypeenum):
				self._predefinedtype = ifcconstructionmaterialresourcetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcconstructionmaterialresourcetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcconstructionmaterialresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifctyperesource.self.resourcetype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifccoolingtowertype #
####################
class ifccoolingtowertype(ifcenergyconversiondevicetype):
	'''Entity ifccoolingtowertype definition.

	:param predefinedtype
	:type predefinedtype:ifccoolingtowertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccoolingtowertypeenum):
				self._predefinedtype = ifccoolingtowertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccoolingtowertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccoolingtowertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcclassification #
####################
class ifcclassification(ifcexternalinformation):
	'''Entity ifcclassification definition.

	:param source
	:type source:ifclabel

	:param edition
	:type edition:ifclabel

	:param editiondate
	:type editiondate:ifcdate

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param location
	:type location:ifcurireference

	:param referencetokens
	:type referencetokens:LIST(1,None,'STRING', scope = schema_scope)

	:param classificationforobjects
	:type classificationforobjects:SET(0,None,'ifcrelassociatesclassification', scope = schema_scope)

	:param hasreferences
	:type hasreferences:SET(0,None,'ifcclassificationreference', scope = schema_scope)
	'''
	def __init__( self , source,edition,editiondate,name,description,location,referencetokens, ):
		ifcexternalinformation.__init__(self , )
		self.source = source
		self.edition = edition
		self.editiondate = editiondate
		self.name = name
		self.description = description
		self.location = location
		self.referencetokens = referencetokens

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._source = ifclabel(value)
				else:
					self._source = value
			else:
				self._source = value
		return property(**locals())

	@apply
	def edition():
		def fget( self ):
			return self._edition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._edition = ifclabel(value)
				else:
					self._edition = value
			else:
				self._edition = value
		return property(**locals())

	@apply
	def editiondate():
		def fget( self ):
			return self._editiondate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdate):
					self._editiondate = ifcdate(value)
				else:
					self._editiondate = value
			else:
				self._editiondate = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def location():
		def fget( self ):
			return self._location
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcurireference):
					self._location = ifcurireference(value)
				else:
					self._location = value
			else:
				self._location = value
		return property(**locals())

	@apply
	def referencetokens():
		def fget( self ):
			return self._referencetokens
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._referencetokens = LIST(value)
				else:
					self._referencetokens = value
			else:
				self._referencetokens = value
		return property(**locals())

	@apply
	def classificationforobjects():
		def fget( self ):
			return self._classificationforobjects
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument classificationforobjects is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasreferences():
		def fget( self ):
			return self._hasreferences
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasreferences is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcresourceconstraintrelationship #
####################
class ifcresourceconstraintrelationship(ifcresourcelevelrelationship):
	'''Entity ifcresourceconstraintrelationship definition.

	:param relatingconstraint
	:type relatingconstraint:ifcconstraint

	:param relatedresourceobjects
	:type relatedresourceobjects:SET(1,None,'ifcresourceobjectselect', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , relatingconstraint,relatedresourceobjects, ):
		ifcresourcelevelrelationship.__init__(self , inherited0__name , inherited1__description , )
		self.relatingconstraint = relatingconstraint
		self.relatedresourceobjects = relatedresourceobjects

	@apply
	def relatingconstraint():
		def fget( self ):
			return self._relatingconstraint
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingconstraint is mantatory and can not be set to None')
			if not check_type(value,ifcconstraint):
				self._relatingconstraint = ifcconstraint(value)
			else:
				self._relatingconstraint = value
		return property(**locals())

	@apply
	def relatedresourceobjects():
		def fget( self ):
			return self._relatedresourceobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedresourceobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcresourceobjectselect', scope = schema_scope)):
				self._relatedresourceobjects = SET(value)
			else:
				self._relatedresourceobjects = value
		return property(**locals())

####################
 # ENTITY ifcfootingtype #
####################
class ifcfootingtype(ifcbuildingelementtype):
	'''Entity ifcfootingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcfootingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcfootingtypeenum):
				self._predefinedtype = ifcfootingtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcfootingtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcfootingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcgridaxis #
####################
class ifcgridaxis(BaseEntityClass):
	'''Entity ifcgridaxis definition.

	:param axistag
	:type axistag:ifclabel

	:param axiscurve
	:type axiscurve:ifccurve

	:param samesense
	:type samesense:ifcboolean

	:param partofw
	:type partofw:SET(0,1,'ifcgrid', scope = schema_scope)

	:param partofv
	:type partofv:SET(0,1,'ifcgrid', scope = schema_scope)

	:param partofu
	:type partofu:SET(0,1,'ifcgrid', scope = schema_scope)

	:param hasintersections
	:type hasintersections:SET(0,None,'ifcvirtualgridintersection', scope = schema_scope)
	'''
	def __init__( self , axistag,axiscurve,samesense, ):
		self.axistag = axistag
		self.axiscurve = axiscurve
		self.samesense = samesense

	@apply
	def axistag():
		def fget( self ):
			return self._axistag
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._axistag = ifclabel(value)
				else:
					self._axistag = value
			else:
				self._axistag = value
		return property(**locals())

	@apply
	def axiscurve():
		def fget( self ):
			return self._axiscurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axiscurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._axiscurve = ifccurve(value)
			else:
				self._axiscurve = value
		return property(**locals())

	@apply
	def samesense():
		def fget( self ):
			return self._samesense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument samesense is mantatory and can not be set to None')
			if not check_type(value,ifcboolean):
				self._samesense = ifcboolean(value)
			else:
				self._samesense = value
		return property(**locals())

	@apply
	def partofw():
		def fget( self ):
			return self._partofw
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofw is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def partofv():
		def fget( self ):
			return self._partofv
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofv is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def partofu():
		def fget( self ):
			return self._partofu
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofu is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasintersections():
		def fget( self ):
			return self._hasintersections
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasintersections is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.axiscurve.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(self.partofu)  ==  1) XOR (SIZEOF(self.partofv)  ==  1) XOR (SIZEOF(self.partofw)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifccablesegment #
####################
class ifccablesegment(ifcflowsegment):
	'''Entity ifccablesegment definition.

	:param predefinedtype
	:type predefinedtype:ifccablesegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowsegment.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccablesegmenttypeenum):
					self._predefinedtype = ifccablesegmenttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccablesegmenttypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccablesegmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCABLESEGMENTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcrelassignstogroupbyfactor #
####################
class ifcrelassignstogroupbyfactor(ifcrelassignstogroup):
	'''Entity ifcrelassignstogroupbyfactor definition.

	:param factor
	:type factor:ifcratiomeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , inherited6__relatinggroup , factor, ):
		ifcrelassignstogroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , inherited6__relatinggroup , )
		self.factor = factor

	@apply
	def factor():
		def fget( self ):
			return self._factor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument factor is mantatory and can not be set to None')
			if not check_type(value,ifcratiomeasure):
				self._factor = ifcratiomeasure(value)
			else:
				self._factor = value
		return property(**locals())

####################
 # ENTITY ifctransportelement #
####################
class ifctransportelement(ifcelement):
	'''Entity ifctransportelement definition.

	:param predefinedtype
	:type predefinedtype:ifctransportelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctransportelementtypeenum):
					self._predefinedtype = ifctransportelementtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifctransportelementtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifctransportelementtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCTRANSPORTELEMENTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcderivedunit #
####################
class ifcderivedunit(BaseEntityClass):
	'''Entity ifcderivedunit definition.

	:param elements
	:type elements:SET(1,None,'ifcderivedunitelement', scope = schema_scope)

	:param unittype
	:type unittype:ifcderivedunitenum

	:param userdefinedtype
	:type userdefinedtype:ifclabel

	:param dimensions
	:type dimensions:ifcdimensionalexponents
	'''
	def __init__( self , elements,unittype,userdefinedtype, ):
		self.elements = elements
		self.unittype = unittype
		self.userdefinedtype = userdefinedtype

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument elements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcderivedunitelement', scope = schema_scope)):
				self._elements = SET(value)
			else:
				self._elements = value
		return property(**locals())

	@apply
	def unittype():
		def fget( self ):
			return self._unittype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unittype is mantatory and can not be set to None')
			if not check_type(value,ifcderivedunitenum):
				self._unittype = ifcderivedunitenum(value)
			else:
				self._unittype = value
		return property(**locals())

	@apply
	def userdefinedtype():
		def fget( self ):
			return self._userdefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedtype = ifclabel(value)
				else:
					self._userdefinedtype = value
			else:
				self._userdefinedtype = value
		return property(**locals())

	@apply
	def dimensions():
		def fget( self ):
			attribute_eval = ifcderivedimensionalexponents(self.elements)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dimensions is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.elements)  >  1)  or  ((SIZEOF(self.elements)  ==  1)  and  (self.elements[1].self.exponent  !=  1)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((self.unittype  !=  ifcderivedunitenum.self.userdefined)  or  ((self.unittype  ==  ifcderivedunitenum.self.userdefined)  and  EXISTS(self.self.userdefinedtype)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcbsplinesurface #
####################
class ifcbsplinesurface(ifcboundedsurface):
	'''Entity ifcbsplinesurface definition.

	:param udegree
	:type udegree:INTEGER

	:param vdegree
	:type vdegree:INTEGER

	:param controlpointslist
	:type controlpointslist:LIST(2,None,LIST(2,None,'ifccartesianpoint', scope = schema_scope))

	:param surfaceform
	:type surfaceform:ifcbsplinesurfaceform

	:param uclosed
	:type uclosed:LOGICAL

	:param vclosed
	:type vclosed:LOGICAL

	:param selfintersect
	:type selfintersect:LOGICAL

	:param uupper
	:type uupper:INTEGER

	:param vupper
	:type vupper:INTEGER

	:param controlpoints
	:type controlpoints:ARRAY(0,uupper,ARRAY(0,vupper,'ifccartesianpoint', scope = schema_scope))
	'''
	def __init__( self , udegree,vdegree,controlpointslist,surfaceform,uclosed,vclosed,selfintersect, ):
		ifcboundedsurface.__init__(self , )
		self.udegree = udegree
		self.vdegree = vdegree
		self.controlpointslist = controlpointslist
		self.surfaceform = surfaceform
		self.uclosed = uclosed
		self.vclosed = vclosed
		self.selfintersect = selfintersect

	@apply
	def udegree():
		def fget( self ):
			return self._udegree
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument udegree is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._udegree = INTEGER(value)
			else:
				self._udegree = value
		return property(**locals())

	@apply
	def vdegree():
		def fget( self ):
			return self._vdegree
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vdegree is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._vdegree = INTEGER(value)
			else:
				self._vdegree = value
		return property(**locals())

	@apply
	def controlpointslist():
		def fget( self ):
			return self._controlpointslist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument controlpointslist is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,LIST(2,None,'ifccartesianpoint', scope = schema_scope))):
				self._controlpointslist = LIST(value)
			else:
				self._controlpointslist = value
		return property(**locals())

	@apply
	def surfaceform():
		def fget( self ):
			return self._surfaceform
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument surfaceform is mantatory and can not be set to None')
			if not check_type(value,ifcbsplinesurfaceform):
				self._surfaceform = ifcbsplinesurfaceform(value)
			else:
				self._surfaceform = value
		return property(**locals())

	@apply
	def uclosed():
		def fget( self ):
			return self._uclosed
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uclosed is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._uclosed = LOGICAL(value)
			else:
				self._uclosed = value
		return property(**locals())

	@apply
	def vclosed():
		def fget( self ):
			return self._vclosed
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vclosed is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._vclosed = LOGICAL(value)
			else:
				self._vclosed = value
		return property(**locals())

	@apply
	def selfintersect():
		def fget( self ):
			return self._selfintersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument selfintersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._selfintersect = LOGICAL(value)
			else:
				self._selfintersect = value
		return property(**locals())

	@apply
	def uupper():
		def fget( self ):
			attribute_eval = (SIZEOF(self.controlpointslist) - 1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument uupper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def vupper():
		def fget( self ):
			attribute_eval = (SIZEOF(self.controlpointslist[1]) - 1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument vupper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def controlpoints():
		def fget( self ):
			attribute_eval = ifcmakearrayofarray(self.controlpointslist,0,self.uupper,0,self.vupper)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument controlpoints is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifccontrollertype #
####################
class ifccontrollertype(ifcdistributioncontrolelementtype):
	'''Entity ifccontrollertype definition.

	:param predefinedtype
	:type predefinedtype:ifccontrollertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccontrollertypeenum):
				self._predefinedtype = ifccontrollertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccontrollertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccontrollertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcrelassignstoproduct #
####################
class ifcrelassignstoproduct(ifcrelassigns):
	'''Entity ifcrelassignstoproduct definition.

	:param relatingproduct
	:type relatingproduct:ifcproductselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatingproduct, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatingproduct = relatingproduct

	@apply
	def relatingproduct():
		def fget( self ):
			return self._relatingproduct
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingproduct is mantatory and can not be set to None')
			if not check_type(value,ifcproductselect):
				self._relatingproduct = ifcproductselect(value)
			else:
				self._relatingproduct = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (SIZEOF(None)  ==  0)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifcrepresentationcontext #
####################
class ifcrepresentationcontext(BaseEntityClass):
	'''Entity ifcrepresentationcontext definition.

	:param contextidentifier
	:type contextidentifier:ifclabel

	:param contexttype
	:type contexttype:ifclabel

	:param representationsincontext
	:type representationsincontext:SET(0,None,'ifcrepresentation', scope = schema_scope)
	'''
	def __init__( self , contextidentifier,contexttype, ):
		self.contextidentifier = contextidentifier
		self.contexttype = contexttype

	@apply
	def contextidentifier():
		def fget( self ):
			return self._contextidentifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._contextidentifier = ifclabel(value)
				else:
					self._contextidentifier = value
			else:
				self._contextidentifier = value
		return property(**locals())

	@apply
	def contexttype():
		def fget( self ):
			return self._contexttype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._contexttype = ifclabel(value)
				else:
					self._contexttype = value
			else:
				self._contexttype = value
		return property(**locals())

	@apply
	def representationsincontext():
		def fget( self ):
			return self._representationsincontext
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument representationsincontext is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcgeometricrepresentationcontext #
####################
class ifcgeometricrepresentationcontext(ifcrepresentationcontext):
	'''Entity ifcgeometricrepresentationcontext definition.

	:param coordinatespacedimension
	:type coordinatespacedimension:ifcdimensioncount

	:param precision
	:type precision:REAL

	:param worldcoordinatesystem
	:type worldcoordinatesystem:ifcaxis2placement

	:param truenorth
	:type truenorth:ifcdirection

	:param hassubcontexts
	:type hassubcontexts:SET(0,None,'ifcgeometricrepresentationsubcontext', scope = schema_scope)
	'''
	def __init__( self , inherited0__contextidentifier , inherited1__contexttype , coordinatespacedimension,precision,worldcoordinatesystem,truenorth, ):
		ifcrepresentationcontext.__init__(self , inherited0__contextidentifier , inherited1__contexttype , )
		self.coordinatespacedimension = coordinatespacedimension
		self.precision = precision
		self.worldcoordinatesystem = worldcoordinatesystem
		self.truenorth = truenorth

	@apply
	def coordinatespacedimension():
		def fget( self ):
			return self._coordinatespacedimension
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordinatespacedimension is mantatory and can not be set to None')
			if not check_type(value,ifcdimensioncount):
				self._coordinatespacedimension = ifcdimensioncount(value)
			else:
				self._coordinatespacedimension = value
		return property(**locals())

	@apply
	def precision():
		def fget( self ):
			return self._precision
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._precision = REAL(value)
				else:
					self._precision = value
			else:
				self._precision = value
		return property(**locals())

	@apply
	def worldcoordinatesystem():
		def fget( self ):
			return self._worldcoordinatesystem
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument worldcoordinatesystem is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._worldcoordinatesystem = ifcaxis2placement(value)
			else:
				self._worldcoordinatesystem = value
		return property(**locals())

	@apply
	def truenorth():
		def fget( self ):
			return self._truenorth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._truenorth = ifcdirection(value)
				else:
					self._truenorth = value
			else:
				self._truenorth = value
		return property(**locals())

	@apply
	def hassubcontexts():
		def fget( self ):
			return self._hassubcontexts
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hassubcontexts is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (( not EXISTS(self.truenorth))  or  (HIINDEX(self.truenorth.self.directionratios)  ==  2))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcstairflight #
####################
class ifcstairflight(ifcbuildingelement):
	'''Entity ifcstairflight definition.

	:param numberofriser
	:type numberofriser:INTEGER

	:param numberoftreads
	:type numberoftreads:INTEGER

	:param riserheight
	:type riserheight:ifcpositivelengthmeasure

	:param treadlength
	:type treadlength:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcstairflighttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , numberofriser,numberoftreads,riserheight,treadlength,predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.numberofriser = numberofriser
		self.numberoftreads = numberoftreads
		self.riserheight = riserheight
		self.treadlength = treadlength
		self.predefinedtype = predefinedtype

	@apply
	def numberofriser():
		def fget( self ):
			return self._numberofriser
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,INTEGER):
					self._numberofriser = INTEGER(value)
				else:
					self._numberofriser = value
			else:
				self._numberofriser = value
		return property(**locals())

	@apply
	def numberoftreads():
		def fget( self ):
			return self._numberoftreads
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,INTEGER):
					self._numberoftreads = INTEGER(value)
				else:
					self._numberoftreads = value
			else:
				self._numberoftreads = value
		return property(**locals())

	@apply
	def riserheight():
		def fget( self ):
			return self._riserheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._riserheight = ifcpositivelengthmeasure(value)
				else:
					self._riserheight = value
			else:
				self._riserheight = value
		return property(**locals())

	@apply
	def treadlength():
		def fget( self ):
			return self._treadlength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._treadlength = ifcpositivelengthmeasure(value)
				else:
					self._treadlength = value
			else:
				self._treadlength = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcstairflighttypeenum):
					self._predefinedtype = ifcstairflighttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcstairflighttypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcstairflighttypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSTAIRFLIGHTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcpath #
####################
class ifcpath(ifctopologicalrepresentationitem):
	'''Entity ifcpath definition.

	:param edgelist
	:type edgelist:LIST(1,None,'ifcorientededge', scope = schema_scope)
	'''
	def __init__( self , edgelist, ):
		ifctopologicalrepresentationitem.__init__(self , )
		self.edgelist = edgelist

	@apply
	def edgelist():
		def fget( self ):
			return self._edgelist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgelist is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcorientededge', scope = schema_scope)):
				self._edgelist = LIST(value)
			else:
				self._edgelist = value
		return property(**locals())
	def iscontinuous(self):
		eval_iscontinuous_wr = ifcpathheadtotail(self)
		if not eval_iscontinuous_wr:
			raise AssertionError('Rule iscontinuous violated')
		else:
			return eval_iscontinuous_wr


####################
 # ENTITY ifcstair #
####################
class ifcstair(ifcbuildingelement):
	'''Entity ifcstair definition.

	:param predefinedtype
	:type predefinedtype:ifcstairtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcstairtypeenum):
					self._predefinedtype = ifcstairtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctshapedecomposition(self):
		eval_correctshapedecomposition_wr = ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  0)  or  ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  1)  and  (( not EXISTS(self.self.ifcproduct.self.representation))  or  (EXISTS(self.self.ifcproduct.self.representation)  and  (SIZEOF(None)  ==  0)))))
		if not eval_correctshapedecomposition_wr:
			raise AssertionError('Rule correctshapedecomposition violated')
		else:
			return eval_correctshapedecomposition_wr

	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcstairtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcstairtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSTAIRTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcstructuralsurfacereaction #
####################
class ifcstructuralsurfacereaction(ifcstructuralreaction):
	'''Entity ifcstructuralsurfacereaction definition.

	:param predefinedtype
	:type predefinedtype:ifcstructuralsurfaceactivitytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , predefinedtype, ):
		ifcstructuralreaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralsurfaceactivitytypeenum):
				self._predefinedtype = ifcstructuralsurfaceactivitytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def haspredefinedtype(self):
		eval_haspredefinedtype_wr = ((self.predefinedtype  !=  ifcstructuralsurfaceactivitytypeenum.self.userdefined)  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_haspredefinedtype_wr:
			raise AssertionError('Rule haspredefinedtype violated')
		else:
			return eval_haspredefinedtype_wr


####################
 # ENTITY ifcductfitting #
####################
class ifcductfitting(ifcflowfitting):
	'''Entity ifcductfitting definition.

	:param predefinedtype
	:type predefinedtype:ifcductfittingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowfitting.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcductfittingtypeenum):
					self._predefinedtype = ifcductfittingtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcductfittingtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcductfittingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCDUCTFITTINGTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcactorrole #
####################
class ifcactorrole(BaseEntityClass):
	'''Entity ifcactorrole definition.

	:param role
	:type role:ifcroleenum

	:param userdefinedrole
	:type userdefinedrole:ifclabel

	:param description
	:type description:ifctext

	:param hasexternalreference
	:type hasexternalreference:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''
	def __init__( self , role,userdefinedrole,description, ):
		self.role = role
		self.userdefinedrole = userdefinedrole
		self.description = description

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,ifcroleenum):
				self._role = ifcroleenum(value)
			else:
				self._role = value
		return property(**locals())

	@apply
	def userdefinedrole():
		def fget( self ):
			return self._userdefinedrole
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedrole = ifclabel(value)
				else:
					self._userdefinedrole = value
			else:
				self._userdefinedrole = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def hasexternalreference():
		def fget( self ):
			return self._hasexternalreference
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.role  !=  ifcroleenum.self.userdefined)  or  ((self.role  ==  ifcroleenum.self.userdefined)  and  EXISTS(self.self.userdefinedrole)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcinterceptortype #
####################
class ifcinterceptortype(ifcflowtreatmentdevicetype):
	'''Entity ifcinterceptortype definition.

	:param predefinedtype
	:type predefinedtype:ifcinterceptortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowtreatmentdevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcinterceptortypeenum):
				self._predefinedtype = ifcinterceptortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcinterceptortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcinterceptortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcpolyline #
####################
class ifcpolyline(ifcboundedcurve):
	'''Entity ifcpolyline definition.

	:param points
	:type points:LIST(2,None,'ifccartesianpoint', scope = schema_scope)
	'''
	def __init__( self , points, ):
		ifcboundedcurve.__init__(self , )
		self.points = points

	@apply
	def points():
		def fget( self ):
			return self._points
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument points is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'ifccartesianpoint', scope = schema_scope)):
				self._points = LIST(value)
			else:
				self._points = value
		return property(**locals())
	def samedim(self):
		eval_samedim_wr = (SIZEOF(None)  ==  0)
		if not eval_samedim_wr:
			raise AssertionError('Rule samedim violated')
		else:
			return eval_samedim_wr


####################
 # ENTITY ifcpredefinedtextfont #
####################
class ifcpredefinedtextfont(ifcpredefineditem):
	'''Entity ifcpredefinedtextfont definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefineditem.__init__(self , inherited0__name , )

####################
 # ENTITY ifcsurfacereinforcementarea #
####################
class ifcsurfacereinforcementarea(ifcstructuralloadorresult):
	'''Entity ifcsurfacereinforcementarea definition.

	:param surfacereinforcement1
	:type surfacereinforcement1:LIST(2,3,'REAL', scope = schema_scope)

	:param surfacereinforcement2
	:type surfacereinforcement2:LIST(2,3,'REAL', scope = schema_scope)

	:param shearreinforcement
	:type shearreinforcement:ifcratiomeasure
	'''
	def __init__( self , inherited0__name , surfacereinforcement1,surfacereinforcement2,shearreinforcement, ):
		ifcstructuralloadorresult.__init__(self , inherited0__name , )
		self.surfacereinforcement1 = surfacereinforcement1
		self.surfacereinforcement2 = surfacereinforcement2
		self.shearreinforcement = shearreinforcement

	@apply
	def surfacereinforcement1():
		def fget( self ):
			return self._surfacereinforcement1
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(2,3,'REAL', scope = schema_scope)):
					self._surfacereinforcement1 = LIST(value)
				else:
					self._surfacereinforcement1 = value
			else:
				self._surfacereinforcement1 = value
		return property(**locals())

	@apply
	def surfacereinforcement2():
		def fget( self ):
			return self._surfacereinforcement2
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(2,3,'REAL', scope = schema_scope)):
					self._surfacereinforcement2 = LIST(value)
				else:
					self._surfacereinforcement2 = value
			else:
				self._surfacereinforcement2 = value
		return property(**locals())

	@apply
	def shearreinforcement():
		def fget( self ):
			return self._shearreinforcement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcratiomeasure):
					self._shearreinforcement = ifcratiomeasure(value)
				else:
					self._shearreinforcement = value
			else:
				self._shearreinforcement = value
		return property(**locals())
	def surfaceandorshearareaspecified(self):
		eval_surfaceandorshearareaspecified_wr = ((EXISTS(self.surfacereinforcement1)  or  EXISTS(self.surfacereinforcement2))  or  EXISTS(self.shearreinforcement))
		if not eval_surfaceandorshearareaspecified_wr:
			raise AssertionError('Rule surfaceandorshearareaspecified violated')
		else:
			return eval_surfaceandorshearareaspecified_wr

	def nonnegativearea1(self):
		eval_nonnegativearea1_wr = (( not EXISTS(self.surfacereinforcement1))  or  (((self.surfacereinforcement1[1]  >=  0)  and  (self.surfacereinforcement1[2]  >=  0))  and  ((SIZEOF(self.surfacereinforcement1)  ==  1)  or  (self.surfacereinforcement1[1]  >=  0))))
		if not eval_nonnegativearea1_wr:
			raise AssertionError('Rule nonnegativearea1 violated')
		else:
			return eval_nonnegativearea1_wr

	def nonnegativearea2(self):
		eval_nonnegativearea2_wr = (( not EXISTS(self.surfacereinforcement2))  or  (((self.surfacereinforcement2[1]  >=  0)  and  (self.surfacereinforcement2[2]  >=  0))  and  ((SIZEOF(self.surfacereinforcement2)  ==  1)  or  (self.surfacereinforcement2[1]  >=  0))))
		if not eval_nonnegativearea2_wr:
			raise AssertionError('Rule nonnegativearea2 violated')
		else:
			return eval_nonnegativearea2_wr

	def nonnegativearea3(self):
		eval_nonnegativearea3_wr = (( not EXISTS(self.shearreinforcement))  or  (self.shearreinforcement  >=  0))
		if not eval_nonnegativearea3_wr:
			raise AssertionError('Rule nonnegativearea3 violated')
		else:
			return eval_nonnegativearea3_wr


####################
 # ENTITY ifcgeometriccurveset #
####################
class ifcgeometriccurveset(ifcgeometricset):
	'''Entity ifcgeometriccurveset definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		ifcgeometricset.__init__(self , inherited0__elements , )
	def nosurfaces(self):
		eval_nosurfaces_wr = (SIZEOF(None)  ==  0)
		if not eval_nosurfaces_wr:
			raise AssertionError('Rule nosurfaces violated')
		else:
			return eval_nosurfaces_wr


####################
 # ENTITY ifctablerow #
####################
class ifctablerow(BaseEntityClass):
	'''Entity ifctablerow definition.

	:param rowcells
	:type rowcells:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param isheading
	:type isheading:BOOLEAN

	:param oftable
	:type oftable:ifctable
	'''
	def __init__( self , rowcells,isheading, ):
		self.rowcells = rowcells
		self.isheading = isheading

	@apply
	def rowcells():
		def fget( self ):
			return self._rowcells
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
					self._rowcells = LIST(value)
				else:
					self._rowcells = value
			else:
				self._rowcells = value
		return property(**locals())

	@apply
	def isheading():
		def fget( self ):
			return self._isheading
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._isheading = BOOLEAN(value)
				else:
					self._isheading = value
			else:
				self._isheading = value
		return property(**locals())

	@apply
	def oftable():
		def fget( self ):
			return self._oftable
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument oftable is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcconnectionsurfacegeometry #
####################
class ifcconnectionsurfacegeometry(ifcconnectiongeometry):
	'''Entity ifcconnectionsurfacegeometry definition.

	:param surfaceonrelatingelement
	:type surfaceonrelatingelement:ifcsurfaceorfacesurface

	:param surfaceonrelatedelement
	:type surfaceonrelatedelement:ifcsurfaceorfacesurface
	'''
	def __init__( self , surfaceonrelatingelement,surfaceonrelatedelement, ):
		ifcconnectiongeometry.__init__(self , )
		self.surfaceonrelatingelement = surfaceonrelatingelement
		self.surfaceonrelatedelement = surfaceonrelatedelement

	@apply
	def surfaceonrelatingelement():
		def fget( self ):
			return self._surfaceonrelatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument surfaceonrelatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcsurfaceorfacesurface):
				self._surfaceonrelatingelement = ifcsurfaceorfacesurface(value)
			else:
				self._surfaceonrelatingelement = value
		return property(**locals())

	@apply
	def surfaceonrelatedelement():
		def fget( self ):
			return self._surfaceonrelatedelement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsurfaceorfacesurface):
					self._surfaceonrelatedelement = ifcsurfaceorfacesurface(value)
				else:
					self._surfaceonrelatedelement = value
			else:
				self._surfaceonrelatedelement = value
		return property(**locals())

####################
 # ENTITY ifcelectricdistributionboardtype #
####################
class ifcelectricdistributionboardtype(ifcflowcontrollertype):
	'''Entity ifcelectricdistributionboardtype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricdistributionboardtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectricdistributionboardtypeenum):
				self._predefinedtype = ifcelectricdistributionboardtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcelectricdistributionboardtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcelectricdistributionboardtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcderivedprofiledef #
####################
class ifcderivedprofiledef(ifcprofiledef):
	'''Entity ifcderivedprofiledef definition.

	:param parentprofile
	:type parentprofile:ifcprofiledef

	:param operator
	:type operator:ifccartesiantransformationoperator2d

	:param label
	:type label:ifclabel
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , parentprofile,operator,label, ):
		ifcprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , )
		self.parentprofile = parentprofile
		self.operator = operator
		self.label = label

	@apply
	def parentprofile():
		def fget( self ):
			return self._parentprofile
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parentprofile is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._parentprofile = ifcprofiledef(value)
			else:
				self._parentprofile = value
		return property(**locals())

	@apply
	def operator():
		def fget( self ):
			return self._operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operator is mantatory and can not be set to None')
			if not check_type(value,ifccartesiantransformationoperator2d):
				self._operator = ifccartesiantransformationoperator2d(value)
			else:
				self._operator = value
		return property(**locals())

	@apply
	def label():
		def fget( self ):
			return self._label
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._label = ifclabel(value)
				else:
					self._label = value
			else:
				self._label = value
		return property(**locals())
	def invariantprofiletype(self):
		eval_invariantprofiletype_wr = (self.self.ifcprofiledef.self.profiletype  ==  self.parentprofile.self.profiletype)
		if not eval_invariantprofiletype_wr:
			raise AssertionError('Rule invariantprofiletype violated')
		else:
			return eval_invariantprofiletype_wr


####################
 # ENTITY ifcflowmovingdevicetype #
####################
class ifcflowmovingdevicetype(ifcdistributionflowelementtype):
	'''Entity ifcflowmovingdevicetype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcfantype #
####################
class ifcfantype(ifcflowmovingdevicetype):
	'''Entity ifcfantype definition.

	:param predefinedtype
	:type predefinedtype:ifcfantypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowmovingdevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcfantypeenum):
				self._predefinedtype = ifcfantypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcfantypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcfantypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcobjectplacement #
####################
class ifcobjectplacement(BaseEntityClass):
	'''Entity ifcobjectplacement definition.

	:param placesobject
	:type placesobject:SET(0,None,'ifcproduct', scope = schema_scope)

	:param referencedbyplacements
	:type referencedbyplacements:SET(0,None,'ifclocalplacement', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def placesobject():
		def fget( self ):
			return self._placesobject
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument placesobject is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def referencedbyplacements():
		def fget( self ):
			return self._referencedbyplacements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referencedbyplacements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcgridplacement #
####################
class ifcgridplacement(ifcobjectplacement):
	'''Entity ifcgridplacement definition.

	:param placementlocation
	:type placementlocation:ifcvirtualgridintersection

	:param placementrefdirection
	:type placementrefdirection:ifcgridplacementdirectionselect
	'''
	def __init__( self , placementlocation,placementrefdirection, ):
		ifcobjectplacement.__init__(self , )
		self.placementlocation = placementlocation
		self.placementrefdirection = placementrefdirection

	@apply
	def placementlocation():
		def fget( self ):
			return self._placementlocation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placementlocation is mantatory and can not be set to None')
			if not check_type(value,ifcvirtualgridintersection):
				self._placementlocation = ifcvirtualgridintersection(value)
			else:
				self._placementlocation = value
		return property(**locals())

	@apply
	def placementrefdirection():
		def fget( self ):
			return self._placementrefdirection
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcgridplacementdirectionselect):
					self._placementrefdirection = ifcgridplacementdirectionselect(value)
				else:
					self._placementrefdirection = value
			else:
				self._placementrefdirection = value
		return property(**locals())

####################
 # ENTITY ifctextstylefontmodel #
####################
class ifctextstylefontmodel(ifcpredefinedtextfont):
	'''Entity ifctextstylefontmodel definition.

	:param fontfamily
	:type fontfamily:LIST(1,None,'STRING', scope = schema_scope)

	:param fontstyle
	:type fontstyle:ifcfontstyle

	:param fontvariant
	:type fontvariant:ifcfontvariant

	:param fontweight
	:type fontweight:ifcfontweight

	:param fontsize
	:type fontsize:ifcsizeselect
	'''
	def __init__( self , inherited0__name , fontfamily,fontstyle,fontvariant,fontweight,fontsize, ):
		ifcpredefinedtextfont.__init__(self , inherited0__name , )
		self.fontfamily = fontfamily
		self.fontstyle = fontstyle
		self.fontvariant = fontvariant
		self.fontweight = fontweight
		self.fontsize = fontsize

	@apply
	def fontfamily():
		def fget( self ):
			return self._fontfamily
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fontfamily is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
				self._fontfamily = LIST(value)
			else:
				self._fontfamily = value
		return property(**locals())

	@apply
	def fontstyle():
		def fget( self ):
			return self._fontstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfontstyle):
					self._fontstyle = ifcfontstyle(value)
				else:
					self._fontstyle = value
			else:
				self._fontstyle = value
		return property(**locals())

	@apply
	def fontvariant():
		def fget( self ):
			return self._fontvariant
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfontvariant):
					self._fontvariant = ifcfontvariant(value)
				else:
					self._fontvariant = value
			else:
				self._fontvariant = value
		return property(**locals())

	@apply
	def fontweight():
		def fget( self ):
			return self._fontweight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfontweight):
					self._fontweight = ifcfontweight(value)
				else:
					self._fontweight = value
			else:
				self._fontweight = value
		return property(**locals())

	@apply
	def fontsize():
		def fget( self ):
			return self._fontsize
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fontsize is mantatory and can not be set to None')
			if not check_type(value,ifcsizeselect):
				self._fontsize = ifcsizeselect(value)
			else:
				self._fontsize = value
		return property(**locals())
	def measureoffontsize(self):
		eval_measureoffontsize_wr = (('IFC4.IFCLENGTHMEASURE'  ==  TYPEOF(self.self.fontsize))  and  (self.self.fontsize  >  0))
		if not eval_measureoffontsize_wr:
			raise AssertionError('Rule measureoffontsize violated')
		else:
			return eval_measureoffontsize_wr


####################
 # ENTITY ifcprotectivedevicetype #
####################
class ifcprotectivedevicetype(ifcflowcontrollertype):
	'''Entity ifcprotectivedevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcprotectivedevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcprotectivedevicetypeenum):
				self._predefinedtype = ifcprotectivedevicetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcprotectivedevicetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcprotectivedevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcsensor #
####################
class ifcsensor(ifcdistributioncontrolelement):
	'''Entity ifcsensor definition.

	:param predefinedtype
	:type predefinedtype:ifcsensortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcdistributioncontrolelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsensortypeenum):
					self._predefinedtype = ifcsensortypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcsensortypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcsensortypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSENSORTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifccircleprofiledef #
####################
class ifccircleprofiledef(ifcparameterizedprofiledef):
	'''Entity ifccircleprofiledef definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , radius, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY ifccolourrgblist #
####################
class ifccolourrgblist(ifcpresentationitem):
	'''Entity ifccolourrgblist definition.

	:param colourlist
	:type colourlist:LIST(1,None,LIST(3,3,'REAL', scope = schema_scope))
	'''
	def __init__( self , colourlist, ):
		ifcpresentationitem.__init__(self , )
		self.colourlist = colourlist

	@apply
	def colourlist():
		def fget( self ):
			return self._colourlist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument colourlist is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,LIST(3,3,'REAL', scope = schema_scope))):
				self._colourlist = LIST(value)
			else:
				self._colourlist = value
		return property(**locals())

####################
 # ENTITY ifcmaterialconstituent #
####################
class ifcmaterialconstituent(ifcmaterialdefinition):
	'''Entity ifcmaterialconstituent definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param material
	:type material:ifcmaterial

	:param fraction
	:type fraction:ifcnormalisedratiomeasure

	:param category
	:type category:ifclabel

	:param tomaterialconstituentset
	:type tomaterialconstituentset:ifcmaterialconstituentset
	'''
	def __init__( self , name,description,material,fraction,category, ):
		ifcmaterialdefinition.__init__(self , )
		self.name = name
		self.description = description
		self.material = material
		self.fraction = fraction
		self.category = category

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def material():
		def fget( self ):
			return self._material
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument material is mantatory and can not be set to None')
			if not check_type(value,ifcmaterial):
				self._material = ifcmaterial(value)
			else:
				self._material = value
		return property(**locals())

	@apply
	def fraction():
		def fget( self ):
			return self._fraction
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._fraction = ifcnormalisedratiomeasure(value)
				else:
					self._fraction = value
			else:
				self._fraction = value
		return property(**locals())

	@apply
	def category():
		def fget( self ):
			return self._category
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._category = ifclabel(value)
				else:
					self._category = value
			else:
				self._category = value
		return property(**locals())

	@apply
	def tomaterialconstituentset():
		def fget( self ):
			return self._tomaterialconstituentset
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument tomaterialconstituentset is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcwindowpanelproperties #
####################
class ifcwindowpanelproperties(ifcpredefinedpropertyset):
	'''Entity ifcwindowpanelproperties definition.

	:param operationtype
	:type operationtype:ifcwindowpaneloperationenum

	:param panelposition
	:type panelposition:ifcwindowpanelpositionenum

	:param framedepth
	:type framedepth:ifcpositivelengthmeasure

	:param framethickness
	:type framethickness:ifcpositivelengthmeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , operationtype,panelposition,framedepth,framethickness,shapeaspectstyle, ):
		ifcpredefinedpropertyset.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.operationtype = operationtype
		self.panelposition = panelposition
		self.framedepth = framedepth
		self.framethickness = framethickness
		self.shapeaspectstyle = shapeaspectstyle

	@apply
	def operationtype():
		def fget( self ):
			return self._operationtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operationtype is mantatory and can not be set to None')
			if not check_type(value,ifcwindowpaneloperationenum):
				self._operationtype = ifcwindowpaneloperationenum(value)
			else:
				self._operationtype = value
		return property(**locals())

	@apply
	def panelposition():
		def fget( self ):
			return self._panelposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument panelposition is mantatory and can not be set to None')
			if not check_type(value,ifcwindowpanelpositionenum):
				self._panelposition = ifcwindowpanelpositionenum(value)
			else:
				self._panelposition = value
		return property(**locals())

	@apply
	def framedepth():
		def fget( self ):
			return self._framedepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._framedepth = ifcpositivelengthmeasure(value)
				else:
					self._framedepth = value
			else:
				self._framedepth = value
		return property(**locals())

	@apply
	def framethickness():
		def fget( self ):
			return self._framethickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._framethickness = ifcpositivelengthmeasure(value)
				else:
					self._framethickness = value
			else:
				self._framethickness = value
		return property(**locals())

	@apply
	def shapeaspectstyle():
		def fget( self ):
			return self._shapeaspectstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshapeaspect):
					self._shapeaspectstyle = ifcshapeaspect(value)
				else:
					self._shapeaspectstyle = value
			else:
				self._shapeaspectstyle = value
		return property(**locals())
	def applicabletotype(self):
		eval_applicabletotype_wr = (EXISTS(self.self.ifcpropertysetdefinition.self.definestype[1])  and  (('IFC4.IFCWINDOWTYPE'  ==  TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))  or  ('IFC4.IFCWINDOWSTYLE'  ==  TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1]))))
		if not eval_applicabletotype_wr:
			raise AssertionError('Rule applicabletotype violated')
		else:
			return eval_applicabletotype_wr


####################
 # ENTITY ifcelectrictimecontrol #
####################
class ifcelectrictimecontrol(ifcflowcontroller):
	'''Entity ifcelectrictimecontrol definition.

	:param predefinedtype
	:type predefinedtype:ifcelectrictimecontroltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowcontroller.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelectrictimecontroltypeenum):
					self._predefinedtype = ifcelectrictimecontroltypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcelectrictimecontroltypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcelectrictimecontroltypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCELECTRICTIMECONTROLTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcdimensionalexponents #
####################
class ifcdimensionalexponents(BaseEntityClass):
	'''Entity ifcdimensionalexponents definition.

	:param lengthexponent
	:type lengthexponent:INTEGER

	:param massexponent
	:type massexponent:INTEGER

	:param timeexponent
	:type timeexponent:INTEGER

	:param electriccurrentexponent
	:type electriccurrentexponent:INTEGER

	:param thermodynamictemperatureexponent
	:type thermodynamictemperatureexponent:INTEGER

	:param amountofsubstanceexponent
	:type amountofsubstanceexponent:INTEGER

	:param luminousintensityexponent
	:type luminousintensityexponent:INTEGER
	'''
	def __init__( self , lengthexponent,massexponent,timeexponent,electriccurrentexponent,thermodynamictemperatureexponent,amountofsubstanceexponent,luminousintensityexponent, ):
		self.lengthexponent = lengthexponent
		self.massexponent = massexponent
		self.timeexponent = timeexponent
		self.electriccurrentexponent = electriccurrentexponent
		self.thermodynamictemperatureexponent = thermodynamictemperatureexponent
		self.amountofsubstanceexponent = amountofsubstanceexponent
		self.luminousintensityexponent = luminousintensityexponent

	@apply
	def lengthexponent():
		def fget( self ):
			return self._lengthexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lengthexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._lengthexponent = INTEGER(value)
			else:
				self._lengthexponent = value
		return property(**locals())

	@apply
	def massexponent():
		def fget( self ):
			return self._massexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument massexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._massexponent = INTEGER(value)
			else:
				self._massexponent = value
		return property(**locals())

	@apply
	def timeexponent():
		def fget( self ):
			return self._timeexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timeexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._timeexponent = INTEGER(value)
			else:
				self._timeexponent = value
		return property(**locals())

	@apply
	def electriccurrentexponent():
		def fget( self ):
			return self._electriccurrentexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument electriccurrentexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._electriccurrentexponent = INTEGER(value)
			else:
				self._electriccurrentexponent = value
		return property(**locals())

	@apply
	def thermodynamictemperatureexponent():
		def fget( self ):
			return self._thermodynamictemperatureexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thermodynamictemperatureexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._thermodynamictemperatureexponent = INTEGER(value)
			else:
				self._thermodynamictemperatureexponent = value
		return property(**locals())

	@apply
	def amountofsubstanceexponent():
		def fget( self ):
			return self._amountofsubstanceexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument amountofsubstanceexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._amountofsubstanceexponent = INTEGER(value)
			else:
				self._amountofsubstanceexponent = value
		return property(**locals())

	@apply
	def luminousintensityexponent():
		def fget( self ):
			return self._luminousintensityexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument luminousintensityexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._luminousintensityexponent = INTEGER(value)
			else:
				self._luminousintensityexponent = value
		return property(**locals())

####################
 # ENTITY ifcmetric #
####################
class ifcmetric(ifcconstraint):
	'''Entity ifcmetric definition.

	:param benchmark
	:type benchmark:ifcbenchmarkenum

	:param valuesource
	:type valuesource:ifclabel

	:param datavalue
	:type datavalue:ifcmetricvalueselect

	:param referencepath
	:type referencepath:ifcreference
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__constraintgrade , inherited3__constraintsource , inherited4__creatingactor , inherited5__creationtime , inherited6__userdefinedgrade , benchmark,valuesource,datavalue,referencepath, ):
		ifcconstraint.__init__(self , inherited0__name , inherited1__description , inherited2__constraintgrade , inherited3__constraintsource , inherited4__creatingactor , inherited5__creationtime , inherited6__userdefinedgrade , )
		self.benchmark = benchmark
		self.valuesource = valuesource
		self.datavalue = datavalue
		self.referencepath = referencepath

	@apply
	def benchmark():
		def fget( self ):
			return self._benchmark
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument benchmark is mantatory and can not be set to None')
			if not check_type(value,ifcbenchmarkenum):
				self._benchmark = ifcbenchmarkenum(value)
			else:
				self._benchmark = value
		return property(**locals())

	@apply
	def valuesource():
		def fget( self ):
			return self._valuesource
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._valuesource = ifclabel(value)
				else:
					self._valuesource = value
			else:
				self._valuesource = value
		return property(**locals())

	@apply
	def datavalue():
		def fget( self ):
			return self._datavalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument datavalue is mantatory and can not be set to None')
			if not check_type(value,ifcmetricvalueselect):
				self._datavalue = ifcmetricvalueselect(value)
			else:
				self._datavalue = value
		return property(**locals())

	@apply
	def referencepath():
		def fget( self ):
			return self._referencepath
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreference):
					self._referencepath = ifcreference(value)
				else:
					self._referencepath = value
			else:
				self._referencepath = value
		return property(**locals())

####################
 # ENTITY ifcunitarycontrolelementtype #
####################
class ifcunitarycontrolelementtype(ifcdistributioncontrolelementtype):
	'''Entity ifcunitarycontrolelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifcunitarycontrolelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcunitarycontrolelementtypeenum):
				self._predefinedtype = ifcunitarycontrolelementtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcunitarycontrolelementtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcunitarycontrolelementtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifccablefittingtype #
####################
class ifccablefittingtype(ifcflowfittingtype):
	'''Entity ifccablefittingtype definition.

	:param predefinedtype
	:type predefinedtype:ifccablefittingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowfittingtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccablefittingtypeenum):
				self._predefinedtype = ifccablefittingtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccablefittingtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccablefittingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcrelconnectswithrealizingelements #
####################
class ifcrelconnectswithrealizingelements(ifcrelconnectselements):
	'''Entity ifcrelconnectswithrealizingelements definition.

	:param realizingelements
	:type realizingelements:SET(1,None,'ifcelement', scope = schema_scope)

	:param connectiontype
	:type connectiontype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__connectiongeometry , inherited5__relatingelement , inherited6__relatedelement , realizingelements,connectiontype, ):
		ifcrelconnectselements.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__connectiongeometry , inherited5__relatingelement , inherited6__relatedelement , )
		self.realizingelements = realizingelements
		self.connectiontype = connectiontype

	@apply
	def realizingelements():
		def fget( self ):
			return self._realizingelements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument realizingelements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcelement', scope = schema_scope)):
				self._realizingelements = SET(value)
			else:
				self._realizingelements = value
		return property(**locals())

	@apply
	def connectiontype():
		def fget( self ):
			return self._connectiontype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._connectiontype = ifclabel(value)
				else:
					self._connectiontype = value
			else:
				self._connectiontype = value
		return property(**locals())

####################
 # ENTITY ifcprocess #
####################
class ifcprocess(ifcobject):
	'''Entity ifcprocess definition.

	:param identification
	:type identification:ifcidentifier

	:param longdescription
	:type longdescription:ifctext

	:param ispredecessorto
	:type ispredecessorto:SET(0,None,'ifcrelsequence', scope = schema_scope)

	:param issuccessorfrom
	:type issuccessorfrom:SET(0,None,'ifcrelsequence', scope = schema_scope)

	:param operateson
	:type operateson:SET(0,None,'ifcrelassignstoprocess', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , identification,longdescription, ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.identification = identification
		self.longdescription = longdescription

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identification = ifcidentifier(value)
				else:
					self._identification = value
			else:
				self._identification = value
		return property(**locals())

	@apply
	def longdescription():
		def fget( self ):
			return self._longdescription
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._longdescription = ifctext(value)
				else:
					self._longdescription = value
			else:
				self._longdescription = value
		return property(**locals())

	@apply
	def ispredecessorto():
		def fget( self ):
			return self._ispredecessorto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ispredecessorto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def issuccessorfrom():
		def fget( self ):
			return self._issuccessorfrom
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument issuccessorfrom is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def operateson():
		def fget( self ):
			return self._operateson
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument operateson is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifctask #
####################
class ifctask(ifcprocess):
	'''Entity ifctask definition.

	:param status
	:type status:ifclabel

	:param workmethod
	:type workmethod:ifclabel

	:param ismilestone
	:type ismilestone:BOOLEAN

	:param priority
	:type priority:INTEGER

	:param tasktime
	:type tasktime:ifctasktime

	:param predefinedtype
	:type predefinedtype:ifctasktypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , status,workmethod,ismilestone,priority,tasktime,predefinedtype, ):
		ifcprocess.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , )
		self.status = status
		self.workmethod = workmethod
		self.ismilestone = ismilestone
		self.priority = priority
		self.tasktime = tasktime
		self.predefinedtype = predefinedtype

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._status = ifclabel(value)
				else:
					self._status = value
			else:
				self._status = value
		return property(**locals())

	@apply
	def workmethod():
		def fget( self ):
			return self._workmethod
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._workmethod = ifclabel(value)
				else:
					self._workmethod = value
			else:
				self._workmethod = value
		return property(**locals())

	@apply
	def ismilestone():
		def fget( self ):
			return self._ismilestone
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ismilestone is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._ismilestone = BOOLEAN(value)
			else:
				self._ismilestone = value
		return property(**locals())

	@apply
	def priority():
		def fget( self ):
			return self._priority
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,INTEGER):
					self._priority = INTEGER(value)
				else:
					self._priority = value
			else:
				self._priority = value
		return property(**locals())

	@apply
	def tasktime():
		def fget( self ):
			return self._tasktime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctasktime):
					self._tasktime = ifctasktime(value)
				else:
					self._tasktime = value
			else:
				self._tasktime = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctasktypeenum):
					self._predefinedtype = ifctasktypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def hasname(self):
		eval_hasname_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_hasname_wr:
			raise AssertionError('Rule hasname violated')
		else:
			return eval_hasname_wr

	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifctasktypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifctasktypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcresource #
####################
class ifcresource(ifcobject):
	'''Entity ifcresource definition.

	:param identification
	:type identification:ifcidentifier

	:param longdescription
	:type longdescription:ifctext

	:param resourceof
	:type resourceof:SET(0,None,'ifcrelassignstoresource', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , identification,longdescription, ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.identification = identification
		self.longdescription = longdescription

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identification = ifcidentifier(value)
				else:
					self._identification = value
			else:
				self._identification = value
		return property(**locals())

	@apply
	def longdescription():
		def fget( self ):
			return self._longdescription
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._longdescription = ifctext(value)
				else:
					self._longdescription = value
			else:
				self._longdescription = value
		return property(**locals())

	@apply
	def resourceof():
		def fget( self ):
			return self._resourceof
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument resourceof is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcconstructionresource #
####################
class ifcconstructionresource(ifcresource):
	'''Entity ifcconstructionresource definition.

	:param usage
	:type usage:ifcresourcetime

	:param basecosts
	:type basecosts:LIST(1,None,'ifcappliedvalue', scope = schema_scope)

	:param basequantity
	:type basequantity:ifcphysicalquantity
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , usage,basecosts,basequantity, ):
		ifcresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , )
		self.usage = usage
		self.basecosts = basecosts
		self.basequantity = basequantity

	@apply
	def usage():
		def fget( self ):
			return self._usage
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcresourcetime):
					self._usage = ifcresourcetime(value)
				else:
					self._usage = value
			else:
				self._usage = value
		return property(**locals())

	@apply
	def basecosts():
		def fget( self ):
			return self._basecosts
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcappliedvalue', scope = schema_scope)):
					self._basecosts = LIST(value)
				else:
					self._basecosts = value
			else:
				self._basecosts = value
		return property(**locals())

	@apply
	def basequantity():
		def fget( self ):
			return self._basequantity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcphysicalquantity):
					self._basequantity = ifcphysicalquantity(value)
				else:
					self._basequantity = value
			else:
				self._basequantity = value
		return property(**locals())

####################
 # ENTITY ifccrewresource #
####################
class ifccrewresource(ifcconstructionresource):
	'''Entity ifccrewresource definition.

	:param predefinedtype
	:type predefinedtype:ifccrewresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , predefinedtype, ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccrewresourcetypeenum):
					self._predefinedtype = ifccrewresourcetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccrewresourcetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccrewresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcunitarycontrolelement #
####################
class ifcunitarycontrolelement(ifcdistributioncontrolelement):
	'''Entity ifcunitarycontrolelement definition.

	:param predefinedtype
	:type predefinedtype:ifcunitarycontrolelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcdistributioncontrolelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunitarycontrolelementtypeenum):
					self._predefinedtype = ifcunitarycontrolelementtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcunitarycontrolelementtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcunitarycontrolelementtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCUNITARYCONTROLELEMENTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcfacetedbrep #
####################
class ifcfacetedbrep(ifcmanifoldsolidbrep):
	'''Entity ifcfacetedbrep definition.
	'''
	def __init__( self , inherited0__outer ,  ):
		ifcmanifoldsolidbrep.__init__(self , inherited0__outer , )

####################
 # ENTITY ifclamp #
####################
class ifclamp(ifcflowterminal):
	'''Entity ifclamp definition.

	:param predefinedtype
	:type predefinedtype:ifclamptypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclamptypeenum):
					self._predefinedtype = ifclamptypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifclamptypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifclamptypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCLAMPTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcbooleanresult #
####################
class ifcbooleanresult(ifcgeometricrepresentationitem):
	'''Entity ifcbooleanresult definition.

	:param operator
	:type operator:ifcbooleanoperator

	:param firstoperand
	:type firstoperand:ifcbooleanoperand

	:param secondoperand
	:type secondoperand:ifcbooleanoperand

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , operator,firstoperand,secondoperand, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.operator = operator
		self.firstoperand = firstoperand
		self.secondoperand = secondoperand

	@apply
	def operator():
		def fget( self ):
			return self._operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operator is mantatory and can not be set to None')
			if not check_type(value,ifcbooleanoperator):
				self._operator = ifcbooleanoperator(value)
			else:
				self._operator = value
		return property(**locals())

	@apply
	def firstoperand():
		def fget( self ):
			return self._firstoperand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument firstoperand is mantatory and can not be set to None')
			if not check_type(value,ifcbooleanoperand):
				self._firstoperand = ifcbooleanoperand(value)
			else:
				self._firstoperand = value
		return property(**locals())

	@apply
	def secondoperand():
		def fget( self ):
			return self._secondoperand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument secondoperand is mantatory and can not be set to None')
			if not check_type(value,ifcbooleanoperand):
				self._secondoperand = ifcbooleanoperand(value)
			else:
				self._secondoperand = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.firstoperand.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def samedim(self):
		eval_samedim_wr = (self.firstoperand.self.dim  ==  self.secondoperand.self.dim)
		if not eval_samedim_wr:
			raise AssertionError('Rule samedim violated')
		else:
			return eval_samedim_wr


####################
 # ENTITY ifcslabtype #
####################
class ifcslabtype(ifcbuildingelementtype):
	'''Entity ifcslabtype definition.

	:param predefinedtype
	:type predefinedtype:ifcslabtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcslabtypeenum):
				self._predefinedtype = ifcslabtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcslabtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcslabtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcelectricgenerator #
####################
class ifcelectricgenerator(ifcenergyconversiondevice):
	'''Entity ifcelectricgenerator definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricgeneratortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelectricgeneratortypeenum):
					self._predefinedtype = ifcelectricgeneratortypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcelectricgeneratortypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcelectricgeneratortypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCELECTRICGENERATORTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifctextstyletextmodel #
####################
class ifctextstyletextmodel(ifcpresentationitem):
	'''Entity ifctextstyletextmodel definition.

	:param textindent
	:type textindent:ifcsizeselect

	:param textalign
	:type textalign:ifctextalignment

	:param textdecoration
	:type textdecoration:ifctextdecoration

	:param letterspacing
	:type letterspacing:ifcsizeselect

	:param wordspacing
	:type wordspacing:ifcsizeselect

	:param texttransform
	:type texttransform:ifctexttransformation

	:param lineheight
	:type lineheight:ifcsizeselect
	'''
	def __init__( self , textindent,textalign,textdecoration,letterspacing,wordspacing,texttransform,lineheight, ):
		ifcpresentationitem.__init__(self , )
		self.textindent = textindent
		self.textalign = textalign
		self.textdecoration = textdecoration
		self.letterspacing = letterspacing
		self.wordspacing = wordspacing
		self.texttransform = texttransform
		self.lineheight = lineheight

	@apply
	def textindent():
		def fget( self ):
			return self._textindent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsizeselect):
					self._textindent = ifcsizeselect(value)
				else:
					self._textindent = value
			else:
				self._textindent = value
		return property(**locals())

	@apply
	def textalign():
		def fget( self ):
			return self._textalign
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctextalignment):
					self._textalign = ifctextalignment(value)
				else:
					self._textalign = value
			else:
				self._textalign = value
		return property(**locals())

	@apply
	def textdecoration():
		def fget( self ):
			return self._textdecoration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctextdecoration):
					self._textdecoration = ifctextdecoration(value)
				else:
					self._textdecoration = value
			else:
				self._textdecoration = value
		return property(**locals())

	@apply
	def letterspacing():
		def fget( self ):
			return self._letterspacing
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsizeselect):
					self._letterspacing = ifcsizeselect(value)
				else:
					self._letterspacing = value
			else:
				self._letterspacing = value
		return property(**locals())

	@apply
	def wordspacing():
		def fget( self ):
			return self._wordspacing
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsizeselect):
					self._wordspacing = ifcsizeselect(value)
				else:
					self._wordspacing = value
			else:
				self._wordspacing = value
		return property(**locals())

	@apply
	def texttransform():
		def fget( self ):
			return self._texttransform
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctexttransformation):
					self._texttransform = ifctexttransformation(value)
				else:
					self._texttransform = value
			else:
				self._texttransform = value
		return property(**locals())

	@apply
	def lineheight():
		def fget( self ):
			return self._lineheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsizeselect):
					self._lineheight = ifcsizeselect(value)
				else:
					self._lineheight = value
			else:
				self._lineheight = value
		return property(**locals())

####################
 # ENTITY ifcunitassignment #
####################
class ifcunitassignment(BaseEntityClass):
	'''Entity ifcunitassignment definition.

	:param units
	:type units:SET(1,None,'ifcunit', scope = schema_scope)
	'''
	def __init__( self , units, ):
		self.units = units

	@apply
	def units():
		def fget( self ):
			return self._units
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument units is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcunit', scope = schema_scope)):
				self._units = SET(value)
			else:
				self._units = value
		return property(**locals())
	def wr01(self):
		eval_wr01_wr = ifccorrectunitassignment(self.units)
		if not eval_wr01_wr:
			raise AssertionError('Rule wr01 violated')
		else:
			return eval_wr01_wr


####################
 # ENTITY ifcbeam #
####################
class ifcbeam(ifcbuildingelement):
	'''Entity ifcbeam definition.

	:param predefinedtype
	:type predefinedtype:ifcbeamtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcbeamtypeenum):
					self._predefinedtype = ifcbeamtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcbeamtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcbeamtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCBEAMTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcplate #
####################
class ifcplate(ifcbuildingelement):
	'''Entity ifcplate definition.

	:param predefinedtype
	:type predefinedtype:ifcplatetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplatetypeenum):
					self._predefinedtype = ifcplatetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcplatetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcplatetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCPLATETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcplatestandardcase #
####################
class ifcplatestandardcase(ifcplate):
	'''Entity ifcplatestandardcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype ,  ):
		ifcplate.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype , )
	def hasmateriallayersetusage(self):
		eval_hasmateriallayersetusage_wr = (SIZEOF(None)  ==  1)
		if not eval_hasmateriallayersetusage_wr:
			raise AssertionError('Rule hasmateriallayersetusage violated')
		else:
			return eval_hasmateriallayersetusage_wr


####################
 # ENTITY ifcvalve #
####################
class ifcvalve(ifcflowcontroller):
	'''Entity ifcvalve definition.

	:param predefinedtype
	:type predefinedtype:ifcvalvetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowcontroller.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvalvetypeenum):
					self._predefinedtype = ifcvalvetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcvalvetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcvalvetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCVALVETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcairterminalbox #
####################
class ifcairterminalbox(ifcflowcontroller):
	'''Entity ifcairterminalbox definition.

	:param predefinedtype
	:type predefinedtype:ifcairterminalboxtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowcontroller.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcairterminalboxtypeenum):
					self._predefinedtype = ifcairterminalboxtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcairterminalboxtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcairterminalboxtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCAIRTERMINALBOXTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcchiller #
####################
class ifcchiller(ifcenergyconversiondevice):
	'''Entity ifcchiller definition.

	:param predefinedtype
	:type predefinedtype:ifcchillertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcchillertypeenum):
					self._predefinedtype = ifcchillertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcchillertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcchillertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCHILLERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcevaporativecoolertype #
####################
class ifcevaporativecoolertype(ifcenergyconversiondevicetype):
	'''Entity ifcevaporativecoolertype definition.

	:param predefinedtype
	:type predefinedtype:ifcevaporativecoolertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcevaporativecoolertypeenum):
				self._predefinedtype = ifcevaporativecoolertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcevaporativecoolertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcevaporativecoolertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcflowmeter #
####################
class ifcflowmeter(ifcflowcontroller):
	'''Entity ifcflowmeter definition.

	:param predefinedtype
	:type predefinedtype:ifcflowmetertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowcontroller.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcflowmetertypeenum):
					self._predefinedtype = ifcflowmetertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcflowmetertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcflowmetertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCFLOWMETERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcelementarysurface #
####################
class ifcelementarysurface(ifcsurface):
	'''Entity ifcelementarysurface definition.

	:param position
	:type position:ifcaxis2placement3d
	'''
	def __init__( self , position, ):
		ifcsurface.__init__(self , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement3d):
				self._position = ifcaxis2placement3d(value)
			else:
				self._position = value
		return property(**locals())

####################
 # ENTITY ifcalarmtype #
####################
class ifcalarmtype(ifcdistributioncontrolelementtype):
	'''Entity ifcalarmtype definition.

	:param predefinedtype
	:type predefinedtype:ifcalarmtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcalarmtypeenum):
				self._predefinedtype = ifcalarmtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcalarmtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcalarmtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcmembertype #
####################
class ifcmembertype(ifcbuildingelementtype):
	'''Entity ifcmembertype definition.

	:param predefinedtype
	:type predefinedtype:ifcmembertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcmembertypeenum):
				self._predefinedtype = ifcmembertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcmembertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcmembertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcrelflowcontrolelements #
####################
class ifcrelflowcontrolelements(ifcrelconnects):
	'''Entity ifcrelflowcontrolelements definition.

	:param relatedcontrolelements
	:type relatedcontrolelements:SET(1,None,'ifcdistributioncontrolelement', scope = schema_scope)

	:param relatingflowelement
	:type relatingflowelement:ifcdistributionflowelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedcontrolelements,relatingflowelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedcontrolelements = relatedcontrolelements
		self.relatingflowelement = relatingflowelement

	@apply
	def relatedcontrolelements():
		def fget( self ):
			return self._relatedcontrolelements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedcontrolelements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcdistributioncontrolelement', scope = schema_scope)):
				self._relatedcontrolelements = SET(value)
			else:
				self._relatedcontrolelements = value
		return property(**locals())

	@apply
	def relatingflowelement():
		def fget( self ):
			return self._relatingflowelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingflowelement is mantatory and can not be set to None')
			if not check_type(value,ifcdistributionflowelement):
				self._relatingflowelement = ifcdistributionflowelement(value)
			else:
				self._relatingflowelement = value
		return property(**locals())

####################
 # ENTITY ifcindexedtexturemap #
####################
class ifcindexedtexturemap(ifctexturecoordinate):
	'''Entity ifcindexedtexturemap definition.

	:param mappedto
	:type mappedto:ifctessellatedfaceset

	:param texcoords
	:type texcoords:ifctexturevertexlist
	'''
	def __init__( self , inherited0__maps , mappedto,texcoords, ):
		ifctexturecoordinate.__init__(self , inherited0__maps , )
		self.mappedto = mappedto
		self.texcoords = texcoords

	@apply
	def mappedto():
		def fget( self ):
			return self._mappedto
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mappedto is mantatory and can not be set to None')
			if not check_type(value,ifctessellatedfaceset):
				self._mappedto = ifctessellatedfaceset(value)
			else:
				self._mappedto = value
		return property(**locals())

	@apply
	def texcoords():
		def fget( self ):
			return self._texcoords
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument texcoords is mantatory and can not be set to None')
			if not check_type(value,ifctexturevertexlist):
				self._texcoords = ifctexturevertexlist(value)
			else:
				self._texcoords = value
		return property(**locals())

####################
 # ENTITY ifcindexedtriangletexturemap #
####################
class ifcindexedtriangletexturemap(ifcindexedtexturemap):
	'''Entity ifcindexedtriangletexturemap definition.

	:param texcoordindex
	:type texcoordindex:LIST(1,None,LIST(3,3,'INTEGER', scope = schema_scope))
	'''
	def __init__( self , inherited0__maps , inherited1__mappedto , inherited2__texcoords , texcoordindex, ):
		ifcindexedtexturemap.__init__(self , inherited0__maps , inherited1__mappedto , inherited2__texcoords , )
		self.texcoordindex = texcoordindex

	@apply
	def texcoordindex():
		def fget( self ):
			return self._texcoordindex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,LIST(3,3,'INTEGER', scope = schema_scope))):
					self._texcoordindex = LIST(value)
				else:
					self._texcoordindex = value
			else:
				self._texcoordindex = value
		return property(**locals())

####################
 # ENTITY ifcpropertylistvalue #
####################
class ifcpropertylistvalue(ifcsimpleproperty):
	'''Entity ifcpropertylistvalue definition.

	:param listvalues
	:type listvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param unit
	:type unit:ifcunit
	'''
	def __init__( self , inherited0__name , inherited1__description , listvalues,unit, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.listvalues = listvalues
		self.unit = unit

	@apply
	def listvalues():
		def fget( self ):
			return self._listvalues
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
					self._listvalues = LIST(value)
				else:
					self._listvalues = value
			else:
				self._listvalues = value
		return property(**locals())

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._unit = ifcunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (SIZEOF(None)  ==  0)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcrelinterfereselements #
####################
class ifcrelinterfereselements(ifcrelconnects):
	'''Entity ifcrelinterfereselements definition.

	:param relatingelement
	:type relatingelement:ifcelement

	:param relatedelement
	:type relatedelement:ifcelement

	:param interferencegeometry
	:type interferencegeometry:ifcconnectiongeometry

	:param interferencetype
	:type interferencetype:ifcidentifier

	:param impliedorder
	:type impliedorder:LOGICAL
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingelement,relatedelement,interferencegeometry,interferencetype,impliedorder, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingelement = relatingelement
		self.relatedelement = relatedelement
		self.interferencegeometry = interferencegeometry
		self.interferencetype = interferencetype
		self.impliedorder = impliedorder

	@apply
	def relatingelement():
		def fget( self ):
			return self._relatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatingelement = ifcelement(value)
			else:
				self._relatingelement = value
		return property(**locals())

	@apply
	def relatedelement():
		def fget( self ):
			return self._relatedelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatedelement = ifcelement(value)
			else:
				self._relatedelement = value
		return property(**locals())

	@apply
	def interferencegeometry():
		def fget( self ):
			return self._interferencegeometry
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcconnectiongeometry):
					self._interferencegeometry = ifcconnectiongeometry(value)
				else:
					self._interferencegeometry = value
			else:
				self._interferencegeometry = value
		return property(**locals())

	@apply
	def interferencetype():
		def fget( self ):
			return self._interferencetype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._interferencetype = ifcidentifier(value)
				else:
					self._interferencetype = value
			else:
				self._interferencetype = value
		return property(**locals())

	@apply
	def impliedorder():
		def fget( self ):
			return self._impliedorder
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument impliedorder is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._impliedorder = LOGICAL(value)
			else:
				self._impliedorder = value
		return property(**locals())
	def notselfreference(self):
		eval_notselfreference_wr = (self.relatingelement  !=  self.relatedelement)
		if not eval_notselfreference_wr:
			raise AssertionError('Rule notselfreference violated')
		else:
			return eval_notselfreference_wr


####################
 # ENTITY ifcsurfacestylerefraction #
####################
class ifcsurfacestylerefraction(ifcpresentationitem):
	'''Entity ifcsurfacestylerefraction definition.

	:param refractionindex
	:type refractionindex:ifcreal

	:param dispersionfactor
	:type dispersionfactor:ifcreal
	'''
	def __init__( self , refractionindex,dispersionfactor, ):
		ifcpresentationitem.__init__(self , )
		self.refractionindex = refractionindex
		self.dispersionfactor = dispersionfactor

	@apply
	def refractionindex():
		def fget( self ):
			return self._refractionindex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreal):
					self._refractionindex = ifcreal(value)
				else:
					self._refractionindex = value
			else:
				self._refractionindex = value
		return property(**locals())

	@apply
	def dispersionfactor():
		def fget( self ):
			return self._dispersionfactor
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreal):
					self._dispersionfactor = ifcreal(value)
				else:
					self._dispersionfactor = value
			else:
				self._dispersionfactor = value
		return property(**locals())

####################
 # ENTITY ifctessellateditem #
####################
class ifctessellateditem(ifcgeometricrepresentationitem):
	'''Entity ifctessellateditem definition.
	'''
	def __init__( self ,  ):
		ifcgeometricrepresentationitem.__init__(self , )

####################
 # ENTITY ifctessellatedfaceset #
####################
class ifctessellatedfaceset(ifctessellateditem):
	'''Entity ifctessellatedfaceset definition.

	:param coordinates
	:type coordinates:ifccartesianpointlist3d

	:param normals
	:type normals:LIST(1,None,LIST(3,3,'REAL', scope = schema_scope))

	:param closed
	:type closed:BOOLEAN

	:param hascolours
	:type hascolours:SET(0,1,'ifcindexedcolourmap', scope = schema_scope)

	:param hastextures
	:type hastextures:SET(0,None,'ifcindexedtexturemap', scope = schema_scope)
	'''
	def __init__( self , coordinates,normals,closed, ):
		ifctessellateditem.__init__(self , )
		self.coordinates = coordinates
		self.normals = normals
		self.closed = closed

	@apply
	def coordinates():
		def fget( self ):
			return self._coordinates
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordinates is mantatory and can not be set to None')
			if not check_type(value,ifccartesianpointlist3d):
				self._coordinates = ifccartesianpointlist3d(value)
			else:
				self._coordinates = value
		return property(**locals())

	@apply
	def normals():
		def fget( self ):
			return self._normals
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,LIST(3,3,'REAL', scope = schema_scope))):
					self._normals = LIST(value)
				else:
					self._normals = value
			else:
				self._normals = value
		return property(**locals())

	@apply
	def closed():
		def fget( self ):
			return self._closed
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._closed = BOOLEAN(value)
				else:
					self._closed = value
			else:
				self._closed = value
		return property(**locals())

	@apply
	def hascolours():
		def fget( self ):
			return self._hascolours
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hascolours is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hastextures():
		def fget( self ):
			return self._hastextures
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hastextures is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcpredefinedcurvefont #
####################
class ifcpredefinedcurvefont(ifcpredefineditem):
	'''Entity ifcpredefinedcurvefont definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefineditem.__init__(self , inherited0__name , )

####################
 # ENTITY ifcrampflight #
####################
class ifcrampflight(ifcbuildingelement):
	'''Entity ifcrampflight definition.

	:param predefinedtype
	:type predefinedtype:ifcrampflighttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrampflighttypeenum):
					self._predefinedtype = ifcrampflighttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcrampflighttypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcrampflighttypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCRAMPFLIGHTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcdiscreteaccessory #
####################
class ifcdiscreteaccessory(ifcelementcomponent):
	'''Entity ifcdiscreteaccessory definition.

	:param predefinedtype
	:type predefinedtype:ifcdiscreteaccessorytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcelementcomponent.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdiscreteaccessorytypeenum):
					self._predefinedtype = ifcdiscreteaccessorytypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcdiscreteaccessorytypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcdiscreteaccessorytypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCDISCRETEACCESSORYTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcperson #
####################
class ifcperson(BaseEntityClass):
	'''Entity ifcperson definition.

	:param identification
	:type identification:ifcidentifier

	:param familyname
	:type familyname:ifclabel

	:param givenname
	:type givenname:ifclabel

	:param middlenames
	:type middlenames:LIST(1,None,'STRING', scope = schema_scope)

	:param prefixtitles
	:type prefixtitles:LIST(1,None,'STRING', scope = schema_scope)

	:param suffixtitles
	:type suffixtitles:LIST(1,None,'STRING', scope = schema_scope)

	:param roles
	:type roles:LIST(1,None,'ifcactorrole', scope = schema_scope)

	:param addresses
	:type addresses:LIST(1,None,'ifcaddress', scope = schema_scope)

	:param engagedin
	:type engagedin:SET(0,None,'ifcpersonandorganization', scope = schema_scope)
	'''
	def __init__( self , identification,familyname,givenname,middlenames,prefixtitles,suffixtitles,roles,addresses, ):
		self.identification = identification
		self.familyname = familyname
		self.givenname = givenname
		self.middlenames = middlenames
		self.prefixtitles = prefixtitles
		self.suffixtitles = suffixtitles
		self.roles = roles
		self.addresses = addresses

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identification = ifcidentifier(value)
				else:
					self._identification = value
			else:
				self._identification = value
		return property(**locals())

	@apply
	def familyname():
		def fget( self ):
			return self._familyname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._familyname = ifclabel(value)
				else:
					self._familyname = value
			else:
				self._familyname = value
		return property(**locals())

	@apply
	def givenname():
		def fget( self ):
			return self._givenname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._givenname = ifclabel(value)
				else:
					self._givenname = value
			else:
				self._givenname = value
		return property(**locals())

	@apply
	def middlenames():
		def fget( self ):
			return self._middlenames
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._middlenames = LIST(value)
				else:
					self._middlenames = value
			else:
				self._middlenames = value
		return property(**locals())

	@apply
	def prefixtitles():
		def fget( self ):
			return self._prefixtitles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._prefixtitles = LIST(value)
				else:
					self._prefixtitles = value
			else:
				self._prefixtitles = value
		return property(**locals())

	@apply
	def suffixtitles():
		def fget( self ):
			return self._suffixtitles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._suffixtitles = LIST(value)
				else:
					self._suffixtitles = value
			else:
				self._suffixtitles = value
		return property(**locals())

	@apply
	def roles():
		def fget( self ):
			return self._roles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcactorrole', scope = schema_scope)):
					self._roles = LIST(value)
				else:
					self._roles = value
			else:
				self._roles = value
		return property(**locals())

	@apply
	def addresses():
		def fget( self ):
			return self._addresses
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcaddress', scope = schema_scope)):
					self._addresses = LIST(value)
				else:
					self._addresses = value
			else:
				self._addresses = value
		return property(**locals())

	@apply
	def engagedin():
		def fget( self ):
			return self._engagedin
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument engagedin is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def identifiableperson(self):
		eval_identifiableperson_wr = ((EXISTS(self.identification)  or  EXISTS(self.familyname))  or  EXISTS(self.givenname))
		if not eval_identifiableperson_wr:
			raise AssertionError('Rule identifiableperson violated')
		else:
			return eval_identifiableperson_wr

	def validsetofnames(self):
		eval_validsetofnames_wr = ((( not EXISTS(self.middlenames))  or  EXISTS(self.familyname))  or  EXISTS(self.givenname))
		if not eval_validsetofnames_wr:
			raise AssertionError('Rule validsetofnames violated')
		else:
			return eval_validsetofnames_wr


####################
 # ENTITY ifcairterminaltype #
####################
class ifcairterminaltype(ifcflowterminaltype):
	'''Entity ifcairterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcairterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcairterminaltypeenum):
				self._predefinedtype = ifcairterminaltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcairterminaltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcairterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcfacebound #
####################
class ifcfacebound(ifctopologicalrepresentationitem):
	'''Entity ifcfacebound definition.

	:param bound
	:type bound:ifcloop

	:param orientation
	:type orientation:BOOLEAN
	'''
	def __init__( self , bound,orientation, ):
		ifctopologicalrepresentationitem.__init__(self , )
		self.bound = bound
		self.orientation = orientation

	@apply
	def bound():
		def fget( self ):
			return self._bound
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bound is mantatory and can not be set to None')
			if not check_type(value,ifcloop):
				self._bound = ifcloop(value)
			else:
				self._bound = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY ifcfiresuppressionterminal #
####################
class ifcfiresuppressionterminal(ifcflowterminal):
	'''Entity ifcfiresuppressionterminal definition.

	:param predefinedtype
	:type predefinedtype:ifcfiresuppressionterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfiresuppressionterminaltypeenum):
					self._predefinedtype = ifcfiresuppressionterminaltypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcfiresuppressionterminaltypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcfiresuppressionterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCFIRESUPPRESSIONTERMINALTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcevaporativecooler #
####################
class ifcevaporativecooler(ifcenergyconversiondevice):
	'''Entity ifcevaporativecooler definition.

	:param predefinedtype
	:type predefinedtype:ifcevaporativecoolertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcevaporativecoolertypeenum):
					self._predefinedtype = ifcevaporativecoolertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcevaporativecoolertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcevaporativecoolertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCEVAPORATIVECOOLERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcsurfacestylelighting #
####################
class ifcsurfacestylelighting(ifcpresentationitem):
	'''Entity ifcsurfacestylelighting definition.

	:param diffusetransmissioncolour
	:type diffusetransmissioncolour:ifccolourrgb

	:param diffusereflectioncolour
	:type diffusereflectioncolour:ifccolourrgb

	:param transmissioncolour
	:type transmissioncolour:ifccolourrgb

	:param reflectancecolour
	:type reflectancecolour:ifccolourrgb
	'''
	def __init__( self , diffusetransmissioncolour,diffusereflectioncolour,transmissioncolour,reflectancecolour, ):
		ifcpresentationitem.__init__(self , )
		self.diffusetransmissioncolour = diffusetransmissioncolour
		self.diffusereflectioncolour = diffusereflectioncolour
		self.transmissioncolour = transmissioncolour
		self.reflectancecolour = reflectancecolour

	@apply
	def diffusetransmissioncolour():
		def fget( self ):
			return self._diffusetransmissioncolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument diffusetransmissioncolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._diffusetransmissioncolour = ifccolourrgb(value)
			else:
				self._diffusetransmissioncolour = value
		return property(**locals())

	@apply
	def diffusereflectioncolour():
		def fget( self ):
			return self._diffusereflectioncolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument diffusereflectioncolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._diffusereflectioncolour = ifccolourrgb(value)
			else:
				self._diffusereflectioncolour = value
		return property(**locals())

	@apply
	def transmissioncolour():
		def fget( self ):
			return self._transmissioncolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transmissioncolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._transmissioncolour = ifccolourrgb(value)
			else:
				self._transmissioncolour = value
		return property(**locals())

	@apply
	def reflectancecolour():
		def fget( self ):
			return self._reflectancecolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reflectancecolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._reflectancecolour = ifccolourrgb(value)
			else:
				self._reflectancecolour = value
		return property(**locals())

####################
 # ENTITY ifctasktype #
####################
class ifctasktype(ifctypeprocess):
	'''Entity ifctasktype definition.

	:param predefinedtype
	:type predefinedtype:ifctasktypeenum

	:param workmethod
	:type workmethod:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__processtype , predefinedtype,workmethod, ):
		ifctypeprocess.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__processtype , )
		self.predefinedtype = predefinedtype
		self.workmethod = workmethod

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctasktypeenum):
				self._predefinedtype = ifctasktypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def workmethod():
		def fget( self ):
			return self._workmethod
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._workmethod = ifclabel(value)
				else:
					self._workmethod = value
			else:
				self._workmethod = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifctasktypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifctasktypeenum.self.userdefined)  and  EXISTS(self.self.ifctypeprocess.self.processtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifctendon #
####################
class ifctendon(ifcreinforcingelement):
	'''Entity ifctendon definition.

	:param predefinedtype
	:type predefinedtype:ifctendontypeenum

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param crosssectionarea
	:type crosssectionarea:ifcareameasure

	:param tensionforce
	:type tensionforce:ifcforcemeasure

	:param prestress
	:type prestress:ifcpressuremeasure

	:param frictioncoefficient
	:type frictioncoefficient:ifcnormalisedratiomeasure

	:param anchorageslip
	:type anchorageslip:ifcpositivelengthmeasure

	:param mincurvatureradius
	:type mincurvatureradius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , predefinedtype,nominaldiameter,crosssectionarea,tensionforce,prestress,frictioncoefficient,anchorageslip,mincurvatureradius, ):
		ifcreinforcingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , )
		self.predefinedtype = predefinedtype
		self.nominaldiameter = nominaldiameter
		self.crosssectionarea = crosssectionarea
		self.tensionforce = tensionforce
		self.prestress = prestress
		self.frictioncoefficient = frictioncoefficient
		self.anchorageslip = anchorageslip
		self.mincurvatureradius = mincurvatureradius

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctendontypeenum):
					self._predefinedtype = ifctendontypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def nominaldiameter():
		def fget( self ):
			return self._nominaldiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominaldiameter = ifcpositivelengthmeasure(value)
				else:
					self._nominaldiameter = value
			else:
				self._nominaldiameter = value
		return property(**locals())

	@apply
	def crosssectionarea():
		def fget( self ):
			return self._crosssectionarea
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._crosssectionarea = ifcareameasure(value)
				else:
					self._crosssectionarea = value
			else:
				self._crosssectionarea = value
		return property(**locals())

	@apply
	def tensionforce():
		def fget( self ):
			return self._tensionforce
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._tensionforce = ifcforcemeasure(value)
				else:
					self._tensionforce = value
			else:
				self._tensionforce = value
		return property(**locals())

	@apply
	def prestress():
		def fget( self ):
			return self._prestress
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpressuremeasure):
					self._prestress = ifcpressuremeasure(value)
				else:
					self._prestress = value
			else:
				self._prestress = value
		return property(**locals())

	@apply
	def frictioncoefficient():
		def fget( self ):
			return self._frictioncoefficient
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._frictioncoefficient = ifcnormalisedratiomeasure(value)
				else:
					self._frictioncoefficient = value
			else:
				self._frictioncoefficient = value
		return property(**locals())

	@apply
	def anchorageslip():
		def fget( self ):
			return self._anchorageslip
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._anchorageslip = ifcpositivelengthmeasure(value)
				else:
					self._anchorageslip = value
			else:
				self._anchorageslip = value
		return property(**locals())

	@apply
	def mincurvatureradius():
		def fget( self ):
			return self._mincurvatureradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._mincurvatureradius = ifcpositivelengthmeasure(value)
				else:
					self._mincurvatureradius = value
			else:
				self._mincurvatureradius = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifctendontypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifctendontypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCTENDONTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcownerhistory #
####################
class ifcownerhistory(BaseEntityClass):
	'''Entity ifcownerhistory definition.

	:param owninguser
	:type owninguser:ifcpersonandorganization

	:param owningapplication
	:type owningapplication:ifcapplication

	:param state
	:type state:ifcstateenum

	:param changeaction
	:type changeaction:ifcchangeactionenum

	:param lastmodifieddate
	:type lastmodifieddate:ifctimestamp

	:param lastmodifyinguser
	:type lastmodifyinguser:ifcpersonandorganization

	:param lastmodifyingapplication
	:type lastmodifyingapplication:ifcapplication

	:param creationdate
	:type creationdate:ifctimestamp
	'''
	def __init__( self , owninguser,owningapplication,state,changeaction,lastmodifieddate,lastmodifyinguser,lastmodifyingapplication,creationdate, ):
		self.owninguser = owninguser
		self.owningapplication = owningapplication
		self.state = state
		self.changeaction = changeaction
		self.lastmodifieddate = lastmodifieddate
		self.lastmodifyinguser = lastmodifyinguser
		self.lastmodifyingapplication = lastmodifyingapplication
		self.creationdate = creationdate

	@apply
	def owninguser():
		def fget( self ):
			return self._owninguser
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument owninguser is mantatory and can not be set to None')
			if not check_type(value,ifcpersonandorganization):
				self._owninguser = ifcpersonandorganization(value)
			else:
				self._owninguser = value
		return property(**locals())

	@apply
	def owningapplication():
		def fget( self ):
			return self._owningapplication
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument owningapplication is mantatory and can not be set to None')
			if not check_type(value,ifcapplication):
				self._owningapplication = ifcapplication(value)
			else:
				self._owningapplication = value
		return property(**locals())

	@apply
	def state():
		def fget( self ):
			return self._state
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcstateenum):
					self._state = ifcstateenum(value)
				else:
					self._state = value
			else:
				self._state = value
		return property(**locals())

	@apply
	def changeaction():
		def fget( self ):
			return self._changeaction
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcchangeactionenum):
					self._changeaction = ifcchangeactionenum(value)
				else:
					self._changeaction = value
			else:
				self._changeaction = value
		return property(**locals())

	@apply
	def lastmodifieddate():
		def fget( self ):
			return self._lastmodifieddate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimestamp):
					self._lastmodifieddate = ifctimestamp(value)
				else:
					self._lastmodifieddate = value
			else:
				self._lastmodifieddate = value
		return property(**locals())

	@apply
	def lastmodifyinguser():
		def fget( self ):
			return self._lastmodifyinguser
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpersonandorganization):
					self._lastmodifyinguser = ifcpersonandorganization(value)
				else:
					self._lastmodifyinguser = value
			else:
				self._lastmodifyinguser = value
		return property(**locals())

	@apply
	def lastmodifyingapplication():
		def fget( self ):
			return self._lastmodifyingapplication
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcapplication):
					self._lastmodifyingapplication = ifcapplication(value)
				else:
					self._lastmodifyingapplication = value
			else:
				self._lastmodifyingapplication = value
		return property(**locals())

	@apply
	def creationdate():
		def fget( self ):
			return self._creationdate
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument creationdate is mantatory and can not be set to None')
			if not check_type(value,ifctimestamp):
				self._creationdate = ifctimestamp(value)
			else:
				self._creationdate = value
		return property(**locals())
	def correctchangeaction(self):
		eval_correctchangeaction_wr = ((EXISTS(self.lastmodifieddate)  or  (( not EXISTS(self.lastmodifieddate))  and  ( not EXISTS(self.changeaction))))  or  ((( not EXISTS(self.lastmodifieddate))  and  EXISTS(self.changeaction))  and  ((self.changeaction  ==  ifcchangeactionenum.self.notdefined)  or  (self.changeaction  ==  ifcchangeactionenum.self.nochange))))
		if not eval_correctchangeaction_wr:
			raise AssertionError('Rule correctchangeaction violated')
		else:
			return eval_correctchangeaction_wr


####################
 # ENTITY ifcsurfacestylewithtextures #
####################
class ifcsurfacestylewithtextures(ifcpresentationitem):
	'''Entity ifcsurfacestylewithtextures definition.

	:param textures
	:type textures:LIST(1,None,'ifcsurfacetexture', scope = schema_scope)
	'''
	def __init__( self , textures, ):
		ifcpresentationitem.__init__(self , )
		self.textures = textures

	@apply
	def textures():
		def fget( self ):
			return self._textures
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument textures is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcsurfacetexture', scope = schema_scope)):
				self._textures = LIST(value)
			else:
				self._textures = value
		return property(**locals())

####################
 # ENTITY ifcpipefitting #
####################
class ifcpipefitting(ifcflowfitting):
	'''Entity ifcpipefitting definition.

	:param predefinedtype
	:type predefinedtype:ifcpipefittingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowfitting.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpipefittingtypeenum):
					self._predefinedtype = ifcpipefittingtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcpipefittingtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcpipefittingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCPIPEFITTINGTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcproject #
####################
class ifcproject(ifccontext):
	'''Entity ifcproject definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__longname , inherited6__phase , inherited7__representationcontexts , inherited8__unitsincontext ,  ):
		ifccontext.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__longname , inherited6__phase , inherited7__representationcontexts , inherited8__unitsincontext , )
	def hasname(self):
		eval_hasname_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_hasname_wr:
			raise AssertionError('Rule hasname violated')
		else:
			return eval_hasname_wr

	def correctcontext(self):
		eval_correctcontext_wr = (( not EXISTS(self.self.ifccontext.self.representationcontexts))  or  (SIZEOF(None)  ==  0))
		if not eval_correctcontext_wr:
			raise AssertionError('Rule correctcontext violated')
		else:
			return eval_correctcontext_wr

	def nodecomposition(self):
		eval_nodecomposition_wr = (SIZEOF(self.self.ifcobjectdefinition.self.decomposes)  ==  0)
		if not eval_nodecomposition_wr:
			raise AssertionError('Rule nodecomposition violated')
		else:
			return eval_nodecomposition_wr

	def hasownerhistory(self):
		eval_hasownerhistory_wr = EXISTS(self.self.ifcroot.self.ownerhistory)
		if not eval_hasownerhistory_wr:
			raise AssertionError('Rule hasownerhistory violated')
		else:
			return eval_hasownerhistory_wr


####################
 # ENTITY ifccolumnstandardcase #
####################
class ifccolumnstandardcase(ifccolumn):
	'''Entity ifccolumnstandardcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype ,  ):
		ifccolumn.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype , )
	def hasmaterialprofilesetusage(self):
		eval_hasmaterialprofilesetusage_wr = (SIZEOF(None)  ==  1)
		if not eval_hasmaterialprofilesetusage_wr:
			raise AssertionError('Rule hasmaterialprofilesetusage violated')
		else:
			return eval_hasmaterialprofilesetusage_wr


####################
 # ENTITY ifcflowstoragedevicetype #
####################
class ifcflowstoragedevicetype(ifcdistributionflowelementtype):
	'''Entity ifcflowstoragedevicetype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcelectricflowstoragedevicetype #
####################
class ifcelectricflowstoragedevicetype(ifcflowstoragedevicetype):
	'''Entity ifcelectricflowstoragedevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricflowstoragedevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowstoragedevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectricflowstoragedevicetypeenum):
				self._predefinedtype = ifcelectricflowstoragedevicetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcelectricflowstoragedevicetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcelectricflowstoragedevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcplane #
####################
class ifcplane(ifcelementarysurface):
	'''Entity ifcplane definition.
	'''
	def __init__( self , inherited0__position ,  ):
		ifcelementarysurface.__init__(self , inherited0__position , )

####################
 # ENTITY ifcstructuralloadgroup #
####################
class ifcstructuralloadgroup(ifcgroup):
	'''Entity ifcstructuralloadgroup definition.

	:param predefinedtype
	:type predefinedtype:ifcloadgrouptypeenum

	:param actiontype
	:type actiontype:ifcactiontypeenum

	:param actionsource
	:type actionsource:ifcactionsourcetypeenum

	:param coefficient
	:type coefficient:ifcratiomeasure

	:param purpose
	:type purpose:ifclabel

	:param sourceofresultgroup
	:type sourceofresultgroup:SET(0,1,'ifcstructuralresultgroup', scope = schema_scope)

	:param loadgroupfor
	:type loadgroupfor:SET(0,None,'ifcstructuralanalysismodel', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , predefinedtype,actiontype,actionsource,coefficient,purpose, ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.predefinedtype = predefinedtype
		self.actiontype = actiontype
		self.actionsource = actionsource
		self.coefficient = coefficient
		self.purpose = purpose

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcloadgrouptypeenum):
				self._predefinedtype = ifcloadgrouptypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def actiontype():
		def fget( self ):
			return self._actiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actiontype is mantatory and can not be set to None')
			if not check_type(value,ifcactiontypeenum):
				self._actiontype = ifcactiontypeenum(value)
			else:
				self._actiontype = value
		return property(**locals())

	@apply
	def actionsource():
		def fget( self ):
			return self._actionsource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actionsource is mantatory and can not be set to None')
			if not check_type(value,ifcactionsourcetypeenum):
				self._actionsource = ifcactionsourcetypeenum(value)
			else:
				self._actionsource = value
		return property(**locals())

	@apply
	def coefficient():
		def fget( self ):
			return self._coefficient
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcratiomeasure):
					self._coefficient = ifcratiomeasure(value)
				else:
					self._coefficient = value
			else:
				self._coefficient = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._purpose = ifclabel(value)
				else:
					self._purpose = value
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def sourceofresultgroup():
		def fget( self ):
			return self._sourceofresultgroup
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument sourceofresultgroup is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def loadgroupfor():
		def fget( self ):
			return self._loadgroupfor
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument loadgroupfor is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def hasobjecttype(self):
		eval_hasobjecttype_wr = ((((self.predefinedtype  !=  ifcloadgrouptypeenum.self.userdefined)  and  (self.actiontype  !=  ifcactiontypeenum.self.userdefined))  and  (self.actionsource  !=  ifcactionsourcetypeenum.self.userdefined))  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_hasobjecttype_wr:
			raise AssertionError('Rule hasobjecttype violated')
		else:
			return eval_hasobjecttype_wr


####################
 # ENTITY ifcstructuralloadcase #
####################
class ifcstructuralloadcase(ifcstructuralloadgroup):
	'''Entity ifcstructuralloadcase definition.

	:param selfweightcoefficients
	:type selfweightcoefficients:LIST(3,3,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__predefinedtype , inherited6__actiontype , inherited7__actionsource , inherited8__coefficient , inherited9__purpose , selfweightcoefficients, ):
		ifcstructuralloadgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__predefinedtype , inherited6__actiontype , inherited7__actionsource , inherited8__coefficient , inherited9__purpose , )
		self.selfweightcoefficients = selfweightcoefficients

	@apply
	def selfweightcoefficients():
		def fget( self ):
			return self._selfweightcoefficients
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(3,3,'REAL', scope = schema_scope)):
					self._selfweightcoefficients = LIST(value)
				else:
					self._selfweightcoefficients = value
			else:
				self._selfweightcoefficients = value
		return property(**locals())
	def isloadcasepredefinedtype(self):
		eval_isloadcasepredefinedtype_wr = (self.self.ifcstructuralloadgroup.self.predefinedtype  ==  ifcloadgrouptypeenum.self.load_case)
		if not eval_isloadcasepredefinedtype_wr:
			raise AssertionError('Rule isloadcasepredefinedtype violated')
		else:
			return eval_isloadcasepredefinedtype_wr


####################
 # ENTITY ifccolourspecification #
####################
class ifccolourspecification(ifcpresentationitem):
	'''Entity ifccolourspecification definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		ifcpresentationitem.__init__(self , )
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifccolourrgb #
####################
class ifccolourrgb(ifccolourspecification):
	'''Entity ifccolourrgb definition.

	:param red
	:type red:ifcnormalisedratiomeasure

	:param green
	:type green:ifcnormalisedratiomeasure

	:param blue
	:type blue:ifcnormalisedratiomeasure
	'''
	def __init__( self , inherited0__name , red,green,blue, ):
		ifccolourspecification.__init__(self , inherited0__name , )
		self.red = red
		self.green = green
		self.blue = blue

	@apply
	def red():
		def fget( self ):
			return self._red
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument red is mantatory and can not be set to None')
			if not check_type(value,ifcnormalisedratiomeasure):
				self._red = ifcnormalisedratiomeasure(value)
			else:
				self._red = value
		return property(**locals())

	@apply
	def green():
		def fget( self ):
			return self._green
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument green is mantatory and can not be set to None')
			if not check_type(value,ifcnormalisedratiomeasure):
				self._green = ifcnormalisedratiomeasure(value)
			else:
				self._green = value
		return property(**locals())

	@apply
	def blue():
		def fget( self ):
			return self._blue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument blue is mantatory and can not be set to None')
			if not check_type(value,ifcnormalisedratiomeasure):
				self._blue = ifcnormalisedratiomeasure(value)
			else:
				self._blue = value
		return property(**locals())

####################
 # ENTITY ifcductsilencer #
####################
class ifcductsilencer(ifcflowtreatmentdevice):
	'''Entity ifcductsilencer definition.

	:param predefinedtype
	:type predefinedtype:ifcductsilencertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowtreatmentdevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcductsilencertypeenum):
					self._predefinedtype = ifcductsilencertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcductsilencertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcductsilencertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCDUCTSILENCERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcwasteterminal #
####################
class ifcwasteterminal(ifcflowterminal):
	'''Entity ifcwasteterminal definition.

	:param predefinedtype
	:type predefinedtype:ifcwasteterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcwasteterminaltypeenum):
					self._predefinedtype = ifcwasteterminaltypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcwasteterminaltypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcwasteterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCWASTETERMINALTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifccablefitting #
####################
class ifccablefitting(ifcflowfitting):
	'''Entity ifccablefitting definition.

	:param predefinedtype
	:type predefinedtype:ifccablefittingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowfitting.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccablefittingtypeenum):
					self._predefinedtype = ifccablefittingtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccablefittingtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccablefittingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCABLEFITTINGTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcreinforcingbar #
####################
class ifcreinforcingbar(ifcreinforcingelement):
	'''Entity ifcreinforcingbar definition.

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param crosssectionarea
	:type crosssectionarea:ifcareameasure

	:param barlength
	:type barlength:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcreinforcingbartypeenum

	:param barsurface
	:type barsurface:ifcreinforcingbarsurfaceenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , nominaldiameter,crosssectionarea,barlength,predefinedtype,barsurface, ):
		ifcreinforcingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , )
		self.nominaldiameter = nominaldiameter
		self.crosssectionarea = crosssectionarea
		self.barlength = barlength
		self.predefinedtype = predefinedtype
		self.barsurface = barsurface

	@apply
	def nominaldiameter():
		def fget( self ):
			return self._nominaldiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominaldiameter = ifcpositivelengthmeasure(value)
				else:
					self._nominaldiameter = value
			else:
				self._nominaldiameter = value
		return property(**locals())

	@apply
	def crosssectionarea():
		def fget( self ):
			return self._crosssectionarea
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._crosssectionarea = ifcareameasure(value)
				else:
					self._crosssectionarea = value
			else:
				self._crosssectionarea = value
		return property(**locals())

	@apply
	def barlength():
		def fget( self ):
			return self._barlength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._barlength = ifcpositivelengthmeasure(value)
				else:
					self._barlength = value
			else:
				self._barlength = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreinforcingbartypeenum):
					self._predefinedtype = ifcreinforcingbartypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def barsurface():
		def fget( self ):
			return self._barsurface
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreinforcingbarsurfaceenum):
					self._barsurface = ifcreinforcingbarsurfaceenum(value)
				else:
					self._barsurface = value
			else:
				self._barsurface = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcreinforcingbartypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcreinforcingbartypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCREINFORCINGBARTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcunitaryequipment #
####################
class ifcunitaryequipment(ifcenergyconversiondevice):
	'''Entity ifcunitaryequipment definition.

	:param predefinedtype
	:type predefinedtype:ifcunitaryequipmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunitaryequipmenttypeenum):
					self._predefinedtype = ifcunitaryequipmenttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcunitaryequipmenttypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcunitaryequipmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCUNITARYEQUIPMENTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcpermit #
####################
class ifcpermit(ifccontrol):
	'''Entity ifcpermit definition.

	:param predefinedtype
	:type predefinedtype:ifcpermittypeenum

	:param status
	:type status:ifclabel

	:param longdescription
	:type longdescription:ifctext
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , predefinedtype,status,longdescription, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , )
		self.predefinedtype = predefinedtype
		self.status = status
		self.longdescription = longdescription

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpermittypeenum):
					self._predefinedtype = ifcpermittypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._status = ifclabel(value)
				else:
					self._status = value
			else:
				self._status = value
		return property(**locals())

	@apply
	def longdescription():
		def fget( self ):
			return self._longdescription
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._longdescription = ifctext(value)
				else:
					self._longdescription = value
			else:
				self._longdescription = value
		return property(**locals())

####################
 # ENTITY ifcsurfacestyleshading #
####################
class ifcsurfacestyleshading(ifcpresentationitem):
	'''Entity ifcsurfacestyleshading definition.

	:param surfacecolour
	:type surfacecolour:ifccolourrgb
	'''
	def __init__( self , surfacecolour, ):
		ifcpresentationitem.__init__(self , )
		self.surfacecolour = surfacecolour

	@apply
	def surfacecolour():
		def fget( self ):
			return self._surfacecolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument surfacecolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._surfacecolour = ifccolourrgb(value)
			else:
				self._surfacecolour = value
		return property(**locals())

####################
 # ENTITY ifcsurfacestylerendering #
####################
class ifcsurfacestylerendering(ifcsurfacestyleshading):
	'''Entity ifcsurfacestylerendering definition.

	:param transparency
	:type transparency:ifcnormalisedratiomeasure

	:param diffusecolour
	:type diffusecolour:ifccolourorfactor

	:param transmissioncolour
	:type transmissioncolour:ifccolourorfactor

	:param diffusetransmissioncolour
	:type diffusetransmissioncolour:ifccolourorfactor

	:param reflectioncolour
	:type reflectioncolour:ifccolourorfactor

	:param specularcolour
	:type specularcolour:ifccolourorfactor

	:param specularhighlight
	:type specularhighlight:ifcspecularhighlightselect

	:param reflectancemethod
	:type reflectancemethod:ifcreflectancemethodenum
	'''
	def __init__( self , inherited0__surfacecolour , transparency,diffusecolour,transmissioncolour,diffusetransmissioncolour,reflectioncolour,specularcolour,specularhighlight,reflectancemethod, ):
		ifcsurfacestyleshading.__init__(self , inherited0__surfacecolour , )
		self.transparency = transparency
		self.diffusecolour = diffusecolour
		self.transmissioncolour = transmissioncolour
		self.diffusetransmissioncolour = diffusetransmissioncolour
		self.reflectioncolour = reflectioncolour
		self.specularcolour = specularcolour
		self.specularhighlight = specularhighlight
		self.reflectancemethod = reflectancemethod

	@apply
	def transparency():
		def fget( self ):
			return self._transparency
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._transparency = ifcnormalisedratiomeasure(value)
				else:
					self._transparency = value
			else:
				self._transparency = value
		return property(**locals())

	@apply
	def diffusecolour():
		def fget( self ):
			return self._diffusecolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourorfactor):
					self._diffusecolour = ifccolourorfactor(value)
				else:
					self._diffusecolour = value
			else:
				self._diffusecolour = value
		return property(**locals())

	@apply
	def transmissioncolour():
		def fget( self ):
			return self._transmissioncolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourorfactor):
					self._transmissioncolour = ifccolourorfactor(value)
				else:
					self._transmissioncolour = value
			else:
				self._transmissioncolour = value
		return property(**locals())

	@apply
	def diffusetransmissioncolour():
		def fget( self ):
			return self._diffusetransmissioncolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourorfactor):
					self._diffusetransmissioncolour = ifccolourorfactor(value)
				else:
					self._diffusetransmissioncolour = value
			else:
				self._diffusetransmissioncolour = value
		return property(**locals())

	@apply
	def reflectioncolour():
		def fget( self ):
			return self._reflectioncolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourorfactor):
					self._reflectioncolour = ifccolourorfactor(value)
				else:
					self._reflectioncolour = value
			else:
				self._reflectioncolour = value
		return property(**locals())

	@apply
	def specularcolour():
		def fget( self ):
			return self._specularcolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourorfactor):
					self._specularcolour = ifccolourorfactor(value)
				else:
					self._specularcolour = value
			else:
				self._specularcolour = value
		return property(**locals())

	@apply
	def specularhighlight():
		def fget( self ):
			return self._specularhighlight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcspecularhighlightselect):
					self._specularhighlight = ifcspecularhighlightselect(value)
				else:
					self._specularhighlight = value
			else:
				self._specularhighlight = value
		return property(**locals())

	@apply
	def reflectancemethod():
		def fget( self ):
			return self._reflectancemethod
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reflectancemethod is mantatory and can not be set to None')
			if not check_type(value,ifcreflectancemethodenum):
				self._reflectancemethod = ifcreflectancemethodenum(value)
			else:
				self._reflectancemethod = value
		return property(**locals())

####################
 # ENTITY ifcelectrictimecontroltype #
####################
class ifcelectrictimecontroltype(ifcflowcontrollertype):
	'''Entity ifcelectrictimecontroltype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectrictimecontroltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectrictimecontroltypeenum):
				self._predefinedtype = ifcelectrictimecontroltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcelectrictimecontroltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcelectrictimecontroltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifccoordinateoperation #
####################
class ifccoordinateoperation(BaseEntityClass):
	'''Entity ifccoordinateoperation definition.

	:param sourcecrs
	:type sourcecrs:ifccoordinatereferencesystemselect

	:param targetcrs
	:type targetcrs:ifccoordinatereferencesystem
	'''
	def __init__( self , sourcecrs,targetcrs, ):
		self.sourcecrs = sourcecrs
		self.targetcrs = targetcrs

	@apply
	def sourcecrs():
		def fget( self ):
			return self._sourcecrs
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sourcecrs is mantatory and can not be set to None')
			if not check_type(value,ifccoordinatereferencesystemselect):
				self._sourcecrs = ifccoordinatereferencesystemselect(value)
			else:
				self._sourcecrs = value
		return property(**locals())

	@apply
	def targetcrs():
		def fget( self ):
			return self._targetcrs
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument targetcrs is mantatory and can not be set to None')
			if not check_type(value,ifccoordinatereferencesystem):
				self._targetcrs = ifccoordinatereferencesystem(value)
			else:
				self._targetcrs = value
		return property(**locals())

####################
 # ENTITY ifcmapconversion #
####################
class ifcmapconversion(ifccoordinateoperation):
	'''Entity ifcmapconversion definition.

	:param eastings
	:type eastings:ifclengthmeasure

	:param northings
	:type northings:ifclengthmeasure

	:param orthogonalheight
	:type orthogonalheight:ifclengthmeasure

	:param xaxisabscissa
	:type xaxisabscissa:ifcreal

	:param xaxisordinate
	:type xaxisordinate:ifcreal

	:param scale
	:type scale:ifcreal
	'''
	def __init__( self , inherited0__sourcecrs , inherited1__targetcrs , eastings,northings,orthogonalheight,xaxisabscissa,xaxisordinate,scale, ):
		ifccoordinateoperation.__init__(self , inherited0__sourcecrs , inherited1__targetcrs , )
		self.eastings = eastings
		self.northings = northings
		self.orthogonalheight = orthogonalheight
		self.xaxisabscissa = xaxisabscissa
		self.xaxisordinate = xaxisordinate
		self.scale = scale

	@apply
	def eastings():
		def fget( self ):
			return self._eastings
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument eastings is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._eastings = ifclengthmeasure(value)
			else:
				self._eastings = value
		return property(**locals())

	@apply
	def northings():
		def fget( self ):
			return self._northings
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument northings is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._northings = ifclengthmeasure(value)
			else:
				self._northings = value
		return property(**locals())

	@apply
	def orthogonalheight():
		def fget( self ):
			return self._orthogonalheight
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orthogonalheight is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._orthogonalheight = ifclengthmeasure(value)
			else:
				self._orthogonalheight = value
		return property(**locals())

	@apply
	def xaxisabscissa():
		def fget( self ):
			return self._xaxisabscissa
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreal):
					self._xaxisabscissa = ifcreal(value)
				else:
					self._xaxisabscissa = value
			else:
				self._xaxisabscissa = value
		return property(**locals())

	@apply
	def xaxisordinate():
		def fget( self ):
			return self._xaxisordinate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreal):
					self._xaxisordinate = ifcreal(value)
				else:
					self._xaxisordinate = value
			else:
				self._xaxisordinate = value
		return property(**locals())

	@apply
	def scale():
		def fget( self ):
			return self._scale
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreal):
					self._scale = ifcreal(value)
				else:
					self._scale = value
			else:
				self._scale = value
		return property(**locals())

####################
 # ENTITY ifcstackterminaltype #
####################
class ifcstackterminaltype(ifcflowterminaltype):
	'''Entity ifcstackterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcstackterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstackterminaltypeenum):
				self._predefinedtype = ifcstackterminaltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcstackterminaltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcstackterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifctank #
####################
class ifctank(ifcflowstoragedevice):
	'''Entity ifctank definition.

	:param predefinedtype
	:type predefinedtype:ifctanktypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowstoragedevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctanktypeenum):
					self._predefinedtype = ifctanktypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifctanktypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifctanktypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCTANKTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifctasktime #
####################
class ifctasktime(ifcschedulingtime):
	'''Entity ifctasktime definition.

	:param durationtype
	:type durationtype:ifctaskdurationenum

	:param scheduleduration
	:type scheduleduration:ifcduration

	:param schedulestart
	:type schedulestart:ifcdatetime

	:param schedulefinish
	:type schedulefinish:ifcdatetime

	:param earlystart
	:type earlystart:ifcdatetime

	:param earlyfinish
	:type earlyfinish:ifcdatetime

	:param latestart
	:type latestart:ifcdatetime

	:param latefinish
	:type latefinish:ifcdatetime

	:param freefloat
	:type freefloat:ifcduration

	:param totalfloat
	:type totalfloat:ifcduration

	:param iscritical
	:type iscritical:BOOLEAN

	:param statustime
	:type statustime:ifcdatetime

	:param actualduration
	:type actualduration:ifcduration

	:param actualstart
	:type actualstart:ifcdatetime

	:param actualfinish
	:type actualfinish:ifcdatetime

	:param remainingtime
	:type remainingtime:ifcduration

	:param completion
	:type completion:ifcpositiveratiomeasure
	'''
	def __init__( self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , durationtype,scheduleduration,schedulestart,schedulefinish,earlystart,earlyfinish,latestart,latefinish,freefloat,totalfloat,iscritical,statustime,actualduration,actualstart,actualfinish,remainingtime,completion, ):
		ifcschedulingtime.__init__(self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , )
		self.durationtype = durationtype
		self.scheduleduration = scheduleduration
		self.schedulestart = schedulestart
		self.schedulefinish = schedulefinish
		self.earlystart = earlystart
		self.earlyfinish = earlyfinish
		self.latestart = latestart
		self.latefinish = latefinish
		self.freefloat = freefloat
		self.totalfloat = totalfloat
		self.iscritical = iscritical
		self.statustime = statustime
		self.actualduration = actualduration
		self.actualstart = actualstart
		self.actualfinish = actualfinish
		self.remainingtime = remainingtime
		self.completion = completion

	@apply
	def durationtype():
		def fget( self ):
			return self._durationtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctaskdurationenum):
					self._durationtype = ifctaskdurationenum(value)
				else:
					self._durationtype = value
			else:
				self._durationtype = value
		return property(**locals())

	@apply
	def scheduleduration():
		def fget( self ):
			return self._scheduleduration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcduration):
					self._scheduleduration = ifcduration(value)
				else:
					self._scheduleduration = value
			else:
				self._scheduleduration = value
		return property(**locals())

	@apply
	def schedulestart():
		def fget( self ):
			return self._schedulestart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._schedulestart = ifcdatetime(value)
				else:
					self._schedulestart = value
			else:
				self._schedulestart = value
		return property(**locals())

	@apply
	def schedulefinish():
		def fget( self ):
			return self._schedulefinish
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._schedulefinish = ifcdatetime(value)
				else:
					self._schedulefinish = value
			else:
				self._schedulefinish = value
		return property(**locals())

	@apply
	def earlystart():
		def fget( self ):
			return self._earlystart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._earlystart = ifcdatetime(value)
				else:
					self._earlystart = value
			else:
				self._earlystart = value
		return property(**locals())

	@apply
	def earlyfinish():
		def fget( self ):
			return self._earlyfinish
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._earlyfinish = ifcdatetime(value)
				else:
					self._earlyfinish = value
			else:
				self._earlyfinish = value
		return property(**locals())

	@apply
	def latestart():
		def fget( self ):
			return self._latestart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._latestart = ifcdatetime(value)
				else:
					self._latestart = value
			else:
				self._latestart = value
		return property(**locals())

	@apply
	def latefinish():
		def fget( self ):
			return self._latefinish
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._latefinish = ifcdatetime(value)
				else:
					self._latefinish = value
			else:
				self._latefinish = value
		return property(**locals())

	@apply
	def freefloat():
		def fget( self ):
			return self._freefloat
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcduration):
					self._freefloat = ifcduration(value)
				else:
					self._freefloat = value
			else:
				self._freefloat = value
		return property(**locals())

	@apply
	def totalfloat():
		def fget( self ):
			return self._totalfloat
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcduration):
					self._totalfloat = ifcduration(value)
				else:
					self._totalfloat = value
			else:
				self._totalfloat = value
		return property(**locals())

	@apply
	def iscritical():
		def fget( self ):
			return self._iscritical
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._iscritical = BOOLEAN(value)
				else:
					self._iscritical = value
			else:
				self._iscritical = value
		return property(**locals())

	@apply
	def statustime():
		def fget( self ):
			return self._statustime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._statustime = ifcdatetime(value)
				else:
					self._statustime = value
			else:
				self._statustime = value
		return property(**locals())

	@apply
	def actualduration():
		def fget( self ):
			return self._actualduration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcduration):
					self._actualduration = ifcduration(value)
				else:
					self._actualduration = value
			else:
				self._actualduration = value
		return property(**locals())

	@apply
	def actualstart():
		def fget( self ):
			return self._actualstart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._actualstart = ifcdatetime(value)
				else:
					self._actualstart = value
			else:
				self._actualstart = value
		return property(**locals())

	@apply
	def actualfinish():
		def fget( self ):
			return self._actualfinish
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._actualfinish = ifcdatetime(value)
				else:
					self._actualfinish = value
			else:
				self._actualfinish = value
		return property(**locals())

	@apply
	def remainingtime():
		def fget( self ):
			return self._remainingtime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcduration):
					self._remainingtime = ifcduration(value)
				else:
					self._remainingtime = value
			else:
				self._remainingtime = value
		return property(**locals())

	@apply
	def completion():
		def fget( self ):
			return self._completion
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._completion = ifcpositiveratiomeasure(value)
				else:
					self._completion = value
			else:
				self._completion = value
		return property(**locals())

####################
 # ENTITY ifctasktimerecurring #
####################
class ifctasktimerecurring(ifctasktime):
	'''Entity ifctasktimerecurring definition.

	:param recurrance
	:type recurrance:ifcrecurrencepattern
	'''
	def __init__( self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , inherited3__durationtype , inherited4__scheduleduration , inherited5__schedulestart , inherited6__schedulefinish , inherited7__earlystart , inherited8__earlyfinish , inherited9__latestart , inherited10__latefinish , inherited11__freefloat , inherited12__totalfloat , inherited13__iscritical , inherited14__statustime , inherited15__actualduration , inherited16__actualstart , inherited17__actualfinish , inherited18__remainingtime , inherited19__completion , recurrance, ):
		ifctasktime.__init__(self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , inherited3__durationtype , inherited4__scheduleduration , inherited5__schedulestart , inherited6__schedulefinish , inherited7__earlystart , inherited8__earlyfinish , inherited9__latestart , inherited10__latefinish , inherited11__freefloat , inherited12__totalfloat , inherited13__iscritical , inherited14__statustime , inherited15__actualduration , inherited16__actualstart , inherited17__actualfinish , inherited18__remainingtime , inherited19__completion , )
		self.recurrance = recurrance

	@apply
	def recurrance():
		def fget( self ):
			return self._recurrance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument recurrance is mantatory and can not be set to None')
			if not check_type(value,ifcrecurrencepattern):
				self._recurrance = ifcrecurrencepattern(value)
			else:
				self._recurrance = value
		return property(**locals())

####################
 # ENTITY ifcport #
####################
class ifcport(ifcproduct):
	'''Entity ifcport definition.

	:param containedin
	:type containedin:SET(0,1,'ifcrelconnectsporttoelement', scope = schema_scope)

	:param connectedfrom
	:type connectedfrom:SET(0,1,'ifcrelconnectsports', scope = schema_scope)

	:param connectedto
	:type connectedto:SET(0,1,'ifcrelconnectsports', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation ,  ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )

	@apply
	def containedin():
		def fget( self ):
			return self._containedin
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument containedin is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def connectedfrom():
		def fget( self ):
			return self._connectedfrom
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectedfrom is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def connectedto():
		def fget( self ):
			return self._connectedto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectedto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcprotectivedevicetrippingunit #
####################
class ifcprotectivedevicetrippingunit(ifcdistributioncontrolelement):
	'''Entity ifcprotectivedevicetrippingunit definition.

	:param predefinedtype
	:type predefinedtype:ifcprotectivedevicetrippingunittypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcdistributioncontrolelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcprotectivedevicetrippingunittypeenum):
					self._predefinedtype = ifcprotectivedevicetrippingunittypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcprotectivedevicetrippingunittypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcprotectivedevicetrippingunittypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCPROTECTIVEDEVICETRIPPINGUNITTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifctendonanchortype #
####################
class ifctendonanchortype(ifcreinforcingelementtype):
	'''Entity ifctendonanchortype definition.

	:param predefinedtype
	:type predefinedtype:ifctendonanchortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcreinforcingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctendonanchortypeenum):
				self._predefinedtype = ifctendonanchortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifctendonanchortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifctendonanchortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcairtoairheatrecovery #
####################
class ifcairtoairheatrecovery(ifcenergyconversiondevice):
	'''Entity ifcairtoairheatrecovery definition.

	:param predefinedtype
	:type predefinedtype:ifcairtoairheatrecoverytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcairtoairheatrecoverytypeenum):
					self._predefinedtype = ifcairtoairheatrecoverytypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcairtoairheatrecoverytypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcairtoairheatrecoverytypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCAIRTOAIRHEATRECOVERYTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcchillertype #
####################
class ifcchillertype(ifcenergyconversiondevicetype):
	'''Entity ifcchillertype definition.

	:param predefinedtype
	:type predefinedtype:ifcchillertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcchillertypeenum):
				self._predefinedtype = ifcchillertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcchillertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcchillertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifccooledbeamtype #
####################
class ifccooledbeamtype(ifcenergyconversiondevicetype):
	'''Entity ifccooledbeamtype definition.

	:param predefinedtype
	:type predefinedtype:ifccooledbeamtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccooledbeamtypeenum):
				self._predefinedtype = ifccooledbeamtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccooledbeamtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccooledbeamtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcpersonandorganization #
####################
class ifcpersonandorganization(BaseEntityClass):
	'''Entity ifcpersonandorganization definition.

	:param theperson
	:type theperson:ifcperson

	:param theorganization
	:type theorganization:ifcorganization

	:param roles
	:type roles:LIST(1,None,'ifcactorrole', scope = schema_scope)
	'''
	def __init__( self , theperson,theorganization,roles, ):
		self.theperson = theperson
		self.theorganization = theorganization
		self.roles = roles

	@apply
	def theperson():
		def fget( self ):
			return self._theperson
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument theperson is mantatory and can not be set to None')
			if not check_type(value,ifcperson):
				self._theperson = ifcperson(value)
			else:
				self._theperson = value
		return property(**locals())

	@apply
	def theorganization():
		def fget( self ):
			return self._theorganization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument theorganization is mantatory and can not be set to None')
			if not check_type(value,ifcorganization):
				self._theorganization = ifcorganization(value)
			else:
				self._theorganization = value
		return property(**locals())

	@apply
	def roles():
		def fget( self ):
			return self._roles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcactorrole', scope = schema_scope)):
					self._roles = LIST(value)
				else:
					self._roles = value
			else:
				self._roles = value
		return property(**locals())

####################
 # ENTITY ifcpostaladdress #
####################
class ifcpostaladdress(ifcaddress):
	'''Entity ifcpostaladdress definition.

	:param internallocation
	:type internallocation:ifclabel

	:param addresslines
	:type addresslines:LIST(1,None,'STRING', scope = schema_scope)

	:param postalbox
	:type postalbox:ifclabel

	:param town
	:type town:ifclabel

	:param region
	:type region:ifclabel

	:param postalcode
	:type postalcode:ifclabel

	:param country
	:type country:ifclabel
	'''
	def __init__( self , inherited0__purpose , inherited1__description , inherited2__userdefinedpurpose , internallocation,addresslines,postalbox,town,region,postalcode,country, ):
		ifcaddress.__init__(self , inherited0__purpose , inherited1__description , inherited2__userdefinedpurpose , )
		self.internallocation = internallocation
		self.addresslines = addresslines
		self.postalbox = postalbox
		self.town = town
		self.region = region
		self.postalcode = postalcode
		self.country = country

	@apply
	def internallocation():
		def fget( self ):
			return self._internallocation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._internallocation = ifclabel(value)
				else:
					self._internallocation = value
			else:
				self._internallocation = value
		return property(**locals())

	@apply
	def addresslines():
		def fget( self ):
			return self._addresslines
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._addresslines = LIST(value)
				else:
					self._addresslines = value
			else:
				self._addresslines = value
		return property(**locals())

	@apply
	def postalbox():
		def fget( self ):
			return self._postalbox
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._postalbox = ifclabel(value)
				else:
					self._postalbox = value
			else:
				self._postalbox = value
		return property(**locals())

	@apply
	def town():
		def fget( self ):
			return self._town
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._town = ifclabel(value)
				else:
					self._town = value
			else:
				self._town = value
		return property(**locals())

	@apply
	def region():
		def fget( self ):
			return self._region
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._region = ifclabel(value)
				else:
					self._region = value
			else:
				self._region = value
		return property(**locals())

	@apply
	def postalcode():
		def fget( self ):
			return self._postalcode
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._postalcode = ifclabel(value)
				else:
					self._postalcode = value
			else:
				self._postalcode = value
		return property(**locals())

	@apply
	def country():
		def fget( self ):
			return self._country
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._country = ifclabel(value)
				else:
					self._country = value
			else:
				self._country = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((((((EXISTS(self.internallocation)  or  EXISTS(self.addresslines))  or  EXISTS(self.postalbox))  or  EXISTS(self.postalcode))  or  EXISTS(self.town))  or  EXISTS(self.region))  or  EXISTS(self.country))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifctimeperiod #
####################
class ifctimeperiod(BaseEntityClass):
	'''Entity ifctimeperiod definition.

	:param starttime
	:type starttime:ifctime

	:param endtime
	:type endtime:ifctime
	'''
	def __init__( self , starttime,endtime, ):
		self.starttime = starttime
		self.endtime = endtime

	@apply
	def starttime():
		def fget( self ):
			return self._starttime
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument starttime is mantatory and can not be set to None')
			if not check_type(value,ifctime):
				self._starttime = ifctime(value)
			else:
				self._starttime = value
		return property(**locals())

	@apply
	def endtime():
		def fget( self ):
			return self._endtime
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument endtime is mantatory and can not be set to None')
			if not check_type(value,ifctime):
				self._endtime = ifctime(value)
			else:
				self._endtime = value
		return property(**locals())

####################
 # ENTITY ifcmappeditem #
####################
class ifcmappeditem(ifcrepresentationitem):
	'''Entity ifcmappeditem definition.

	:param mappingsource
	:type mappingsource:ifcrepresentationmap

	:param mappingtarget
	:type mappingtarget:ifccartesiantransformationoperator
	'''
	def __init__( self , mappingsource,mappingtarget, ):
		ifcrepresentationitem.__init__(self , )
		self.mappingsource = mappingsource
		self.mappingtarget = mappingtarget

	@apply
	def mappingsource():
		def fget( self ):
			return self._mappingsource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mappingsource is mantatory and can not be set to None')
			if not check_type(value,ifcrepresentationmap):
				self._mappingsource = ifcrepresentationmap(value)
			else:
				self._mappingsource = value
		return property(**locals())

	@apply
	def mappingtarget():
		def fget( self ):
			return self._mappingtarget
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mappingtarget is mantatory and can not be set to None')
			if not check_type(value,ifccartesiantransformationoperator):
				self._mappingtarget = ifccartesiantransformationoperator(value)
			else:
				self._mappingtarget = value
		return property(**locals())

####################
 # ENTITY ifcoutlettype #
####################
class ifcoutlettype(ifcflowterminaltype):
	'''Entity ifcoutlettype definition.

	:param predefinedtype
	:type predefinedtype:ifcoutlettypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcoutlettypeenum):
				self._predefinedtype = ifcoutlettypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcoutlettypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcoutlettypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcslabstandardcase #
####################
class ifcslabstandardcase(ifcslab):
	'''Entity ifcslabstandardcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype ,  ):
		ifcslab.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype , )
	def hasmateriallayersetusage(self):
		eval_hasmateriallayersetusage_wr = (SIZEOF(None)  ==  1)
		if not eval_hasmateriallayersetusage_wr:
			raise AssertionError('Rule hasmateriallayersetusage violated')
		else:
			return eval_hasmateriallayersetusage_wr


####################
 # ENTITY ifcpointoncurve #
####################
class ifcpointoncurve(ifcpoint):
	'''Entity ifcpointoncurve definition.

	:param basiscurve
	:type basiscurve:ifccurve

	:param pointparameter
	:type pointparameter:ifcparametervalue

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , basiscurve,pointparameter, ):
		ifcpoint.__init__(self , )
		self.basiscurve = basiscurve
		self.pointparameter = pointparameter

	@apply
	def basiscurve():
		def fget( self ):
			return self._basiscurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basiscurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._basiscurve = ifccurve(value)
			else:
				self._basiscurve = value
		return property(**locals())

	@apply
	def pointparameter():
		def fget( self ):
			return self._pointparameter
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pointparameter is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._pointparameter = ifcparametervalue(value)
			else:
				self._pointparameter = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.basiscurve.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcrelsequence #
####################
class ifcrelsequence(ifcrelconnects):
	'''Entity ifcrelsequence definition.

	:param relatingprocess
	:type relatingprocess:ifcprocess

	:param relatedprocess
	:type relatedprocess:ifcprocess

	:param timelag
	:type timelag:ifclagtime

	:param sequencetype
	:type sequencetype:ifcsequenceenum

	:param userdefinedsequencetype
	:type userdefinedsequencetype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingprocess,relatedprocess,timelag,sequencetype,userdefinedsequencetype, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingprocess = relatingprocess
		self.relatedprocess = relatedprocess
		self.timelag = timelag
		self.sequencetype = sequencetype
		self.userdefinedsequencetype = userdefinedsequencetype

	@apply
	def relatingprocess():
		def fget( self ):
			return self._relatingprocess
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingprocess is mantatory and can not be set to None')
			if not check_type(value,ifcprocess):
				self._relatingprocess = ifcprocess(value)
			else:
				self._relatingprocess = value
		return property(**locals())

	@apply
	def relatedprocess():
		def fget( self ):
			return self._relatedprocess
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedprocess is mantatory and can not be set to None')
			if not check_type(value,ifcprocess):
				self._relatedprocess = ifcprocess(value)
			else:
				self._relatedprocess = value
		return property(**locals())

	@apply
	def timelag():
		def fget( self ):
			return self._timelag
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclagtime):
					self._timelag = ifclagtime(value)
				else:
					self._timelag = value
			else:
				self._timelag = value
		return property(**locals())

	@apply
	def sequencetype():
		def fget( self ):
			return self._sequencetype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsequenceenum):
					self._sequencetype = ifcsequenceenum(value)
				else:
					self._sequencetype = value
			else:
				self._sequencetype = value
		return property(**locals())

	@apply
	def userdefinedsequencetype():
		def fget( self ):
			return self._userdefinedsequencetype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedsequencetype = ifclabel(value)
				else:
					self._userdefinedsequencetype = value
			else:
				self._userdefinedsequencetype = value
		return property(**locals())
	def avoidinconsistentsequence(self):
		eval_avoidinconsistentsequence_wr = (self.relatingprocess  !=  self.relatedprocess)
		if not eval_avoidinconsistentsequence_wr:
			raise AssertionError('Rule avoidinconsistentsequence violated')
		else:
			return eval_avoidinconsistentsequence_wr

	def correctsequencetype(self):
		eval_correctsequencetype_wr = ((self.sequencetype  !=  ifcsequenceenum.self.userdefined)  or  ((self.sequencetype  ==  ifcsequenceenum.self.userdefined)  and  EXISTS(self.userdefinedsequencetype)))
		if not eval_correctsequencetype_wr:
			raise AssertionError('Rule correctsequencetype violated')
		else:
			return eval_correctsequencetype_wr


####################
 # ENTITY ifcfacetedbrepwithvoids #
####################
class ifcfacetedbrepwithvoids(ifcfacetedbrep):
	'''Entity ifcfacetedbrepwithvoids definition.

	:param voids
	:type voids:SET(1,None,'ifcclosedshell', scope = schema_scope)
	'''
	def __init__( self , inherited0__outer , voids, ):
		ifcfacetedbrep.__init__(self , inherited0__outer , )
		self.voids = voids

	@apply
	def voids():
		def fget( self ):
			return self._voids
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument voids is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcclosedshell', scope = schema_scope)):
				self._voids = SET(value)
			else:
				self._voids = value
		return property(**locals())

####################
 # ENTITY ifccoiltype #
####################
class ifccoiltype(ifcenergyconversiondevicetype):
	'''Entity ifccoiltype definition.

	:param predefinedtype
	:type predefinedtype:ifccoiltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccoiltypeenum):
				self._predefinedtype = ifccoiltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccoiltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccoiltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcrelconnectsstructuralmember #
####################
class ifcrelconnectsstructuralmember(ifcrelconnects):
	'''Entity ifcrelconnectsstructuralmember definition.

	:param relatingstructuralmember
	:type relatingstructuralmember:ifcstructuralmember

	:param relatedstructuralconnection
	:type relatedstructuralconnection:ifcstructuralconnection

	:param appliedcondition
	:type appliedcondition:ifcboundarycondition

	:param additionalconditions
	:type additionalconditions:ifcstructuralconnectioncondition

	:param supportedlength
	:type supportedlength:ifclengthmeasure

	:param conditioncoordinatesystem
	:type conditioncoordinatesystem:ifcaxis2placement3d
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingstructuralmember,relatedstructuralconnection,appliedcondition,additionalconditions,supportedlength,conditioncoordinatesystem, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingstructuralmember = relatingstructuralmember
		self.relatedstructuralconnection = relatedstructuralconnection
		self.appliedcondition = appliedcondition
		self.additionalconditions = additionalconditions
		self.supportedlength = supportedlength
		self.conditioncoordinatesystem = conditioncoordinatesystem

	@apply
	def relatingstructuralmember():
		def fget( self ):
			return self._relatingstructuralmember
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingstructuralmember is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralmember):
				self._relatingstructuralmember = ifcstructuralmember(value)
			else:
				self._relatingstructuralmember = value
		return property(**locals())

	@apply
	def relatedstructuralconnection():
		def fget( self ):
			return self._relatedstructuralconnection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedstructuralconnection is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralconnection):
				self._relatedstructuralconnection = ifcstructuralconnection(value)
			else:
				self._relatedstructuralconnection = value
		return property(**locals())

	@apply
	def appliedcondition():
		def fget( self ):
			return self._appliedcondition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcboundarycondition):
					self._appliedcondition = ifcboundarycondition(value)
				else:
					self._appliedcondition = value
			else:
				self._appliedcondition = value
		return property(**locals())

	@apply
	def additionalconditions():
		def fget( self ):
			return self._additionalconditions
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcstructuralconnectioncondition):
					self._additionalconditions = ifcstructuralconnectioncondition(value)
				else:
					self._additionalconditions = value
			else:
				self._additionalconditions = value
		return property(**locals())

	@apply
	def supportedlength():
		def fget( self ):
			return self._supportedlength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._supportedlength = ifclengthmeasure(value)
				else:
					self._supportedlength = value
			else:
				self._supportedlength = value
		return property(**locals())

	@apply
	def conditioncoordinatesystem():
		def fget( self ):
			return self._conditioncoordinatesystem
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaxis2placement3d):
					self._conditioncoordinatesystem = ifcaxis2placement3d(value)
				else:
					self._conditioncoordinatesystem = value
			else:
				self._conditioncoordinatesystem = value
		return property(**locals())

####################
 # ENTITY ifcrelconnectswitheccentricity #
####################
class ifcrelconnectswitheccentricity(ifcrelconnectsstructuralmember):
	'''Entity ifcrelconnectswitheccentricity definition.

	:param connectionconstraint
	:type connectionconstraint:ifcconnectiongeometry
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingstructuralmember , inherited5__relatedstructuralconnection , inherited6__appliedcondition , inherited7__additionalconditions , inherited8__supportedlength , inherited9__conditioncoordinatesystem , connectionconstraint, ):
		ifcrelconnectsstructuralmember.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingstructuralmember , inherited5__relatedstructuralconnection , inherited6__appliedcondition , inherited7__additionalconditions , inherited8__supportedlength , inherited9__conditioncoordinatesystem , )
		self.connectionconstraint = connectionconstraint

	@apply
	def connectionconstraint():
		def fget( self ):
			return self._connectionconstraint
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument connectionconstraint is mantatory and can not be set to None')
			if not check_type(value,ifcconnectiongeometry):
				self._connectionconstraint = ifcconnectiongeometry(value)
			else:
				self._connectionconstraint = value
		return property(**locals())

####################
 # ENTITY ifcrelfillselement #
####################
class ifcrelfillselement(ifcrelconnects):
	'''Entity ifcrelfillselement definition.

	:param relatingopeningelement
	:type relatingopeningelement:ifcopeningelement

	:param relatedbuildingelement
	:type relatedbuildingelement:ifcelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingopeningelement,relatedbuildingelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingopeningelement = relatingopeningelement
		self.relatedbuildingelement = relatedbuildingelement

	@apply
	def relatingopeningelement():
		def fget( self ):
			return self._relatingopeningelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingopeningelement is mantatory and can not be set to None')
			if not check_type(value,ifcopeningelement):
				self._relatingopeningelement = ifcopeningelement(value)
			else:
				self._relatingopeningelement = value
		return property(**locals())

	@apply
	def relatedbuildingelement():
		def fget( self ):
			return self._relatedbuildingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedbuildingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatedbuildingelement = ifcelement(value)
			else:
				self._relatedbuildingelement = value
		return property(**locals())

####################
 # ENTITY ifcrepresentationmap #
####################
class ifcrepresentationmap(BaseEntityClass):
	'''Entity ifcrepresentationmap definition.

	:param mappingorigin
	:type mappingorigin:ifcaxis2placement

	:param mappedrepresentation
	:type mappedrepresentation:ifcrepresentation

	:param hasshapeaspects
	:type hasshapeaspects:SET(0,None,'ifcshapeaspect', scope = schema_scope)

	:param mapusage
	:type mapusage:SET(0,None,'ifcmappeditem', scope = schema_scope)
	'''
	def __init__( self , mappingorigin,mappedrepresentation, ):
		self.mappingorigin = mappingorigin
		self.mappedrepresentation = mappedrepresentation

	@apply
	def mappingorigin():
		def fget( self ):
			return self._mappingorigin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mappingorigin is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._mappingorigin = ifcaxis2placement(value)
			else:
				self._mappingorigin = value
		return property(**locals())

	@apply
	def mappedrepresentation():
		def fget( self ):
			return self._mappedrepresentation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mappedrepresentation is mantatory and can not be set to None')
			if not check_type(value,ifcrepresentation):
				self._mappedrepresentation = ifcrepresentation(value)
			else:
				self._mappedrepresentation = value
		return property(**locals())

	@apply
	def hasshapeaspects():
		def fget( self ):
			return self._hasshapeaspects
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasshapeaspects is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def mapusage():
		def fget( self ):
			return self._mapusage
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument mapusage is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def applicablemappedrepr(self):
		eval_applicablemappedrepr_wr = ('IFC4.IFCSHAPEMODEL'  ==  TYPEOF(self.mappedrepresentation))
		if not eval_applicablemappedrepr_wr:
			raise AssertionError('Rule applicablemappedrepr violated')
		else:
			return eval_applicablemappedrepr_wr


####################
 # ENTITY ifcslabelementedcase #
####################
class ifcslabelementedcase(ifcslab):
	'''Entity ifcslabelementedcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype ,  ):
		ifcslab.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype , )
	def hasdecomposition(self):
		eval_hasdecomposition_wr = (HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  >  0)
		if not eval_hasdecomposition_wr:
			raise AssertionError('Rule hasdecomposition violated')
		else:
			return eval_hasdecomposition_wr


####################
 # ENTITY ifcpcurve #
####################
class ifcpcurve(ifccurve):
	'''Entity ifcpcurve definition.

	:param basissurface
	:type basissurface:ifcsurface

	:param referencecurve
	:type referencecurve:ifccurve
	'''
	def __init__( self , basissurface,referencecurve, ):
		ifccurve.__init__(self , )
		self.basissurface = basissurface
		self.referencecurve = referencecurve

	@apply
	def basissurface():
		def fget( self ):
			return self._basissurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basissurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._basissurface = ifcsurface(value)
			else:
				self._basissurface = value
		return property(**locals())

	@apply
	def referencecurve():
		def fget( self ):
			return self._referencecurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument referencecurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._referencecurve = ifccurve(value)
			else:
				self._referencecurve = value
		return property(**locals())
	def dimis2d(self):
		eval_dimis2d_wr = (self.referencecurve.self.dim  ==  2)
		if not eval_dimis2d_wr:
			raise AssertionError('Rule dimis2d violated')
		else:
			return eval_dimis2d_wr


####################
 # ENTITY ifcvirtualgridintersection #
####################
class ifcvirtualgridintersection(BaseEntityClass):
	'''Entity ifcvirtualgridintersection definition.

	:param intersectingaxes
	:type intersectingaxes:LIST(2,2,'ifcgridaxis', scope = schema_scope)

	:param offsetdistances
	:type offsetdistances:LIST(2,3,'REAL', scope = schema_scope)
	'''
	def __init__( self , intersectingaxes,offsetdistances, ):
		self.intersectingaxes = intersectingaxes
		self.offsetdistances = offsetdistances

	@apply
	def intersectingaxes():
		def fget( self ):
			return self._intersectingaxes
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument intersectingaxes is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'ifcgridaxis', scope = schema_scope)):
				self._intersectingaxes = LIST(value)
			else:
				self._intersectingaxes = value
		return property(**locals())

	@apply
	def offsetdistances():
		def fget( self ):
			return self._offsetdistances
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offsetdistances is mantatory and can not be set to None')
			if not check_type(value,LIST(2,3,'REAL', scope = schema_scope)):
				self._offsetdistances = LIST(value)
			else:
				self._offsetdistances = value
		return property(**locals())

####################
 # ENTITY ifccoordinatereferencesystem #
####################
class ifccoordinatereferencesystem(BaseEntityClass):
	'''Entity ifccoordinatereferencesystem definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param geodeticdatum
	:type geodeticdatum:ifcidentifier

	:param verticaldatum
	:type verticaldatum:ifcidentifier
	'''
	def __init__( self , name,description,geodeticdatum,verticaldatum, ):
		self.name = name
		self.description = description
		self.geodeticdatum = geodeticdatum
		self.verticaldatum = verticaldatum

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def geodeticdatum():
		def fget( self ):
			return self._geodeticdatum
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument geodeticdatum is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._geodeticdatum = ifcidentifier(value)
			else:
				self._geodeticdatum = value
		return property(**locals())

	@apply
	def verticaldatum():
		def fget( self ):
			return self._verticaldatum
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._verticaldatum = ifcidentifier(value)
				else:
					self._verticaldatum = value
			else:
				self._verticaldatum = value
		return property(**locals())

####################
 # ENTITY ifclightsourceambient #
####################
class ifclightsourceambient(ifclightsource):
	'''Entity ifclightsourceambient definition.
	'''
	def __init__( self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity ,  ):
		ifclightsource.__init__(self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , )

####################
 # ENTITY ifcprotectivedevicetrippingunittype #
####################
class ifcprotectivedevicetrippingunittype(ifcdistributioncontrolelementtype):
	'''Entity ifcprotectivedevicetrippingunittype definition.

	:param predefinedtype
	:type predefinedtype:ifcprotectivedevicetrippingunittypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcprotectivedevicetrippingunittypeenum):
				self._predefinedtype = ifcprotectivedevicetrippingunittypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcprotectivedevicetrippingunittypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcprotectivedevicetrippingunittypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcrelreferencedinspatialstructure #
####################
class ifcrelreferencedinspatialstructure(ifcrelconnects):
	'''Entity ifcrelreferencedinspatialstructure definition.

	:param relatedelements
	:type relatedelements:SET(1,None,'ifcproduct', scope = schema_scope)

	:param relatingstructure
	:type relatingstructure:ifcspatialelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedelements,relatingstructure, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedelements = relatedelements
		self.relatingstructure = relatingstructure

	@apply
	def relatedelements():
		def fget( self ):
			return self._relatedelements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedelements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproduct', scope = schema_scope)):
				self._relatedelements = SET(value)
			else:
				self._relatedelements = value
		return property(**locals())

	@apply
	def relatingstructure():
		def fget( self ):
			return self._relatingstructure
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingstructure is mantatory and can not be set to None')
			if not check_type(value,ifcspatialelement):
				self._relatingstructure = ifcspatialelement(value)
			else:
				self._relatingstructure = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (SIZEOF(None)  ==  0)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifccostvalue #
####################
class ifccostvalue(ifcappliedvalue):
	'''Entity ifccostvalue definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__appliedvalue , inherited3__unitbasis , inherited4__applicabledate , inherited5__fixeduntildate , inherited6__category , inherited7__condition , inherited8__arithmeticoperator , inherited9__components ,  ):
		ifcappliedvalue.__init__(self , inherited0__name , inherited1__description , inherited2__appliedvalue , inherited3__unitbasis , inherited4__applicabledate , inherited5__fixeduntildate , inherited6__category , inherited7__condition , inherited8__arithmeticoperator , inherited9__components , )

####################
 # ENTITY ifcfan #
####################
class ifcfan(ifcflowmovingdevice):
	'''Entity ifcfan definition.

	:param predefinedtype
	:type predefinedtype:ifcfantypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowmovingdevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfantypeenum):
					self._predefinedtype = ifcfantypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcfantypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcfantypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCFANTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcbsplinecurvewithknots #
####################
class ifcbsplinecurvewithknots(ifcbsplinecurve):
	'''Entity ifcbsplinecurvewithknots definition.

	:param knotmultiplicities
	:type knotmultiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param knots
	:type knots:LIST(2,None,'REAL', scope = schema_scope)

	:param knotspec
	:type knotspec:ifcknottype

	:param upperindexonknots
	:type upperindexonknots:INTEGER
	'''
	def __init__( self , inherited0__degree , inherited1__controlpointslist , inherited2__curveform , inherited3__closedcurve , inherited4__selfintersect , knotmultiplicities,knots,knotspec, ):
		ifcbsplinecurve.__init__(self , inherited0__degree , inherited1__controlpointslist , inherited2__curveform , inherited3__closedcurve , inherited4__selfintersect , )
		self.knotmultiplicities = knotmultiplicities
		self.knots = knots
		self.knotspec = knotspec

	@apply
	def knotmultiplicities():
		def fget( self ):
			return self._knotmultiplicities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knotmultiplicities is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
				self._knotmultiplicities = LIST(value)
			else:
				self._knotmultiplicities = value
		return property(**locals())

	@apply
	def knots():
		def fget( self ):
			return self._knots
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knots is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._knots = LIST(value)
			else:
				self._knots = value
		return property(**locals())

	@apply
	def knotspec():
		def fget( self ):
			return self._knotspec
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knotspec is mantatory and can not be set to None')
			if not check_type(value,ifcknottype):
				self._knotspec = ifcknottype(value)
			else:
				self._knotspec = value
		return property(**locals())

	@apply
	def upperindexonknots():
		def fget( self ):
			attribute_eval = SIZEOF(self.knots)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument upperindexonknots is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def consistentbspline(self):
		eval_consistentbspline_wr = ifcconstraintsparambspline(self.degree,self.upperindexonknots,self.upperindexoncontrolpoints,self.knotmultiplicities,self.knots)
		if not eval_consistentbspline_wr:
			raise AssertionError('Rule consistentbspline violated')
		else:
			return eval_consistentbspline_wr

	def correspondingknotlists(self):
		eval_correspondingknotlists_wr = (SIZEOF(self.knotmultiplicities)  ==  self.upperindexonknots)
		if not eval_correspondingknotlists_wr:
			raise AssertionError('Rule correspondingknotlists violated')
		else:
			return eval_correspondingknotlists_wr


####################
 # ENTITY ifcrationalbsplinecurvewithknots #
####################
class ifcrationalbsplinecurvewithknots(ifcbsplinecurvewithknots):
	'''Entity ifcrationalbsplinecurvewithknots definition.

	:param weightsdata
	:type weightsdata:LIST(2,None,'REAL', scope = schema_scope)

	:param weights
	:type weights:ARRAY(0,upperindexoncontrolpoints,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__degree , inherited1__controlpointslist , inherited2__curveform , inherited3__closedcurve , inherited4__selfintersect , inherited5__knotmultiplicities , inherited6__knots , inherited7__knotspec , weightsdata, ):
		ifcbsplinecurvewithknots.__init__(self , inherited0__degree , inherited1__controlpointslist , inherited2__curveform , inherited3__closedcurve , inherited4__selfintersect , inherited5__knotmultiplicities , inherited6__knots , inherited7__knotspec , )
		self.weightsdata = weightsdata

	@apply
	def weightsdata():
		def fget( self ):
			return self._weightsdata
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument weightsdata is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._weightsdata = LIST(value)
			else:
				self._weightsdata = value
		return property(**locals())

	@apply
	def weights():
		def fget( self ):
			attribute_eval = ifclisttoarray(self.weightsdata,0,self.self.ifcbsplinecurve.self.upperindexoncontrolpoints)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument weights is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def samenumofweightsandpoints(self):
		eval_samenumofweightsandpoints_wr = (SIZEOF(self.weightsdata)  ==  SIZEOF(self.self.ifcbsplinecurve.self.controlpointslist))
		if not eval_samenumofweightsandpoints_wr:
			raise AssertionError('Rule samenumofweightsandpoints violated')
		else:
			return eval_samenumofweightsandpoints_wr

	def weightsgreaterzero(self):
		eval_weightsgreaterzero_wr = ifccurveweightspositive(self)
		if not eval_weightsgreaterzero_wr:
			raise AssertionError('Rule weightsgreaterzero violated')
		else:
			return eval_weightsgreaterzero_wr


####################
 # ENTITY ifcrooftype #
####################
class ifcrooftype(ifcbuildingelementtype):
	'''Entity ifcrooftype definition.

	:param predefinedtype
	:type predefinedtype:ifcrooftypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcrooftypeenum):
				self._predefinedtype = ifcrooftypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcrooftypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcrooftypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcimagetexture #
####################
class ifcimagetexture(ifcsurfacetexture):
	'''Entity ifcimagetexture definition.

	:param urlreference
	:type urlreference:ifcurireference
	'''
	def __init__( self , inherited0__repeats , inherited1__repeatt , inherited2__mode , inherited3__texturetransform , inherited4__parameter , urlreference, ):
		ifcsurfacetexture.__init__(self , inherited0__repeats , inherited1__repeatt , inherited2__mode , inherited3__texturetransform , inherited4__parameter , )
		self.urlreference = urlreference

	@apply
	def urlreference():
		def fget( self ):
			return self._urlreference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument urlreference is mantatory and can not be set to None')
			if not check_type(value,ifcurireference):
				self._urlreference = ifcurireference(value)
			else:
				self._urlreference = value
		return property(**locals())

####################
 # ENTITY ifcloop #
####################
class ifcloop(ifctopologicalrepresentationitem):
	'''Entity ifcloop definition.
	'''
	def __init__( self ,  ):
		ifctopologicalrepresentationitem.__init__(self , )

####################
 # ENTITY ifcvertexloop #
####################
class ifcvertexloop(ifcloop):
	'''Entity ifcvertexloop definition.

	:param loopvertex
	:type loopvertex:ifcvertex
	'''
	def __init__( self , loopvertex, ):
		ifcloop.__init__(self , )
		self.loopvertex = loopvertex

	@apply
	def loopvertex():
		def fget( self ):
			return self._loopvertex
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument loopvertex is mantatory and can not be set to None')
			if not check_type(value,ifcvertex):
				self._loopvertex = ifcvertex(value)
			else:
				self._loopvertex = value
		return property(**locals())

####################
 # ENTITY ifcarbitraryclosedprofiledef #
####################
class ifcarbitraryclosedprofiledef(ifcprofiledef):
	'''Entity ifcarbitraryclosedprofiledef definition.

	:param outercurve
	:type outercurve:ifccurve
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , outercurve, ):
		ifcprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , )
		self.outercurve = outercurve

	@apply
	def outercurve():
		def fget( self ):
			return self._outercurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outercurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._outercurve = ifccurve(value)
			else:
				self._outercurve = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.outercurve.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not ('IFC4.IFCLINE'  ==  TYPEOF(self.outercurve)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ( not ('IFC4.IFCOFFSETCURVE2D'  ==  TYPEOF(self.outercurve)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcarbitraryprofiledefwithvoids #
####################
class ifcarbitraryprofiledefwithvoids(ifcarbitraryclosedprofiledef):
	'''Entity ifcarbitraryprofiledefwithvoids definition.

	:param innercurves
	:type innercurves:SET(1,None,'ifccurve', scope = schema_scope)
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__outercurve , innercurves, ):
		ifcarbitraryclosedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__outercurve , )
		self.innercurves = innercurves

	@apply
	def innercurves():
		def fget( self ):
			return self._innercurves
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument innercurves is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifccurve', scope = schema_scope)):
				self._innercurves = SET(value)
			else:
				self._innercurves = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.ifcprofiledef.self.profiletype  ==  area)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcsanitaryterminaltype #
####################
class ifcsanitaryterminaltype(ifcflowterminaltype):
	'''Entity ifcsanitaryterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcsanitaryterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcsanitaryterminaltypeenum):
				self._predefinedtype = ifcsanitaryterminaltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcsanitaryterminaltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcsanitaryterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcswitchingdevicetype #
####################
class ifcswitchingdevicetype(ifcflowcontrollertype):
	'''Entity ifcswitchingdevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcswitchingdevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcswitchingdevicetypeenum):
				self._predefinedtype = ifcswitchingdevicetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcswitchingdevicetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcswitchingdevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcapproval #
####################
class ifcapproval(BaseEntityClass):
	'''Entity ifcapproval definition.

	:param identifier
	:type identifier:ifcidentifier

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param timeofapproval
	:type timeofapproval:ifcdatetime

	:param status
	:type status:ifclabel

	:param level
	:type level:ifclabel

	:param qualifier
	:type qualifier:ifctext

	:param requestingapproval
	:type requestingapproval:ifcactorselect

	:param givingapproval
	:type givingapproval:ifcactorselect

	:param hasexternalreferences
	:type hasexternalreferences:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)

	:param approvedobjects
	:type approvedobjects:SET(0,None,'ifcrelassociatesapproval', scope = schema_scope)

	:param approvedresources
	:type approvedresources:SET(0,None,'ifcresourceapprovalrelationship', scope = schema_scope)

	:param isrelatedwith
	:type isrelatedwith:SET(0,None,'ifcapprovalrelationship', scope = schema_scope)

	:param relates
	:type relates:SET(0,None,'ifcapprovalrelationship', scope = schema_scope)
	'''
	def __init__( self , identifier,name,description,timeofapproval,status,level,qualifier,requestingapproval,givingapproval, ):
		self.identifier = identifier
		self.name = name
		self.description = description
		self.timeofapproval = timeofapproval
		self.status = status
		self.level = level
		self.qualifier = qualifier
		self.requestingapproval = requestingapproval
		self.givingapproval = givingapproval

	@apply
	def identifier():
		def fget( self ):
			return self._identifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identifier = ifcidentifier(value)
				else:
					self._identifier = value
			else:
				self._identifier = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def timeofapproval():
		def fget( self ):
			return self._timeofapproval
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._timeofapproval = ifcdatetime(value)
				else:
					self._timeofapproval = value
			else:
				self._timeofapproval = value
		return property(**locals())

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._status = ifclabel(value)
				else:
					self._status = value
			else:
				self._status = value
		return property(**locals())

	@apply
	def level():
		def fget( self ):
			return self._level
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._level = ifclabel(value)
				else:
					self._level = value
			else:
				self._level = value
		return property(**locals())

	@apply
	def qualifier():
		def fget( self ):
			return self._qualifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._qualifier = ifctext(value)
				else:
					self._qualifier = value
			else:
				self._qualifier = value
		return property(**locals())

	@apply
	def requestingapproval():
		def fget( self ):
			return self._requestingapproval
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._requestingapproval = ifcactorselect(value)
				else:
					self._requestingapproval = value
			else:
				self._requestingapproval = value
		return property(**locals())

	@apply
	def givingapproval():
		def fget( self ):
			return self._givingapproval
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._givingapproval = ifcactorselect(value)
				else:
					self._givingapproval = value
			else:
				self._givingapproval = value
		return property(**locals())

	@apply
	def hasexternalreferences():
		def fget( self ):
			return self._hasexternalreferences
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasexternalreferences is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def approvedobjects():
		def fget( self ):
			return self._approvedobjects
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument approvedobjects is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def approvedresources():
		def fget( self ):
			return self._approvedresources
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument approvedresources is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isrelatedwith():
		def fget( self ):
			return self._isrelatedwith
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isrelatedwith is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def relates():
		def fget( self ):
			return self._relates
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument relates is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def hasidentifierorname(self):
		eval_hasidentifierorname_wr = (EXISTS(self.identifier)  or  EXISTS(self.name))
		if not eval_hasidentifierorname_wr:
			raise AssertionError('Rule hasidentifierorname violated')
		else:
			return eval_hasidentifierorname_wr


####################
 # ENTITY ifccontroller #
####################
class ifccontroller(ifcdistributioncontrolelement):
	'''Entity ifccontroller definition.

	:param predefinedtype
	:type predefinedtype:ifccontrollertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcdistributioncontrolelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccontrollertypeenum):
					self._predefinedtype = ifccontrollertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccontrollertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccontrollertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCONTROLLERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifccostschedule #
####################
class ifccostschedule(ifccontrol):
	'''Entity ifccostschedule definition.

	:param predefinedtype
	:type predefinedtype:ifccostscheduletypeenum

	:param status
	:type status:ifclabel

	:param submittedon
	:type submittedon:ifcdatetime

	:param updatedate
	:type updatedate:ifcdatetime
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , predefinedtype,status,submittedon,updatedate, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , )
		self.predefinedtype = predefinedtype
		self.status = status
		self.submittedon = submittedon
		self.updatedate = updatedate

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccostscheduletypeenum):
					self._predefinedtype = ifccostscheduletypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._status = ifclabel(value)
				else:
					self._status = value
			else:
				self._status = value
		return property(**locals())

	@apply
	def submittedon():
		def fget( self ):
			return self._submittedon
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._submittedon = ifcdatetime(value)
				else:
					self._submittedon = value
			else:
				self._submittedon = value
		return property(**locals())

	@apply
	def updatedate():
		def fget( self ):
			return self._updatedate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._updatedate = ifcdatetime(value)
				else:
					self._updatedate = value
			else:
				self._updatedate = value
		return property(**locals())

####################
 # ENTITY ifclibraryreference #
####################
class ifclibraryreference(ifcexternalreference):
	'''Entity ifclibraryreference definition.

	:param description
	:type description:ifctext

	:param language
	:type language:ifclanguageid

	:param referencedlibrary
	:type referencedlibrary:ifclibraryinformation

	:param libraryrefforobjects
	:type libraryrefforobjects:SET(0,None,'ifcrelassociateslibrary', scope = schema_scope)
	'''
	def __init__( self , inherited0__location , inherited1__identification , inherited2__name , description,language,referencedlibrary, ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__identification , inherited2__name , )
		self.description = description
		self.language = language
		self.referencedlibrary = referencedlibrary

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def language():
		def fget( self ):
			return self._language
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclanguageid):
					self._language = ifclanguageid(value)
				else:
					self._language = value
			else:
				self._language = value
		return property(**locals())

	@apply
	def referencedlibrary():
		def fget( self ):
			return self._referencedlibrary
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclibraryinformation):
					self._referencedlibrary = ifclibraryinformation(value)
				else:
					self._referencedlibrary = value
			else:
				self._referencedlibrary = value
		return property(**locals())

	@apply
	def libraryrefforobjects():
		def fget( self ):
			return self._libraryrefforobjects
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument libraryrefforobjects is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcevent #
####################
class ifcevent(ifcprocess):
	'''Entity ifcevent definition.

	:param predefinedtype
	:type predefinedtype:ifceventtypeenum

	:param eventtriggertype
	:type eventtriggertype:ifceventtriggertypeenum

	:param userdefinedeventtriggertype
	:type userdefinedeventtriggertype:ifclabel

	:param eventoccurencetime
	:type eventoccurencetime:ifceventtime
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , predefinedtype,eventtriggertype,userdefinedeventtriggertype,eventoccurencetime, ):
		ifcprocess.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , )
		self.predefinedtype = predefinedtype
		self.eventtriggertype = eventtriggertype
		self.userdefinedeventtriggertype = userdefinedeventtriggertype
		self.eventoccurencetime = eventoccurencetime

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifceventtypeenum):
					self._predefinedtype = ifceventtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def eventtriggertype():
		def fget( self ):
			return self._eventtriggertype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifceventtriggertypeenum):
					self._eventtriggertype = ifceventtriggertypeenum(value)
				else:
					self._eventtriggertype = value
			else:
				self._eventtriggertype = value
		return property(**locals())

	@apply
	def userdefinedeventtriggertype():
		def fget( self ):
			return self._userdefinedeventtriggertype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedeventtriggertype = ifclabel(value)
				else:
					self._userdefinedeventtriggertype = value
			else:
				self._userdefinedeventtriggertype = value
		return property(**locals())

	@apply
	def eventoccurencetime():
		def fget( self ):
			return self._eventoccurencetime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifceventtime):
					self._eventoccurencetime = ifceventtime(value)
				else:
					self._eventoccurencetime = value
			else:
				self._eventoccurencetime = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifceventtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifceventtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((( not EXISTS(self.eventtriggertype))  or  (self.eventtriggertype  !=  ifceventtriggertypeenum.self.userdefined))  or  ((self.eventtriggertype  ==  ifceventtriggertypeenum.self.userdefined)  and  EXISTS(self.userdefinedeventtriggertype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcmateriallist #
####################
class ifcmateriallist(BaseEntityClass):
	'''Entity ifcmateriallist definition.

	:param materials
	:type materials:LIST(1,None,'ifcmaterial', scope = schema_scope)
	'''
	def __init__( self , materials, ):
		self.materials = materials

	@apply
	def materials():
		def fget( self ):
			return self._materials
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument materials is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcmaterial', scope = schema_scope)):
				self._materials = LIST(value)
			else:
				self._materials = value
		return property(**locals())

####################
 # ENTITY ifcplatetype #
####################
class ifcplatetype(ifcbuildingelementtype):
	'''Entity ifcplatetype definition.

	:param predefinedtype
	:type predefinedtype:ifcplatetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcplatetypeenum):
				self._predefinedtype = ifcplatetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcplatetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcplatetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcreldefines #
####################
class ifcreldefines(ifcrelationship):
	'''Entity ifcreldefines definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcrelationship.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

####################
 # ENTITY ifcreldefinesbytype #
####################
class ifcreldefinesbytype(ifcreldefines):
	'''Entity ifcreldefinesbytype definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobject', scope = schema_scope)

	:param relatingtype
	:type relatingtype:ifctypeobject
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedobjects,relatingtype, ):
		ifcreldefines.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedobjects = relatedobjects
		self.relatingtype = relatingtype

	@apply
	def relatedobjects():
		def fget( self ):
			return self._relatedobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcobject', scope = schema_scope)):
				self._relatedobjects = SET(value)
			else:
				self._relatedobjects = value
		return property(**locals())

	@apply
	def relatingtype():
		def fget( self ):
			return self._relatingtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingtype is mantatory and can not be set to None')
			if not check_type(value,ifctypeobject):
				self._relatingtype = ifctypeobject(value)
			else:
				self._relatingtype = value
		return property(**locals())

####################
 # ENTITY ifctable #
####################
class ifctable(BaseEntityClass):
	'''Entity ifctable definition.

	:param name
	:type name:ifclabel

	:param rows
	:type rows:LIST(1,None,'ifctablerow', scope = schema_scope)

	:param columns
	:type columns:LIST(1,None,'ifctablecolumn', scope = schema_scope)

	:param numberofcellsinrow
	:type numberofcellsinrow:INTEGER

	:param numberofheadings
	:type numberofheadings:INTEGER

	:param numberofdatarows
	:type numberofdatarows:INTEGER
	'''
	def __init__( self , name,rows,columns, ):
		self.name = name
		self.rows = rows
		self.columns = columns

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def rows():
		def fget( self ):
			return self._rows
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifctablerow', scope = schema_scope)):
					self._rows = LIST(value)
				else:
					self._rows = value
			else:
				self._rows = value
		return property(**locals())

	@apply
	def columns():
		def fget( self ):
			return self._columns
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifctablecolumn', scope = schema_scope)):
					self._columns = LIST(value)
				else:
					self._columns = value
			else:
				self._columns = value
		return property(**locals())

	@apply
	def numberofcellsinrow():
		def fget( self ):
			attribute_eval = HIINDEX(self.rows[1].self.rowcells)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument numberofcellsinrow is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def numberofheadings():
		def fget( self ):
			attribute_eval = SIZEOF(None)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument numberofheadings is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def numberofdatarows():
		def fget( self ):
			attribute_eval = SIZEOF(None)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument numberofdatarows is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((0  <=  self.numberofheadings)  and  (self.numberofheadings  <=  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcrailingtype #
####################
class ifcrailingtype(ifcbuildingelementtype):
	'''Entity ifcrailingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcrailingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcrailingtypeenum):
				self._predefinedtype = ifcrailingtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcrailingtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcrailingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcfurnituretype #
####################
class ifcfurnituretype(ifcfurnishingelementtype):
	'''Entity ifcfurnituretype definition.

	:param assemblyplace
	:type assemblyplace:ifcassemblyplaceenum

	:param predefinedtype
	:type predefinedtype:ifcfurnituretypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , assemblyplace,predefinedtype, ):
		ifcfurnishingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.assemblyplace = assemblyplace
		self.predefinedtype = predefinedtype

	@apply
	def assemblyplace():
		def fget( self ):
			return self._assemblyplace
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assemblyplace is mantatory and can not be set to None')
			if not check_type(value,ifcassemblyplaceenum):
				self._assemblyplace = ifcassemblyplaceenum(value)
			else:
				self._assemblyplace = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfurnituretypeenum):
					self._predefinedtype = ifcfurnituretypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcfurnituretypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcfurnituretypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcfiresuppressionterminaltype #
####################
class ifcfiresuppressionterminaltype(ifcflowterminaltype):
	'''Entity ifcfiresuppressionterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcfiresuppressionterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcfiresuppressionterminaltypeenum):
				self._predefinedtype = ifcfiresuppressionterminaltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcfiresuppressionterminaltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcfiresuppressionterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifctendonanchor #
####################
class ifctendonanchor(ifcreinforcingelement):
	'''Entity ifctendonanchor definition.

	:param predefinedtype
	:type predefinedtype:ifctendonanchortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , predefinedtype, ):
		ifcreinforcingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctendonanchortypeenum):
					self._predefinedtype = ifctendonanchortypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifctendonanchortypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifctendonanchortypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCTENDONANCHORTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcmedicaldevice #
####################
class ifcmedicaldevice(ifcflowterminal):
	'''Entity ifcmedicaldevice definition.

	:param predefinedtype
	:type predefinedtype:ifcmedicaldevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmedicaldevicetypeenum):
					self._predefinedtype = ifcmedicaldevicetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcmedicaldevicetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcmedicaldevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCMEDICALDEVICETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcconstructionequipmentresource #
####################
class ifcconstructionequipmentresource(ifcconstructionresource):
	'''Entity ifcconstructionequipmentresource definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionequipmentresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , predefinedtype, ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcconstructionequipmentresourcetypeenum):
					self._predefinedtype = ifcconstructionequipmentresourcetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcconstructionequipmentresourcetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcconstructionequipmentresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifctexturevertex #
####################
class ifctexturevertex(ifcpresentationitem):
	'''Entity ifctexturevertex definition.

	:param coordinates
	:type coordinates:LIST(2,2,'REAL', scope = schema_scope)
	'''
	def __init__( self , coordinates, ):
		ifcpresentationitem.__init__(self , )
		self.coordinates = coordinates

	@apply
	def coordinates():
		def fget( self ):
			return self._coordinates
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordinates is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'REAL', scope = schema_scope)):
				self._coordinates = LIST(value)
			else:
				self._coordinates = value
		return property(**locals())

####################
 # ENTITY ifcpile #
####################
class ifcpile(ifcbuildingelement):
	'''Entity ifcpile definition.

	:param predefinedtype
	:type predefinedtype:ifcpiletypeenum

	:param constructiontype
	:type constructiontype:ifcpileconstructionenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype,constructiontype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype
		self.constructiontype = constructiontype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpiletypeenum):
					self._predefinedtype = ifcpiletypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def constructiontype():
		def fget( self ):
			return self._constructiontype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpileconstructionenum):
					self._constructiontype = ifcpileconstructionenum(value)
				else:
					self._constructiontype = value
			else:
				self._constructiontype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcpiletypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcpiletypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCPILETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcreinforcingmeshtype #
####################
class ifcreinforcingmeshtype(ifcreinforcingelementtype):
	'''Entity ifcreinforcingmeshtype definition.

	:param predefinedtype
	:type predefinedtype:ifcreinforcingmeshtypeenum

	:param meshlength
	:type meshlength:ifcpositivelengthmeasure

	:param meshwidth
	:type meshwidth:ifcpositivelengthmeasure

	:param longitudinalbarnominaldiameter
	:type longitudinalbarnominaldiameter:ifcpositivelengthmeasure

	:param transversebarnominaldiameter
	:type transversebarnominaldiameter:ifcpositivelengthmeasure

	:param longitudinalbarcrosssectionarea
	:type longitudinalbarcrosssectionarea:ifcareameasure

	:param transversebarcrosssectionarea
	:type transversebarcrosssectionarea:ifcareameasure

	:param longitudinalbarspacing
	:type longitudinalbarspacing:ifcpositivelengthmeasure

	:param transversebarspacing
	:type transversebarspacing:ifcpositivelengthmeasure

	:param bendingshapecode
	:type bendingshapecode:ifclabel

	:param bendingparameters
	:type bendingparameters:LIST(1,None,'ifcbendingparameterselect', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype,meshlength,meshwidth,longitudinalbarnominaldiameter,transversebarnominaldiameter,longitudinalbarcrosssectionarea,transversebarcrosssectionarea,longitudinalbarspacing,transversebarspacing,bendingshapecode,bendingparameters, ):
		ifcreinforcingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype
		self.meshlength = meshlength
		self.meshwidth = meshwidth
		self.longitudinalbarnominaldiameter = longitudinalbarnominaldiameter
		self.transversebarnominaldiameter = transversebarnominaldiameter
		self.longitudinalbarcrosssectionarea = longitudinalbarcrosssectionarea
		self.transversebarcrosssectionarea = transversebarcrosssectionarea
		self.longitudinalbarspacing = longitudinalbarspacing
		self.transversebarspacing = transversebarspacing
		self.bendingshapecode = bendingshapecode
		self.bendingparameters = bendingparameters

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcreinforcingmeshtypeenum):
				self._predefinedtype = ifcreinforcingmeshtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def meshlength():
		def fget( self ):
			return self._meshlength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._meshlength = ifcpositivelengthmeasure(value)
				else:
					self._meshlength = value
			else:
				self._meshlength = value
		return property(**locals())

	@apply
	def meshwidth():
		def fget( self ):
			return self._meshwidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._meshwidth = ifcpositivelengthmeasure(value)
				else:
					self._meshwidth = value
			else:
				self._meshwidth = value
		return property(**locals())

	@apply
	def longitudinalbarnominaldiameter():
		def fget( self ):
			return self._longitudinalbarnominaldiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._longitudinalbarnominaldiameter = ifcpositivelengthmeasure(value)
				else:
					self._longitudinalbarnominaldiameter = value
			else:
				self._longitudinalbarnominaldiameter = value
		return property(**locals())

	@apply
	def transversebarnominaldiameter():
		def fget( self ):
			return self._transversebarnominaldiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._transversebarnominaldiameter = ifcpositivelengthmeasure(value)
				else:
					self._transversebarnominaldiameter = value
			else:
				self._transversebarnominaldiameter = value
		return property(**locals())

	@apply
	def longitudinalbarcrosssectionarea():
		def fget( self ):
			return self._longitudinalbarcrosssectionarea
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._longitudinalbarcrosssectionarea = ifcareameasure(value)
				else:
					self._longitudinalbarcrosssectionarea = value
			else:
				self._longitudinalbarcrosssectionarea = value
		return property(**locals())

	@apply
	def transversebarcrosssectionarea():
		def fget( self ):
			return self._transversebarcrosssectionarea
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._transversebarcrosssectionarea = ifcareameasure(value)
				else:
					self._transversebarcrosssectionarea = value
			else:
				self._transversebarcrosssectionarea = value
		return property(**locals())

	@apply
	def longitudinalbarspacing():
		def fget( self ):
			return self._longitudinalbarspacing
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._longitudinalbarspacing = ifcpositivelengthmeasure(value)
				else:
					self._longitudinalbarspacing = value
			else:
				self._longitudinalbarspacing = value
		return property(**locals())

	@apply
	def transversebarspacing():
		def fget( self ):
			return self._transversebarspacing
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._transversebarspacing = ifcpositivelengthmeasure(value)
				else:
					self._transversebarspacing = value
			else:
				self._transversebarspacing = value
		return property(**locals())

	@apply
	def bendingshapecode():
		def fget( self ):
			return self._bendingshapecode
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._bendingshapecode = ifclabel(value)
				else:
					self._bendingshapecode = value
			else:
				self._bendingshapecode = value
		return property(**locals())

	@apply
	def bendingparameters():
		def fget( self ):
			return self._bendingparameters
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcbendingparameterselect', scope = schema_scope)):
					self._bendingparameters = LIST(value)
				else:
					self._bendingparameters = value
			else:
				self._bendingparameters = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcreinforcingmeshtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcreinforcingmeshtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def bendingshapecodeprovided(self):
		eval_bendingshapecodeprovided_wr = (( not EXISTS(self.bendingparameters))  or  EXISTS(self.bendingshapecode))
		if not eval_bendingshapecodeprovided_wr:
			raise AssertionError('Rule bendingshapecodeprovided violated')
		else:
			return eval_bendingshapecodeprovided_wr


####################
 # ENTITY ifcrelassociateslibrary #
####################
class ifcrelassociateslibrary(ifcrelassociates):
	'''Entity ifcrelassociateslibrary definition.

	:param relatinglibrary
	:type relatinglibrary:ifclibraryselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatinglibrary, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatinglibrary = relatinglibrary

	@apply
	def relatinglibrary():
		def fget( self ):
			return self._relatinglibrary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatinglibrary is mantatory and can not be set to None')
			if not check_type(value,ifclibraryselect):
				self._relatinglibrary = ifclibraryselect(value)
			else:
				self._relatinglibrary = value
		return property(**locals())

####################
 # ENTITY ifcsimplepropertytemplate #
####################
class ifcsimplepropertytemplate(ifcpropertytemplate):
	'''Entity ifcsimplepropertytemplate definition.

	:param templatetype
	:type templatetype:ifcsimplepropertytemplatetypeenum

	:param primarymeasuretype
	:type primarymeasuretype:ifclabel

	:param secondarymeasuretype
	:type secondarymeasuretype:ifclabel

	:param enumerators
	:type enumerators:ifcpropertyenumeration

	:param primaryunit
	:type primaryunit:ifcunit

	:param secondaryunit
	:type secondaryunit:ifcunit

	:param expression
	:type expression:ifclabel

	:param accessstate
	:type accessstate:ifcstateenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , templatetype,primarymeasuretype,secondarymeasuretype,enumerators,primaryunit,secondaryunit,expression,accessstate, ):
		ifcpropertytemplate.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.templatetype = templatetype
		self.primarymeasuretype = primarymeasuretype
		self.secondarymeasuretype = secondarymeasuretype
		self.enumerators = enumerators
		self.primaryunit = primaryunit
		self.secondaryunit = secondaryunit
		self.expression = expression
		self.accessstate = accessstate

	@apply
	def templatetype():
		def fget( self ):
			return self._templatetype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsimplepropertytemplatetypeenum):
					self._templatetype = ifcsimplepropertytemplatetypeenum(value)
				else:
					self._templatetype = value
			else:
				self._templatetype = value
		return property(**locals())

	@apply
	def primarymeasuretype():
		def fget( self ):
			return self._primarymeasuretype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._primarymeasuretype = ifclabel(value)
				else:
					self._primarymeasuretype = value
			else:
				self._primarymeasuretype = value
		return property(**locals())

	@apply
	def secondarymeasuretype():
		def fget( self ):
			return self._secondarymeasuretype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._secondarymeasuretype = ifclabel(value)
				else:
					self._secondarymeasuretype = value
			else:
				self._secondarymeasuretype = value
		return property(**locals())

	@apply
	def enumerators():
		def fget( self ):
			return self._enumerators
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpropertyenumeration):
					self._enumerators = ifcpropertyenumeration(value)
				else:
					self._enumerators = value
			else:
				self._enumerators = value
		return property(**locals())

	@apply
	def primaryunit():
		def fget( self ):
			return self._primaryunit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._primaryunit = ifcunit(value)
				else:
					self._primaryunit = value
			else:
				self._primaryunit = value
		return property(**locals())

	@apply
	def secondaryunit():
		def fget( self ):
			return self._secondaryunit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._secondaryunit = ifcunit(value)
				else:
					self._secondaryunit = value
			else:
				self._secondaryunit = value
		return property(**locals())

	@apply
	def expression():
		def fget( self ):
			return self._expression
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._expression = ifclabel(value)
				else:
					self._expression = value
			else:
				self._expression = value
		return property(**locals())

	@apply
	def accessstate():
		def fget( self ):
			return self._accessstate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcstateenum):
					self._accessstate = ifcstateenum(value)
				else:
					self._accessstate = value
			else:
				self._accessstate = value
		return property(**locals())

####################
 # ENTITY ifcrectanglehollowprofiledef #
####################
class ifcrectanglehollowprofiledef(ifcrectangleprofiledef):
	'''Entity ifcrectanglehollowprofiledef definition.

	:param wallthickness
	:type wallthickness:ifcpositivelengthmeasure

	:param innerfilletradius
	:type innerfilletradius:ifcnonnegativelengthmeasure

	:param outerfilletradius
	:type outerfilletradius:ifcnonnegativelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__xdim , inherited4__ydim , wallthickness,innerfilletradius,outerfilletradius, ):
		ifcrectangleprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__xdim , inherited4__ydim , )
		self.wallthickness = wallthickness
		self.innerfilletradius = innerfilletradius
		self.outerfilletradius = outerfilletradius

	@apply
	def wallthickness():
		def fget( self ):
			return self._wallthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument wallthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._wallthickness = ifcpositivelengthmeasure(value)
			else:
				self._wallthickness = value
		return property(**locals())

	@apply
	def innerfilletradius():
		def fget( self ):
			return self._innerfilletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._innerfilletradius = ifcnonnegativelengthmeasure(value)
				else:
					self._innerfilletradius = value
			else:
				self._innerfilletradius = value
		return property(**locals())

	@apply
	def outerfilletradius():
		def fget( self ):
			return self._outerfilletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._outerfilletradius = ifcnonnegativelengthmeasure(value)
				else:
					self._outerfilletradius = value
			else:
				self._outerfilletradius = value
		return property(**locals())
	def validwallthickness(self):
		eval_validwallthickness_wr = ((self.wallthickness  <  (self.self.ifcrectangleprofiledef.self.xdim / 2))  and  (self.wallthickness  <  (self.self.ifcrectangleprofiledef.self.ydim / 2)))
		if not eval_validwallthickness_wr:
			raise AssertionError('Rule validwallthickness violated')
		else:
			return eval_validwallthickness_wr

	def validinnerradius(self):
		eval_validinnerradius_wr = (( not EXISTS(self.innerfilletradius))  or  ((self.innerfilletradius  <=  ((self.self.ifcrectangleprofiledef.self.xdim / 2) - self.wallthickness))  and  (self.innerfilletradius  <=  ((self.self.ifcrectangleprofiledef.self.ydim / 2) - self.wallthickness))))
		if not eval_validinnerradius_wr:
			raise AssertionError('Rule validinnerradius violated')
		else:
			return eval_validinnerradius_wr

	def validouterradius(self):
		eval_validouterradius_wr = (( not EXISTS(self.outerfilletradius))  or  ((self.outerfilletradius  <=  (self.self.ifcrectangleprofiledef.self.xdim / 2))  and  (self.outerfilletradius  <=  (self.self.ifcrectangleprofiledef.self.ydim / 2))))
		if not eval_validouterradius_wr:
			raise AssertionError('Rule validouterradius violated')
		else:
			return eval_validouterradius_wr


####################
 # ENTITY ifcproxy #
####################
class ifcproxy(ifcproduct):
	'''Entity ifcproxy definition.

	:param proxytype
	:type proxytype:ifcobjecttypeenum

	:param tag
	:type tag:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , proxytype,tag, ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.proxytype = proxytype
		self.tag = tag

	@apply
	def proxytype():
		def fget( self ):
			return self._proxytype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument proxytype is mantatory and can not be set to None')
			if not check_type(value,ifcobjecttypeenum):
				self._proxytype = ifcobjecttypeenum(value)
			else:
				self._proxytype = value
		return property(**locals())

	@apply
	def tag():
		def fget( self ):
			return self._tag
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._tag = ifclabel(value)
				else:
					self._tag = value
			else:
				self._tag = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcrevolvedareasolidtapered #
####################
class ifcrevolvedareasolidtapered(ifcrevolvedareasolid):
	'''Entity ifcrevolvedareasolidtapered definition.

	:param endsweptarea
	:type endsweptarea:ifcprofiledef
	'''
	def __init__( self , inherited0__sweptarea , inherited1__position , inherited2__axis , inherited3__angle , endsweptarea, ):
		ifcrevolvedareasolid.__init__(self , inherited0__sweptarea , inherited1__position , inherited2__axis , inherited3__angle , )
		self.endsweptarea = endsweptarea

	@apply
	def endsweptarea():
		def fget( self ):
			return self._endsweptarea
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument endsweptarea is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._endsweptarea = ifcprofiledef(value)
			else:
				self._endsweptarea = value
		return property(**locals())
	def correctprofileassignment(self):
		eval_correctprofileassignment_wr = ifctaperedsweptareaprofiles(self.self.ifcsweptareasolid.self.sweptarea,self.self.endsweptarea)
		if not eval_correctprofileassignment_wr:
			raise AssertionError('Rule correctprofileassignment violated')
		else:
			return eval_correctprofileassignment_wr


####################
 # ENTITY ifcwallelementedcase #
####################
class ifcwallelementedcase(ifcwall):
	'''Entity ifcwallelementedcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype ,  ):
		ifcwall.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype , )
	def hasdecomposition(self):
		eval_hasdecomposition_wr = (HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  >  0)
		if not eval_hasdecomposition_wr:
			raise AssertionError('Rule hasdecomposition violated')
		else:
			return eval_hasdecomposition_wr


####################
 # ENTITY ifcevaporator #
####################
class ifcevaporator(ifcenergyconversiondevice):
	'''Entity ifcevaporator definition.

	:param predefinedtype
	:type predefinedtype:ifcevaporatortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcevaporatortypeenum):
					self._predefinedtype = ifcevaporatortypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcevaporatortypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcevaporatortypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCEVAPORATORTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcprojectedcrs #
####################
class ifcprojectedcrs(ifccoordinatereferencesystem):
	'''Entity ifcprojectedcrs definition.

	:param mapprojection
	:type mapprojection:ifcidentifier

	:param mapzone
	:type mapzone:ifcidentifier

	:param mapunit
	:type mapunit:ifcnamedunit
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__geodeticdatum , inherited3__verticaldatum , mapprojection,mapzone,mapunit, ):
		ifccoordinatereferencesystem.__init__(self , inherited0__name , inherited1__description , inherited2__geodeticdatum , inherited3__verticaldatum , )
		self.mapprojection = mapprojection
		self.mapzone = mapzone
		self.mapunit = mapunit

	@apply
	def mapprojection():
		def fget( self ):
			return self._mapprojection
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._mapprojection = ifcidentifier(value)
				else:
					self._mapprojection = value
			else:
				self._mapprojection = value
		return property(**locals())

	@apply
	def mapzone():
		def fget( self ):
			return self._mapzone
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._mapzone = ifcidentifier(value)
				else:
					self._mapzone = value
			else:
				self._mapzone = value
		return property(**locals())

	@apply
	def mapunit():
		def fget( self ):
			return self._mapunit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnamedunit):
					self._mapunit = ifcnamedunit(value)
				else:
					self._mapunit = value
			else:
				self._mapunit = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (( not EXISTS(self.mapunit))  or  (self.mapunit.self.unittype  ==  ifcunitenum.self.lengthunit))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcwindowtype #
####################
class ifcwindowtype(ifcbuildingelementtype):
	'''Entity ifcwindowtype definition.

	:param predefinedtype
	:type predefinedtype:ifcwindowtypeenum

	:param partitioningtype
	:type partitioningtype:ifcwindowtypepartitioningenum

	:param parametertakesprecedence
	:type parametertakesprecedence:BOOLEAN

	:param userdefinedpartitioningtype
	:type userdefinedpartitioningtype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype,partitioningtype,parametertakesprecedence,userdefinedpartitioningtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype
		self.partitioningtype = partitioningtype
		self.parametertakesprecedence = parametertakesprecedence
		self.userdefinedpartitioningtype = userdefinedpartitioningtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcwindowtypeenum):
				self._predefinedtype = ifcwindowtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def partitioningtype():
		def fget( self ):
			return self._partitioningtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument partitioningtype is mantatory and can not be set to None')
			if not check_type(value,ifcwindowtypepartitioningenum):
				self._partitioningtype = ifcwindowtypepartitioningenum(value)
			else:
				self._partitioningtype = value
		return property(**locals())

	@apply
	def parametertakesprecedence():
		def fget( self ):
			return self._parametertakesprecedence
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._parametertakesprecedence = BOOLEAN(value)
				else:
					self._parametertakesprecedence = value
			else:
				self._parametertakesprecedence = value
		return property(**locals())

	@apply
	def userdefinedpartitioningtype():
		def fget( self ):
			return self._userdefinedpartitioningtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedpartitioningtype = ifclabel(value)
				else:
					self._userdefinedpartitioningtype = value
			else:
				self._userdefinedpartitioningtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcwindowtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcwindowtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcpropertyboundedvalue #
####################
class ifcpropertyboundedvalue(ifcsimpleproperty):
	'''Entity ifcpropertyboundedvalue definition.

	:param upperboundvalue
	:type upperboundvalue:ifcvalue

	:param lowerboundvalue
	:type lowerboundvalue:ifcvalue

	:param unit
	:type unit:ifcunit

	:param setpointvalue
	:type setpointvalue:ifcvalue
	'''
	def __init__( self , inherited0__name , inherited1__description , upperboundvalue,lowerboundvalue,unit,setpointvalue, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.upperboundvalue = upperboundvalue
		self.lowerboundvalue = lowerboundvalue
		self.unit = unit
		self.setpointvalue = setpointvalue

	@apply
	def upperboundvalue():
		def fget( self ):
			return self._upperboundvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvalue):
					self._upperboundvalue = ifcvalue(value)
				else:
					self._upperboundvalue = value
			else:
				self._upperboundvalue = value
		return property(**locals())

	@apply
	def lowerboundvalue():
		def fget( self ):
			return self._lowerboundvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvalue):
					self._lowerboundvalue = ifcvalue(value)
				else:
					self._lowerboundvalue = value
			else:
				self._lowerboundvalue = value
		return property(**locals())

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._unit = ifcunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())

	@apply
	def setpointvalue():
		def fget( self ):
			return self._setpointvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvalue):
					self._setpointvalue = ifcvalue(value)
				else:
					self._setpointvalue = value
			else:
				self._setpointvalue = value
		return property(**locals())
	def sameunitupperlower(self):
		eval_sameunitupperlower_wr = ((( not EXISTS(self.upperboundvalue))  or  ( not EXISTS(self.lowerboundvalue)))  or  (TYPEOF(self.upperboundvalue)  ==  TYPEOF(self.lowerboundvalue)))
		if not eval_sameunitupperlower_wr:
			raise AssertionError('Rule sameunitupperlower violated')
		else:
			return eval_sameunitupperlower_wr

	def sameunitupperset(self):
		eval_sameunitupperset_wr = ((( not EXISTS(self.upperboundvalue))  or  ( not EXISTS(self.setpointvalue)))  or  (TYPEOF(self.upperboundvalue)  ==  TYPEOF(self.setpointvalue)))
		if not eval_sameunitupperset_wr:
			raise AssertionError('Rule sameunitupperset violated')
		else:
			return eval_sameunitupperset_wr

	def sameunitlowerset(self):
		eval_sameunitlowerset_wr = ((( not EXISTS(self.lowerboundvalue))  or  ( not EXISTS(self.setpointvalue)))  or  (TYPEOF(self.lowerboundvalue)  ==  TYPEOF(self.setpointvalue)))
		if not eval_sameunitlowerset_wr:
			raise AssertionError('Rule sameunitlowerset violated')
		else:
			return eval_sameunitlowerset_wr


####################
 # ENTITY ifcpump #
####################
class ifcpump(ifcflowmovingdevice):
	'''Entity ifcpump definition.

	:param predefinedtype
	:type predefinedtype:ifcpumptypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowmovingdevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpumptypeenum):
					self._predefinedtype = ifcpumptypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcpumptypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcpumptypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCPUMPTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcpresentationstyleassignment #
####################
class ifcpresentationstyleassignment(BaseEntityClass):
	'''Entity ifcpresentationstyleassignment definition.

	:param styles
	:type styles:SET(1,None,'ifcpresentationstyleselect', scope = schema_scope)
	'''
	def __init__( self , styles, ):
		self.styles = styles

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcpresentationstyleselect', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())

####################
 # ENTITY ifcexternalreferencerelationship #
####################
class ifcexternalreferencerelationship(ifcresourcelevelrelationship):
	'''Entity ifcexternalreferencerelationship definition.

	:param relatingreference
	:type relatingreference:ifcexternalreference

	:param relatedresourceobjects
	:type relatedresourceobjects:SET(1,None,'ifcresourceobjectselect', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , relatingreference,relatedresourceobjects, ):
		ifcresourcelevelrelationship.__init__(self , inherited0__name , inherited1__description , )
		self.relatingreference = relatingreference
		self.relatedresourceobjects = relatedresourceobjects

	@apply
	def relatingreference():
		def fget( self ):
			return self._relatingreference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingreference is mantatory and can not be set to None')
			if not check_type(value,ifcexternalreference):
				self._relatingreference = ifcexternalreference(value)
			else:
				self._relatingreference = value
		return property(**locals())

	@apply
	def relatedresourceobjects():
		def fget( self ):
			return self._relatedresourceobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedresourceobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcresourceobjectselect', scope = schema_scope)):
				self._relatedresourceobjects = SET(value)
			else:
				self._relatedresourceobjects = value
		return property(**locals())

####################
 # ENTITY ifcmirroredprofiledef #
####################
class ifcmirroredprofiledef(ifcderivedprofiledef):
	'''Entity ifcmirroredprofiledef definition.

	:param ifcderivedprofiledef_operator
	:type ifcderivedprofiledef_operator:ifccartesiantransformationoperator2d
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__parentprofile , inherited3__operator , inherited4__label ,  ):
		ifcderivedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__parentprofile , inherited3__operator , inherited4__label , )

	@apply
	def ifcderivedprofiledef_operator():
		def fget( self ):
			attribute_eval = (((ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifccartesiantransformationoperator((ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([-1,0]),(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,1]),((ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcpoint())  ==  ifccartesianpoint([0,0]),1))  ==  ifccartesiantransformationoperator2d())
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcderivedprofiledef_operator is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcsite #
####################
class ifcsite(ifcspatialstructureelement):
	'''Entity ifcsite definition.

	:param reflatitude
	:type reflatitude:LIST(3,4,'INTEGER', scope = schema_scope)

	:param reflongitude
	:type reflongitude:LIST(3,4,'INTEGER', scope = schema_scope)

	:param refelevation
	:type refelevation:ifclengthmeasure

	:param landtitlenumber
	:type landtitlenumber:ifclabel

	:param siteaddress
	:type siteaddress:ifcpostaladdress
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , reflatitude,reflongitude,refelevation,landtitlenumber,siteaddress, ):
		ifcspatialstructureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , )
		self.reflatitude = reflatitude
		self.reflongitude = reflongitude
		self.refelevation = refelevation
		self.landtitlenumber = landtitlenumber
		self.siteaddress = siteaddress

	@apply
	def reflatitude():
		def fget( self ):
			return self._reflatitude
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(3,4,'INTEGER', scope = schema_scope)):
					self._reflatitude = LIST(value)
				else:
					self._reflatitude = value
			else:
				self._reflatitude = value
		return property(**locals())

	@apply
	def reflongitude():
		def fget( self ):
			return self._reflongitude
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(3,4,'INTEGER', scope = schema_scope)):
					self._reflongitude = LIST(value)
				else:
					self._reflongitude = value
			else:
				self._reflongitude = value
		return property(**locals())

	@apply
	def refelevation():
		def fget( self ):
			return self._refelevation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._refelevation = ifclengthmeasure(value)
				else:
					self._refelevation = value
			else:
				self._refelevation = value
		return property(**locals())

	@apply
	def landtitlenumber():
		def fget( self ):
			return self._landtitlenumber
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._landtitlenumber = ifclabel(value)
				else:
					self._landtitlenumber = value
			else:
				self._landtitlenumber = value
		return property(**locals())

	@apply
	def siteaddress():
		def fget( self ):
			return self._siteaddress
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpostaladdress):
					self._siteaddress = ifcpostaladdress(value)
				else:
					self._siteaddress = value
			else:
				self._siteaddress = value
		return property(**locals())

####################
 # ENTITY ifcarbitraryopenprofiledef #
####################
class ifcarbitraryopenprofiledef(ifcprofiledef):
	'''Entity ifcarbitraryopenprofiledef definition.

	:param curve
	:type curve:ifcboundedcurve
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , curve, ):
		ifcprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , )
		self.curve = curve

	@apply
	def curve():
		def fget( self ):
			return self._curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve is mantatory and can not be set to None')
			if not check_type(value,ifcboundedcurve):
				self._curve = ifcboundedcurve(value)
			else:
				self._curve = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (('IFC4.IFCCENTERLINEPROFILEDEF'  ==  TYPEOF(self))  or  (self.self.ifcprofiledef.self.profiletype  ==  ifcprofiletypeenum.self.curve))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (self.curve.self.dim  ==  2)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr


####################
 # ENTITY ifccoil #
####################
class ifccoil(ifcenergyconversiondevice):
	'''Entity ifccoil definition.

	:param predefinedtype
	:type predefinedtype:ifccoiltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccoiltypeenum):
					self._predefinedtype = ifccoiltypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccoiltypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccoiltypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCOILTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcquantitylength #
####################
class ifcquantitylength(ifcphysicalsimplequantity):
	'''Entity ifcquantitylength definition.

	:param lengthvalue
	:type lengthvalue:ifclengthmeasure

	:param formula
	:type formula:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , lengthvalue,formula, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.lengthvalue = lengthvalue
		self.formula = formula

	@apply
	def lengthvalue():
		def fget( self ):
			return self._lengthvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lengthvalue is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._lengthvalue = ifclengthmeasure(value)
			else:
				self._lengthvalue = value
		return property(**locals())

	@apply
	def formula():
		def fget( self ):
			return self._formula
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._formula = ifclabel(value)
				else:
					self._formula = value
			else:
				self._formula = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.self.ifcphysicalsimplequantity.self.unit))  or  (self.self.ifcphysicalsimplequantity.self.unit.self.unittype  ==  ifcunitenum.self.lengthunit))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.lengthvalue  >=  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcsubcontractresource #
####################
class ifcsubcontractresource(ifcconstructionresource):
	'''Entity ifcsubcontractresource definition.

	:param predefinedtype
	:type predefinedtype:ifcsubcontractresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , predefinedtype, ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsubcontractresourcetypeenum):
					self._predefinedtype = ifcsubcontractresourcetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcsubcontractresourcetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcsubcontractresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifctimeseries #
####################
class ifctimeseries(BaseEntityClass):
	'''Entity ifctimeseries definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param starttime
	:type starttime:ifcdatetime

	:param endtime
	:type endtime:ifcdatetime

	:param timeseriesdatatype
	:type timeseriesdatatype:ifctimeseriesdatatypeenum

	:param dataorigin
	:type dataorigin:ifcdataoriginenum

	:param userdefineddataorigin
	:type userdefineddataorigin:ifclabel

	:param unit
	:type unit:ifcunit

	:param hasexternalreference
	:type hasexternalreference:SET(1,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''
	def __init__( self , name,description,starttime,endtime,timeseriesdatatype,dataorigin,userdefineddataorigin,unit, ):
		self.name = name
		self.description = description
		self.starttime = starttime
		self.endtime = endtime
		self.timeseriesdatatype = timeseriesdatatype
		self.dataorigin = dataorigin
		self.userdefineddataorigin = userdefineddataorigin
		self.unit = unit

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def starttime():
		def fget( self ):
			return self._starttime
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument starttime is mantatory and can not be set to None')
			if not check_type(value,ifcdatetime):
				self._starttime = ifcdatetime(value)
			else:
				self._starttime = value
		return property(**locals())

	@apply
	def endtime():
		def fget( self ):
			return self._endtime
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument endtime is mantatory and can not be set to None')
			if not check_type(value,ifcdatetime):
				self._endtime = ifcdatetime(value)
			else:
				self._endtime = value
		return property(**locals())

	@apply
	def timeseriesdatatype():
		def fget( self ):
			return self._timeseriesdatatype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timeseriesdatatype is mantatory and can not be set to None')
			if not check_type(value,ifctimeseriesdatatypeenum):
				self._timeseriesdatatype = ifctimeseriesdatatypeenum(value)
			else:
				self._timeseriesdatatype = value
		return property(**locals())

	@apply
	def dataorigin():
		def fget( self ):
			return self._dataorigin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dataorigin is mantatory and can not be set to None')
			if not check_type(value,ifcdataoriginenum):
				self._dataorigin = ifcdataoriginenum(value)
			else:
				self._dataorigin = value
		return property(**locals())

	@apply
	def userdefineddataorigin():
		def fget( self ):
			return self._userdefineddataorigin
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefineddataorigin = ifclabel(value)
				else:
					self._userdefineddataorigin = value
			else:
				self._userdefineddataorigin = value
		return property(**locals())

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._unit = ifcunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())

	@apply
	def hasexternalreference():
		def fget( self ):
			return self._hasexternalreference
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcregulartimeseries #
####################
class ifcregulartimeseries(ifctimeseries):
	'''Entity ifcregulartimeseries definition.

	:param timestep
	:type timestep:ifctimemeasure

	:param values
	:type values:LIST(1,None,'ifctimeseriesvalue', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__starttime , inherited3__endtime , inherited4__timeseriesdatatype , inherited5__dataorigin , inherited6__userdefineddataorigin , inherited7__unit , timestep,values, ):
		ifctimeseries.__init__(self , inherited0__name , inherited1__description , inherited2__starttime , inherited3__endtime , inherited4__timeseriesdatatype , inherited5__dataorigin , inherited6__userdefineddataorigin , inherited7__unit , )
		self.timestep = timestep
		self.values = values

	@apply
	def timestep():
		def fget( self ):
			return self._timestep
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timestep is mantatory and can not be set to None')
			if not check_type(value,ifctimemeasure):
				self._timestep = ifctimemeasure(value)
			else:
				self._timestep = value
		return property(**locals())

	@apply
	def values():
		def fget( self ):
			return self._values
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument values is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifctimeseriesvalue', scope = schema_scope)):
				self._values = LIST(value)
			else:
				self._values = value
		return property(**locals())

####################
 # ENTITY ifcdistributionport #
####################
class ifcdistributionport(ifcport):
	'''Entity ifcdistributionport definition.

	:param flowdirection
	:type flowdirection:ifcflowdirectionenum

	:param predefinedtype
	:type predefinedtype:ifcdistributionporttypeenum

	:param systemtype
	:type systemtype:ifcdistributionsystemenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , flowdirection,predefinedtype,systemtype, ):
		ifcport.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.flowdirection = flowdirection
		self.predefinedtype = predefinedtype
		self.systemtype = systemtype

	@apply
	def flowdirection():
		def fget( self ):
			return self._flowdirection
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcflowdirectionenum):
					self._flowdirection = ifcflowdirectionenum(value)
				else:
					self._flowdirection = value
			else:
				self._flowdirection = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdistributionporttypeenum):
					self._predefinedtype = ifcdistributionporttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def systemtype():
		def fget( self ):
			return self._systemtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdistributionsystemenum):
					self._systemtype = ifcdistributionsystemenum(value)
				else:
					self._systemtype = value
			else:
				self._systemtype = value
		return property(**locals())

####################
 # ENTITY ifcreldefinesbytemplate #
####################
class ifcreldefinesbytemplate(ifcreldefines):
	'''Entity ifcreldefinesbytemplate definition.

	:param relatedpropertysets
	:type relatedpropertysets:SET(1,None,'ifcpropertysetdefinition', scope = schema_scope)

	:param relatingtemplate
	:type relatingtemplate:ifcpropertysettemplate
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedpropertysets,relatingtemplate, ):
		ifcreldefines.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedpropertysets = relatedpropertysets
		self.relatingtemplate = relatingtemplate

	@apply
	def relatedpropertysets():
		def fget( self ):
			return self._relatedpropertysets
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedpropertysets is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcpropertysetdefinition', scope = schema_scope)):
				self._relatedpropertysets = SET(value)
			else:
				self._relatedpropertysets = value
		return property(**locals())

	@apply
	def relatingtemplate():
		def fget( self ):
			return self._relatingtemplate
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingtemplate is mantatory and can not be set to None')
			if not check_type(value,ifcpropertysettemplate):
				self._relatingtemplate = ifcpropertysettemplate(value)
			else:
				self._relatingtemplate = value
		return property(**locals())

####################
 # ENTITY ifccartesianpointlist #
####################
class ifccartesianpointlist(ifcgeometricrepresentationitem):
	'''Entity ifccartesianpointlist definition.
	'''
	def __init__( self ,  ):
		ifcgeometricrepresentationitem.__init__(self , )

####################
 # ENTITY ifccartesianpointlist3d #
####################
class ifccartesianpointlist3d(ifccartesianpointlist):
	'''Entity ifccartesianpointlist3d definition.

	:param coordlist
	:type coordlist:LIST(1,None,LIST(3,3,'REAL', scope = schema_scope))
	'''
	def __init__( self , coordlist, ):
		ifccartesianpointlist.__init__(self , )
		self.coordlist = coordlist

	@apply
	def coordlist():
		def fget( self ):
			return self._coordlist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordlist is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,LIST(3,3,'REAL', scope = schema_scope))):
				self._coordlist = LIST(value)
			else:
				self._coordlist = value
		return property(**locals())

####################
 # ENTITY ifclightsourcepositional #
####################
class ifclightsourcepositional(ifclightsource):
	'''Entity ifclightsourcepositional definition.

	:param position
	:type position:ifccartesianpoint

	:param radius
	:type radius:ifcpositivelengthmeasure

	:param constantattenuation
	:type constantattenuation:ifcreal

	:param distanceattenuation
	:type distanceattenuation:ifcreal

	:param quadricattenuation
	:type quadricattenuation:ifcreal
	'''
	def __init__( self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , position,radius,constantattenuation,distanceattenuation,quadricattenuation, ):
		ifclightsource.__init__(self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , )
		self.position = position
		self.radius = radius
		self.constantattenuation = constantattenuation
		self.distanceattenuation = distanceattenuation
		self.quadricattenuation = quadricattenuation

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifccartesianpoint):
				self._position = ifccartesianpoint(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def constantattenuation():
		def fget( self ):
			return self._constantattenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constantattenuation is mantatory and can not be set to None')
			if not check_type(value,ifcreal):
				self._constantattenuation = ifcreal(value)
			else:
				self._constantattenuation = value
		return property(**locals())

	@apply
	def distanceattenuation():
		def fget( self ):
			return self._distanceattenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distanceattenuation is mantatory and can not be set to None')
			if not check_type(value,ifcreal):
				self._distanceattenuation = ifcreal(value)
			else:
				self._distanceattenuation = value
		return property(**locals())

	@apply
	def quadricattenuation():
		def fget( self ):
			return self._quadricattenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument quadricattenuation is mantatory and can not be set to None')
			if not check_type(value,ifcreal):
				self._quadricattenuation = ifcreal(value)
			else:
				self._quadricattenuation = value
		return property(**locals())

####################
 # ENTITY ifcpiletype #
####################
class ifcpiletype(ifcbuildingelementtype):
	'''Entity ifcpiletype definition.

	:param predefinedtype
	:type predefinedtype:ifcpiletypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcpiletypeenum):
				self._predefinedtype = ifcpiletypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcpiletypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcpiletypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifccompositecurveonsurface #
####################
class ifccompositecurveonsurface(ifccompositecurve):
	'''Entity ifccompositecurveonsurface definition.

	:param basissurface
	:type basissurface:SET(0,1,'ifcsurface', scope = schema_scope)
	'''
	def __init__( self , inherited0__segments , inherited1__selfintersect ,  ):
		ifccompositecurve.__init__(self , inherited0__segments , inherited1__selfintersect , )

	@apply
	def basissurface():
		def fget( self ):
			attribute_eval = ifcgetbasissurface(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument basissurface is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def samesurface(self):
		eval_samesurface_wr = (SIZEOF(self.basissurface)  >  0)
		if not eval_samesurface_wr:
			raise AssertionError('Rule samesurface violated')
		else:
			return eval_samesurface_wr


####################
 # ENTITY ifcboundarycurve #
####################
class ifcboundarycurve(ifccompositecurveonsurface):
	'''Entity ifcboundarycurve definition.
	'''
	def __init__( self , inherited0__segments , inherited1__selfintersect ,  ):
		ifccompositecurveonsurface.__init__(self , inherited0__segments , inherited1__selfintersect , )
	def isclosed(self):
		eval_isclosed_wr = self.self.ifccompositecurve.self.closedcurve
		if not eval_isclosed_wr:
			raise AssertionError('Rule isclosed violated')
		else:
			return eval_isclosed_wr


####################
 # ENTITY ifclightsourcedirectional #
####################
class ifclightsourcedirectional(ifclightsource):
	'''Entity ifclightsourcedirectional definition.

	:param orientation
	:type orientation:ifcdirection
	'''
	def __init__( self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , orientation, ):
		ifclightsource.__init__(self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , )
		self.orientation = orientation

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._orientation = ifcdirection(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY ifcstructuralpointreaction #
####################
class ifcstructuralpointreaction(ifcstructuralreaction):
	'''Entity ifcstructuralpointreaction definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal ,  ):
		ifcstructuralreaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , )
	def suitableloadtype(self):
		eval_suitableloadtype_wr = (SIZEOF(['IFC4.IFCSTRUCTURALLOADSINGLEFORCE','IFC4.IFCSTRUCTURALLOADSINGLEDISPLACEMENT']  *  TYPEOF(self.self.ifcstructuralactivity.self.appliedload))  ==  1)
		if not eval_suitableloadtype_wr:
			raise AssertionError('Rule suitableloadtype violated')
		else:
			return eval_suitableloadtype_wr


####################
 # ENTITY ifcstructurallinearaction #
####################
class ifcstructurallinearaction(ifcstructuralcurveaction):
	'''Entity ifcstructurallinearaction definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__projectedortrue , inherited11__predefinedtype ,  ):
		ifcstructuralcurveaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__projectedortrue , inherited11__predefinedtype , )
	def suitableloadtype(self):
		eval_suitableloadtype_wr = (SIZEOF(['IFC4.IFCSTRUCTURALLOADLINEARFORCE','IFC4.IFCSTRUCTURALLOADTEMPERATURE']  *  TYPEOF(self.self.ifcstructuralactivity.self.appliedload))  ==  1)
		if not eval_suitableloadtype_wr:
			raise AssertionError('Rule suitableloadtype violated')
		else:
			return eval_suitableloadtype_wr

	def constpredefinedtype(self):
		eval_constpredefinedtype_wr = (self.self.ifcstructuralcurveaction.self.predefinedtype  ==  ifcstructuralcurveactivitytypeenum.self.const)
		if not eval_constpredefinedtype_wr:
			raise AssertionError('Rule constpredefinedtype violated')
		else:
			return eval_constpredefinedtype_wr


####################
 # ENTITY ifcfastener #
####################
class ifcfastener(ifcelementcomponent):
	'''Entity ifcfastener definition.

	:param predefinedtype
	:type predefinedtype:ifcfastenertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcelementcomponent.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfastenertypeenum):
					self._predefinedtype = ifcfastenertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcfastenertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcfastenertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCFASTENERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcorientededge #
####################
class ifcorientededge(ifcedge):
	'''Entity ifcorientededge definition.

	:param edgeelement
	:type edgeelement:ifcedge

	:param orientation
	:type orientation:BOOLEAN

	:param ifcedge_edgestart
	:type ifcedge_edgestart:ifcvertex

	:param ifcedge_edgeend
	:type ifcedge_edgeend:ifcvertex
	'''
	def __init__( self , inherited0__edgestart , inherited1__edgeend , edgeelement,orientation, ):
		ifcedge.__init__(self , inherited0__edgestart , inherited1__edgeend , )
		self.edgeelement = edgeelement
		self.orientation = orientation

	@apply
	def edgeelement():
		def fget( self ):
			return self._edgeelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgeelement is mantatory and can not be set to None')
			if not check_type(value,ifcedge):
				self._edgeelement = ifcedge(value)
			else:
				self._edgeelement = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def ifcedge_edgestart():
		def fget( self ):
			attribute_eval = ifcbooleanchoose(self.orientation,self.edgeelement.self.edgestart,self.edgeelement.self.edgeend)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcedge_edgestart is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ifcedge_edgeend():
		def fget( self ):
			attribute_eval = ifcbooleanchoose(self.orientation,self.edgeelement.self.edgeend,self.edgeelement.self.edgestart)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcedge_edgeend is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def edgeelementnotoriented(self):
		eval_edgeelementnotoriented_wr = ( not ('IFC4.IFCORIENTEDEDGE'  ==  TYPEOF(self.edgeelement)))
		if not eval_edgeelementnotoriented_wr:
			raise AssertionError('Rule edgeelementnotoriented violated')
		else:
			return eval_edgeelementnotoriented_wr


####################
 # ENTITY ifcrelassociatesconstraint #
####################
class ifcrelassociatesconstraint(ifcrelassociates):
	'''Entity ifcrelassociatesconstraint definition.

	:param intent
	:type intent:ifclabel

	:param relatingconstraint
	:type relatingconstraint:ifcconstraint
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , intent,relatingconstraint, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.intent = intent
		self.relatingconstraint = relatingconstraint

	@apply
	def intent():
		def fget( self ):
			return self._intent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._intent = ifclabel(value)
				else:
					self._intent = value
			else:
				self._intent = value
		return property(**locals())

	@apply
	def relatingconstraint():
		def fget( self ):
			return self._relatingconstraint
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingconstraint is mantatory and can not be set to None')
			if not check_type(value,ifcconstraint):
				self._relatingconstraint = ifcconstraint(value)
			else:
				self._relatingconstraint = value
		return property(**locals())

####################
 # ENTITY ifctimeseriesvalue #
####################
class ifctimeseriesvalue(BaseEntityClass):
	'''Entity ifctimeseriesvalue definition.

	:param listvalues
	:type listvalues:LIST(1,None,'ifcvalue', scope = schema_scope)
	'''
	def __init__( self , listvalues, ):
		self.listvalues = listvalues

	@apply
	def listvalues():
		def fget( self ):
			return self._listvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument listvalues is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
				self._listvalues = LIST(value)
			else:
				self._listvalues = value
		return property(**locals())

####################
 # ENTITY ifcbuildingelementpart #
####################
class ifcbuildingelementpart(ifcelementcomponent):
	'''Entity ifcbuildingelementpart definition.

	:param predefinedtype
	:type predefinedtype:ifcbuildingelementparttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcelementcomponent.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcbuildingelementparttypeenum):
					self._predefinedtype = ifcbuildingelementparttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcbuildingelementparttypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcbuildingelementparttypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCBUILDINGELEMENTPARTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcmaterialconstituentset #
####################
class ifcmaterialconstituentset(ifcmaterialdefinition):
	'''Entity ifcmaterialconstituentset definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param materialconstituents
	:type materialconstituents:SET(1,None,'ifcmaterialconstituent', scope = schema_scope)
	'''
	def __init__( self , name,description,materialconstituents, ):
		ifcmaterialdefinition.__init__(self , )
		self.name = name
		self.description = description
		self.materialconstituents = materialconstituents

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def materialconstituents():
		def fget( self ):
			return self._materialconstituents
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcmaterialconstituent', scope = schema_scope)):
					self._materialconstituents = SET(value)
				else:
					self._materialconstituents = value
			else:
				self._materialconstituents = value
		return property(**locals())

####################
 # ENTITY ifcbuildingelementproxy #
####################
class ifcbuildingelementproxy(ifcbuildingelement):
	'''Entity ifcbuildingelementproxy definition.

	:param predefinedtype
	:type predefinedtype:ifcbuildingelementproxytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcbuildingelementproxytypeenum):
					self._predefinedtype = ifcbuildingelementproxytypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def hasobjectname(self):
		eval_hasobjectname_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_hasobjectname_wr:
			raise AssertionError('Rule hasobjectname violated')
		else:
			return eval_hasobjectname_wr

	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcbuildingelementproxytypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcbuildingelementproxytypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCBUILDINGELEMENTPROXYTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcdiscreteaccessorytype #
####################
class ifcdiscreteaccessorytype(ifcelementcomponenttype):
	'''Entity ifcdiscreteaccessorytype definition.

	:param predefinedtype
	:type predefinedtype:ifcdiscreteaccessorytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcelementcomponenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcdiscreteaccessorytypeenum):
				self._predefinedtype = ifcdiscreteaccessorytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcdiscreteaccessorytypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcdiscreteaccessorytypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcsurfacefeature #
####################
class ifcsurfacefeature(ifcfeatureelement):
	'''Entity ifcsurfacefeature definition.

	:param predefinedtype
	:type predefinedtype:ifcsurfacefeaturetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcfeatureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsurfacefeaturetypeenum):
					self._predefinedtype = ifcsurfacefeaturetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def hasobjecttype(self):
		eval_hasobjecttype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcsurfacefeaturetypeenum.self.userdefined))  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_hasobjecttype_wr:
			raise AssertionError('Rule hasobjecttype violated')
		else:
			return eval_hasobjecttype_wr


####################
 # ENTITY ifcconnectedfaceset #
####################
class ifcconnectedfaceset(ifctopologicalrepresentationitem):
	'''Entity ifcconnectedfaceset definition.

	:param cfsfaces
	:type cfsfaces:SET(1,None,'ifcface', scope = schema_scope)
	'''
	def __init__( self , cfsfaces, ):
		ifctopologicalrepresentationitem.__init__(self , )
		self.cfsfaces = cfsfaces

	@apply
	def cfsfaces():
		def fget( self ):
			return self._cfsfaces
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument cfsfaces is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcface', scope = schema_scope)):
				self._cfsfaces = SET(value)
			else:
				self._cfsfaces = value
		return property(**locals())

####################
 # ENTITY ifcclosedshell #
####################
class ifcclosedshell(ifcconnectedfaceset):
	'''Entity ifcclosedshell definition.
	'''
	def __init__( self , inherited0__cfsfaces ,  ):
		ifcconnectedfaceset.__init__(self , inherited0__cfsfaces , )

####################
 # ENTITY ifccooledbeam #
####################
class ifccooledbeam(ifcenergyconversiondevice):
	'''Entity ifccooledbeam definition.

	:param predefinedtype
	:type predefinedtype:ifccooledbeamtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccooledbeamtypeenum):
					self._predefinedtype = ifccooledbeamtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccooledbeamtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccooledbeamtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCOOLEDBEAMTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcmemberstandardcase #
####################
class ifcmemberstandardcase(ifcmember):
	'''Entity ifcmemberstandardcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype ,  ):
		ifcmember.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype , )
	def hasmaterialprofilesetusage(self):
		eval_hasmaterialprofilesetusage_wr = (SIZEOF(None)  ==  1)
		if not eval_hasmaterialprofilesetusage_wr:
			raise AssertionError('Rule hasmaterialprofilesetusage violated')
		else:
			return eval_hasmaterialprofilesetusage_wr


####################
 # ENTITY ifcorganizationrelationship #
####################
class ifcorganizationrelationship(ifcresourcelevelrelationship):
	'''Entity ifcorganizationrelationship definition.

	:param relatingorganization
	:type relatingorganization:ifcorganization

	:param relatedorganizations
	:type relatedorganizations:SET(1,None,'ifcorganization', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , relatingorganization,relatedorganizations, ):
		ifcresourcelevelrelationship.__init__(self , inherited0__name , inherited1__description , )
		self.relatingorganization = relatingorganization
		self.relatedorganizations = relatedorganizations

	@apply
	def relatingorganization():
		def fget( self ):
			return self._relatingorganization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingorganization is mantatory and can not be set to None')
			if not check_type(value,ifcorganization):
				self._relatingorganization = ifcorganization(value)
			else:
				self._relatingorganization = value
		return property(**locals())

	@apply
	def relatedorganizations():
		def fget( self ):
			return self._relatedorganizations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedorganizations is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcorganization', scope = schema_scope)):
				self._relatedorganizations = SET(value)
			else:
				self._relatedorganizations = value
		return property(**locals())

####################
 # ENTITY ifcsanitaryterminal #
####################
class ifcsanitaryterminal(ifcflowterminal):
	'''Entity ifcsanitaryterminal definition.

	:param predefinedtype
	:type predefinedtype:ifcsanitaryterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsanitaryterminaltypeenum):
					self._predefinedtype = ifcsanitaryterminaltypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcsanitaryterminaltypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcsanitaryterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSANITARYTERMINALTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcvibrationisolator #
####################
class ifcvibrationisolator(ifcelementcomponent):
	'''Entity ifcvibrationisolator definition.

	:param predefinedtype
	:type predefinedtype:ifcvibrationisolatortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcelementcomponent.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvibrationisolatortypeenum):
					self._predefinedtype = ifcvibrationisolatortypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcvibrationisolatortypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcvibrationisolatortypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCVIBRATIONISOLATORTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifccovering #
####################
class ifccovering(ifcbuildingelement):
	'''Entity ifccovering definition.

	:param predefinedtype
	:type predefinedtype:ifccoveringtypeenum

	:param coversspaces
	:type coversspaces:SET(0,1,'ifcrelcoversspaces', scope = schema_scope)

	:param coverselements
	:type coverselements:SET(0,1,'ifcrelcoversbldgelements', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccoveringtypeenum):
					self._predefinedtype = ifccoveringtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def coversspaces():
		def fget( self ):
			return self._coversspaces
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument coversspaces is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def coverselements():
		def fget( self ):
			return self._coverselements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument coverselements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccoveringtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccoveringtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCOVERINGTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcquantitytime #
####################
class ifcquantitytime(ifcphysicalsimplequantity):
	'''Entity ifcquantitytime definition.

	:param timevalue
	:type timevalue:ifctimemeasure

	:param formula
	:type formula:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , timevalue,formula, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.timevalue = timevalue
		self.formula = formula

	@apply
	def timevalue():
		def fget( self ):
			return self._timevalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timevalue is mantatory and can not be set to None')
			if not check_type(value,ifctimemeasure):
				self._timevalue = ifctimemeasure(value)
			else:
				self._timevalue = value
		return property(**locals())

	@apply
	def formula():
		def fget( self ):
			return self._formula
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._formula = ifclabel(value)
				else:
					self._formula = value
			else:
				self._formula = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.self.ifcphysicalsimplequantity.self.unit))  or  (self.self.ifcphysicalsimplequantity.self.unit.self.unittype  ==  ifcunitenum.self.timeunit))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.timevalue  >=  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcdocumentinformationrelationship #
####################
class ifcdocumentinformationrelationship(ifcresourcelevelrelationship):
	'''Entity ifcdocumentinformationrelationship definition.

	:param relatingdocument
	:type relatingdocument:ifcdocumentinformation

	:param relateddocuments
	:type relateddocuments:SET(1,None,'ifcdocumentinformation', scope = schema_scope)

	:param relationshiptype
	:type relationshiptype:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , relatingdocument,relateddocuments,relationshiptype, ):
		ifcresourcelevelrelationship.__init__(self , inherited0__name , inherited1__description , )
		self.relatingdocument = relatingdocument
		self.relateddocuments = relateddocuments
		self.relationshiptype = relationshiptype

	@apply
	def relatingdocument():
		def fget( self ):
			return self._relatingdocument
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingdocument is mantatory and can not be set to None')
			if not check_type(value,ifcdocumentinformation):
				self._relatingdocument = ifcdocumentinformation(value)
			else:
				self._relatingdocument = value
		return property(**locals())

	@apply
	def relateddocuments():
		def fget( self ):
			return self._relateddocuments
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relateddocuments is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcdocumentinformation', scope = schema_scope)):
				self._relateddocuments = SET(value)
			else:
				self._relateddocuments = value
		return property(**locals())

	@apply
	def relationshiptype():
		def fget( self ):
			return self._relationshiptype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._relationshiptype = ifclabel(value)
				else:
					self._relationshiptype = value
			else:
				self._relationshiptype = value
		return property(**locals())

####################
 # ENTITY ifcgeometricrepresentationsubcontext #
####################
class ifcgeometricrepresentationsubcontext(ifcgeometricrepresentationcontext):
	'''Entity ifcgeometricrepresentationsubcontext definition.

	:param parentcontext
	:type parentcontext:ifcgeometricrepresentationcontext

	:param targetscale
	:type targetscale:ifcpositiveratiomeasure

	:param targetview
	:type targetview:ifcgeometricprojectionenum

	:param userdefinedtargetview
	:type userdefinedtargetview:ifclabel

	:param ifcgeometricrepresentationcontext_worldcoordinatesystem
	:type ifcgeometricrepresentationcontext_worldcoordinatesystem:ifcaxis2placement

	:param ifcgeometricrepresentationcontext_coordinatespacedimension
	:type ifcgeometricrepresentationcontext_coordinatespacedimension:ifcdimensioncount

	:param ifcgeometricrepresentationcontext_truenorth
	:type ifcgeometricrepresentationcontext_truenorth:ifcdirection

	:param ifcgeometricrepresentationcontext_precision
	:type ifcgeometricrepresentationcontext_precision:REAL
	'''
	def __init__( self , inherited0__contextidentifier , inherited1__contexttype , inherited2__coordinatespacedimension , inherited3__precision , inherited4__worldcoordinatesystem , inherited5__truenorth , parentcontext,targetscale,targetview,userdefinedtargetview, ):
		ifcgeometricrepresentationcontext.__init__(self , inherited0__contextidentifier , inherited1__contexttype , inherited2__coordinatespacedimension , inherited3__precision , inherited4__worldcoordinatesystem , inherited5__truenorth , )
		self.parentcontext = parentcontext
		self.targetscale = targetscale
		self.targetview = targetview
		self.userdefinedtargetview = userdefinedtargetview

	@apply
	def parentcontext():
		def fget( self ):
			return self._parentcontext
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parentcontext is mantatory and can not be set to None')
			if not check_type(value,ifcgeometricrepresentationcontext):
				self._parentcontext = ifcgeometricrepresentationcontext(value)
			else:
				self._parentcontext = value
		return property(**locals())

	@apply
	def targetscale():
		def fget( self ):
			return self._targetscale
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._targetscale = ifcpositiveratiomeasure(value)
				else:
					self._targetscale = value
			else:
				self._targetscale = value
		return property(**locals())

	@apply
	def targetview():
		def fget( self ):
			return self._targetview
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument targetview is mantatory and can not be set to None')
			if not check_type(value,ifcgeometricprojectionenum):
				self._targetview = ifcgeometricprojectionenum(value)
			else:
				self._targetview = value
		return property(**locals())

	@apply
	def userdefinedtargetview():
		def fget( self ):
			return self._userdefinedtargetview
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedtargetview = ifclabel(value)
				else:
					self._userdefinedtargetview = value
			else:
				self._userdefinedtargetview = value
		return property(**locals())

	@apply
	def ifcgeometricrepresentationcontext_worldcoordinatesystem():
		def fget( self ):
			attribute_eval = self.parentcontext.self.worldcoordinatesystem
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcgeometricrepresentationcontext_worldcoordinatesystem is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ifcgeometricrepresentationcontext_coordinatespacedimension():
		def fget( self ):
			attribute_eval = self.parentcontext.self.coordinatespacedimension
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcgeometricrepresentationcontext_coordinatespacedimension is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ifcgeometricrepresentationcontext_truenorth():
		def fget( self ):
			attribute_eval = NVL(self.parentcontext.self.truenorth,ifcconvertdirectioninto2d(self.self.ifcgeometricrepresentationcontext.self.worldcoordinatesystem.self.p[2]))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcgeometricrepresentationcontext_truenorth is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ifcgeometricrepresentationcontext_precision():
		def fget( self ):
			attribute_eval = NVL(self.parentcontext.self.precision,1e-005)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcgeometricrepresentationcontext_precision is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = ( not ('IFC4.IFCGEOMETRICREPRESENTATIONSUBCONTEXT'  ==  TYPEOF(self.parentcontext)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = ((self.targetview  !=  ifcgeometricprojectionenum.self.userdefined)  or  ((self.targetview  ==  ifcgeometricprojectionenum.self.userdefined)  and  EXISTS(self.userdefinedtargetview)))
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr


####################
 # ENTITY ifccommunicationsappliancetype #
####################
class ifccommunicationsappliancetype(ifcflowterminaltype):
	'''Entity ifccommunicationsappliancetype definition.

	:param predefinedtype
	:type predefinedtype:ifccommunicationsappliancetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccommunicationsappliancetypeenum):
				self._predefinedtype = ifccommunicationsappliancetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccommunicationsappliancetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccommunicationsappliancetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcdocumentreference #
####################
class ifcdocumentreference(ifcexternalreference):
	'''Entity ifcdocumentreference definition.

	:param description
	:type description:ifctext

	:param referenceddocument
	:type referenceddocument:ifcdocumentinformation

	:param documentrefforobjects
	:type documentrefforobjects:SET(0,None,'ifcrelassociatesdocument', scope = schema_scope)
	'''
	def __init__( self , inherited0__location , inherited1__identification , inherited2__name , description,referenceddocument, ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__identification , inherited2__name , )
		self.description = description
		self.referenceddocument = referenceddocument

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def referenceddocument():
		def fget( self ):
			return self._referenceddocument
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdocumentinformation):
					self._referenceddocument = ifcdocumentinformation(value)
				else:
					self._referenceddocument = value
			else:
				self._referenceddocument = value
		return property(**locals())

	@apply
	def documentrefforobjects():
		def fget( self ):
			return self._documentrefforobjects
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument documentrefforobjects is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.name) XOR EXISTS(self.referenceddocument))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcexternallydefinedtextfont #
####################
class ifcexternallydefinedtextfont(ifcexternalreference):
	'''Entity ifcexternallydefinedtextfont definition.
	'''
	def __init__( self , inherited0__location , inherited1__identification , inherited2__name ,  ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__identification , inherited2__name , )

####################
 # ENTITY ifcconnectioncurvegeometry #
####################
class ifcconnectioncurvegeometry(ifcconnectiongeometry):
	'''Entity ifcconnectioncurvegeometry definition.

	:param curveonrelatingelement
	:type curveonrelatingelement:ifccurveoredgecurve

	:param curveonrelatedelement
	:type curveonrelatedelement:ifccurveoredgecurve
	'''
	def __init__( self , curveonrelatingelement,curveonrelatedelement, ):
		ifcconnectiongeometry.__init__(self , )
		self.curveonrelatingelement = curveonrelatingelement
		self.curveonrelatedelement = curveonrelatedelement

	@apply
	def curveonrelatingelement():
		def fget( self ):
			return self._curveonrelatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curveonrelatingelement is mantatory and can not be set to None')
			if not check_type(value,ifccurveoredgecurve):
				self._curveonrelatingelement = ifccurveoredgecurve(value)
			else:
				self._curveonrelatingelement = value
		return property(**locals())

	@apply
	def curveonrelatedelement():
		def fget( self ):
			return self._curveonrelatedelement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccurveoredgecurve):
					self._curveonrelatedelement = ifccurveoredgecurve(value)
				else:
					self._curveonrelatedelement = value
			else:
				self._curveonrelatedelement = value
		return property(**locals())

####################
 # ENTITY ifcengine #
####################
class ifcengine(ifcenergyconversiondevice):
	'''Entity ifcengine definition.

	:param predefinedtype
	:type predefinedtype:ifcenginetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcenginetypeenum):
					self._predefinedtype = ifcenginetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcenginetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcenginetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCENGINETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcresourcetime #
####################
class ifcresourcetime(ifcschedulingtime):
	'''Entity ifcresourcetime definition.

	:param schedulework
	:type schedulework:ifcduration

	:param scheduleusage
	:type scheduleusage:ifcpositiveratiomeasure

	:param schedulestart
	:type schedulestart:ifcdatetime

	:param schedulefinish
	:type schedulefinish:ifcdatetime

	:param schedulecontour
	:type schedulecontour:ifclabel

	:param levelingdelay
	:type levelingdelay:ifcduration

	:param isoverallocated
	:type isoverallocated:BOOLEAN

	:param statustime
	:type statustime:ifcdatetime

	:param actualwork
	:type actualwork:ifcduration

	:param actualusage
	:type actualusage:ifcpositiveratiomeasure

	:param actualstart
	:type actualstart:ifcdatetime

	:param actualfinish
	:type actualfinish:ifcdatetime

	:param remainingwork
	:type remainingwork:ifcduration

	:param remainingusage
	:type remainingusage:ifcpositiveratiomeasure

	:param completion
	:type completion:ifcpositiveratiomeasure
	'''
	def __init__( self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , schedulework,scheduleusage,schedulestart,schedulefinish,schedulecontour,levelingdelay,isoverallocated,statustime,actualwork,actualusage,actualstart,actualfinish,remainingwork,remainingusage,completion, ):
		ifcschedulingtime.__init__(self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , )
		self.schedulework = schedulework
		self.scheduleusage = scheduleusage
		self.schedulestart = schedulestart
		self.schedulefinish = schedulefinish
		self.schedulecontour = schedulecontour
		self.levelingdelay = levelingdelay
		self.isoverallocated = isoverallocated
		self.statustime = statustime
		self.actualwork = actualwork
		self.actualusage = actualusage
		self.actualstart = actualstart
		self.actualfinish = actualfinish
		self.remainingwork = remainingwork
		self.remainingusage = remainingusage
		self.completion = completion

	@apply
	def schedulework():
		def fget( self ):
			return self._schedulework
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcduration):
					self._schedulework = ifcduration(value)
				else:
					self._schedulework = value
			else:
				self._schedulework = value
		return property(**locals())

	@apply
	def scheduleusage():
		def fget( self ):
			return self._scheduleusage
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._scheduleusage = ifcpositiveratiomeasure(value)
				else:
					self._scheduleusage = value
			else:
				self._scheduleusage = value
		return property(**locals())

	@apply
	def schedulestart():
		def fget( self ):
			return self._schedulestart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._schedulestart = ifcdatetime(value)
				else:
					self._schedulestart = value
			else:
				self._schedulestart = value
		return property(**locals())

	@apply
	def schedulefinish():
		def fget( self ):
			return self._schedulefinish
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._schedulefinish = ifcdatetime(value)
				else:
					self._schedulefinish = value
			else:
				self._schedulefinish = value
		return property(**locals())

	@apply
	def schedulecontour():
		def fget( self ):
			return self._schedulecontour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._schedulecontour = ifclabel(value)
				else:
					self._schedulecontour = value
			else:
				self._schedulecontour = value
		return property(**locals())

	@apply
	def levelingdelay():
		def fget( self ):
			return self._levelingdelay
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcduration):
					self._levelingdelay = ifcduration(value)
				else:
					self._levelingdelay = value
			else:
				self._levelingdelay = value
		return property(**locals())

	@apply
	def isoverallocated():
		def fget( self ):
			return self._isoverallocated
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._isoverallocated = BOOLEAN(value)
				else:
					self._isoverallocated = value
			else:
				self._isoverallocated = value
		return property(**locals())

	@apply
	def statustime():
		def fget( self ):
			return self._statustime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._statustime = ifcdatetime(value)
				else:
					self._statustime = value
			else:
				self._statustime = value
		return property(**locals())

	@apply
	def actualwork():
		def fget( self ):
			return self._actualwork
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcduration):
					self._actualwork = ifcduration(value)
				else:
					self._actualwork = value
			else:
				self._actualwork = value
		return property(**locals())

	@apply
	def actualusage():
		def fget( self ):
			return self._actualusage
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._actualusage = ifcpositiveratiomeasure(value)
				else:
					self._actualusage = value
			else:
				self._actualusage = value
		return property(**locals())

	@apply
	def actualstart():
		def fget( self ):
			return self._actualstart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._actualstart = ifcdatetime(value)
				else:
					self._actualstart = value
			else:
				self._actualstart = value
		return property(**locals())

	@apply
	def actualfinish():
		def fget( self ):
			return self._actualfinish
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._actualfinish = ifcdatetime(value)
				else:
					self._actualfinish = value
			else:
				self._actualfinish = value
		return property(**locals())

	@apply
	def remainingwork():
		def fget( self ):
			return self._remainingwork
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcduration):
					self._remainingwork = ifcduration(value)
				else:
					self._remainingwork = value
			else:
				self._remainingwork = value
		return property(**locals())

	@apply
	def remainingusage():
		def fget( self ):
			return self._remainingusage
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._remainingusage = ifcpositiveratiomeasure(value)
				else:
					self._remainingusage = value
			else:
				self._remainingusage = value
		return property(**locals())

	@apply
	def completion():
		def fget( self ):
			return self._completion
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._completion = ifcpositiveratiomeasure(value)
				else:
					self._completion = value
			else:
				self._completion = value
		return property(**locals())

####################
 # ENTITY ifccrewresourcetype #
####################
class ifccrewresourcetype(ifcconstructionresourcetype):
	'''Entity ifccrewresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifccrewresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , predefinedtype, ):
		ifcconstructionresourcetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccrewresourcetypeenum):
				self._predefinedtype = ifccrewresourcetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccrewresourcetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccrewresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifctyperesource.self.resourcetype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcdraughtingpredefinedcolour #
####################
class ifcdraughtingpredefinedcolour(ifcpredefinedcolour):
	'''Entity ifcdraughtingpredefinedcolour definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefinedcolour.__init__(self , inherited0__name , )
	def predefinedcolournames(self):
		eval_predefinedcolournames_wr = (self.self.ifcpredefineditem.self.name  ==  ['black','red','green','blue','yellow','magenta','cyan','white','by layer'])
		if not eval_predefinedcolournames_wr:
			raise AssertionError('Rule predefinedcolournames violated')
		else:
			return eval_predefinedcolournames_wr


####################
 # ENTITY ifcrelcoversspaces #
####################
class ifcrelcoversspaces(ifcrelconnects):
	'''Entity ifcrelcoversspaces definition.

	:param relatingspace
	:type relatingspace:ifcspace

	:param relatedcoverings
	:type relatedcoverings:SET(1,None,'ifccovering', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingspace,relatedcoverings, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingspace = relatingspace
		self.relatedcoverings = relatedcoverings

	@apply
	def relatingspace():
		def fget( self ):
			return self._relatingspace
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingspace is mantatory and can not be set to None')
			if not check_type(value,ifcspace):
				self._relatingspace = ifcspace(value)
			else:
				self._relatingspace = value
		return property(**locals())

	@apply
	def relatedcoverings():
		def fget( self ):
			return self._relatedcoverings
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedcoverings is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifccovering', scope = schema_scope)):
				self._relatedcoverings = SET(value)
			else:
				self._relatedcoverings = value
		return property(**locals())

####################
 # ENTITY ifclaborresource #
####################
class ifclaborresource(ifcconstructionresource):
	'''Entity ifclaborresource definition.

	:param predefinedtype
	:type predefinedtype:ifclaborresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , predefinedtype, ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclaborresourcetypeenum):
					self._predefinedtype = ifclaborresourcetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifclaborresourcetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifclaborresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcmechanicalfastenertype #
####################
class ifcmechanicalfastenertype(ifcelementcomponenttype):
	'''Entity ifcmechanicalfastenertype definition.

	:param predefinedtype
	:type predefinedtype:ifcmechanicalfastenertypeenum

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param nominallength
	:type nominallength:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype,nominaldiameter,nominallength, ):
		ifcelementcomponenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype
		self.nominaldiameter = nominaldiameter
		self.nominallength = nominallength

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcmechanicalfastenertypeenum):
				self._predefinedtype = ifcmechanicalfastenertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def nominaldiameter():
		def fget( self ):
			return self._nominaldiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominaldiameter = ifcpositivelengthmeasure(value)
				else:
					self._nominaldiameter = value
			else:
				self._nominaldiameter = value
		return property(**locals())

	@apply
	def nominallength():
		def fget( self ):
			return self._nominallength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominallength = ifcpositivelengthmeasure(value)
				else:
					self._nominallength = value
			else:
				self._nominallength = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcmechanicalfastenertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcmechanicalfastenertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcquantityweight #
####################
class ifcquantityweight(ifcphysicalsimplequantity):
	'''Entity ifcquantityweight definition.

	:param weightvalue
	:type weightvalue:ifcmassmeasure

	:param formula
	:type formula:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , weightvalue,formula, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.weightvalue = weightvalue
		self.formula = formula

	@apply
	def weightvalue():
		def fget( self ):
			return self._weightvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument weightvalue is mantatory and can not be set to None')
			if not check_type(value,ifcmassmeasure):
				self._weightvalue = ifcmassmeasure(value)
			else:
				self._weightvalue = value
		return property(**locals())

	@apply
	def formula():
		def fget( self ):
			return self._formula
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._formula = ifclabel(value)
				else:
					self._formula = value
			else:
				self._formula = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.self.ifcphysicalsimplequantity.self.unit))  or  (self.self.ifcphysicalsimplequantity.self.unit.self.unittype  ==  ifcunitenum.self.massunit))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.weightvalue  >=  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcwalltype #
####################
class ifcwalltype(ifcbuildingelementtype):
	'''Entity ifcwalltype definition.

	:param predefinedtype
	:type predefinedtype:ifcwalltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcwalltypeenum):
				self._predefinedtype = ifcwalltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcwalltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcwalltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcconstructionmaterialresource #
####################
class ifcconstructionmaterialresource(ifcconstructionresource):
	'''Entity ifcconstructionmaterialresource definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionmaterialresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , predefinedtype, ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcconstructionmaterialresourcetypeenum):
					self._predefinedtype = ifcconstructionmaterialresourcetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcconstructionmaterialresourcetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcconstructionmaterialresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcapprovalrelationship #
####################
class ifcapprovalrelationship(ifcresourcelevelrelationship):
	'''Entity ifcapprovalrelationship definition.

	:param relatingapproval
	:type relatingapproval:ifcapproval

	:param relatedapprovals
	:type relatedapprovals:SET(1,None,'ifcapproval', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , relatingapproval,relatedapprovals, ):
		ifcresourcelevelrelationship.__init__(self , inherited0__name , inherited1__description , )
		self.relatingapproval = relatingapproval
		self.relatedapprovals = relatedapprovals

	@apply
	def relatingapproval():
		def fget( self ):
			return self._relatingapproval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingapproval is mantatory and can not be set to None')
			if not check_type(value,ifcapproval):
				self._relatingapproval = ifcapproval(value)
			else:
				self._relatingapproval = value
		return property(**locals())

	@apply
	def relatedapprovals():
		def fget( self ):
			return self._relatedapprovals
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedapprovals is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcapproval', scope = schema_scope)):
				self._relatedapprovals = SET(value)
			else:
				self._relatedapprovals = value
		return property(**locals())

####################
 # ENTITY ifcboundingbox #
####################
class ifcboundingbox(ifcgeometricrepresentationitem):
	'''Entity ifcboundingbox definition.

	:param corner
	:type corner:ifccartesianpoint

	:param xdim
	:type xdim:ifcpositivelengthmeasure

	:param ydim
	:type ydim:ifcpositivelengthmeasure

	:param zdim
	:type zdim:ifcpositivelengthmeasure

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , corner,xdim,ydim,zdim, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.corner = corner
		self.xdim = xdim
		self.ydim = ydim
		self.zdim = zdim

	@apply
	def corner():
		def fget( self ):
			return self._corner
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument corner is mantatory and can not be set to None')
			if not check_type(value,ifccartesianpoint):
				self._corner = ifccartesianpoint(value)
			else:
				self._corner = value
		return property(**locals())

	@apply
	def xdim():
		def fget( self ):
			return self._xdim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument xdim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._xdim = ifcpositivelengthmeasure(value)
			else:
				self._xdim = value
		return property(**locals())

	@apply
	def ydim():
		def fget( self ):
			return self._ydim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ydim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._ydim = ifcpositivelengthmeasure(value)
			else:
				self._ydim = value
		return property(**locals())

	@apply
	def zdim():
		def fget( self ):
			return self._zdim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zdim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._zdim = ifcpositivelengthmeasure(value)
			else:
				self._zdim = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcishapeprofiledef #
####################
class ifcishapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifcishapeprofiledef definition.

	:param overallwidth
	:type overallwidth:ifcpositivelengthmeasure

	:param overalldepth
	:type overalldepth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcnonnegativelengthmeasure

	:param flangeedgeradius
	:type flangeedgeradius:ifcnonnegativelengthmeasure

	:param flangeslope
	:type flangeslope:ifcplaneanglemeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , overallwidth,overalldepth,webthickness,flangethickness,filletradius,flangeedgeradius,flangeslope, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.overallwidth = overallwidth
		self.overalldepth = overalldepth
		self.webthickness = webthickness
		self.flangethickness = flangethickness
		self.filletradius = filletradius
		self.flangeedgeradius = flangeedgeradius
		self.flangeslope = flangeslope

	@apply
	def overallwidth():
		def fget( self ):
			return self._overallwidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument overallwidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._overallwidth = ifcpositivelengthmeasure(value)
			else:
				self._overallwidth = value
		return property(**locals())

	@apply
	def overalldepth():
		def fget( self ):
			return self._overalldepth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument overalldepth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._overalldepth = ifcpositivelengthmeasure(value)
			else:
				self._overalldepth = value
		return property(**locals())

	@apply
	def webthickness():
		def fget( self ):
			return self._webthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument webthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._webthickness = ifcpositivelengthmeasure(value)
			else:
				self._webthickness = value
		return property(**locals())

	@apply
	def flangethickness():
		def fget( self ):
			return self._flangethickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangethickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangethickness = ifcpositivelengthmeasure(value)
			else:
				self._flangethickness = value
		return property(**locals())

	@apply
	def filletradius():
		def fget( self ):
			return self._filletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._filletradius = ifcnonnegativelengthmeasure(value)
				else:
					self._filletradius = value
			else:
				self._filletradius = value
		return property(**locals())

	@apply
	def flangeedgeradius():
		def fget( self ):
			return self._flangeedgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._flangeedgeradius = ifcnonnegativelengthmeasure(value)
				else:
					self._flangeedgeradius = value
			else:
				self._flangeedgeradius = value
		return property(**locals())

	@apply
	def flangeslope():
		def fget( self ):
			return self._flangeslope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._flangeslope = ifcplaneanglemeasure(value)
				else:
					self._flangeslope = value
			else:
				self._flangeslope = value
		return property(**locals())
	def validflangethickness(self):
		eval_validflangethickness_wr = ((2  *  self.flangethickness)  <  self.overalldepth)
		if not eval_validflangethickness_wr:
			raise AssertionError('Rule validflangethickness violated')
		else:
			return eval_validflangethickness_wr

	def validwebthickness(self):
		eval_validwebthickness_wr = (self.webthickness  <  self.overallwidth)
		if not eval_validwebthickness_wr:
			raise AssertionError('Rule validwebthickness violated')
		else:
			return eval_validwebthickness_wr

	def validfilletradius(self):
		eval_validfilletradius_wr = (( not EXISTS(self.filletradius))  or  ((self.filletradius  <=  ((self.overallwidth - self.webthickness) / 2))  and  (self.filletradius  <=  ((self.overalldepth - (2  *  self.flangethickness)) / 2))))
		if not eval_validfilletradius_wr:
			raise AssertionError('Rule validfilletradius violated')
		else:
			return eval_validfilletradius_wr


####################
 # ENTITY ifctextstylefordefinedfont #
####################
class ifctextstylefordefinedfont(ifcpresentationitem):
	'''Entity ifctextstylefordefinedfont definition.

	:param colour
	:type colour:ifccolour

	:param backgroundcolour
	:type backgroundcolour:ifccolour
	'''
	def __init__( self , colour,backgroundcolour, ):
		ifcpresentationitem.__init__(self , )
		self.colour = colour
		self.backgroundcolour = backgroundcolour

	@apply
	def colour():
		def fget( self ):
			return self._colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument colour is mantatory and can not be set to None')
			if not check_type(value,ifccolour):
				self._colour = ifccolour(value)
			else:
				self._colour = value
		return property(**locals())

	@apply
	def backgroundcolour():
		def fget( self ):
			return self._backgroundcolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolour):
					self._backgroundcolour = ifccolour(value)
				else:
					self._backgroundcolour = value
			else:
				self._backgroundcolour = value
		return property(**locals())

####################
 # ENTITY ifcconstructionproductresource #
####################
class ifcconstructionproductresource(ifcconstructionresource):
	'''Entity ifcconstructionproductresource definition.

	:param predefinedtype
	:type predefinedtype:ifcconstructionproductresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , predefinedtype, ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , inherited7__usage , inherited8__basecosts , inherited9__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcconstructionproductresourcetypeenum):
					self._predefinedtype = ifcconstructionproductresourcetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcconstructionproductresourcetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcconstructionproductresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcmonetaryunit #
####################
class ifcmonetaryunit(BaseEntityClass):
	'''Entity ifcmonetaryunit definition.

	:param currency
	:type currency:ifclabel
	'''
	def __init__( self , currency, ):
		self.currency = currency

	@apply
	def currency():
		def fget( self ):
			return self._currency
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument currency is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._currency = ifclabel(value)
			else:
				self._currency = value
		return property(**locals())

####################
 # ENTITY ifcpropertysinglevalue #
####################
class ifcpropertysinglevalue(ifcsimpleproperty):
	'''Entity ifcpropertysinglevalue definition.

	:param nominalvalue
	:type nominalvalue:ifcvalue

	:param unit
	:type unit:ifcunit
	'''
	def __init__( self , inherited0__name , inherited1__description , nominalvalue,unit, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.nominalvalue = nominalvalue
		self.unit = unit

	@apply
	def nominalvalue():
		def fget( self ):
			return self._nominalvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvalue):
					self._nominalvalue = ifcvalue(value)
				else:
					self._nominalvalue = value
			else:
				self._nominalvalue = value
		return property(**locals())

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._unit = ifcunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())

####################
 # ENTITY ifcrelassignstoprocess #
####################
class ifcrelassignstoprocess(ifcrelassigns):
	'''Entity ifcrelassignstoprocess definition.

	:param relatingprocess
	:type relatingprocess:ifcprocessselect

	:param quantityinprocess
	:type quantityinprocess:ifcmeasurewithunit
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatingprocess,quantityinprocess, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatingprocess = relatingprocess
		self.quantityinprocess = quantityinprocess

	@apply
	def relatingprocess():
		def fget( self ):
			return self._relatingprocess
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingprocess is mantatory and can not be set to None')
			if not check_type(value,ifcprocessselect):
				self._relatingprocess = ifcprocessselect(value)
			else:
				self._relatingprocess = value
		return property(**locals())

	@apply
	def quantityinprocess():
		def fget( self ):
			return self._quantityinprocess
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmeasurewithunit):
					self._quantityinprocess = ifcmeasurewithunit(value)
				else:
					self._quantityinprocess = value
			else:
				self._quantityinprocess = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (SIZEOF(None)  ==  0)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifcsiunit #
####################
class ifcsiunit(ifcnamedunit):
	'''Entity ifcsiunit definition.

	:param prefix
	:type prefix:ifcsiprefix

	:param name
	:type name:ifcsiunitname

	:param ifcnamedunit_dimensions
	:type ifcnamedunit_dimensions:ifcdimensionalexponents
	'''
	def __init__( self , inherited0__dimensions , inherited1__unittype , prefix,name, ):
		ifcnamedunit.__init__(self , inherited0__dimensions , inherited1__unittype , )
		self.prefix = prefix
		self.name = name

	@apply
	def prefix():
		def fget( self ):
			return self._prefix
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsiprefix):
					self._prefix = ifcsiprefix(value)
				else:
					self._prefix = value
			else:
				self._prefix = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifcsiunitname):
				self._name = ifcsiunitname(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def ifcnamedunit_dimensions():
		def fget( self ):
			attribute_eval = ifcdimensionsforsiunit(self.self.name)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcnamedunit_dimensions is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcspaceheatertype #
####################
class ifcspaceheatertype(ifcflowterminaltype):
	'''Entity ifcspaceheatertype definition.

	:param predefinedtype
	:type predefinedtype:ifcspaceheatertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcspaceheatertypeenum):
				self._predefinedtype = ifcspaceheatertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcspaceheatertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcspaceheatertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcsubcontractresourcetype #
####################
class ifcsubcontractresourcetype(ifcconstructionresourcetype):
	'''Entity ifcsubcontractresourcetype definition.

	:param predefinedtype
	:type predefinedtype:ifcsubcontractresourcetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , predefinedtype, ):
		ifcconstructionresourcetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__resourcetype , inherited9__basecosts , inherited10__basequantity , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcsubcontractresourcetypeenum):
				self._predefinedtype = ifcsubcontractresourcetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcsubcontractresourcetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcsubcontractresourcetypeenum.self.userdefined)  and  EXISTS(self.self.ifctyperesource.self.resourcetype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcdistributionchamberelementtype #
####################
class ifcdistributionchamberelementtype(ifcdistributionflowelementtype):
	'''Entity ifcdistributionchamberelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifcdistributionchamberelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcdistributionchamberelementtypeenum):
				self._predefinedtype = ifcdistributionchamberelementtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcdistributionchamberelementtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcdistributionchamberelementtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcstructuralcurvemember #
####################
class ifcstructuralcurvemember(ifcstructuralmember):
	'''Entity ifcstructuralcurvemember definition.

	:param predefinedtype
	:type predefinedtype:ifcstructuralcurvemembertypeenum

	:param axis
	:type axis:ifcdirection
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , predefinedtype,axis, ):
		ifcstructuralmember.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.predefinedtype = predefinedtype
		self.axis = axis

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralcurvemembertypeenum):
				self._predefinedtype = ifcstructuralcurvemembertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axis is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._axis = ifcdirection(value)
			else:
				self._axis = value
		return property(**locals())
	def hasobjecttype(self):
		eval_hasobjecttype_wr = ((self.predefinedtype  !=  ifcstructuralcurvemembertypeenum.self.userdefined)  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_hasobjecttype_wr:
			raise AssertionError('Rule hasobjecttype violated')
		else:
			return eval_hasobjecttype_wr


####################
 # ENTITY ifcjunctionboxtype #
####################
class ifcjunctionboxtype(ifcflowfittingtype):
	'''Entity ifcjunctionboxtype definition.

	:param predefinedtype
	:type predefinedtype:ifcjunctionboxtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowfittingtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcjunctionboxtypeenum):
				self._predefinedtype = ifcjunctionboxtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcjunctionboxtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcjunctionboxtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifccontextdependentunit #
####################
class ifccontextdependentunit(ifcnamedunit):
	'''Entity ifccontextdependentunit definition.

	:param name
	:type name:ifclabel

	:param hasexternalreference
	:type hasexternalreference:SET(0,None,'ifcexternalreferencerelationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__dimensions , inherited1__unittype , name, ):
		ifcnamedunit.__init__(self , inherited0__dimensions , inherited1__unittype , )
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def hasexternalreference():
		def fget( self ):
			return self._hasexternalreference
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasexternalreference is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcsectionproperties #
####################
class ifcsectionproperties(ifcpredefinedproperties):
	'''Entity ifcsectionproperties definition.

	:param sectiontype
	:type sectiontype:ifcsectiontypeenum

	:param startprofile
	:type startprofile:ifcprofiledef

	:param endprofile
	:type endprofile:ifcprofiledef
	'''
	def __init__( self , sectiontype,startprofile,endprofile, ):
		ifcpredefinedproperties.__init__(self , )
		self.sectiontype = sectiontype
		self.startprofile = startprofile
		self.endprofile = endprofile

	@apply
	def sectiontype():
		def fget( self ):
			return self._sectiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sectiontype is mantatory and can not be set to None')
			if not check_type(value,ifcsectiontypeenum):
				self._sectiontype = ifcsectiontypeenum(value)
			else:
				self._sectiontype = value
		return property(**locals())

	@apply
	def startprofile():
		def fget( self ):
			return self._startprofile
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument startprofile is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._startprofile = ifcprofiledef(value)
			else:
				self._startprofile = value
		return property(**locals())

	@apply
	def endprofile():
		def fget( self ):
			return self._endprofile
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcprofiledef):
					self._endprofile = ifcprofiledef(value)
				else:
					self._endprofile = value
			else:
				self._endprofile = value
		return property(**locals())

####################
 # ENTITY ifcshaperepresentation #
####################
class ifcshaperepresentation(ifcshapemodel):
	'''Entity ifcshaperepresentation definition.
	'''
	def __init__( self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items ,  ):
		ifcshapemodel.__init__(self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items , )
	def wr21(self):
		eval_wr21_wr = ('IFC4.IFCGEOMETRICREPRESENTATIONCONTEXT'  ==  TYPEOF(self.self.ifcrepresentation.self.contextofitems))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (SIZEOF(None)  ==  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr

	def wr23(self):
		eval_wr23_wr = EXISTS(self.self.ifcrepresentation.self.representationtype)
		if not eval_wr23_wr:
			raise AssertionError('Rule wr23 violated')
		else:
			return eval_wr23_wr

	def wr24(self):
		eval_wr24_wr = ifcshaperepresentationtypes(self.self.ifcrepresentation.self.representationtype,self.self.ifcrepresentation.self.items)
		if not eval_wr24_wr:
			raise AssertionError('Rule wr24 violated')
		else:
			return eval_wr24_wr


####################
 # ENTITY ifctriangulatedfaceset #
####################
class ifctriangulatedfaceset(ifctessellatedfaceset):
	'''Entity ifctriangulatedfaceset definition.

	:param coordindex
	:type coordindex:LIST(1,None,LIST(3,3,'INTEGER', scope = schema_scope))

	:param normalindex
	:type normalindex:LIST(1,None,LIST(3,3,'INTEGER', scope = schema_scope))

	:param numberoftriangles
	:type numberoftriangles:INTEGER
	'''
	def __init__( self , inherited0__coordinates , inherited1__normals , inherited2__closed , coordindex,normalindex, ):
		ifctessellatedfaceset.__init__(self , inherited0__coordinates , inherited1__normals , inherited2__closed , )
		self.coordindex = coordindex
		self.normalindex = normalindex

	@apply
	def coordindex():
		def fget( self ):
			return self._coordindex
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordindex is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,LIST(3,3,'INTEGER', scope = schema_scope))):
				self._coordindex = LIST(value)
			else:
				self._coordindex = value
		return property(**locals())

	@apply
	def normalindex():
		def fget( self ):
			return self._normalindex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,LIST(3,3,'INTEGER', scope = schema_scope))):
					self._normalindex = LIST(value)
				else:
					self._normalindex = value
			else:
				self._normalindex = value
		return property(**locals())

	@apply
	def numberoftriangles():
		def fget( self ):
			attribute_eval = SIZEOF(self.coordindex)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument numberoftriangles is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcworktime #
####################
class ifcworktime(ifcschedulingtime):
	'''Entity ifcworktime definition.

	:param recurrencepattern
	:type recurrencepattern:ifcrecurrencepattern

	:param start
	:type start:ifcdate

	:param finish
	:type finish:ifcdate
	'''
	def __init__( self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , recurrencepattern,start,finish, ):
		ifcschedulingtime.__init__(self , inherited0__name , inherited1__dataorigin , inherited2__userdefineddataorigin , )
		self.recurrencepattern = recurrencepattern
		self.start = start
		self.finish = finish

	@apply
	def recurrencepattern():
		def fget( self ):
			return self._recurrencepattern
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrecurrencepattern):
					self._recurrencepattern = ifcrecurrencepattern(value)
				else:
					self._recurrencepattern = value
			else:
				self._recurrencepattern = value
		return property(**locals())

	@apply
	def start():
		def fget( self ):
			return self._start
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdate):
					self._start = ifcdate(value)
				else:
					self._start = value
			else:
				self._start = value
		return property(**locals())

	@apply
	def finish():
		def fget( self ):
			return self._finish
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdate):
					self._finish = ifcdate(value)
				else:
					self._finish = value
			else:
				self._finish = value
		return property(**locals())

####################
 # ENTITY ifcfiltertype #
####################
class ifcfiltertype(ifcflowtreatmentdevicetype):
	'''Entity ifcfiltertype definition.

	:param predefinedtype
	:type predefinedtype:ifcfiltertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowtreatmentdevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcfiltertypeenum):
				self._predefinedtype = ifcfiltertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcfiltertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcfiltertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcsolardevice #
####################
class ifcsolardevice(ifcenergyconversiondevice):
	'''Entity ifcsolardevice definition.

	:param predefinedtype
	:type predefinedtype:ifcsolardevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsolardevicetypeenum):
					self._predefinedtype = ifcsolardevicetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcsolardevicetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcsolardevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSOLARDEVICETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcspace #
####################
class ifcspace(ifcspatialstructureelement):
	'''Entity ifcspace definition.

	:param predefinedtype
	:type predefinedtype:ifcspacetypeenum

	:param elevationwithflooring
	:type elevationwithflooring:ifclengthmeasure

	:param hascoverings
	:type hascoverings:SET(0,None,'ifcrelcoversspaces', scope = schema_scope)

	:param boundedby
	:type boundedby:SET(0,None,'ifcrelspaceboundary', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , predefinedtype,elevationwithflooring, ):
		ifcspatialstructureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , )
		self.predefinedtype = predefinedtype
		self.elevationwithflooring = elevationwithflooring

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcspacetypeenum):
					self._predefinedtype = ifcspacetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def elevationwithflooring():
		def fget( self ):
			return self._elevationwithflooring
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._elevationwithflooring = ifclengthmeasure(value)
				else:
					self._elevationwithflooring = value
			else:
				self._elevationwithflooring = value
		return property(**locals())

	@apply
	def hascoverings():
		def fget( self ):
			return self._hascoverings
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hascoverings is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def boundedby():
		def fget( self ):
			return self._boundedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument boundedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcspacetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcspacetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSPACETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcpolyloop #
####################
class ifcpolyloop(ifcloop):
	'''Entity ifcpolyloop definition.

	:param polygon
	:type polygon:LIST(3,None,'ifccartesianpoint', scope = schema_scope)
	'''
	def __init__( self , polygon, ):
		ifcloop.__init__(self , )
		self.polygon = polygon

	@apply
	def polygon():
		def fget( self ):
			return self._polygon
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument polygon is mantatory and can not be set to None')
			if not check_type(value,LIST(3,None,'ifccartesianpoint', scope = schema_scope)):
				self._polygon = LIST(value)
			else:
				self._polygon = value
		return property(**locals())
	def allpointssamedim(self):
		eval_allpointssamedim_wr = (SIZEOF(None)  ==  0)
		if not eval_allpointssamedim_wr:
			raise AssertionError('Rule allpointssamedim violated')
		else:
			return eval_allpointssamedim_wr


####################
 # ENTITY ifcrelassociatesmaterial #
####################
class ifcrelassociatesmaterial(ifcrelassociates):
	'''Entity ifcrelassociatesmaterial definition.

	:param relatingmaterial
	:type relatingmaterial:ifcmaterialselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingmaterial, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingmaterial = relatingmaterial

	@apply
	def relatingmaterial():
		def fget( self ):
			return self._relatingmaterial
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingmaterial is mantatory and can not be set to None')
			if not check_type(value,ifcmaterialselect):
				self._relatingmaterial = ifcmaterialselect(value)
			else:
				self._relatingmaterial = value
		return property(**locals())
	def novoidelement(self):
		eval_novoidelement_wr = (SIZEOF(None)  ==  0)
		if not eval_novoidelement_wr:
			raise AssertionError('Rule novoidelement violated')
		else:
			return eval_novoidelement_wr

	def allowedelements(self):
		eval_allowedelements_wr = (SIZEOF(None)  ==  0)
		if not eval_allowedelements_wr:
			raise AssertionError('Rule allowedelements violated')
		else:
			return eval_allowedelements_wr


####################
 # ENTITY ifcmedicaldevicetype #
####################
class ifcmedicaldevicetype(ifcflowterminaltype):
	'''Entity ifcmedicaldevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcmedicaldevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcmedicaldevicetypeenum):
				self._predefinedtype = ifcmedicaldevicetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcmedicaldevicetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcmedicaldevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcramptype #
####################
class ifcramptype(ifcbuildingelementtype):
	'''Entity ifcramptype definition.

	:param predefinedtype
	:type predefinedtype:ifcramptypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcramptypeenum):
				self._predefinedtype = ifcramptypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcramptypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcramptypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifccshapeprofiledef #
####################
class ifccshapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifccshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param width
	:type width:ifcpositivelengthmeasure

	:param wallthickness
	:type wallthickness:ifcpositivelengthmeasure

	:param girth
	:type girth:ifcpositivelengthmeasure

	:param internalfilletradius
	:type internalfilletradius:ifcnonnegativelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , depth,width,wallthickness,girth,internalfilletradius, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.depth = depth
		self.width = width
		self.wallthickness = wallthickness
		self.girth = girth
		self.internalfilletradius = internalfilletradius

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def width():
		def fget( self ):
			return self._width
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument width is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._width = ifcpositivelengthmeasure(value)
			else:
				self._width = value
		return property(**locals())

	@apply
	def wallthickness():
		def fget( self ):
			return self._wallthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument wallthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._wallthickness = ifcpositivelengthmeasure(value)
			else:
				self._wallthickness = value
		return property(**locals())

	@apply
	def girth():
		def fget( self ):
			return self._girth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument girth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._girth = ifcpositivelengthmeasure(value)
			else:
				self._girth = value
		return property(**locals())

	@apply
	def internalfilletradius():
		def fget( self ):
			return self._internalfilletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._internalfilletradius = ifcnonnegativelengthmeasure(value)
				else:
					self._internalfilletradius = value
			else:
				self._internalfilletradius = value
		return property(**locals())
	def validgirth(self):
		eval_validgirth_wr = (self.girth  <  (self.depth / 2))
		if not eval_validgirth_wr:
			raise AssertionError('Rule validgirth violated')
		else:
			return eval_validgirth_wr

	def validinternalfilletradius(self):
		eval_validinternalfilletradius_wr = (( not EXISTS(self.internalfilletradius))  or  ((self.internalfilletradius  <=  ((self.width / 2) - self.wallthickness))  and  (self.internalfilletradius  <=  ((self.depth / 2) - self.wallthickness))))
		if not eval_validinternalfilletradius_wr:
			raise AssertionError('Rule validinternalfilletradius violated')
		else:
			return eval_validinternalfilletradius_wr

	def validwallthickness(self):
		eval_validwallthickness_wr = ((self.wallthickness  <  (self.width / 2))  and  (self.wallthickness  <  (self.depth / 2)))
		if not eval_validwallthickness_wr:
			raise AssertionError('Rule validwallthickness violated')
		else:
			return eval_validwallthickness_wr


####################
 # ENTITY ifcpropertytablevalue #
####################
class ifcpropertytablevalue(ifcsimpleproperty):
	'''Entity ifcpropertytablevalue definition.

	:param definingvalues
	:type definingvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param definedvalues
	:type definedvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param expression
	:type expression:ifctext

	:param definingunit
	:type definingunit:ifcunit

	:param definedunit
	:type definedunit:ifcunit

	:param curveinterpolation
	:type curveinterpolation:ifccurveinterpolationenum
	'''
	def __init__( self , inherited0__name , inherited1__description , definingvalues,definedvalues,expression,definingunit,definedunit,curveinterpolation, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.definingvalues = definingvalues
		self.definedvalues = definedvalues
		self.expression = expression
		self.definingunit = definingunit
		self.definedunit = definedunit
		self.curveinterpolation = curveinterpolation

	@apply
	def definingvalues():
		def fget( self ):
			return self._definingvalues
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
					self._definingvalues = LIST(value)
				else:
					self._definingvalues = value
			else:
				self._definingvalues = value
		return property(**locals())

	@apply
	def definedvalues():
		def fget( self ):
			return self._definedvalues
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
					self._definedvalues = LIST(value)
				else:
					self._definedvalues = value
			else:
				self._definedvalues = value
		return property(**locals())

	@apply
	def expression():
		def fget( self ):
			return self._expression
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._expression = ifctext(value)
				else:
					self._expression = value
			else:
				self._expression = value
		return property(**locals())

	@apply
	def definingunit():
		def fget( self ):
			return self._definingunit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._definingunit = ifcunit(value)
				else:
					self._definingunit = value
			else:
				self._definingunit = value
		return property(**locals())

	@apply
	def definedunit():
		def fget( self ):
			return self._definedunit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._definedunit = ifcunit(value)
				else:
					self._definedunit = value
			else:
				self._definedunit = value
		return property(**locals())

	@apply
	def curveinterpolation():
		def fget( self ):
			return self._curveinterpolation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccurveinterpolationenum):
					self._curveinterpolation = ifccurveinterpolationenum(value)
				else:
					self._curveinterpolation = value
			else:
				self._curveinterpolation = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = ((( not EXISTS(self.definingvalues))  and  ( not EXISTS(self.definedvalues)))  or  (SIZEOF(self.definingvalues)  ==  SIZEOF(self.definedvalues)))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (( not EXISTS(self.definingvalues))  or  (SIZEOF(None)  ==  0))
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr

	def wr23(self):
		eval_wr23_wr = (( not EXISTS(self.definedvalues))  or  (SIZEOF(None)  ==  0))
		if not eval_wr23_wr:
			raise AssertionError('Rule wr23 violated')
		else:
			return eval_wr23_wr


####################
 # ENTITY ifcspatialzone #
####################
class ifcspatialzone(ifcspatialelement):
	'''Entity ifcspatialzone definition.

	:param predefinedtype
	:type predefinedtype:ifcspatialzonetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , predefinedtype, ):
		ifcspatialelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcspatialzonetypeenum):
					self._predefinedtype = ifcspatialzonetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcspatialzonetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcspatialzonetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSPATIALZONETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcstructuralloadplanarforce #
####################
class ifcstructuralloadplanarforce(ifcstructuralloadstatic):
	'''Entity ifcstructuralloadplanarforce definition.

	:param planarforcex
	:type planarforcex:ifcplanarforcemeasure

	:param planarforcey
	:type planarforcey:ifcplanarforcemeasure

	:param planarforcez
	:type planarforcez:ifcplanarforcemeasure
	'''
	def __init__( self , inherited0__name , planarforcex,planarforcey,planarforcez, ):
		ifcstructuralloadstatic.__init__(self , inherited0__name , )
		self.planarforcex = planarforcex
		self.planarforcey = planarforcey
		self.planarforcez = planarforcez

	@apply
	def planarforcex():
		def fget( self ):
			return self._planarforcex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplanarforcemeasure):
					self._planarforcex = ifcplanarforcemeasure(value)
				else:
					self._planarforcex = value
			else:
				self._planarforcex = value
		return property(**locals())

	@apply
	def planarforcey():
		def fget( self ):
			return self._planarforcey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplanarforcemeasure):
					self._planarforcey = ifcplanarforcemeasure(value)
				else:
					self._planarforcey = value
			else:
				self._planarforcey = value
		return property(**locals())

	@apply
	def planarforcez():
		def fget( self ):
			return self._planarforcez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplanarforcemeasure):
					self._planarforcez = ifcplanarforcemeasure(value)
				else:
					self._planarforcez = value
			else:
				self._planarforcez = value
		return property(**locals())

####################
 # ENTITY ifcbooleanclippingresult #
####################
class ifcbooleanclippingresult(ifcbooleanresult):
	'''Entity ifcbooleanclippingresult definition.
	'''
	def __init__( self , inherited0__operator , inherited1__firstoperand , inherited2__secondoperand ,  ):
		ifcbooleanresult.__init__(self , inherited0__operator , inherited1__firstoperand , inherited2__secondoperand , )
	def firstoperandtype(self):
		eval_firstoperandtype_wr = ((('IFC4.IFCSWEPTAREASOLID'  ==  TYPEOF(self.firstoperand))  or  ('IFC4.IFCSWEPTDISCSOLID'  ==  TYPEOF(self.firstoperand)))  or  ('IFC4.IFCBOOLEANCLIPPINGRESULT'  ==  TYPEOF(self.firstoperand)))
		if not eval_firstoperandtype_wr:
			raise AssertionError('Rule firstoperandtype violated')
		else:
			return eval_firstoperandtype_wr

	def secondoperandtype(self):
		eval_secondoperandtype_wr = ('IFC4.IFCHALFSPACESOLID'  ==  TYPEOF(self.secondoperand))
		if not eval_secondoperandtype_wr:
			raise AssertionError('Rule secondoperandtype violated')
		else:
			return eval_secondoperandtype_wr

	def operatortype(self):
		eval_operatortype_wr = (self.operator  ==  difference)
		if not eval_operatortype_wr:
			raise AssertionError('Rule operatortype violated')
		else:
			return eval_operatortype_wr


####################
 # ENTITY ifccivilelementtype #
####################
class ifccivilelementtype(ifcelementtype):
	'''Entity ifccivilelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcbuildingstorey #
####################
class ifcbuildingstorey(ifcspatialstructureelement):
	'''Entity ifcbuildingstorey definition.

	:param elevation
	:type elevation:ifclengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , elevation, ):
		ifcspatialstructureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , )
		self.elevation = elevation

	@apply
	def elevation():
		def fget( self ):
			return self._elevation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._elevation = ifclengthmeasure(value)
				else:
					self._elevation = value
			else:
				self._elevation = value
		return property(**locals())

####################
 # ENTITY ifcsectionreinforcementproperties #
####################
class ifcsectionreinforcementproperties(ifcpredefinedproperties):
	'''Entity ifcsectionreinforcementproperties definition.

	:param longitudinalstartposition
	:type longitudinalstartposition:ifclengthmeasure

	:param longitudinalendposition
	:type longitudinalendposition:ifclengthmeasure

	:param transverseposition
	:type transverseposition:ifclengthmeasure

	:param reinforcementrole
	:type reinforcementrole:ifcreinforcingbarroleenum

	:param sectiondefinition
	:type sectiondefinition:ifcsectionproperties

	:param crosssectionreinforcementdefinitions
	:type crosssectionreinforcementdefinitions:SET(1,None,'ifcreinforcementbarproperties', scope = schema_scope)
	'''
	def __init__( self , longitudinalstartposition,longitudinalendposition,transverseposition,reinforcementrole,sectiondefinition,crosssectionreinforcementdefinitions, ):
		ifcpredefinedproperties.__init__(self , )
		self.longitudinalstartposition = longitudinalstartposition
		self.longitudinalendposition = longitudinalendposition
		self.transverseposition = transverseposition
		self.reinforcementrole = reinforcementrole
		self.sectiondefinition = sectiondefinition
		self.crosssectionreinforcementdefinitions = crosssectionreinforcementdefinitions

	@apply
	def longitudinalstartposition():
		def fget( self ):
			return self._longitudinalstartposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument longitudinalstartposition is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._longitudinalstartposition = ifclengthmeasure(value)
			else:
				self._longitudinalstartposition = value
		return property(**locals())

	@apply
	def longitudinalendposition():
		def fget( self ):
			return self._longitudinalendposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument longitudinalendposition is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._longitudinalendposition = ifclengthmeasure(value)
			else:
				self._longitudinalendposition = value
		return property(**locals())

	@apply
	def transverseposition():
		def fget( self ):
			return self._transverseposition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._transverseposition = ifclengthmeasure(value)
				else:
					self._transverseposition = value
			else:
				self._transverseposition = value
		return property(**locals())

	@apply
	def reinforcementrole():
		def fget( self ):
			return self._reinforcementrole
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reinforcementrole is mantatory and can not be set to None')
			if not check_type(value,ifcreinforcingbarroleenum):
				self._reinforcementrole = ifcreinforcingbarroleenum(value)
			else:
				self._reinforcementrole = value
		return property(**locals())

	@apply
	def sectiondefinition():
		def fget( self ):
			return self._sectiondefinition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sectiondefinition is mantatory and can not be set to None')
			if not check_type(value,ifcsectionproperties):
				self._sectiondefinition = ifcsectionproperties(value)
			else:
				self._sectiondefinition = value
		return property(**locals())

	@apply
	def crosssectionreinforcementdefinitions():
		def fget( self ):
			return self._crosssectionreinforcementdefinitions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument crosssectionreinforcementdefinitions is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcreinforcementbarproperties', scope = schema_scope)):
				self._crosssectionreinforcementdefinitions = SET(value)
			else:
				self._crosssectionreinforcementdefinitions = value
		return property(**locals())

####################
 # ENTITY ifcrelassignstoresource #
####################
class ifcrelassignstoresource(ifcrelassigns):
	'''Entity ifcrelassignstoresource definition.

	:param relatingresource
	:type relatingresource:ifcresourceselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatingresource, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatingresource = relatingresource

	@apply
	def relatingresource():
		def fget( self ):
			return self._relatingresource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingresource is mantatory and can not be set to None')
			if not check_type(value,ifcresourceselect):
				self._relatingresource = ifcresourceselect(value)
			else:
				self._relatingresource = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (SIZEOF(None)  ==  0)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifcmaterialprofileset #
####################
class ifcmaterialprofileset(ifcmaterialdefinition):
	'''Entity ifcmaterialprofileset definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param materialprofiles
	:type materialprofiles:LIST(1,None,'ifcmaterialprofile', scope = schema_scope)

	:param compositeprofile
	:type compositeprofile:ifccompositeprofiledef
	'''
	def __init__( self , name,description,materialprofiles,compositeprofile, ):
		ifcmaterialdefinition.__init__(self , )
		self.name = name
		self.description = description
		self.materialprofiles = materialprofiles
		self.compositeprofile = compositeprofile

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def materialprofiles():
		def fget( self ):
			return self._materialprofiles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument materialprofiles is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcmaterialprofile', scope = schema_scope)):
				self._materialprofiles = LIST(value)
			else:
				self._materialprofiles = value
		return property(**locals())

	@apply
	def compositeprofile():
		def fget( self ):
			return self._compositeprofile
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccompositeprofiledef):
					self._compositeprofile = ifccompositeprofiledef(value)
				else:
					self._compositeprofile = value
			else:
				self._compositeprofile = value
		return property(**locals())

####################
 # ENTITY ifcprocedure #
####################
class ifcprocedure(ifcprocess):
	'''Entity ifcprocedure definition.

	:param predefinedtype
	:type predefinedtype:ifcproceduretypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , predefinedtype, ):
		ifcprocess.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__longdescription , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcproceduretypeenum):
					self._predefinedtype = ifcproceduretypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def hasname(self):
		eval_hasname_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_hasname_wr:
			raise AssertionError('Rule hasname violated')
		else:
			return eval_hasname_wr

	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcproceduretypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcproceduretypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcactionrequest #
####################
class ifcactionrequest(ifccontrol):
	'''Entity ifcactionrequest definition.

	:param predefinedtype
	:type predefinedtype:ifcactionrequesttypeenum

	:param status
	:type status:ifclabel

	:param longdescription
	:type longdescription:ifctext
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , predefinedtype,status,longdescription, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , )
		self.predefinedtype = predefinedtype
		self.status = status
		self.longdescription = longdescription

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactionrequesttypeenum):
					self._predefinedtype = ifcactionrequesttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._status = ifclabel(value)
				else:
					self._status = value
			else:
				self._status = value
		return property(**locals())

	@apply
	def longdescription():
		def fget( self ):
			return self._longdescription
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._longdescription = ifctext(value)
				else:
					self._longdescription = value
			else:
				self._longdescription = value
		return property(**locals())

####################
 # ENTITY ifcadvancedface #
####################
class ifcadvancedface(ifcfacesurface):
	'''Entity ifcadvancedface definition.
	'''
	def __init__( self , inherited0__bounds , inherited1__facesurface , inherited2__samesense ,  ):
		ifcfacesurface.__init__(self , inherited0__bounds , inherited1__facesurface , inherited2__samesense , )
	def applicablesurface(self):
		eval_applicablesurface_wr = (SIZEOF(['IFC4.IFCELEMENTARYSURFACE','IFC4.IFCSWEPTSURFACE','IFC4.IFCBSPLINESURFACE']  *  TYPEOF(self.self.ifcfacesurface.self.facesurface))  ==  1)
		if not eval_applicablesurface_wr:
			raise AssertionError('Rule applicablesurface violated')
		else:
			return eval_applicablesurface_wr

	def requiresedgecurve(self):
		eval_requiresedgecurve_wr = (SIZEOF(None)  ==  0)
		if not eval_requiresedgecurve_wr:
			raise AssertionError('Rule requiresedgecurve violated')
		else:
			return eval_requiresedgecurve_wr

	def applicableedgecurves(self):
		eval_applicableedgecurves_wr = (SIZEOF(None)  ==  0)
		if not eval_applicableedgecurves_wr:
			raise AssertionError('Rule applicableedgecurves violated')
		else:
			return eval_applicableedgecurves_wr


####################
 # ENTITY ifcinventory #
####################
class ifcinventory(ifcgroup):
	'''Entity ifcinventory definition.

	:param predefinedtype
	:type predefinedtype:ifcinventorytypeenum

	:param jurisdiction
	:type jurisdiction:ifcactorselect

	:param responsiblepersons
	:type responsiblepersons:SET(1,None,'ifcperson', scope = schema_scope)

	:param lastupdatedate
	:type lastupdatedate:ifcdate

	:param currentvalue
	:type currentvalue:ifccostvalue

	:param originalvalue
	:type originalvalue:ifccostvalue
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , predefinedtype,jurisdiction,responsiblepersons,lastupdatedate,currentvalue,originalvalue, ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.predefinedtype = predefinedtype
		self.jurisdiction = jurisdiction
		self.responsiblepersons = responsiblepersons
		self.lastupdatedate = lastupdatedate
		self.currentvalue = currentvalue
		self.originalvalue = originalvalue

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcinventorytypeenum):
					self._predefinedtype = ifcinventorytypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def jurisdiction():
		def fget( self ):
			return self._jurisdiction
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._jurisdiction = ifcactorselect(value)
				else:
					self._jurisdiction = value
			else:
				self._jurisdiction = value
		return property(**locals())

	@apply
	def responsiblepersons():
		def fget( self ):
			return self._responsiblepersons
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcperson', scope = schema_scope)):
					self._responsiblepersons = SET(value)
				else:
					self._responsiblepersons = value
			else:
				self._responsiblepersons = value
		return property(**locals())

	@apply
	def lastupdatedate():
		def fget( self ):
			return self._lastupdatedate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdate):
					self._lastupdatedate = ifcdate(value)
				else:
					self._lastupdatedate = value
			else:
				self._lastupdatedate = value
		return property(**locals())

	@apply
	def currentvalue():
		def fget( self ):
			return self._currentvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccostvalue):
					self._currentvalue = ifccostvalue(value)
				else:
					self._currentvalue = value
			else:
				self._currentvalue = value
		return property(**locals())

	@apply
	def originalvalue():
		def fget( self ):
			return self._originalvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccostvalue):
					self._originalvalue = ifccostvalue(value)
				else:
					self._originalvalue = value
			else:
				self._originalvalue = value
		return property(**locals())

####################
 # ENTITY ifcrelconnectspathelements #
####################
class ifcrelconnectspathelements(ifcrelconnectselements):
	'''Entity ifcrelconnectspathelements definition.

	:param relatingpriorities
	:type relatingpriorities:LIST(0,None,'(null)', scope = schema_scope)

	:param relatedpriorities
	:type relatedpriorities:LIST(0,None,'(null)', scope = schema_scope)

	:param relatedconnectiontype
	:type relatedconnectiontype:ifcconnectiontypeenum

	:param relatingconnectiontype
	:type relatingconnectiontype:ifcconnectiontypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__connectiongeometry , inherited5__relatingelement , inherited6__relatedelement , relatingpriorities,relatedpriorities,relatedconnectiontype,relatingconnectiontype, ):
		ifcrelconnectselements.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__connectiongeometry , inherited5__relatingelement , inherited6__relatedelement , )
		self.relatingpriorities = relatingpriorities
		self.relatedpriorities = relatedpriorities
		self.relatedconnectiontype = relatedconnectiontype
		self.relatingconnectiontype = relatingconnectiontype

	@apply
	def relatingpriorities():
		def fget( self ):
			return self._relatingpriorities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingpriorities is mantatory and can not be set to None')
			if not check_type(value,LIST(0,None,'(null)', scope = schema_scope)):
				self._relatingpriorities = LIST(value)
			else:
				self._relatingpriorities = value
		return property(**locals())

	@apply
	def relatedpriorities():
		def fget( self ):
			return self._relatedpriorities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedpriorities is mantatory and can not be set to None')
			if not check_type(value,LIST(0,None,'(null)', scope = schema_scope)):
				self._relatedpriorities = LIST(value)
			else:
				self._relatedpriorities = value
		return property(**locals())

	@apply
	def relatedconnectiontype():
		def fget( self ):
			return self._relatedconnectiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedconnectiontype is mantatory and can not be set to None')
			if not check_type(value,ifcconnectiontypeenum):
				self._relatedconnectiontype = ifcconnectiontypeenum(value)
			else:
				self._relatedconnectiontype = value
		return property(**locals())

	@apply
	def relatingconnectiontype():
		def fget( self ):
			return self._relatingconnectiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingconnectiontype is mantatory and can not be set to None')
			if not check_type(value,ifcconnectiontypeenum):
				self._relatingconnectiontype = ifcconnectiontypeenum(value)
			else:
				self._relatingconnectiontype = value
		return property(**locals())
	def normalizedrelatingpriorities(self):
		eval_normalizedrelatingpriorities_wr = ((SIZEOF(self.relatingpriorities)  ==  0)  or  (SIZEOF(None)  ==  SIZEOF(self.relatingpriorities)))
		if not eval_normalizedrelatingpriorities_wr:
			raise AssertionError('Rule normalizedrelatingpriorities violated')
		else:
			return eval_normalizedrelatingpriorities_wr

	def normalizedrelatedpriorities(self):
		eval_normalizedrelatedpriorities_wr = ((SIZEOF(self.relatedpriorities)  ==  0)  or  (SIZEOF(None)  ==  SIZEOF(self.relatedpriorities)))
		if not eval_normalizedrelatedpriorities_wr:
			raise AssertionError('Rule normalizedrelatedpriorities violated')
		else:
			return eval_normalizedrelatedpriorities_wr


####################
 # ENTITY ifccurtainwalltype #
####################
class ifccurtainwalltype(ifcbuildingelementtype):
	'''Entity ifccurtainwalltype definition.

	:param predefinedtype
	:type predefinedtype:ifccurtainwalltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccurtainwalltypeenum):
				self._predefinedtype = ifccurtainwalltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccurtainwalltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccurtainwalltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcdraughtingpredefinedcurvefont #
####################
class ifcdraughtingpredefinedcurvefont(ifcpredefinedcurvefont):
	'''Entity ifcdraughtingpredefinedcurvefont definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefinedcurvefont.__init__(self , inherited0__name , )
	def predefinedcurvefontnames(self):
		eval_predefinedcurvefontnames_wr = (self.self.ifcpredefineditem.self.name  ==  ['continuous','chain','chain double dash','dashed','dotted','by layer'])
		if not eval_predefinedcurvefontnames_wr:
			raise AssertionError('Rule predefinedcurvefontnames violated')
		else:
			return eval_predefinedcurvefontnames_wr


####################
 # ENTITY ifcrelcoversbldgelements #
####################
class ifcrelcoversbldgelements(ifcrelconnects):
	'''Entity ifcrelcoversbldgelements definition.

	:param relatingbuildingelement
	:type relatingbuildingelement:ifcelement

	:param relatedcoverings
	:type relatedcoverings:SET(1,None,'ifccovering', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingbuildingelement,relatedcoverings, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingbuildingelement = relatingbuildingelement
		self.relatedcoverings = relatedcoverings

	@apply
	def relatingbuildingelement():
		def fget( self ):
			return self._relatingbuildingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingbuildingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatingbuildingelement = ifcelement(value)
			else:
				self._relatingbuildingelement = value
		return property(**locals())

	@apply
	def relatedcoverings():
		def fget( self ):
			return self._relatedcoverings
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedcoverings is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifccovering', scope = schema_scope)):
				self._relatedcoverings = SET(value)
			else:
				self._relatedcoverings = value
		return property(**locals())

####################
 # ENTITY ifcdoorstyle #
####################
class ifcdoorstyle(ifctypeproduct):
	'''Entity ifcdoorstyle definition.

	:param operationtype
	:type operationtype:ifcdoorstyleoperationenum

	:param constructiontype
	:type constructiontype:ifcdoorstyleconstructionenum

	:param parametertakesprecedence
	:type parametertakesprecedence:BOOLEAN

	:param sizeable
	:type sizeable:BOOLEAN
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , operationtype,constructiontype,parametertakesprecedence,sizeable, ):
		ifctypeproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , )
		self.operationtype = operationtype
		self.constructiontype = constructiontype
		self.parametertakesprecedence = parametertakesprecedence
		self.sizeable = sizeable

	@apply
	def operationtype():
		def fget( self ):
			return self._operationtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operationtype is mantatory and can not be set to None')
			if not check_type(value,ifcdoorstyleoperationenum):
				self._operationtype = ifcdoorstyleoperationenum(value)
			else:
				self._operationtype = value
		return property(**locals())

	@apply
	def constructiontype():
		def fget( self ):
			return self._constructiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constructiontype is mantatory and can not be set to None')
			if not check_type(value,ifcdoorstyleconstructionenum):
				self._constructiontype = ifcdoorstyleconstructionenum(value)
			else:
				self._constructiontype = value
		return property(**locals())

	@apply
	def parametertakesprecedence():
		def fget( self ):
			return self._parametertakesprecedence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parametertakesprecedence is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._parametertakesprecedence = BOOLEAN(value)
			else:
				self._parametertakesprecedence = value
		return property(**locals())

	@apply
	def sizeable():
		def fget( self ):
			return self._sizeable
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sizeable is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._sizeable = BOOLEAN(value)
			else:
				self._sizeable = value
		return property(**locals())

####################
 # ENTITY ifcellipse #
####################
class ifcellipse(ifcconic):
	'''Entity ifcellipse definition.

	:param semiaxis1
	:type semiaxis1:ifcpositivelengthmeasure

	:param semiaxis2
	:type semiaxis2:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , semiaxis1,semiaxis2, ):
		ifcconic.__init__(self , inherited0__position , )
		self.semiaxis1 = semiaxis1
		self.semiaxis2 = semiaxis2

	@apply
	def semiaxis1():
		def fget( self ):
			return self._semiaxis1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semiaxis1 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._semiaxis1 = ifcpositivelengthmeasure(value)
			else:
				self._semiaxis1 = value
		return property(**locals())

	@apply
	def semiaxis2():
		def fget( self ):
			return self._semiaxis2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semiaxis2 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._semiaxis2 = ifcpositivelengthmeasure(value)
			else:
				self._semiaxis2 = value
		return property(**locals())

####################
 # ENTITY ifcstairflighttype #
####################
class ifcstairflighttype(ifcbuildingelementtype):
	'''Entity ifcstairflighttype definition.

	:param predefinedtype
	:type predefinedtype:ifcstairflighttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstairflighttypeenum):
				self._predefinedtype = ifcstairflighttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcstairflighttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcstairflighttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcstructuralloadtemperature #
####################
class ifcstructuralloadtemperature(ifcstructuralloadstatic):
	'''Entity ifcstructuralloadtemperature definition.

	:param deltatconstant
	:type deltatconstant:ifcthermodynamictemperaturemeasure

	:param deltaty
	:type deltaty:ifcthermodynamictemperaturemeasure

	:param deltatz
	:type deltatz:ifcthermodynamictemperaturemeasure
	'''
	def __init__( self , inherited0__name , deltatconstant,deltaty,deltatz, ):
		ifcstructuralloadstatic.__init__(self , inherited0__name , )
		self.deltatconstant = deltatconstant
		self.deltaty = deltaty
		self.deltatz = deltatz

	@apply
	def deltatconstant():
		def fget( self ):
			return self._deltatconstant
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermodynamictemperaturemeasure):
					self._deltatconstant = ifcthermodynamictemperaturemeasure(value)
				else:
					self._deltatconstant = value
			else:
				self._deltatconstant = value
		return property(**locals())

	@apply
	def deltaty():
		def fget( self ):
			return self._deltaty
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermodynamictemperaturemeasure):
					self._deltaty = ifcthermodynamictemperaturemeasure(value)
				else:
					self._deltaty = value
			else:
				self._deltaty = value
		return property(**locals())

	@apply
	def deltatz():
		def fget( self ):
			return self._deltatz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermodynamictemperaturemeasure):
					self._deltatz = ifcthermodynamictemperaturemeasure(value)
				else:
					self._deltatz = value
			else:
				self._deltatz = value
		return property(**locals())

####################
 # ENTITY ifcstyleditem #
####################
class ifcstyleditem(ifcrepresentationitem):
	'''Entity ifcstyleditem definition.

	:param item
	:type item:ifcrepresentationitem

	:param styles
	:type styles:SET(1,None,'ifcstyleassignmentselect', scope = schema_scope)

	:param name
	:type name:ifclabel
	'''
	def __init__( self , item,styles,name, ):
		ifcrepresentationitem.__init__(self , )
		self.item = item
		self.styles = styles
		self.name = name

	@apply
	def item():
		def fget( self ):
			return self._item
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrepresentationitem):
					self._item = ifcrepresentationitem(value)
				else:
					self._item = value
			else:
				self._item = value
		return property(**locals())

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcstyleassignmentselect', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())
	def applicableitem(self):
		eval_applicableitem_wr = ( not ('IFC4.IFCSTYLEDITEM'  ==  TYPEOF(self.item)))
		if not eval_applicableitem_wr:
			raise AssertionError('Rule applicableitem violated')
		else:
			return eval_applicableitem_wr


####################
 # ENTITY ifclshapeprofiledef #
####################
class ifclshapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifclshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param width
	:type width:ifcpositivelengthmeasure

	:param thickness
	:type thickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcnonnegativelengthmeasure

	:param edgeradius
	:type edgeradius:ifcnonnegativelengthmeasure

	:param legslope
	:type legslope:ifcplaneanglemeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , depth,width,thickness,filletradius,edgeradius,legslope, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.depth = depth
		self.width = width
		self.thickness = thickness
		self.filletradius = filletradius
		self.edgeradius = edgeradius
		self.legslope = legslope

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def width():
		def fget( self ):
			return self._width
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._width = ifcpositivelengthmeasure(value)
				else:
					self._width = value
			else:
				self._width = value
		return property(**locals())

	@apply
	def thickness():
		def fget( self ):
			return self._thickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._thickness = ifcpositivelengthmeasure(value)
			else:
				self._thickness = value
		return property(**locals())

	@apply
	def filletradius():
		def fget( self ):
			return self._filletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._filletradius = ifcnonnegativelengthmeasure(value)
				else:
					self._filletradius = value
			else:
				self._filletradius = value
		return property(**locals())

	@apply
	def edgeradius():
		def fget( self ):
			return self._edgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnonnegativelengthmeasure):
					self._edgeradius = ifcnonnegativelengthmeasure(value)
				else:
					self._edgeradius = value
			else:
				self._edgeradius = value
		return property(**locals())

	@apply
	def legslope():
		def fget( self ):
			return self._legslope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._legslope = ifcplaneanglemeasure(value)
				else:
					self._legslope = value
			else:
				self._legslope = value
		return property(**locals())
	def validthickness(self):
		eval_validthickness_wr = ((self.thickness  <  self.depth)  and  (( not EXISTS(self.width))  or  (self.thickness  <  self.width)))
		if not eval_validthickness_wr:
			raise AssertionError('Rule validthickness violated')
		else:
			return eval_validthickness_wr


####################
 # ENTITY ifcdistributionsystem #
####################
class ifcdistributionsystem(ifcsystem):
	'''Entity ifcdistributionsystem definition.

	:param longname
	:type longname:ifclabel

	:param predefinedtype
	:type predefinedtype:ifcdistributionsystemenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , longname,predefinedtype, ):
		ifcsystem.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.longname = longname
		self.predefinedtype = predefinedtype

	@apply
	def longname():
		def fget( self ):
			return self._longname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._longname = ifclabel(value)
				else:
					self._longname = value
			else:
				self._longname = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdistributionsystemenum):
					self._predefinedtype = ifcdistributionsystemenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcdistributioncircuit #
####################
class ifcdistributioncircuit(ifcdistributionsystem):
	'''Entity ifcdistributioncircuit definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__longname , inherited6__predefinedtype ,  ):
		ifcdistributionsystem.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__longname , inherited6__predefinedtype , )

####################
 # ENTITY ifcflowinstrumenttype #
####################
class ifcflowinstrumenttype(ifcdistributioncontrolelementtype):
	'''Entity ifcflowinstrumenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcflowinstrumenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcflowinstrumenttypeenum):
				self._predefinedtype = ifcflowinstrumenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcflowinstrumenttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcflowinstrumenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifccircle #
####################
class ifccircle(ifcconic):
	'''Entity ifccircle definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , radius, ):
		ifcconic.__init__(self , inherited0__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY ifcdistributionchamberelement #
####################
class ifcdistributionchamberelement(ifcdistributionflowelement):
	'''Entity ifcdistributionchamberelement definition.

	:param predefinedtype
	:type predefinedtype:ifcdistributionchamberelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdistributionchamberelementtypeenum):
					self._predefinedtype = ifcdistributionchamberelementtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcdistributionchamberelementtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcdistributionchamberelementtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCDISTRIBUTIONCHAMBERELEMENTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcmotorconnectiontype #
####################
class ifcmotorconnectiontype(ifcenergyconversiondevicetype):
	'''Entity ifcmotorconnectiontype definition.

	:param predefinedtype
	:type predefinedtype:ifcmotorconnectiontypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcmotorconnectiontypeenum):
				self._predefinedtype = ifcmotorconnectiontypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcmotorconnectiontypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcmotorconnectiontypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcpropertysettemplate #
####################
class ifcpropertysettemplate(ifcpropertytemplatedefinition):
	'''Entity ifcpropertysettemplate definition.

	:param templatetype
	:type templatetype:ifcpropertysettemplatetypeenum

	:param applicableentity
	:type applicableentity:ifcidentifier

	:param haspropertytemplates
	:type haspropertytemplates:SET(1,None,'ifcpropertytemplate', scope = schema_scope)

	:param defines
	:type defines:SET(0,None,'ifcreldefinesbytemplate', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , templatetype,applicableentity,haspropertytemplates, ):
		ifcpropertytemplatedefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.templatetype = templatetype
		self.applicableentity = applicableentity
		self.haspropertytemplates = haspropertytemplates

	@apply
	def templatetype():
		def fget( self ):
			return self._templatetype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpropertysettemplatetypeenum):
					self._templatetype = ifcpropertysettemplatetypeenum(value)
				else:
					self._templatetype = value
			else:
				self._templatetype = value
		return property(**locals())

	@apply
	def applicableentity():
		def fget( self ):
			return self._applicableentity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._applicableentity = ifcidentifier(value)
				else:
					self._applicableentity = value
			else:
				self._applicableentity = value
		return property(**locals())

	@apply
	def haspropertytemplates():
		def fget( self ):
			return self._haspropertytemplates
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument haspropertytemplates is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcpropertytemplate', scope = schema_scope)):
				self._haspropertytemplates = SET(value)
			else:
				self._haspropertytemplates = value
		return property(**locals())

	@apply
	def defines():
		def fget( self ):
			return self._defines
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument defines is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def existsname(self):
		eval_existsname_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_existsname_wr:
			raise AssertionError('Rule existsname violated')
		else:
			return eval_existsname_wr

	def uniquepropertynames(self):
		eval_uniquepropertynames_wr = ifcuniquepropertytemplatenames(self.haspropertytemplates)
		if not eval_uniquepropertynames_wr:
			raise AssertionError('Rule uniquepropertynames violated')
		else:
			return eval_uniquepropertynames_wr


####################
 # ENTITY ifcshellbasedsurfacemodel #
####################
class ifcshellbasedsurfacemodel(ifcgeometricrepresentationitem):
	'''Entity ifcshellbasedsurfacemodel definition.

	:param sbsmboundary
	:type sbsmboundary:SET(1,None,'ifcshell', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , sbsmboundary, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.sbsmboundary = sbsmboundary

	@apply
	def sbsmboundary():
		def fget( self ):
			return self._sbsmboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sbsmboundary is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcshell', scope = schema_scope)):
				self._sbsmboundary = SET(value)
			else:
				self._sbsmboundary = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcprojectorder #
####################
class ifcprojectorder(ifccontrol):
	'''Entity ifcprojectorder definition.

	:param predefinedtype
	:type predefinedtype:ifcprojectordertypeenum

	:param status
	:type status:ifclabel

	:param longdescription
	:type longdescription:ifctext
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , predefinedtype,status,longdescription, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , )
		self.predefinedtype = predefinedtype
		self.status = status
		self.longdescription = longdescription

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcprojectordertypeenum):
					self._predefinedtype = ifcprojectordertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._status = ifclabel(value)
				else:
					self._status = value
			else:
				self._status = value
		return property(**locals())

	@apply
	def longdescription():
		def fget( self ):
			return self._longdescription
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._longdescription = ifctext(value)
				else:
					self._longdescription = value
			else:
				self._longdescription = value
		return property(**locals())

####################
 # ENTITY ifcrampflighttype #
####################
class ifcrampflighttype(ifcbuildingelementtype):
	'''Entity ifcrampflighttype definition.

	:param predefinedtype
	:type predefinedtype:ifcrampflighttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcrampflighttypeenum):
				self._predefinedtype = ifcrampflighttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcrampflighttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcrampflighttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcsurfacecurvesweptareasolid #
####################
class ifcsurfacecurvesweptareasolid(ifcsweptareasolid):
	'''Entity ifcsurfacecurvesweptareasolid definition.

	:param directrix
	:type directrix:ifccurve

	:param startparam
	:type startparam:ifcparametervalue

	:param endparam
	:type endparam:ifcparametervalue

	:param referencesurface
	:type referencesurface:ifcsurface
	'''
	def __init__( self , inherited0__sweptarea , inherited1__position , directrix,startparam,endparam,referencesurface, ):
		ifcsweptareasolid.__init__(self , inherited0__sweptarea , inherited1__position , )
		self.directrix = directrix
		self.startparam = startparam
		self.endparam = endparam
		self.referencesurface = referencesurface

	@apply
	def directrix():
		def fget( self ):
			return self._directrix
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directrix is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._directrix = ifccurve(value)
			else:
				self._directrix = value
		return property(**locals())

	@apply
	def startparam():
		def fget( self ):
			return self._startparam
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcparametervalue):
					self._startparam = ifcparametervalue(value)
				else:
					self._startparam = value
			else:
				self._startparam = value
		return property(**locals())

	@apply
	def endparam():
		def fget( self ):
			return self._endparam
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcparametervalue):
					self._endparam = ifcparametervalue(value)
				else:
					self._endparam = value
			else:
				self._endparam = value
		return property(**locals())

	@apply
	def referencesurface():
		def fget( self ):
			return self._referencesurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument referencesurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._referencesurface = ifcsurface(value)
			else:
				self._referencesurface = value
		return property(**locals())
	def directrixbounded(self):
		eval_directrixbounded_wr = ((EXISTS(self.startparam)  and  EXISTS(self.endparam))  or  (SIZEOF(['IFC4.IFCCONIC','IFC4.IFCBOUNDEDCURVE']  *  TYPEOF(self.directrix))  ==  1))
		if not eval_directrixbounded_wr:
			raise AssertionError('Rule directrixbounded violated')
		else:
			return eval_directrixbounded_wr


####################
 # ENTITY ifcbsplinesurfacewithknots #
####################
class ifcbsplinesurfacewithknots(ifcbsplinesurface):
	'''Entity ifcbsplinesurfacewithknots definition.

	:param umultiplicities
	:type umultiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param vmultiplicities
	:type vmultiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param uknots
	:type uknots:LIST(2,None,'REAL', scope = schema_scope)

	:param vknots
	:type vknots:LIST(2,None,'REAL', scope = schema_scope)

	:param knotspec
	:type knotspec:ifcknottype

	:param knotvupper
	:type knotvupper:INTEGER

	:param knotuupper
	:type knotuupper:INTEGER
	'''
	def __init__( self , inherited0__udegree , inherited1__vdegree , inherited2__controlpointslist , inherited3__surfaceform , inherited4__uclosed , inherited5__vclosed , inherited6__selfintersect , umultiplicities,vmultiplicities,uknots,vknots,knotspec, ):
		ifcbsplinesurface.__init__(self , inherited0__udegree , inherited1__vdegree , inherited2__controlpointslist , inherited3__surfaceform , inherited4__uclosed , inherited5__vclosed , inherited6__selfintersect , )
		self.umultiplicities = umultiplicities
		self.vmultiplicities = vmultiplicities
		self.uknots = uknots
		self.vknots = vknots
		self.knotspec = knotspec

	@apply
	def umultiplicities():
		def fget( self ):
			return self._umultiplicities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument umultiplicities is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
				self._umultiplicities = LIST(value)
			else:
				self._umultiplicities = value
		return property(**locals())

	@apply
	def vmultiplicities():
		def fget( self ):
			return self._vmultiplicities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vmultiplicities is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
				self._vmultiplicities = LIST(value)
			else:
				self._vmultiplicities = value
		return property(**locals())

	@apply
	def uknots():
		def fget( self ):
			return self._uknots
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uknots is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._uknots = LIST(value)
			else:
				self._uknots = value
		return property(**locals())

	@apply
	def vknots():
		def fget( self ):
			return self._vknots
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vknots is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._vknots = LIST(value)
			else:
				self._vknots = value
		return property(**locals())

	@apply
	def knotspec():
		def fget( self ):
			return self._knotspec
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knotspec is mantatory and can not be set to None')
			if not check_type(value,ifcknottype):
				self._knotspec = ifcknottype(value)
			else:
				self._knotspec = value
		return property(**locals())

	@apply
	def knotvupper():
		def fget( self ):
			attribute_eval = SIZEOF(self.vknots)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument knotvupper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def knotuupper():
		def fget( self ):
			attribute_eval = SIZEOF(self.uknots)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument knotuupper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def udirectionconstraints(self):
		eval_udirectionconstraints_wr = ifcconstraintsparambspline(self.self.ifcbsplinesurface.self.udegree,self.knotuupper,self.self.ifcbsplinesurface.self.uupper,self.umultiplicities,self.uknots)
		if not eval_udirectionconstraints_wr:
			raise AssertionError('Rule udirectionconstraints violated')
		else:
			return eval_udirectionconstraints_wr

	def vdirectionconstraints(self):
		eval_vdirectionconstraints_wr = ifcconstraintsparambspline(self.self.ifcbsplinesurface.self.vdegree,self.knotvupper,self.self.ifcbsplinesurface.self.vupper,self.vmultiplicities,self.vknots)
		if not eval_vdirectionconstraints_wr:
			raise AssertionError('Rule vdirectionconstraints violated')
		else:
			return eval_vdirectionconstraints_wr

	def correspondingulists(self):
		eval_correspondingulists_wr = (SIZEOF(self.umultiplicities)  ==  self.knotuupper)
		if not eval_correspondingulists_wr:
			raise AssertionError('Rule correspondingulists violated')
		else:
			return eval_correspondingulists_wr

	def correspondingvlists(self):
		eval_correspondingvlists_wr = (SIZEOF(self.vmultiplicities)  ==  self.knotvupper)
		if not eval_correspondingvlists_wr:
			raise AssertionError('Rule correspondingvlists violated')
		else:
			return eval_correspondingvlists_wr


####################
 # ENTITY ifcrationalbsplinesurfacewithknots #
####################
class ifcrationalbsplinesurfacewithknots(ifcbsplinesurfacewithknots):
	'''Entity ifcrationalbsplinesurfacewithknots definition.

	:param weightsdata
	:type weightsdata:LIST(2,None,LIST(2,None,'REAL', scope = schema_scope))

	:param weights
	:type weights:ARRAY(0,uupper,ARRAY(0,vupper,'REAL', scope = schema_scope))
	'''
	def __init__( self , inherited0__udegree , inherited1__vdegree , inherited2__controlpointslist , inherited3__surfaceform , inherited4__uclosed , inherited5__vclosed , inherited6__selfintersect , inherited7__umultiplicities , inherited8__vmultiplicities , inherited9__uknots , inherited10__vknots , inherited11__knotspec , weightsdata, ):
		ifcbsplinesurfacewithknots.__init__(self , inherited0__udegree , inherited1__vdegree , inherited2__controlpointslist , inherited3__surfaceform , inherited4__uclosed , inherited5__vclosed , inherited6__selfintersect , inherited7__umultiplicities , inherited8__vmultiplicities , inherited9__uknots , inherited10__vknots , inherited11__knotspec , )
		self.weightsdata = weightsdata

	@apply
	def weightsdata():
		def fget( self ):
			return self._weightsdata
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument weightsdata is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,LIST(2,None,'REAL', scope = schema_scope))):
				self._weightsdata = LIST(value)
			else:
				self._weightsdata = value
		return property(**locals())

	@apply
	def weights():
		def fget( self ):
			attribute_eval = ifcmakearrayofarray(self.weightsdata,0,self.uupper,0,self.vupper)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument weights is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def correspondingweightsdatalists(self):
		eval_correspondingweightsdatalists_wr = ((SIZEOF(self.weightsdata)  ==  SIZEOF(self.self.ifcbsplinesurface.self.controlpointslist))  and  (SIZEOF(self.weightsdata[1])  ==  SIZEOF(self.self.ifcbsplinesurface.self.controlpointslist[1])))
		if not eval_correspondingweightsdatalists_wr:
			raise AssertionError('Rule correspondingweightsdatalists violated')
		else:
			return eval_correspondingweightsdatalists_wr

	def weightvaluesgreaterzero(self):
		eval_weightvaluesgreaterzero_wr = ifcsurfaceweightspositive(self)
		if not eval_weightvaluesgreaterzero_wr:
			raise AssertionError('Rule weightvaluesgreaterzero violated')
		else:
			return eval_weightvaluesgreaterzero_wr


####################
 # ENTITY ifcreference #
####################
class ifcreference(BaseEntityClass):
	'''Entity ifcreference definition.

	:param typeidentifier
	:type typeidentifier:ifcidentifier

	:param attributeidentifier
	:type attributeidentifier:ifcidentifier

	:param instancename
	:type instancename:ifclabel

	:param listpositions
	:type listpositions:LIST(1,None,'INTEGER', scope = schema_scope)

	:param innerreference
	:type innerreference:ifcreference
	'''
	def __init__( self , typeidentifier,attributeidentifier,instancename,listpositions,innerreference, ):
		self.typeidentifier = typeidentifier
		self.attributeidentifier = attributeidentifier
		self.instancename = instancename
		self.listpositions = listpositions
		self.innerreference = innerreference

	@apply
	def typeidentifier():
		def fget( self ):
			return self._typeidentifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._typeidentifier = ifcidentifier(value)
				else:
					self._typeidentifier = value
			else:
				self._typeidentifier = value
		return property(**locals())

	@apply
	def attributeidentifier():
		def fget( self ):
			return self._attributeidentifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._attributeidentifier = ifcidentifier(value)
				else:
					self._attributeidentifier = value
			else:
				self._attributeidentifier = value
		return property(**locals())

	@apply
	def instancename():
		def fget( self ):
			return self._instancename
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._instancename = ifclabel(value)
				else:
					self._instancename = value
			else:
				self._instancename = value
		return property(**locals())

	@apply
	def listpositions():
		def fget( self ):
			return self._listpositions
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'INTEGER', scope = schema_scope)):
					self._listpositions = LIST(value)
				else:
					self._listpositions = value
			else:
				self._listpositions = value
		return property(**locals())

	@apply
	def innerreference():
		def fget( self ):
			return self._innerreference
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreference):
					self._innerreference = ifcreference(value)
				else:
					self._innerreference = value
			else:
				self._innerreference = value
		return property(**locals())

####################
 # ENTITY ifcspatialzonetype #
####################
class ifcspatialzonetype(ifcspatialelementtype):
	'''Entity ifcspatialzonetype definition.

	:param predefinedtype
	:type predefinedtype:ifcspatialzonetypeenum

	:param longname
	:type longname:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype,longname, ):
		ifcspatialelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype
		self.longname = longname

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcspatialzonetypeenum):
				self._predefinedtype = ifcspatialzonetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def longname():
		def fget( self ):
			return self._longname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._longname = ifclabel(value)
				else:
					self._longname = value
			else:
				self._longname = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcspatialzonetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcspatialzonetypeenum.self.userdefined)  and  EXISTS(self.self.ifcspatialelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcstructuralpointaction #
####################
class ifcstructuralpointaction(ifcstructuralaction):
	'''Entity ifcstructuralpointaction definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload ,  ):
		ifcstructuralaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , )
	def suitableloadtype(self):
		eval_suitableloadtype_wr = (SIZEOF(['IFC4.IFCSTRUCTURALLOADSINGLEFORCE','IFC4.IFCSTRUCTURALLOADSINGLEDISPLACEMENT']  *  TYPEOF(self.self.ifcstructuralactivity.self.appliedload))  ==  1)
		if not eval_suitableloadtype_wr:
			raise AssertionError('Rule suitableloadtype violated')
		else:
			return eval_suitableloadtype_wr


####################
 # ENTITY ifcpropertyreferencevalue #
####################
class ifcpropertyreferencevalue(ifcsimpleproperty):
	'''Entity ifcpropertyreferencevalue definition.

	:param usagename
	:type usagename:ifctext

	:param propertyreference
	:type propertyreference:ifcobjectreferenceselect
	'''
	def __init__( self , inherited0__name , inherited1__description , usagename,propertyreference, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.usagename = usagename
		self.propertyreference = propertyreference

	@apply
	def usagename():
		def fget( self ):
			return self._usagename
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._usagename = ifctext(value)
				else:
					self._usagename = value
			else:
				self._usagename = value
		return property(**locals())

	@apply
	def propertyreference():
		def fget( self ):
			return self._propertyreference
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcobjectreferenceselect):
					self._propertyreference = ifcobjectreferenceselect(value)
				else:
					self._propertyreference = value
			else:
				self._propertyreference = value
		return property(**locals())

####################
 # ENTITY ifcpointonsurface #
####################
class ifcpointonsurface(ifcpoint):
	'''Entity ifcpointonsurface definition.

	:param basissurface
	:type basissurface:ifcsurface

	:param pointparameteru
	:type pointparameteru:ifcparametervalue

	:param pointparameterv
	:type pointparameterv:ifcparametervalue

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , basissurface,pointparameteru,pointparameterv, ):
		ifcpoint.__init__(self , )
		self.basissurface = basissurface
		self.pointparameteru = pointparameteru
		self.pointparameterv = pointparameterv

	@apply
	def basissurface():
		def fget( self ):
			return self._basissurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basissurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._basissurface = ifcsurface(value)
			else:
				self._basissurface = value
		return property(**locals())

	@apply
	def pointparameteru():
		def fget( self ):
			return self._pointparameteru
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pointparameteru is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._pointparameteru = ifcparametervalue(value)
			else:
				self._pointparameteru = value
		return property(**locals())

	@apply
	def pointparameterv():
		def fget( self ):
			return self._pointparameterv
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pointparameterv is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._pointparameterv = ifcparametervalue(value)
			else:
				self._pointparameterv = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.basissurface.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcboilertype #
####################
class ifcboilertype(ifcenergyconversiondevicetype):
	'''Entity ifcboilertype definition.

	:param predefinedtype
	:type predefinedtype:ifcboilertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcboilertypeenum):
				self._predefinedtype = ifcboilertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcboilertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcboilertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcactor #
####################
class ifcactor(ifcobject):
	'''Entity ifcactor definition.

	:param theactor
	:type theactor:ifcactorselect

	:param isactingupon
	:type isactingupon:SET(0,None,'ifcrelassignstoactor', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , theactor, ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.theactor = theactor

	@apply
	def theactor():
		def fget( self ):
			return self._theactor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument theactor is mantatory and can not be set to None')
			if not check_type(value,ifcactorselect):
				self._theactor = ifcactorselect(value)
			else:
				self._theactor = value
		return property(**locals())

	@apply
	def isactingupon():
		def fget( self ):
			return self._isactingupon
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isactingupon is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcoccupant #
####################
class ifcoccupant(ifcactor):
	'''Entity ifcoccupant definition.

	:param predefinedtype
	:type predefinedtype:ifcoccupanttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__theactor , predefinedtype, ):
		ifcactor.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__theactor , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcoccupanttypeenum):
					self._predefinedtype = ifcoccupanttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (( not (self.predefinedtype  ==  ifcoccupanttypeenum.self.userdefined))  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcrelcontainedinspatialstructure #
####################
class ifcrelcontainedinspatialstructure(ifcrelconnects):
	'''Entity ifcrelcontainedinspatialstructure definition.

	:param relatedelements
	:type relatedelements:SET(1,None,'ifcproduct', scope = schema_scope)

	:param relatingstructure
	:type relatingstructure:ifcspatialelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedelements,relatingstructure, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedelements = relatedelements
		self.relatingstructure = relatingstructure

	@apply
	def relatedelements():
		def fget( self ):
			return self._relatedelements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedelements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproduct', scope = schema_scope)):
				self._relatedelements = SET(value)
			else:
				self._relatedelements = value
		return property(**locals())

	@apply
	def relatingstructure():
		def fget( self ):
			return self._relatingstructure
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingstructure is mantatory and can not be set to None')
			if not check_type(value,ifcspatialelement):
				self._relatingstructure = ifcspatialelement(value)
			else:
				self._relatingstructure = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (SIZEOF(None)  ==  0)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcstructuralpointconnection #
####################
class ifcstructuralpointconnection(ifcstructuralconnection):
	'''Entity ifcstructuralpointconnection definition.

	:param conditioncoordinatesystem
	:type conditioncoordinatesystem:ifcaxis2placement3d
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition , conditioncoordinatesystem, ):
		ifcstructuralconnection.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition , )
		self.conditioncoordinatesystem = conditioncoordinatesystem

	@apply
	def conditioncoordinatesystem():
		def fget( self ):
			return self._conditioncoordinatesystem
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaxis2placement3d):
					self._conditioncoordinatesystem = ifcaxis2placement3d(value)
				else:
					self._conditioncoordinatesystem = value
			else:
				self._conditioncoordinatesystem = value
		return property(**locals())

####################
 # ENTITY ifccomplexpropertytemplate #
####################
class ifccomplexpropertytemplate(ifcpropertytemplate):
	'''Entity ifccomplexpropertytemplate definition.

	:param usagename
	:type usagename:ifclabel

	:param templatetype
	:type templatetype:ifccomplexpropertytemplatetypeenum

	:param haspropertytemplates
	:type haspropertytemplates:SET(1,None,'ifcpropertytemplate', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , usagename,templatetype,haspropertytemplates, ):
		ifcpropertytemplate.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.usagename = usagename
		self.templatetype = templatetype
		self.haspropertytemplates = haspropertytemplates

	@apply
	def usagename():
		def fget( self ):
			return self._usagename
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._usagename = ifclabel(value)
				else:
					self._usagename = value
			else:
				self._usagename = value
		return property(**locals())

	@apply
	def templatetype():
		def fget( self ):
			return self._templatetype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccomplexpropertytemplatetypeenum):
					self._templatetype = ifccomplexpropertytemplatetypeenum(value)
				else:
					self._templatetype = value
			else:
				self._templatetype = value
		return property(**locals())

	@apply
	def haspropertytemplates():
		def fget( self ):
			return self._haspropertytemplates
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcpropertytemplate', scope = schema_scope)):
					self._haspropertytemplates = SET(value)
				else:
					self._haspropertytemplates = value
			else:
				self._haspropertytemplates = value
		return property(**locals())
	def uniquepropertynames(self):
		eval_uniquepropertynames_wr = ifcuniquepropertytemplatenames(self.haspropertytemplates)
		if not eval_uniquepropertynames_wr:
			raise AssertionError('Rule uniquepropertynames violated')
		else:
			return eval_uniquepropertynames_wr

	def noselfreference(self):
		eval_noselfreference_wr = (SIZEOF(None)  ==  0)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifcoffsetcurve3d #
####################
class ifcoffsetcurve3d(ifccurve):
	'''Entity ifcoffsetcurve3d definition.

	:param basiscurve
	:type basiscurve:ifccurve

	:param distance
	:type distance:ifclengthmeasure

	:param selfintersect
	:type selfintersect:LOGICAL

	:param refdirection
	:type refdirection:ifcdirection
	'''
	def __init__( self , basiscurve,distance,selfintersect,refdirection, ):
		ifccurve.__init__(self , )
		self.basiscurve = basiscurve
		self.distance = distance
		self.selfintersect = selfintersect
		self.refdirection = refdirection

	@apply
	def basiscurve():
		def fget( self ):
			return self._basiscurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basiscurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._basiscurve = ifccurve(value)
			else:
				self._basiscurve = value
		return property(**locals())

	@apply
	def distance():
		def fget( self ):
			return self._distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._distance = ifclengthmeasure(value)
			else:
				self._distance = value
		return property(**locals())

	@apply
	def selfintersect():
		def fget( self ):
			return self._selfintersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument selfintersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._selfintersect = LOGICAL(value)
			else:
				self._selfintersect = value
		return property(**locals())

	@apply
	def refdirection():
		def fget( self ):
			return self._refdirection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument refdirection is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._refdirection = ifcdirection(value)
			else:
				self._refdirection = value
		return property(**locals())
	def dimis2d(self):
		eval_dimis2d_wr = (self.basiscurve.self.dim  ==  3)
		if not eval_dimis2d_wr:
			raise AssertionError('Rule dimis2d violated')
		else:
			return eval_dimis2d_wr


####################
 # ENTITY ifcvibrationisolatortype #
####################
class ifcvibrationisolatortype(ifcelementcomponenttype):
	'''Entity ifcvibrationisolatortype definition.

	:param predefinedtype
	:type predefinedtype:ifcvibrationisolatortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcelementcomponenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcvibrationisolatortypeenum):
				self._predefinedtype = ifcvibrationisolatortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcvibrationisolatortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcvibrationisolatortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcconnectionvolumegeometry #
####################
class ifcconnectionvolumegeometry(ifcconnectiongeometry):
	'''Entity ifcconnectionvolumegeometry definition.

	:param volumeonrelatingelement
	:type volumeonrelatingelement:ifcsolidorshell

	:param volumeonrelatedelement
	:type volumeonrelatedelement:ifcsolidorshell
	'''
	def __init__( self , volumeonrelatingelement,volumeonrelatedelement, ):
		ifcconnectiongeometry.__init__(self , )
		self.volumeonrelatingelement = volumeonrelatingelement
		self.volumeonrelatedelement = volumeonrelatedelement

	@apply
	def volumeonrelatingelement():
		def fget( self ):
			return self._volumeonrelatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument volumeonrelatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcsolidorshell):
				self._volumeonrelatingelement = ifcsolidorshell(value)
			else:
				self._volumeonrelatingelement = value
		return property(**locals())

	@apply
	def volumeonrelatedelement():
		def fget( self ):
			return self._volumeonrelatedelement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsolidorshell):
					self._volumeonrelatedelement = ifcsolidorshell(value)
				else:
					self._volumeonrelatedelement = value
			else:
				self._volumeonrelatedelement = value
		return property(**locals())

####################
 # ENTITY ifcelectricappliance #
####################
class ifcelectricappliance(ifcflowterminal):
	'''Entity ifcelectricappliance definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricappliancetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelectricappliancetypeenum):
					self._predefinedtype = ifcelectricappliancetypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcelectricappliancetypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcelectricappliancetypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCELECTRICAPPLIANCETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcreldefinesbyobject #
####################
class ifcreldefinesbyobject(ifcreldefines):
	'''Entity ifcreldefinesbyobject definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobject', scope = schema_scope)

	:param relatingobject
	:type relatingobject:ifcobject
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedobjects,relatingobject, ):
		ifcreldefines.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedobjects = relatedobjects
		self.relatingobject = relatingobject

	@apply
	def relatedobjects():
		def fget( self ):
			return self._relatedobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcobject', scope = schema_scope)):
				self._relatedobjects = SET(value)
			else:
				self._relatedobjects = value
		return property(**locals())

	@apply
	def relatingobject():
		def fget( self ):
			return self._relatingobject
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingobject is mantatory and can not be set to None')
			if not check_type(value,ifcobject):
				self._relatingobject = ifcobject(value)
			else:
				self._relatingobject = value
		return property(**locals())

####################
 # ENTITY ifctablecolumn #
####################
class ifctablecolumn(BaseEntityClass):
	'''Entity ifctablecolumn definition.

	:param identifier
	:type identifier:ifcidentifier

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param unit
	:type unit:ifcunit

	:param referencepath
	:type referencepath:ifcreference
	'''
	def __init__( self , identifier,name,description,unit,referencepath, ):
		self.identifier = identifier
		self.name = name
		self.description = description
		self.unit = unit
		self.referencepath = referencepath

	@apply
	def identifier():
		def fget( self ):
			return self._identifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identifier = ifcidentifier(value)
				else:
					self._identifier = value
			else:
				self._identifier = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._unit = ifcunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())

	@apply
	def referencepath():
		def fget( self ):
			return self._referencepath
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreference):
					self._referencepath = ifcreference(value)
				else:
					self._referencepath = value
			else:
				self._referencepath = value
		return property(**locals())

####################
 # ENTITY ifctransformertype #
####################
class ifctransformertype(ifcenergyconversiondevicetype):
	'''Entity ifctransformertype definition.

	:param predefinedtype
	:type predefinedtype:ifctransformertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctransformertypeenum):
				self._predefinedtype = ifctransformertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifctransformertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifctransformertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcapplication #
####################
class ifcapplication(BaseEntityClass):
	'''Entity ifcapplication definition.

	:param applicationdeveloper
	:type applicationdeveloper:ifcorganization

	:param version
	:type version:ifclabel

	:param applicationfullname
	:type applicationfullname:ifclabel

	:param applicationidentifier
	:type applicationidentifier:ifcidentifier
	'''
	def __init__( self , applicationdeveloper,version,applicationfullname,applicationidentifier, ):
		self.applicationdeveloper = applicationdeveloper
		self.version = version
		self.applicationfullname = applicationfullname
		self.applicationidentifier = applicationidentifier

	@apply
	def applicationdeveloper():
		def fget( self ):
			return self._applicationdeveloper
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applicationdeveloper is mantatory and can not be set to None')
			if not check_type(value,ifcorganization):
				self._applicationdeveloper = ifcorganization(value)
			else:
				self._applicationdeveloper = value
		return property(**locals())

	@apply
	def version():
		def fget( self ):
			return self._version
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument version is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._version = ifclabel(value)
			else:
				self._version = value
		return property(**locals())

	@apply
	def applicationfullname():
		def fget( self ):
			return self._applicationfullname
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applicationfullname is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._applicationfullname = ifclabel(value)
			else:
				self._applicationfullname = value
		return property(**locals())

	@apply
	def applicationidentifier():
		def fget( self ):
			return self._applicationidentifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applicationidentifier is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._applicationidentifier = ifcidentifier(value)
			else:
				self._applicationidentifier = value
		return property(**locals())

####################
 # ENTITY ifcreldeclares #
####################
class ifcreldeclares(ifcrelationship):
	'''Entity ifcreldeclares definition.

	:param relatingcontext
	:type relatingcontext:ifccontext

	:param relateddefinitions
	:type relateddefinitions:SET(1,None,'ifcdefinitionselect', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingcontext,relateddefinitions, ):
		ifcrelationship.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingcontext = relatingcontext
		self.relateddefinitions = relateddefinitions

	@apply
	def relatingcontext():
		def fget( self ):
			return self._relatingcontext
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingcontext is mantatory and can not be set to None')
			if not check_type(value,ifccontext):
				self._relatingcontext = ifccontext(value)
			else:
				self._relatingcontext = value
		return property(**locals())

	@apply
	def relateddefinitions():
		def fget( self ):
			return self._relateddefinitions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relateddefinitions is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcdefinitionselect', scope = schema_scope)):
				self._relateddefinitions = SET(value)
			else:
				self._relateddefinitions = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (SIZEOF(None)  ==  0)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifccoveringtype #
####################
class ifccoveringtype(ifcbuildingelementtype):
	'''Entity ifccoveringtype definition.

	:param predefinedtype
	:type predefinedtype:ifccoveringtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccoveringtypeenum):
				self._predefinedtype = ifccoveringtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccoveringtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccoveringtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcproductdefinitionshape #
####################
class ifcproductdefinitionshape(ifcproductrepresentation):
	'''Entity ifcproductdefinitionshape definition.

	:param shapeofproduct
	:type shapeofproduct:SET(1,None,'ifcproduct', scope = schema_scope)

	:param hasshapeaspects
	:type hasshapeaspects:SET(0,None,'ifcshapeaspect', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__representations ,  ):
		ifcproductrepresentation.__init__(self , inherited0__name , inherited1__description , inherited2__representations , )

	@apply
	def shapeofproduct():
		def fget( self ):
			return self._shapeofproduct
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument shapeofproduct is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasshapeaspects():
		def fget( self ):
			return self._hasshapeaspects
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasshapeaspects is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def onlyshapemodel(self):
		eval_onlyshapemodel_wr = (SIZEOF(None)  ==  0)
		if not eval_onlyshapemodel_wr:
			raise AssertionError('Rule onlyshapemodel violated')
		else:
			return eval_onlyshapemodel_wr


####################
 # ENTITY ifccirclehollowprofiledef #
####################
class ifccirclehollowprofiledef(ifccircleprofiledef):
	'''Entity ifccirclehollowprofiledef definition.

	:param wallthickness
	:type wallthickness:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__radius , wallthickness, ):
		ifccircleprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__radius , )
		self.wallthickness = wallthickness

	@apply
	def wallthickness():
		def fget( self ):
			return self._wallthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument wallthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._wallthickness = ifcpositivelengthmeasure(value)
			else:
				self._wallthickness = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.wallthickness  <  self.self.ifccircleprofiledef.self.radius)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcgeographicelementtype #
####################
class ifcgeographicelementtype(ifcelementtype):
	'''Entity ifcgeographicelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifcgeographicelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcgeographicelementtypeenum):
				self._predefinedtype = ifcgeographicelementtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcgeographicelementtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcgeographicelementtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcairterminal #
####################
class ifcairterminal(ifcflowterminal):
	'''Entity ifcairterminal definition.

	:param predefinedtype
	:type predefinedtype:ifcairterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcairterminaltypeenum):
					self._predefinedtype = ifcairterminaltypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcairterminaltypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcairterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCAIRTERMINALTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifccenterlineprofiledef #
####################
class ifccenterlineprofiledef(ifcarbitraryopenprofiledef):
	'''Entity ifccenterlineprofiledef definition.

	:param thickness
	:type thickness:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__curve , thickness, ):
		ifcarbitraryopenprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__curve , )
		self.thickness = thickness

	@apply
	def thickness():
		def fget( self ):
			return self._thickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._thickness = ifcpositivelengthmeasure(value)
			else:
				self._thickness = value
		return property(**locals())

####################
 # ENTITY ifcfaceouterbound #
####################
class ifcfaceouterbound(ifcfacebound):
	'''Entity ifcfaceouterbound definition.
	'''
	def __init__( self , inherited0__bound , inherited1__orientation ,  ):
		ifcfacebound.__init__(self , inherited0__bound , inherited1__orientation , )

####################
 # ENTITY ifcvector #
####################
class ifcvector(ifcgeometricrepresentationitem):
	'''Entity ifcvector definition.

	:param orientation
	:type orientation:ifcdirection

	:param magnitude
	:type magnitude:ifclengthmeasure

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , orientation,magnitude, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.orientation = orientation
		self.magnitude = magnitude

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._orientation = ifcdirection(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def magnitude():
		def fget( self ):
			return self._magnitude
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument magnitude is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._magnitude = ifclengthmeasure(value)
			else:
				self._magnitude = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.orientation.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def maggreaterorequalzero(self):
		eval_maggreaterorequalzero_wr = (self.magnitude  >=  0)
		if not eval_maggreaterorequalzero_wr:
			raise AssertionError('Rule maggreaterorequalzero violated')
		else:
			return eval_maggreaterorequalzero_wr


####################
 # ENTITY ifccurtainwall #
####################
class ifccurtainwall(ifcbuildingelement):
	'''Entity ifccurtainwall definition.

	:param predefinedtype
	:type predefinedtype:ifccurtainwalltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccurtainwalltypeenum):
					self._predefinedtype = ifccurtainwalltypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccurtainwalltypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccurtainwalltypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCURTAINWALLTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcexternallydefinedhatchstyle #
####################
class ifcexternallydefinedhatchstyle(ifcexternalreference):
	'''Entity ifcexternallydefinedhatchstyle definition.
	'''
	def __init__( self , inherited0__location , inherited1__identification , inherited2__name ,  ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__identification , inherited2__name , )

####################
 # ENTITY ifcmeasurewithunit #
####################
class ifcmeasurewithunit(BaseEntityClass):
	'''Entity ifcmeasurewithunit definition.

	:param valuecomponent
	:type valuecomponent:ifcvalue

	:param unitcomponent
	:type unitcomponent:ifcunit
	'''
	def __init__( self , valuecomponent,unitcomponent, ):
		self.valuecomponent = valuecomponent
		self.unitcomponent = unitcomponent

	@apply
	def valuecomponent():
		def fget( self ):
			return self._valuecomponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument valuecomponent is mantatory and can not be set to None')
			if not check_type(value,ifcvalue):
				self._valuecomponent = ifcvalue(value)
			else:
				self._valuecomponent = value
		return property(**locals())

	@apply
	def unitcomponent():
		def fget( self ):
			return self._unitcomponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unitcomponent is mantatory and can not be set to None')
			if not check_type(value,ifcunit):
				self._unitcomponent = ifcunit(value)
			else:
				self._unitcomponent = value
		return property(**locals())

####################
 # ENTITY ifcrectangularpyramid #
####################
class ifcrectangularpyramid(ifccsgprimitive3d):
	'''Entity ifcrectangularpyramid definition.

	:param xlength
	:type xlength:ifcpositivelengthmeasure

	:param ylength
	:type ylength:ifcpositivelengthmeasure

	:param height
	:type height:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , xlength,ylength,height, ):
		ifccsgprimitive3d.__init__(self , inherited0__position , )
		self.xlength = xlength
		self.ylength = ylength
		self.height = height

	@apply
	def xlength():
		def fget( self ):
			return self._xlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument xlength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._xlength = ifcpositivelengthmeasure(value)
			else:
				self._xlength = value
		return property(**locals())

	@apply
	def ylength():
		def fget( self ):
			return self._ylength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ylength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._ylength = ifcpositivelengthmeasure(value)
			else:
				self._ylength = value
		return property(**locals())

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._height = ifcpositivelengthmeasure(value)
			else:
				self._height = value
		return property(**locals())

####################
 # ENTITY ifcsurfacestyle #
####################
class ifcsurfacestyle(ifcpresentationstyle):
	'''Entity ifcsurfacestyle definition.

	:param side
	:type side:ifcsurfaceside

	:param styles
	:type styles:SET(1,5,'ifcsurfacestyleelementselect', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , side,styles, ):
		ifcpresentationstyle.__init__(self , inherited0__name , )
		self.side = side
		self.styles = styles

	@apply
	def side():
		def fget( self ):
			return self._side
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument side is mantatory and can not be set to None')
			if not check_type(value,ifcsurfaceside):
				self._side = ifcsurfaceside(value)
			else:
				self._side = value
		return property(**locals())

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,5,'ifcsurfacestyleelementselect', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())
	def maxoneshading(self):
		eval_maxoneshading_wr = (SIZEOF(None)  <=  1)
		if not eval_maxoneshading_wr:
			raise AssertionError('Rule maxoneshading violated')
		else:
			return eval_maxoneshading_wr

	def maxonelighting(self):
		eval_maxonelighting_wr = (SIZEOF(None)  <=  1)
		if not eval_maxonelighting_wr:
			raise AssertionError('Rule maxonelighting violated')
		else:
			return eval_maxonelighting_wr

	def maxonerefraction(self):
		eval_maxonerefraction_wr = (SIZEOF(None)  <=  1)
		if not eval_maxonerefraction_wr:
			raise AssertionError('Rule maxonerefraction violated')
		else:
			return eval_maxonerefraction_wr

	def maxonetextures(self):
		eval_maxonetextures_wr = (SIZEOF(None)  <=  1)
		if not eval_maxonetextures_wr:
			raise AssertionError('Rule maxonetextures violated')
		else:
			return eval_maxonetextures_wr

	def maxoneextdefined(self):
		eval_maxoneextdefined_wr = (SIZEOF(None)  <=  1)
		if not eval_maxoneextdefined_wr:
			raise AssertionError('Rule maxoneextdefined violated')
		else:
			return eval_maxoneextdefined_wr


####################
 # ENTITY ifcelectricmotortype #
####################
class ifcelectricmotortype(ifcenergyconversiondevicetype):
	'''Entity ifcelectricmotortype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricmotortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectricmotortypeenum):
				self._predefinedtype = ifcelectricmotortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcelectricmotortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcelectricmotortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcproceduretype #
####################
class ifcproceduretype(ifctypeprocess):
	'''Entity ifcproceduretype definition.

	:param predefinedtype
	:type predefinedtype:ifcproceduretypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__processtype , predefinedtype, ):
		ifctypeprocess.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__identification , inherited7__longdescription , inherited8__processtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcproceduretypeenum):
				self._predefinedtype = ifcproceduretypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcproceduretypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcproceduretypeenum.self.userdefined)  and  EXISTS(self.self.ifctypeprocess.self.processtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcirregulartimeseriesvalue #
####################
class ifcirregulartimeseriesvalue(BaseEntityClass):
	'''Entity ifcirregulartimeseriesvalue definition.

	:param timestamp
	:type timestamp:ifcdatetime

	:param listvalues
	:type listvalues:LIST(1,None,'ifcvalue', scope = schema_scope)
	'''
	def __init__( self , timestamp,listvalues, ):
		self.timestamp = timestamp
		self.listvalues = listvalues

	@apply
	def timestamp():
		def fget( self ):
			return self._timestamp
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timestamp is mantatory and can not be set to None')
			if not check_type(value,ifcdatetime):
				self._timestamp = ifcdatetime(value)
			else:
				self._timestamp = value
		return property(**locals())

	@apply
	def listvalues():
		def fget( self ):
			return self._listvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument listvalues is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
				self._listvalues = LIST(value)
			else:
				self._listvalues = value
		return property(**locals())

####################
 # ENTITY ifcoutlet #
####################
class ifcoutlet(ifcflowterminal):
	'''Entity ifcoutlet definition.

	:param predefinedtype
	:type predefinedtype:ifcoutlettypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcoutlettypeenum):
					self._predefinedtype = ifcoutlettypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcoutlettypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcoutlettypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCOUTLETTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcsolardevicetype #
####################
class ifcsolardevicetype(ifcenergyconversiondevicetype):
	'''Entity ifcsolardevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcsolardevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcsolardevicetypeenum):
				self._predefinedtype = ifcsolardevicetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcsolardevicetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcsolardevicetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcpresentationlayerassignment #
####################
class ifcpresentationlayerassignment(BaseEntityClass):
	'''Entity ifcpresentationlayerassignment definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param assigneditems
	:type assigneditems:SET(1,None,'ifclayereditem', scope = schema_scope)

	:param identifier
	:type identifier:ifcidentifier
	'''
	def __init__( self , name,description,assigneditems,identifier, ):
		self.name = name
		self.description = description
		self.assigneditems = assigneditems
		self.identifier = identifier

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def assigneditems():
		def fget( self ):
			return self._assigneditems
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigneditems is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifclayereditem', scope = schema_scope)):
				self._assigneditems = SET(value)
			else:
				self._assigneditems = value
		return property(**locals())

	@apply
	def identifier():
		def fget( self ):
			return self._identifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identifier = ifcidentifier(value)
				else:
					self._identifier = value
			else:
				self._identifier = value
		return property(**locals())
	def applicableitems(self):
		eval_applicableitems_wr = (SIZEOF(None)  ==  SIZEOF(self.assigneditems))
		if not eval_applicableitems_wr:
			raise AssertionError('Rule applicableitems violated')
		else:
			return eval_applicableitems_wr


####################
 # ENTITY ifcprojectionelement #
####################
class ifcprojectionelement(ifcfeatureelementaddition):
	'''Entity ifcprojectionelement definition.

	:param predefinedtype
	:type predefinedtype:ifcprojectionelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcfeatureelementaddition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcprojectionelementtypeenum):
					self._predefinedtype = ifcprojectionelementtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcrelassociatesapproval #
####################
class ifcrelassociatesapproval(ifcrelassociates):
	'''Entity ifcrelassociatesapproval definition.

	:param relatingapproval
	:type relatingapproval:ifcapproval
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingapproval, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingapproval = relatingapproval

	@apply
	def relatingapproval():
		def fget( self ):
			return self._relatingapproval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingapproval is mantatory and can not be set to None')
			if not check_type(value,ifcapproval):
				self._relatingapproval = ifcapproval(value)
			else:
				self._relatingapproval = value
		return property(**locals())

####################
 # ENTITY ifccurvestyle #
####################
class ifccurvestyle(ifcpresentationstyle):
	'''Entity ifccurvestyle definition.

	:param curvefont
	:type curvefont:ifccurvefontorscaledcurvefontselect

	:param curvewidth
	:type curvewidth:ifcsizeselect

	:param curvecolour
	:type curvecolour:ifccolour

	:param modelordraughting
	:type modelordraughting:BOOLEAN
	'''
	def __init__( self , inherited0__name , curvefont,curvewidth,curvecolour,modelordraughting, ):
		ifcpresentationstyle.__init__(self , inherited0__name , )
		self.curvefont = curvefont
		self.curvewidth = curvewidth
		self.curvecolour = curvecolour
		self.modelordraughting = modelordraughting

	@apply
	def curvefont():
		def fget( self ):
			return self._curvefont
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccurvefontorscaledcurvefontselect):
					self._curvefont = ifccurvefontorscaledcurvefontselect(value)
				else:
					self._curvefont = value
			else:
				self._curvefont = value
		return property(**locals())

	@apply
	def curvewidth():
		def fget( self ):
			return self._curvewidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsizeselect):
					self._curvewidth = ifcsizeselect(value)
				else:
					self._curvewidth = value
			else:
				self._curvewidth = value
		return property(**locals())

	@apply
	def curvecolour():
		def fget( self ):
			return self._curvecolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolour):
					self._curvecolour = ifccolour(value)
				else:
					self._curvecolour = value
			else:
				self._curvecolour = value
		return property(**locals())

	@apply
	def modelordraughting():
		def fget( self ):
			return self._modelordraughting
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._modelordraughting = BOOLEAN(value)
				else:
					self._modelordraughting = value
			else:
				self._modelordraughting = value
		return property(**locals())
	def measureofwidth(self):
		eval_measureofwidth_wr = ((( not EXISTS(self.curvewidth))  or  ('IFC4.IFCPOSITIVELENGTHMEASURE'  ==  TYPEOF(self.curvewidth)))  or  (('IFC4.IFCDESCRIPTIVEMEASURE'  ==  TYPEOF(self.curvewidth))  and  (self.curvewidth  ==  'by layer')))
		if not eval_measureofwidth_wr:
			raise AssertionError('Rule measureofwidth violated')
		else:
			return eval_measureofwidth_wr

	def identifiablecurvestyle(self):
		eval_identifiablecurvestyle_wr = ((EXISTS(self.curvefont)  or  EXISTS(self.curvewidth))  or  EXISTS(self.curvecolour))
		if not eval_identifiablecurvestyle_wr:
			raise AssertionError('Rule identifiablecurvestyle violated')
		else:
			return eval_identifiablecurvestyle_wr


####################
 # ENTITY ifcdirection #
####################
class ifcdirection(ifcgeometricrepresentationitem):
	'''Entity ifcdirection definition.

	:param directionratios
	:type directionratios:LIST(2,3,'REAL', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , directionratios, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.directionratios = directionratios

	@apply
	def directionratios():
		def fget( self ):
			return self._directionratios
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directionratios is mantatory and can not be set to None')
			if not check_type(value,LIST(2,3,'REAL', scope = schema_scope)):
				self._directionratios = LIST(value)
			else:
				self._directionratios = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = HIINDEX(self.directionratios)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def magnitudegreaterzero(self):
		eval_magnitudegreaterzero_wr = (SIZEOF(None)  >  0)
		if not eval_magnitudegreaterzero_wr:
			raise AssertionError('Rule magnitudegreaterzero violated')
		else:
			return eval_magnitudegreaterzero_wr


####################
 # ENTITY ifcstackterminal #
####################
class ifcstackterminal(ifcflowterminal):
	'''Entity ifcstackterminal definition.

	:param predefinedtype
	:type predefinedtype:ifcstackterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowterminal.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcstackterminaltypeenum):
					self._predefinedtype = ifcstackterminaltypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcstackterminaltypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcstackterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCSTACKTERMINALTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcstructuralloadconfiguration #
####################
class ifcstructuralloadconfiguration(ifcstructuralload):
	'''Entity ifcstructuralloadconfiguration definition.

	:param values
	:type values:LIST(1,None,'ifcstructuralloadorresult', scope = schema_scope)

	:param locations
	:type locations:LIST(1,None,LIST(1,2,'REAL', scope = schema_scope))
	'''
	def __init__( self , inherited0__name , values,locations, ):
		ifcstructuralload.__init__(self , inherited0__name , )
		self.values = values
		self.locations = locations

	@apply
	def values():
		def fget( self ):
			return self._values
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument values is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcstructuralloadorresult', scope = schema_scope)):
				self._values = LIST(value)
			else:
				self._values = value
		return property(**locals())

	@apply
	def locations():
		def fget( self ):
			return self._locations
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,LIST(1,2,'REAL', scope = schema_scope))):
					self._locations = LIST(value)
				else:
					self._locations = value
			else:
				self._locations = value
		return property(**locals())
	def validlistsize(self):
		eval_validlistsize_wr = (( not EXISTS(self.locations))  or  (SIZEOF(self.locations)  ==  SIZEOF(self.values)))
		if not eval_validlistsize_wr:
			raise AssertionError('Rule validlistsize violated')
		else:
			return eval_validlistsize_wr


####################
 # ENTITY ifcbeamstandardcase #
####################
class ifcbeamstandardcase(ifcbeam):
	'''Entity ifcbeamstandardcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype ,  ):
		ifcbeam.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype , )
	def hasmaterialprofilesetusage(self):
		eval_hasmaterialprofilesetusage_wr = (SIZEOF(None)  ==  1)
		if not eval_hasmaterialprofilesetusage_wr:
			raise AssertionError('Rule hasmaterialprofilesetusage violated')
		else:
			return eval_hasmaterialprofilesetusage_wr


####################
 # ENTITY ifcfillareastyletiles #
####################
class ifcfillareastyletiles(ifcgeometricrepresentationitem):
	'''Entity ifcfillareastyletiles definition.

	:param tilingpattern
	:type tilingpattern:LIST(2,2,'ifcvector', scope = schema_scope)

	:param tiles
	:type tiles:SET(1,None,'ifcstyleditem', scope = schema_scope)

	:param tilingscale
	:type tilingscale:ifcpositiveratiomeasure
	'''
	def __init__( self , tilingpattern,tiles,tilingscale, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.tilingpattern = tilingpattern
		self.tiles = tiles
		self.tilingscale = tilingscale

	@apply
	def tilingpattern():
		def fget( self ):
			return self._tilingpattern
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tilingpattern is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'ifcvector', scope = schema_scope)):
				self._tilingpattern = LIST(value)
			else:
				self._tilingpattern = value
		return property(**locals())

	@apply
	def tiles():
		def fget( self ):
			return self._tiles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tiles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcstyleditem', scope = schema_scope)):
				self._tiles = SET(value)
			else:
				self._tiles = value
		return property(**locals())

	@apply
	def tilingscale():
		def fget( self ):
			return self._tilingscale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tilingscale is mantatory and can not be set to None')
			if not check_type(value,ifcpositiveratiomeasure):
				self._tilingscale = ifcpositiveratiomeasure(value)
			else:
				self._tilingscale = value
		return property(**locals())

####################
 # ENTITY ifcbeamtype #
####################
class ifcbeamtype(ifcbuildingelementtype):
	'''Entity ifcbeamtype definition.

	:param predefinedtype
	:type predefinedtype:ifcbeamtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcbeamtypeenum):
				self._predefinedtype = ifcbeamtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcbeamtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcbeamtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcextrudedareasolidtapered #
####################
class ifcextrudedareasolidtapered(ifcextrudedareasolid):
	'''Entity ifcextrudedareasolidtapered definition.

	:param endsweptarea
	:type endsweptarea:ifcprofiledef
	'''
	def __init__( self , inherited0__sweptarea , inherited1__position , inherited2__extrudeddirection , inherited3__depth , endsweptarea, ):
		ifcextrudedareasolid.__init__(self , inherited0__sweptarea , inherited1__position , inherited2__extrudeddirection , inherited3__depth , )
		self.endsweptarea = endsweptarea

	@apply
	def endsweptarea():
		def fget( self ):
			return self._endsweptarea
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument endsweptarea is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._endsweptarea = ifcprofiledef(value)
			else:
				self._endsweptarea = value
		return property(**locals())
	def correctprofileassignment(self):
		eval_correctprofileassignment_wr = ifctaperedsweptareaprofiles(self.self.ifcsweptareasolid.self.sweptarea,self.self.endsweptarea)
		if not eval_correctprofileassignment_wr:
			raise AssertionError('Rule correctprofileassignment violated')
		else:
			return eval_correctprofileassignment_wr


####################
 # ENTITY ifclightsourcegoniometric #
####################
class ifclightsourcegoniometric(ifclightsource):
	'''Entity ifclightsourcegoniometric definition.

	:param position
	:type position:ifcaxis2placement3d

	:param colourappearance
	:type colourappearance:ifccolourrgb

	:param colourtemperature
	:type colourtemperature:ifcthermodynamictemperaturemeasure

	:param luminousflux
	:type luminousflux:ifcluminousfluxmeasure

	:param lightemissionsource
	:type lightemissionsource:ifclightemissionsourceenum

	:param lightdistributiondatasource
	:type lightdistributiondatasource:ifclightdistributiondatasourceselect
	'''
	def __init__( self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , position,colourappearance,colourtemperature,luminousflux,lightemissionsource,lightdistributiondatasource, ):
		ifclightsource.__init__(self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , )
		self.position = position
		self.colourappearance = colourappearance
		self.colourtemperature = colourtemperature
		self.luminousflux = luminousflux
		self.lightemissionsource = lightemissionsource
		self.lightdistributiondatasource = lightdistributiondatasource

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement3d):
				self._position = ifcaxis2placement3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def colourappearance():
		def fget( self ):
			return self._colourappearance
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourrgb):
					self._colourappearance = ifccolourrgb(value)
				else:
					self._colourappearance = value
			else:
				self._colourappearance = value
		return property(**locals())

	@apply
	def colourtemperature():
		def fget( self ):
			return self._colourtemperature
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument colourtemperature is mantatory and can not be set to None')
			if not check_type(value,ifcthermodynamictemperaturemeasure):
				self._colourtemperature = ifcthermodynamictemperaturemeasure(value)
			else:
				self._colourtemperature = value
		return property(**locals())

	@apply
	def luminousflux():
		def fget( self ):
			return self._luminousflux
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument luminousflux is mantatory and can not be set to None')
			if not check_type(value,ifcluminousfluxmeasure):
				self._luminousflux = ifcluminousfluxmeasure(value)
			else:
				self._luminousflux = value
		return property(**locals())

	@apply
	def lightemissionsource():
		def fget( self ):
			return self._lightemissionsource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lightemissionsource is mantatory and can not be set to None')
			if not check_type(value,ifclightemissionsourceenum):
				self._lightemissionsource = ifclightemissionsourceenum(value)
			else:
				self._lightemissionsource = value
		return property(**locals())

	@apply
	def lightdistributiondatasource():
		def fget( self ):
			return self._lightdistributiondatasource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lightdistributiondatasource is mantatory and can not be set to None')
			if not check_type(value,ifclightdistributiondatasourceselect):
				self._lightdistributiondatasource = ifclightdistributiondatasourceselect(value)
			else:
				self._lightdistributiondatasource = value
		return property(**locals())

####################
 # ENTITY ifcsensortype #
####################
class ifcsensortype(ifcdistributioncontrolelementtype):
	'''Entity ifcsensortype definition.

	:param predefinedtype
	:type predefinedtype:ifcsensortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcsensortypeenum):
				self._predefinedtype = ifcsensortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcsensortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcsensortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcrelassignstoactor #
####################
class ifcrelassignstoactor(ifcrelassigns):
	'''Entity ifcrelassignstoactor definition.

	:param relatingactor
	:type relatingactor:ifcactor

	:param actingrole
	:type actingrole:ifcactorrole
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatingactor,actingrole, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatingactor = relatingactor
		self.actingrole = actingrole

	@apply
	def relatingactor():
		def fget( self ):
			return self._relatingactor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingactor is mantatory and can not be set to None')
			if not check_type(value,ifcactor):
				self._relatingactor = ifcactor(value)
			else:
				self._relatingactor = value
		return property(**locals())

	@apply
	def actingrole():
		def fget( self ):
			return self._actingrole
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorrole):
					self._actingrole = ifcactorrole(value)
				else:
					self._actingrole = value
			else:
				self._actingrole = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (SIZEOF(None)  ==  0)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr


####################
 # ENTITY ifcstructuralplanaraction #
####################
class ifcstructuralplanaraction(ifcstructuralsurfaceaction):
	'''Entity ifcstructuralplanaraction definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__projectedortrue , inherited11__predefinedtype ,  ):
		ifcstructuralsurfaceaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__projectedortrue , inherited11__predefinedtype , )
	def suitableloadtype(self):
		eval_suitableloadtype_wr = (SIZEOF(['IFC4.IFCSTRUCTURALLOADPLANARFORCE','IFC4.IFCSTRUCTURALLOADTEMPERATURE']  *  TYPEOF(self.self.ifcstructuralactivity.self.appliedload))  ==  1)
		if not eval_suitableloadtype_wr:
			raise AssertionError('Rule suitableloadtype violated')
		else:
			return eval_suitableloadtype_wr

	def constpredefinedtype(self):
		eval_constpredefinedtype_wr = (self.self.ifcstructuralsurfaceaction.self.predefinedtype  ==  ifcstructuralsurfaceactivitytypeenum.self.const)
		if not eval_constpredefinedtype_wr:
			raise AssertionError('Rule constpredefinedtype violated')
		else:
			return eval_constpredefinedtype_wr


####################
 # ENTITY ifccylindricalsurface #
####################
class ifccylindricalsurface(ifcelementarysurface):
	'''Entity ifccylindricalsurface definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , radius, ):
		ifcelementarysurface.__init__(self , inherited0__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY ifcpipesegment #
####################
class ifcpipesegment(ifcflowsegment):
	'''Entity ifcpipesegment definition.

	:param predefinedtype
	:type predefinedtype:ifcpipesegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowsegment.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpipesegmenttypeenum):
					self._predefinedtype = ifcpipesegmenttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcpipesegmenttypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcpipesegmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCPIPESEGMENTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcslippageconnectioncondition #
####################
class ifcslippageconnectioncondition(ifcstructuralconnectioncondition):
	'''Entity ifcslippageconnectioncondition definition.

	:param slippagex
	:type slippagex:ifclengthmeasure

	:param slippagey
	:type slippagey:ifclengthmeasure

	:param slippagez
	:type slippagez:ifclengthmeasure
	'''
	def __init__( self , inherited0__name , slippagex,slippagey,slippagez, ):
		ifcstructuralconnectioncondition.__init__(self , inherited0__name , )
		self.slippagex = slippagex
		self.slippagey = slippagey
		self.slippagez = slippagez

	@apply
	def slippagex():
		def fget( self ):
			return self._slippagex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._slippagex = ifclengthmeasure(value)
				else:
					self._slippagex = value
			else:
				self._slippagex = value
		return property(**locals())

	@apply
	def slippagey():
		def fget( self ):
			return self._slippagey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._slippagey = ifclengthmeasure(value)
				else:
					self._slippagey = value
			else:
				self._slippagey = value
		return property(**locals())

	@apply
	def slippagez():
		def fget( self ):
			return self._slippagez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._slippagez = ifclengthmeasure(value)
				else:
					self._slippagez = value
			else:
				self._slippagez = value
		return property(**locals())

####################
 # ENTITY ifcstructuralresultgroup #
####################
class ifcstructuralresultgroup(ifcgroup):
	'''Entity ifcstructuralresultgroup definition.

	:param theorytype
	:type theorytype:ifcanalysistheorytypeenum

	:param resultforloadgroup
	:type resultforloadgroup:ifcstructuralloadgroup

	:param islinear
	:type islinear:BOOLEAN

	:param resultgroupfor
	:type resultgroupfor:SET(0,1,'ifcstructuralanalysismodel', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , theorytype,resultforloadgroup,islinear, ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.theorytype = theorytype
		self.resultforloadgroup = resultforloadgroup
		self.islinear = islinear

	@apply
	def theorytype():
		def fget( self ):
			return self._theorytype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument theorytype is mantatory and can not be set to None')
			if not check_type(value,ifcanalysistheorytypeenum):
				self._theorytype = ifcanalysistheorytypeenum(value)
			else:
				self._theorytype = value
		return property(**locals())

	@apply
	def resultforloadgroup():
		def fget( self ):
			return self._resultforloadgroup
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcstructuralloadgroup):
					self._resultforloadgroup = ifcstructuralloadgroup(value)
				else:
					self._resultforloadgroup = value
			else:
				self._resultforloadgroup = value
		return property(**locals())

	@apply
	def islinear():
		def fget( self ):
			return self._islinear
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument islinear is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._islinear = BOOLEAN(value)
			else:
				self._islinear = value
		return property(**locals())

	@apply
	def resultgroupfor():
		def fget( self ):
			return self._resultgroupfor
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument resultgroupfor is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def hasobjecttype(self):
		eval_hasobjecttype_wr = ((self.theorytype  !=  ifcanalysistheorytypeenum.self.userdefined)  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_hasobjecttype_wr:
			raise AssertionError('Rule hasobjecttype violated')
		else:
			return eval_hasobjecttype_wr


####################
 # ENTITY ifctopologyrepresentation #
####################
class ifctopologyrepresentation(ifcshapemodel):
	'''Entity ifctopologyrepresentation definition.
	'''
	def __init__( self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items ,  ):
		ifcshapemodel.__init__(self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items , )
	def wr21(self):
		eval_wr21_wr = (SIZEOF(None)  ==  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = EXISTS(self.self.ifcrepresentation.self.representationtype)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr

	def wr23(self):
		eval_wr23_wr = ifctopologyrepresentationtypes(self.self.ifcrepresentation.self.representationtype,self.self.ifcrepresentation.self.items)
		if not eval_wr23_wr:
			raise AssertionError('Rule wr23 violated')
		else:
			return eval_wr23_wr


####################
 # ENTITY ifcblock #
####################
class ifcblock(ifccsgprimitive3d):
	'''Entity ifcblock definition.

	:param xlength
	:type xlength:ifcpositivelengthmeasure

	:param ylength
	:type ylength:ifcpositivelengthmeasure

	:param zlength
	:type zlength:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , xlength,ylength,zlength, ):
		ifccsgprimitive3d.__init__(self , inherited0__position , )
		self.xlength = xlength
		self.ylength = ylength
		self.zlength = zlength

	@apply
	def xlength():
		def fget( self ):
			return self._xlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument xlength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._xlength = ifcpositivelengthmeasure(value)
			else:
				self._xlength = value
		return property(**locals())

	@apply
	def ylength():
		def fget( self ):
			return self._ylength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ylength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._ylength = ifcpositivelengthmeasure(value)
			else:
				self._ylength = value
		return property(**locals())

	@apply
	def zlength():
		def fget( self ):
			return self._zlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zlength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._zlength = ifcpositivelengthmeasure(value)
			else:
				self._zlength = value
		return property(**locals())

####################
 # ENTITY ifcconnectionpointgeometry #
####################
class ifcconnectionpointgeometry(ifcconnectiongeometry):
	'''Entity ifcconnectionpointgeometry definition.

	:param pointonrelatingelement
	:type pointonrelatingelement:ifcpointorvertexpoint

	:param pointonrelatedelement
	:type pointonrelatedelement:ifcpointorvertexpoint
	'''
	def __init__( self , pointonrelatingelement,pointonrelatedelement, ):
		ifcconnectiongeometry.__init__(self , )
		self.pointonrelatingelement = pointonrelatingelement
		self.pointonrelatedelement = pointonrelatedelement

	@apply
	def pointonrelatingelement():
		def fget( self ):
			return self._pointonrelatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pointonrelatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcpointorvertexpoint):
				self._pointonrelatingelement = ifcpointorvertexpoint(value)
			else:
				self._pointonrelatingelement = value
		return property(**locals())

	@apply
	def pointonrelatedelement():
		def fget( self ):
			return self._pointonrelatedelement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpointorvertexpoint):
					self._pointonrelatedelement = ifcpointorvertexpoint(value)
				else:
					self._pointonrelatedelement = value
			else:
				self._pointonrelatedelement = value
		return property(**locals())

####################
 # ENTITY ifcconnectionpointeccentricity #
####################
class ifcconnectionpointeccentricity(ifcconnectionpointgeometry):
	'''Entity ifcconnectionpointeccentricity definition.

	:param eccentricityinx
	:type eccentricityinx:ifclengthmeasure

	:param eccentricityiny
	:type eccentricityiny:ifclengthmeasure

	:param eccentricityinz
	:type eccentricityinz:ifclengthmeasure
	'''
	def __init__( self , inherited0__pointonrelatingelement , inherited1__pointonrelatedelement , eccentricityinx,eccentricityiny,eccentricityinz, ):
		ifcconnectionpointgeometry.__init__(self , inherited0__pointonrelatingelement , inherited1__pointonrelatedelement , )
		self.eccentricityinx = eccentricityinx
		self.eccentricityiny = eccentricityiny
		self.eccentricityinz = eccentricityinz

	@apply
	def eccentricityinx():
		def fget( self ):
			return self._eccentricityinx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._eccentricityinx = ifclengthmeasure(value)
				else:
					self._eccentricityinx = value
			else:
				self._eccentricityinx = value
		return property(**locals())

	@apply
	def eccentricityiny():
		def fget( self ):
			return self._eccentricityiny
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._eccentricityiny = ifclengthmeasure(value)
				else:
					self._eccentricityiny = value
			else:
				self._eccentricityiny = value
		return property(**locals())

	@apply
	def eccentricityinz():
		def fget( self ):
			return self._eccentricityinz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._eccentricityinz = ifclengthmeasure(value)
				else:
					self._eccentricityinz = value
			else:
				self._eccentricityinz = value
		return property(**locals())

####################
 # ENTITY ifcouterboundarycurve #
####################
class ifcouterboundarycurve(ifcboundarycurve):
	'''Entity ifcouterboundarycurve definition.
	'''
	def __init__( self , inherited0__segments , inherited1__selfintersect ,  ):
		ifcboundarycurve.__init__(self , inherited0__segments , inherited1__selfintersect , )

####################
 # ENTITY ifcedgeloop #
####################
class ifcedgeloop(ifcloop):
	'''Entity ifcedgeloop definition.

	:param edgelist
	:type edgelist:LIST(1,None,'ifcorientededge', scope = schema_scope)

	:param ne
	:type ne:INTEGER
	'''
	def __init__( self , edgelist, ):
		ifcloop.__init__(self , )
		self.edgelist = edgelist

	@apply
	def edgelist():
		def fget( self ):
			return self._edgelist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgelist is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcorientededge', scope = schema_scope)):
				self._edgelist = LIST(value)
			else:
				self._edgelist = value
		return property(**locals())

	@apply
	def ne():
		def fget( self ):
			attribute_eval = SIZEOF(self.edgelist)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ne is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def isclosed(self):
		eval_isclosed_wr = (self.edgelist[1].self.edgestart  ==  self.edgelist[self.ne].self.edgeend)
		if not eval_isclosed_wr:
			raise AssertionError('Rule isclosed violated')
		else:
			return eval_isclosed_wr

	def iscontinuous(self):
		eval_iscontinuous_wr = ifcloopheadtotail(self)
		if not eval_iscontinuous_wr:
			raise AssertionError('Rule iscontinuous violated')
		else:
			return eval_iscontinuous_wr


####################
 # ENTITY ifcrelservicesbuildings #
####################
class ifcrelservicesbuildings(ifcrelconnects):
	'''Entity ifcrelservicesbuildings definition.

	:param relatingsystem
	:type relatingsystem:ifcsystem

	:param relatedbuildings
	:type relatedbuildings:SET(1,None,'ifcspatialelement', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingsystem,relatedbuildings, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingsystem = relatingsystem
		self.relatedbuildings = relatedbuildings

	@apply
	def relatingsystem():
		def fget( self ):
			return self._relatingsystem
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingsystem is mantatory and can not be set to None')
			if not check_type(value,ifcsystem):
				self._relatingsystem = ifcsystem(value)
			else:
				self._relatingsystem = value
		return property(**locals())

	@apply
	def relatedbuildings():
		def fget( self ):
			return self._relatedbuildings
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedbuildings is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcspatialelement', scope = schema_scope)):
				self._relatedbuildings = SET(value)
			else:
				self._relatedbuildings = value
		return property(**locals())

####################
 # ENTITY ifctexturecoordinategenerator #
####################
class ifctexturecoordinategenerator(ifctexturecoordinate):
	'''Entity ifctexturecoordinategenerator definition.

	:param mode
	:type mode:ifclabel

	:param parameter
	:type parameter:LIST(1,None,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__maps , mode,parameter, ):
		ifctexturecoordinate.__init__(self , inherited0__maps , )
		self.mode = mode
		self.parameter = parameter

	@apply
	def mode():
		def fget( self ):
			return self._mode
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mode is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._mode = ifclabel(value)
			else:
				self._mode = value
		return property(**locals())

	@apply
	def parameter():
		def fget( self ):
			return self._parameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'REAL', scope = schema_scope)):
					self._parameter = LIST(value)
				else:
					self._parameter = value
			else:
				self._parameter = value
		return property(**locals())

####################
 # ENTITY ifccablecarrierfittingtype #
####################
class ifccablecarrierfittingtype(ifcflowfittingtype):
	'''Entity ifccablecarrierfittingtype definition.

	:param predefinedtype
	:type predefinedtype:ifccablecarrierfittingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowfittingtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccablecarrierfittingtypeenum):
				self._predefinedtype = ifccablecarrierfittingtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccablecarrierfittingtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccablecarrierfittingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcelementassemblytype #
####################
class ifcelementassemblytype(ifcelementtype):
	'''Entity ifcelementassemblytype definition.

	:param predefinedtype
	:type predefinedtype:ifcelementassemblytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelementassemblytypeenum):
				self._predefinedtype = ifcelementassemblytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcelementassemblytypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcelementassemblytypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcductfittingtype #
####################
class ifcductfittingtype(ifcflowfittingtype):
	'''Entity ifcductfittingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcductfittingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowfittingtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcductfittingtypeenum):
				self._predefinedtype = ifcductfittingtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcductfittingtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcductfittingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifclocalplacement #
####################
class ifclocalplacement(ifcobjectplacement):
	'''Entity ifclocalplacement definition.

	:param placementrelto
	:type placementrelto:ifcobjectplacement

	:param relativeplacement
	:type relativeplacement:ifcaxis2placement
	'''
	def __init__( self , placementrelto,relativeplacement, ):
		ifcobjectplacement.__init__(self , )
		self.placementrelto = placementrelto
		self.relativeplacement = relativeplacement

	@apply
	def placementrelto():
		def fget( self ):
			return self._placementrelto
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcobjectplacement):
					self._placementrelto = ifcobjectplacement(value)
				else:
					self._placementrelto = value
			else:
				self._placementrelto = value
		return property(**locals())

	@apply
	def relativeplacement():
		def fget( self ):
			return self._relativeplacement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relativeplacement is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._relativeplacement = ifcaxis2placement(value)
			else:
				self._relativeplacement = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = ifccorrectlocalplacement(self.relativeplacement,self.placementrelto)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcpropertyset #
####################
class ifcpropertyset(ifcpropertysetdefinition):
	'''Entity ifcpropertyset definition.

	:param hasproperties
	:type hasproperties:SET(1,None,'ifcproperty', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , hasproperties, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.hasproperties = hasproperties

	@apply
	def hasproperties():
		def fget( self ):
			return self._hasproperties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hasproperties is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproperty', scope = schema_scope)):
				self._hasproperties = SET(value)
			else:
				self._hasproperties = value
		return property(**locals())
	def existsname(self):
		eval_existsname_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_existsname_wr:
			raise AssertionError('Rule existsname violated')
		else:
			return eval_existsname_wr

	def uniquepropertynames(self):
		eval_uniquepropertynames_wr = ifcuniquepropertyname(self.hasproperties)
		if not eval_uniquepropertynames_wr:
			raise AssertionError('Rule uniquepropertynames violated')
		else:
			return eval_uniquepropertynames_wr


####################
 # ENTITY ifcstructuralcurvemembervarying #
####################
class ifcstructuralcurvemembervarying(ifcstructuralcurvemember):
	'''Entity ifcstructuralcurvemembervarying definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__predefinedtype , inherited8__axis ,  ):
		ifcstructuralcurvemember.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__predefinedtype , inherited8__axis , )

####################
 # ENTITY ifcunitaryequipmenttype #
####################
class ifcunitaryequipmenttype(ifcenergyconversiondevicetype):
	'''Entity ifcunitaryequipmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcunitaryequipmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcunitaryequipmenttypeenum):
				self._predefinedtype = ifcunitaryequipmenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcunitaryequipmenttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcunitaryequipmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifczone #
####################
class ifczone(ifcsystem):
	'''Entity ifczone definition.

	:param longname
	:type longname:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , longname, ):
		ifcsystem.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.longname = longname

	@apply
	def longname():
		def fget( self ):
			return self._longname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._longname = ifclabel(value)
				else:
					self._longname = value
			else:
				self._longname = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.self.ifcgroup.self.isgroupedby)  ==  0)  or  (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcrelprojectselement #
####################
class ifcrelprojectselement(ifcreldecomposes):
	'''Entity ifcrelprojectselement definition.

	:param relatingelement
	:type relatingelement:ifcelement

	:param relatedfeatureelement
	:type relatedfeatureelement:ifcfeatureelementaddition
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingelement,relatedfeatureelement, ):
		ifcreldecomposes.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingelement = relatingelement
		self.relatedfeatureelement = relatedfeatureelement

	@apply
	def relatingelement():
		def fget( self ):
			return self._relatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatingelement = ifcelement(value)
			else:
				self._relatingelement = value
		return property(**locals())

	@apply
	def relatedfeatureelement():
		def fget( self ):
			return self._relatedfeatureelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedfeatureelement is mantatory and can not be set to None')
			if not check_type(value,ifcfeatureelementaddition):
				self._relatedfeatureelement = ifcfeatureelementaddition(value)
			else:
				self._relatedfeatureelement = value
		return property(**locals())

####################
 # ENTITY ifcburnertype #
####################
class ifcburnertype(ifcenergyconversiondevicetype):
	'''Entity ifcburnertype definition.

	:param predefinedtype
	:type predefinedtype:ifcburnertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcburnertypeenum):
				self._predefinedtype = ifcburnertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcburnertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcburnertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcmotorconnection #
####################
class ifcmotorconnection(ifcenergyconversiondevice):
	'''Entity ifcmotorconnection definition.

	:param predefinedtype
	:type predefinedtype:ifcmotorconnectiontypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmotorconnectiontypeenum):
					self._predefinedtype = ifcmotorconnectiontypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcmotorconnectiontypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcmotorconnectiontypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCMOTORCONNECTIONTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcopeningelement #
####################
class ifcopeningelement(ifcfeatureelementsubtraction):
	'''Entity ifcopeningelement definition.

	:param predefinedtype
	:type predefinedtype:ifcopeningelementtypeenum

	:param hasfillings
	:type hasfillings:SET(0,None,'ifcrelfillselement', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcfeatureelementsubtraction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcopeningelementtypeenum):
					self._predefinedtype = ifcopeningelementtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def hasfillings():
		def fget( self ):
			return self._hasfillings
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasfillings is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcopeningstandardcase #
####################
class ifcopeningstandardcase(ifcopeningelement):
	'''Entity ifcopeningstandardcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype ,  ):
		ifcopeningelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__predefinedtype , )

####################
 # ENTITY ifctanktype #
####################
class ifctanktype(ifcflowstoragedevicetype):
	'''Entity ifctanktype definition.

	:param predefinedtype
	:type predefinedtype:ifctanktypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowstoragedevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctanktypeenum):
				self._predefinedtype = ifctanktypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifctanktypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifctanktypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcchimneytype #
####################
class ifcchimneytype(ifcbuildingelementtype):
	'''Entity ifcchimneytype definition.

	:param predefinedtype
	:type predefinedtype:ifcchimneytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcchimneytypeenum):
				self._predefinedtype = ifcchimneytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcchimneytypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcchimneytypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcwindowstyle #
####################
class ifcwindowstyle(ifctypeproduct):
	'''Entity ifcwindowstyle definition.

	:param constructiontype
	:type constructiontype:ifcwindowstyleconstructionenum

	:param operationtype
	:type operationtype:ifcwindowstyleoperationenum

	:param parametertakesprecedence
	:type parametertakesprecedence:BOOLEAN

	:param sizeable
	:type sizeable:BOOLEAN
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , constructiontype,operationtype,parametertakesprecedence,sizeable, ):
		ifctypeproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , )
		self.constructiontype = constructiontype
		self.operationtype = operationtype
		self.parametertakesprecedence = parametertakesprecedence
		self.sizeable = sizeable

	@apply
	def constructiontype():
		def fget( self ):
			return self._constructiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constructiontype is mantatory and can not be set to None')
			if not check_type(value,ifcwindowstyleconstructionenum):
				self._constructiontype = ifcwindowstyleconstructionenum(value)
			else:
				self._constructiontype = value
		return property(**locals())

	@apply
	def operationtype():
		def fget( self ):
			return self._operationtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operationtype is mantatory and can not be set to None')
			if not check_type(value,ifcwindowstyleoperationenum):
				self._operationtype = ifcwindowstyleoperationenum(value)
			else:
				self._operationtype = value
		return property(**locals())

	@apply
	def parametertakesprecedence():
		def fget( self ):
			return self._parametertakesprecedence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parametertakesprecedence is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._parametertakesprecedence = BOOLEAN(value)
			else:
				self._parametertakesprecedence = value
		return property(**locals())

	@apply
	def sizeable():
		def fget( self ):
			return self._sizeable
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sizeable is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._sizeable = BOOLEAN(value)
			else:
				self._sizeable = value
		return property(**locals())

####################
 # ENTITY ifcworkschedule #
####################
class ifcworkschedule(ifcworkcontrol):
	'''Entity ifcworkschedule definition.

	:param predefinedtype
	:type predefinedtype:ifcworkscheduletypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__creationdate , inherited7__creators , inherited8__purpose , inherited9__duration , inherited10__totalfloat , inherited11__starttime , inherited12__finishtime , predefinedtype, ):
		ifcworkcontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identification , inherited6__creationdate , inherited7__creators , inherited8__purpose , inherited9__duration , inherited10__totalfloat , inherited11__starttime , inherited12__finishtime , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcworkscheduletypeenum):
					self._predefinedtype = ifcworkscheduletypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcworkscheduletypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcworkscheduletypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcboundaryfacecondition #
####################
class ifcboundaryfacecondition(ifcboundarycondition):
	'''Entity ifcboundaryfacecondition definition.

	:param translationalstiffnessbyareax
	:type translationalstiffnessbyareax:ifcmodulusofsubgradereactionselect

	:param translationalstiffnessbyareay
	:type translationalstiffnessbyareay:ifcmodulusofsubgradereactionselect

	:param translationalstiffnessbyareaz
	:type translationalstiffnessbyareaz:ifcmodulusofsubgradereactionselect
	'''
	def __init__( self , inherited0__name , translationalstiffnessbyareax,translationalstiffnessbyareay,translationalstiffnessbyareaz, ):
		ifcboundarycondition.__init__(self , inherited0__name , )
		self.translationalstiffnessbyareax = translationalstiffnessbyareax
		self.translationalstiffnessbyareay = translationalstiffnessbyareay
		self.translationalstiffnessbyareaz = translationalstiffnessbyareaz

	@apply
	def translationalstiffnessbyareax():
		def fget( self ):
			return self._translationalstiffnessbyareax
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofsubgradereactionselect):
					self._translationalstiffnessbyareax = ifcmodulusofsubgradereactionselect(value)
				else:
					self._translationalstiffnessbyareax = value
			else:
				self._translationalstiffnessbyareax = value
		return property(**locals())

	@apply
	def translationalstiffnessbyareay():
		def fget( self ):
			return self._translationalstiffnessbyareay
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofsubgradereactionselect):
					self._translationalstiffnessbyareay = ifcmodulusofsubgradereactionselect(value)
				else:
					self._translationalstiffnessbyareay = value
			else:
				self._translationalstiffnessbyareay = value
		return property(**locals())

	@apply
	def translationalstiffnessbyareaz():
		def fget( self ):
			return self._translationalstiffnessbyareaz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofsubgradereactionselect):
					self._translationalstiffnessbyareaz = ifcmodulusofsubgradereactionselect(value)
				else:
					self._translationalstiffnessbyareaz = value
			else:
				self._translationalstiffnessbyareaz = value
		return property(**locals())

####################
 # ENTITY ifcbuildingsystem #
####################
class ifcbuildingsystem(ifcsystem):
	'''Entity ifcbuildingsystem definition.

	:param predefinedtype
	:type predefinedtype:ifcbuildingsystemtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , predefinedtype, ):
		ifcsystem.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcbuildingsystemtypeenum):
					self._predefinedtype = ifcbuildingsystemtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifccompositeprofiledef #
####################
class ifccompositeprofiledef(ifcprofiledef):
	'''Entity ifccompositeprofiledef definition.

	:param profiles
	:type profiles:SET(2,None,'ifcprofiledef', scope = schema_scope)

	:param label
	:type label:ifclabel
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , profiles,label, ):
		ifcprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , )
		self.profiles = profiles
		self.label = label

	@apply
	def profiles():
		def fget( self ):
			return self._profiles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument profiles is mantatory and can not be set to None')
			if not check_type(value,SET(2,None,'ifcprofiledef', scope = schema_scope)):
				self._profiles = SET(value)
			else:
				self._profiles = value
		return property(**locals())

	@apply
	def label():
		def fget( self ):
			return self._label
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._label = ifclabel(value)
				else:
					self._label = value
			else:
				self._label = value
		return property(**locals())
	def invariantprofiletype(self):
		eval_invariantprofiletype_wr = (SIZEOF(None)  ==  0)
		if not eval_invariantprofiletype_wr:
			raise AssertionError('Rule invariantprofiletype violated')
		else:
			return eval_invariantprofiletype_wr

	def norecursion(self):
		eval_norecursion_wr = (SIZEOF(None)  ==  0)
		if not eval_norecursion_wr:
			raise AssertionError('Rule norecursion violated')
		else:
			return eval_norecursion_wr


####################
 # ENTITY ifcductsegment #
####################
class ifcductsegment(ifcflowsegment):
	'''Entity ifcductsegment definition.

	:param predefinedtype
	:type predefinedtype:ifcductsegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcflowsegment.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcductsegmenttypeenum):
					self._predefinedtype = ifcductsegmenttypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcductsegmenttypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcductsegmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCDUCTSEGMENTTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcasset #
####################
class ifcasset(ifcgroup):
	'''Entity ifcasset definition.

	:param identification
	:type identification:ifcidentifier

	:param originalvalue
	:type originalvalue:ifccostvalue

	:param currentvalue
	:type currentvalue:ifccostvalue

	:param totalreplacementcost
	:type totalreplacementcost:ifccostvalue

	:param owner
	:type owner:ifcactorselect

	:param user
	:type user:ifcactorselect

	:param responsibleperson
	:type responsibleperson:ifcperson

	:param incorporationdate
	:type incorporationdate:ifcdate

	:param depreciatedvalue
	:type depreciatedvalue:ifccostvalue
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , identification,originalvalue,currentvalue,totalreplacementcost,owner,user,responsibleperson,incorporationdate,depreciatedvalue, ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.identification = identification
		self.originalvalue = originalvalue
		self.currentvalue = currentvalue
		self.totalreplacementcost = totalreplacementcost
		self.owner = owner
		self.user = user
		self.responsibleperson = responsibleperson
		self.incorporationdate = incorporationdate
		self.depreciatedvalue = depreciatedvalue

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identification = ifcidentifier(value)
				else:
					self._identification = value
			else:
				self._identification = value
		return property(**locals())

	@apply
	def originalvalue():
		def fget( self ):
			return self._originalvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccostvalue):
					self._originalvalue = ifccostvalue(value)
				else:
					self._originalvalue = value
			else:
				self._originalvalue = value
		return property(**locals())

	@apply
	def currentvalue():
		def fget( self ):
			return self._currentvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccostvalue):
					self._currentvalue = ifccostvalue(value)
				else:
					self._currentvalue = value
			else:
				self._currentvalue = value
		return property(**locals())

	@apply
	def totalreplacementcost():
		def fget( self ):
			return self._totalreplacementcost
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccostvalue):
					self._totalreplacementcost = ifccostvalue(value)
				else:
					self._totalreplacementcost = value
			else:
				self._totalreplacementcost = value
		return property(**locals())

	@apply
	def owner():
		def fget( self ):
			return self._owner
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._owner = ifcactorselect(value)
				else:
					self._owner = value
			else:
				self._owner = value
		return property(**locals())

	@apply
	def user():
		def fget( self ):
			return self._user
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._user = ifcactorselect(value)
				else:
					self._user = value
			else:
				self._user = value
		return property(**locals())

	@apply
	def responsibleperson():
		def fget( self ):
			return self._responsibleperson
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcperson):
					self._responsibleperson = ifcperson(value)
				else:
					self._responsibleperson = value
			else:
				self._responsibleperson = value
		return property(**locals())

	@apply
	def incorporationdate():
		def fget( self ):
			return self._incorporationdate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdate):
					self._incorporationdate = ifcdate(value)
				else:
					self._incorporationdate = value
			else:
				self._incorporationdate = value
		return property(**locals())

	@apply
	def depreciatedvalue():
		def fget( self ):
			return self._depreciatedvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccostvalue):
					self._depreciatedvalue = ifccostvalue(value)
				else:
					self._depreciatedvalue = value
			else:
				self._depreciatedvalue = value
		return property(**locals())

####################
 # ENTITY ifcirregulartimeseries #
####################
class ifcirregulartimeseries(ifctimeseries):
	'''Entity ifcirregulartimeseries definition.

	:param values
	:type values:LIST(1,None,'ifcirregulartimeseriesvalue', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__starttime , inherited3__endtime , inherited4__timeseriesdatatype , inherited5__dataorigin , inherited6__userdefineddataorigin , inherited7__unit , values, ):
		ifctimeseries.__init__(self , inherited0__name , inherited1__description , inherited2__starttime , inherited3__endtime , inherited4__timeseriesdatatype , inherited5__dataorigin , inherited6__userdefineddataorigin , inherited7__unit , )
		self.values = values

	@apply
	def values():
		def fget( self ):
			return self._values
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument values is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcirregulartimeseriesvalue', scope = schema_scope)):
				self._values = LIST(value)
			else:
				self._values = value
		return property(**locals())

####################
 # ENTITY ifcblobtexture #
####################
class ifcblobtexture(ifcsurfacetexture):
	'''Entity ifcblobtexture definition.

	:param rasterformat
	:type rasterformat:ifcidentifier

	:param rastercode
	:type rastercode:(null)
	'''
	def __init__( self , inherited0__repeats , inherited1__repeatt , inherited2__mode , inherited3__texturetransform , inherited4__parameter , rasterformat,rastercode, ):
		ifcsurfacetexture.__init__(self , inherited0__repeats , inherited1__repeatt , inherited2__mode , inherited3__texturetransform , inherited4__parameter , )
		self.rasterformat = rasterformat
		self.rastercode = rastercode

	@apply
	def rasterformat():
		def fget( self ):
			return self._rasterformat
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rasterformat is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._rasterformat = ifcidentifier(value)
			else:
				self._rasterformat = value
		return property(**locals())

	@apply
	def rastercode():
		def fget( self ):
			return self._rastercode
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rastercode is mantatory and can not be set to None')
			if not check_type(value,(null)):
				self._rastercode = (null)(value)
			else:
				self._rastercode = value
		return property(**locals())
	def supportedrasterformat(self):
		eval_supportedrasterformat_wr = (self.self.rasterformat  ==  ['BMP','JPG','GIF','PNG'])
		if not eval_supportedrasterformat_wr:
			raise AssertionError('Rule supportedrasterformat violated')
		else:
			return eval_supportedrasterformat_wr

	def rastercodebytestream(self):
		eval_rastercodebytestream_wr = ((BLENGTH(self.rastercode)  %  8)  ==  0)
		if not eval_rastercodebytestream_wr:
			raise AssertionError('Rule rastercodebytestream violated')
		else:
			return eval_rastercodebytestream_wr


####################
 # ENTITY ifclightintensitydistribution #
####################
class ifclightintensitydistribution(BaseEntityClass):
	'''Entity ifclightintensitydistribution definition.

	:param lightdistributioncurve
	:type lightdistributioncurve:ifclightdistributioncurveenum

	:param distributiondata
	:type distributiondata:LIST(1,None,'ifclightdistributiondata', scope = schema_scope)
	'''
	def __init__( self , lightdistributioncurve,distributiondata, ):
		self.lightdistributioncurve = lightdistributioncurve
		self.distributiondata = distributiondata

	@apply
	def lightdistributioncurve():
		def fget( self ):
			return self._lightdistributioncurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lightdistributioncurve is mantatory and can not be set to None')
			if not check_type(value,ifclightdistributioncurveenum):
				self._lightdistributioncurve = ifclightdistributioncurveenum(value)
			else:
				self._lightdistributioncurve = value
		return property(**locals())

	@apply
	def distributiondata():
		def fget( self ):
			return self._distributiondata
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distributiondata is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifclightdistributiondata', scope = schema_scope)):
				self._distributiondata = LIST(value)
			else:
				self._distributiondata = value
		return property(**locals())

####################
 # ENTITY ifccurveboundedsurface #
####################
class ifccurveboundedsurface(ifcboundedsurface):
	'''Entity ifccurveboundedsurface definition.

	:param basissurface
	:type basissurface:ifcsurface

	:param boundaries
	:type boundaries:SET(1,None,'ifcboundarycurve', scope = schema_scope)

	:param implicitouter
	:type implicitouter:BOOLEAN
	'''
	def __init__( self , basissurface,boundaries,implicitouter, ):
		ifcboundedsurface.__init__(self , )
		self.basissurface = basissurface
		self.boundaries = boundaries
		self.implicitouter = implicitouter

	@apply
	def basissurface():
		def fget( self ):
			return self._basissurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basissurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._basissurface = ifcsurface(value)
			else:
				self._basissurface = value
		return property(**locals())

	@apply
	def boundaries():
		def fget( self ):
			return self._boundaries
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument boundaries is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcboundarycurve', scope = schema_scope)):
				self._boundaries = SET(value)
			else:
				self._boundaries = value
		return property(**locals())

	@apply
	def implicitouter():
		def fget( self ):
			return self._implicitouter
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument implicitouter is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._implicitouter = BOOLEAN(value)
			else:
				self._implicitouter = value
		return property(**locals())

####################
 # ENTITY ifcgrid #
####################
class ifcgrid(ifcproduct):
	'''Entity ifcgrid definition.

	:param uaxes
	:type uaxes:LIST(1,None,'ifcgridaxis', scope = schema_scope)

	:param vaxes
	:type vaxes:LIST(1,None,'ifcgridaxis', scope = schema_scope)

	:param waxes
	:type waxes:LIST(1,None,'ifcgridaxis', scope = schema_scope)

	:param predefinedtype
	:type predefinedtype:ifcgridtypeenum

	:param containedinstructure
	:type containedinstructure:SET(0,1,'ifcrelcontainedinspatialstructure', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , uaxes,vaxes,waxes,predefinedtype, ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.uaxes = uaxes
		self.vaxes = vaxes
		self.waxes = waxes
		self.predefinedtype = predefinedtype

	@apply
	def uaxes():
		def fget( self ):
			return self._uaxes
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uaxes is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcgridaxis', scope = schema_scope)):
				self._uaxes = LIST(value)
			else:
				self._uaxes = value
		return property(**locals())

	@apply
	def vaxes():
		def fget( self ):
			return self._vaxes
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vaxes is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcgridaxis', scope = schema_scope)):
				self._vaxes = LIST(value)
			else:
				self._vaxes = value
		return property(**locals())

	@apply
	def waxes():
		def fget( self ):
			return self._waxes
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcgridaxis', scope = schema_scope)):
					self._waxes = LIST(value)
				else:
					self._waxes = value
			else:
				self._waxes = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcgridtypeenum):
					self._predefinedtype = ifcgridtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def containedinstructure():
		def fget( self ):
			return self._containedinstructure
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument containedinstructure is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def hasplacement(self):
		eval_hasplacement_wr = EXISTS(self.self.ifcproduct.self.objectplacement)
		if not eval_hasplacement_wr:
			raise AssertionError('Rule hasplacement violated')
		else:
			return eval_hasplacement_wr


####################
 # ENTITY ifcmechanicalfastener #
####################
class ifcmechanicalfastener(ifcelementcomponent):
	'''Entity ifcmechanicalfastener definition.

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param nominallength
	:type nominallength:ifcpositivelengthmeasure

	:param predefinedtype
	:type predefinedtype:ifcmechanicalfastenertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , nominaldiameter,nominallength,predefinedtype, ):
		ifcelementcomponent.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.nominaldiameter = nominaldiameter
		self.nominallength = nominallength
		self.predefinedtype = predefinedtype

	@apply
	def nominaldiameter():
		def fget( self ):
			return self._nominaldiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominaldiameter = ifcpositivelengthmeasure(value)
				else:
					self._nominaldiameter = value
			else:
				self._nominaldiameter = value
		return property(**locals())

	@apply
	def nominallength():
		def fget( self ):
			return self._nominallength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominallength = ifcpositivelengthmeasure(value)
				else:
					self._nominallength = value
			else:
				self._nominallength = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmechanicalfastenertypeenum):
					self._predefinedtype = ifcmechanicalfastenertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcmechanicalfastenertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcmechanicalfastenertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCMECHANICALFASTENERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcphysicalcomplexquantity #
####################
class ifcphysicalcomplexquantity(ifcphysicalquantity):
	'''Entity ifcphysicalcomplexquantity definition.

	:param hasquantities
	:type hasquantities:SET(1,None,'ifcphysicalquantity', scope = schema_scope)

	:param discrimination
	:type discrimination:ifclabel

	:param quality
	:type quality:ifclabel

	:param usage
	:type usage:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , hasquantities,discrimination,quality,usage, ):
		ifcphysicalquantity.__init__(self , inherited0__name , inherited1__description , )
		self.hasquantities = hasquantities
		self.discrimination = discrimination
		self.quality = quality
		self.usage = usage

	@apply
	def hasquantities():
		def fget( self ):
			return self._hasquantities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hasquantities is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcphysicalquantity', scope = schema_scope)):
				self._hasquantities = SET(value)
			else:
				self._hasquantities = value
		return property(**locals())

	@apply
	def discrimination():
		def fget( self ):
			return self._discrimination
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument discrimination is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._discrimination = ifclabel(value)
			else:
				self._discrimination = value
		return property(**locals())

	@apply
	def quality():
		def fget( self ):
			return self._quality
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._quality = ifclabel(value)
				else:
					self._quality = value
			else:
				self._quality = value
		return property(**locals())

	@apply
	def usage():
		def fget( self ):
			return self._usage
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._usage = ifclabel(value)
				else:
					self._usage = value
			else:
				self._usage = value
		return property(**locals())
	def noselfreference(self):
		eval_noselfreference_wr = (SIZEOF(None)  ==  0)
		if not eval_noselfreference_wr:
			raise AssertionError('Rule noselfreference violated')
		else:
			return eval_noselfreference_wr

	def uniquequantitynames(self):
		eval_uniquequantitynames_wr = ifcuniquequantitynames(self.hasquantities)
		if not eval_uniquequantitynames_wr:
			raise AssertionError('Rule uniquequantitynames violated')
		else:
			return eval_uniquequantitynames_wr


####################
 # ENTITY ifcpresentationlayerwithstyle #
####################
class ifcpresentationlayerwithstyle(ifcpresentationlayerassignment):
	'''Entity ifcpresentationlayerwithstyle definition.

	:param layeron
	:type layeron:LOGICAL

	:param layerfrozen
	:type layerfrozen:LOGICAL

	:param layerblocked
	:type layerblocked:LOGICAL

	:param layerstyles
	:type layerstyles:SET(0,None,'ifcpresentationstyle', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__assigneditems , inherited3__identifier , layeron,layerfrozen,layerblocked,layerstyles, ):
		ifcpresentationlayerassignment.__init__(self , inherited0__name , inherited1__description , inherited2__assigneditems , inherited3__identifier , )
		self.layeron = layeron
		self.layerfrozen = layerfrozen
		self.layerblocked = layerblocked
		self.layerstyles = layerstyles

	@apply
	def layeron():
		def fget( self ):
			return self._layeron
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layeron is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._layeron = LOGICAL(value)
			else:
				self._layeron = value
		return property(**locals())

	@apply
	def layerfrozen():
		def fget( self ):
			return self._layerfrozen
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layerfrozen is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._layerfrozen = LOGICAL(value)
			else:
				self._layerfrozen = value
		return property(**locals())

	@apply
	def layerblocked():
		def fget( self ):
			return self._layerblocked
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layerblocked is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._layerblocked = LOGICAL(value)
			else:
				self._layerblocked = value
		return property(**locals())

	@apply
	def layerstyles():
		def fget( self ):
			return self._layerstyles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layerstyles is mantatory and can not be set to None')
			if not check_type(value,SET(0,None,'ifcpresentationstyle', scope = schema_scope)):
				self._layerstyles = SET(value)
			else:
				self._layerstyles = value
		return property(**locals())
	def applicableonlytoitems(self):
		eval_applicableonlytoitems_wr = (SIZEOF(None)  ==  SIZEOF(self.assigneditems))
		if not eval_applicableonlytoitems_wr:
			raise AssertionError('Rule applicableonlytoitems violated')
		else:
			return eval_applicableonlytoitems_wr


####################
 # ENTITY ifcprojectlibrary #
####################
class ifcprojectlibrary(ifccontext):
	'''Entity ifcprojectlibrary definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__longname , inherited6__phase , inherited7__representationcontexts , inherited8__unitsincontext ,  ):
		ifccontext.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__longname , inherited6__phase , inherited7__representationcontexts , inherited8__unitsincontext , )

####################
 # ENTITY ifccompressortype #
####################
class ifccompressortype(ifcflowmovingdevicetype):
	'''Entity ifccompressortype definition.

	:param predefinedtype
	:type predefinedtype:ifccompressortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowmovingdevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccompressortypeenum):
				self._predefinedtype = ifccompressortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifccompressortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccompressortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifclightdistributiondata #
####################
class ifclightdistributiondata(BaseEntityClass):
	'''Entity ifclightdistributiondata definition.

	:param mainplaneangle
	:type mainplaneangle:ifcplaneanglemeasure

	:param secondaryplaneangle
	:type secondaryplaneangle:LIST(1,None,'REAL', scope = schema_scope)

	:param luminousintensity
	:type luminousintensity:LIST(1,None,'REAL', scope = schema_scope)
	'''
	def __init__( self , mainplaneangle,secondaryplaneangle,luminousintensity, ):
		self.mainplaneangle = mainplaneangle
		self.secondaryplaneangle = secondaryplaneangle
		self.luminousintensity = luminousintensity

	@apply
	def mainplaneangle():
		def fget( self ):
			return self._mainplaneangle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mainplaneangle is mantatory and can not be set to None')
			if not check_type(value,ifcplaneanglemeasure):
				self._mainplaneangle = ifcplaneanglemeasure(value)
			else:
				self._mainplaneangle = value
		return property(**locals())

	@apply
	def secondaryplaneangle():
		def fget( self ):
			return self._secondaryplaneangle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument secondaryplaneangle is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'REAL', scope = schema_scope)):
				self._secondaryplaneangle = LIST(value)
			else:
				self._secondaryplaneangle = value
		return property(**locals())

	@apply
	def luminousintensity():
		def fget( self ):
			return self._luminousintensity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument luminousintensity is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'REAL', scope = schema_scope)):
				self._luminousintensity = LIST(value)
			else:
				self._luminousintensity = value
		return property(**locals())

####################
 # ENTITY ifcpipesegmenttype #
####################
class ifcpipesegmenttype(ifcflowsegmenttype):
	'''Entity ifcpipesegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcpipesegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowsegmenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcpipesegmenttypeenum):
				self._predefinedtype = ifcpipesegmenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcpipesegmenttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcpipesegmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcquantityvolume #
####################
class ifcquantityvolume(ifcphysicalsimplequantity):
	'''Entity ifcquantityvolume definition.

	:param volumevalue
	:type volumevalue:ifcvolumemeasure

	:param formula
	:type formula:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , volumevalue,formula, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.volumevalue = volumevalue
		self.formula = formula

	@apply
	def volumevalue():
		def fget( self ):
			return self._volumevalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument volumevalue is mantatory and can not be set to None')
			if not check_type(value,ifcvolumemeasure):
				self._volumevalue = ifcvolumemeasure(value)
			else:
				self._volumevalue = value
		return property(**locals())

	@apply
	def formula():
		def fget( self ):
			return self._formula
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._formula = ifclabel(value)
				else:
					self._formula = value
			else:
				self._formula = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.self.ifcphysicalsimplequantity.self.unit))  or  (self.self.ifcphysicalsimplequantity.self.unit.self.unittype  ==  ifcunitenum.self.volumeunit))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.volumevalue  >=  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcaxis2placement2d #
####################
class ifcaxis2placement2d(ifcplacement):
	'''Entity ifcaxis2placement2d definition.

	:param refdirection
	:type refdirection:ifcdirection

	:param p
	:type p:LIST(2,2,'ifcdirection', scope = schema_scope)
	'''
	def __init__( self , inherited0__location , refdirection, ):
		ifcplacement.__init__(self , inherited0__location , )
		self.refdirection = refdirection

	@apply
	def refdirection():
		def fget( self ):
			return self._refdirection
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._refdirection = ifcdirection(value)
				else:
					self._refdirection = value
			else:
				self._refdirection = value
		return property(**locals())

	@apply
	def p():
		def fget( self ):
			attribute_eval = ifcbuild2axes(self.refdirection)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def refdiris2d(self):
		eval_refdiris2d_wr = (( not EXISTS(self.refdirection))  or  (self.refdirection.self.dim  ==  2))
		if not eval_refdiris2d_wr:
			raise AssertionError('Rule refdiris2d violated')
		else:
			return eval_refdiris2d_wr

	def locationis2d(self):
		eval_locationis2d_wr = (self.self.ifcplacement.self.location.self.dim  ==  2)
		if not eval_locationis2d_wr:
			raise AssertionError('Rule locationis2d violated')
		else:
			return eval_locationis2d_wr


####################
 # ENTITY ifcrightcircularcone #
####################
class ifcrightcircularcone(ifccsgprimitive3d):
	'''Entity ifcrightcircularcone definition.

	:param height
	:type height:ifcpositivelengthmeasure

	:param bottomradius
	:type bottomradius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , height,bottomradius, ):
		ifccsgprimitive3d.__init__(self , inherited0__position , )
		self.height = height
		self.bottomradius = bottomradius

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._height = ifcpositivelengthmeasure(value)
			else:
				self._height = value
		return property(**locals())

	@apply
	def bottomradius():
		def fget( self ):
			return self._bottomradius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bottomradius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._bottomradius = ifcpositivelengthmeasure(value)
			else:
				self._bottomradius = value
		return property(**locals())

####################
 # ENTITY ifcstructuralloadlinearforce #
####################
class ifcstructuralloadlinearforce(ifcstructuralloadstatic):
	'''Entity ifcstructuralloadlinearforce definition.

	:param linearforcex
	:type linearforcex:ifclinearforcemeasure

	:param linearforcey
	:type linearforcey:ifclinearforcemeasure

	:param linearforcez
	:type linearforcez:ifclinearforcemeasure

	:param linearmomentx
	:type linearmomentx:ifclinearmomentmeasure

	:param linearmomenty
	:type linearmomenty:ifclinearmomentmeasure

	:param linearmomentz
	:type linearmomentz:ifclinearmomentmeasure
	'''
	def __init__( self , inherited0__name , linearforcex,linearforcey,linearforcez,linearmomentx,linearmomenty,linearmomentz, ):
		ifcstructuralloadstatic.__init__(self , inherited0__name , )
		self.linearforcex = linearforcex
		self.linearforcey = linearforcey
		self.linearforcez = linearforcez
		self.linearmomentx = linearmomentx
		self.linearmomenty = linearmomenty
		self.linearmomentz = linearmomentz

	@apply
	def linearforcex():
		def fget( self ):
			return self._linearforcex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearforcemeasure):
					self._linearforcex = ifclinearforcemeasure(value)
				else:
					self._linearforcex = value
			else:
				self._linearforcex = value
		return property(**locals())

	@apply
	def linearforcey():
		def fget( self ):
			return self._linearforcey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearforcemeasure):
					self._linearforcey = ifclinearforcemeasure(value)
				else:
					self._linearforcey = value
			else:
				self._linearforcey = value
		return property(**locals())

	@apply
	def linearforcez():
		def fget( self ):
			return self._linearforcez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearforcemeasure):
					self._linearforcez = ifclinearforcemeasure(value)
				else:
					self._linearforcez = value
			else:
				self._linearforcez = value
		return property(**locals())

	@apply
	def linearmomentx():
		def fget( self ):
			return self._linearmomentx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearmomentmeasure):
					self._linearmomentx = ifclinearmomentmeasure(value)
				else:
					self._linearmomentx = value
			else:
				self._linearmomentx = value
		return property(**locals())

	@apply
	def linearmomenty():
		def fget( self ):
			return self._linearmomenty
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearmomentmeasure):
					self._linearmomenty = ifclinearmomentmeasure(value)
				else:
					self._linearmomenty = value
			else:
				self._linearmomenty = value
		return property(**locals())

	@apply
	def linearmomentz():
		def fget( self ):
			return self._linearmomentz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearmomentmeasure):
					self._linearmomentz = ifclinearmomentmeasure(value)
				else:
					self._linearmomentz = value
			else:
				self._linearmomentz = value
		return property(**locals())

####################
 # ENTITY ifcopenshell #
####################
class ifcopenshell(ifcconnectedfaceset):
	'''Entity ifcopenshell definition.
	'''
	def __init__( self , inherited0__cfsfaces ,  ):
		ifcconnectedfaceset.__init__(self , inherited0__cfsfaces , )

####################
 # ENTITY ifcreldefinesbyproperties #
####################
class ifcreldefinesbyproperties(ifcreldefines):
	'''Entity ifcreldefinesbyproperties definition.

	:param relatedobjects
	:type relatedobjects:SET(1,1,'ifcobjectdefinition', scope = schema_scope)

	:param relatingpropertydefinition
	:type relatingpropertydefinition:ifcpropertysetdefinitionselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedobjects,relatingpropertydefinition, ):
		ifcreldefines.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedobjects = relatedobjects
		self.relatingpropertydefinition = relatingpropertydefinition

	@apply
	def relatedobjects():
		def fget( self ):
			return self._relatedobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,1,'ifcobjectdefinition', scope = schema_scope)):
				self._relatedobjects = SET(value)
			else:
				self._relatedobjects = value
		return property(**locals())

	@apply
	def relatingpropertydefinition():
		def fget( self ):
			return self._relatingpropertydefinition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingpropertydefinition is mantatory and can not be set to None')
			if not check_type(value,ifcpropertysetdefinitionselect):
				self._relatingpropertydefinition = ifcpropertysetdefinitionselect(value)
			else:
				self._relatingpropertydefinition = value
		return property(**locals())

####################
 # ENTITY ifclibraryinformation #
####################
class ifclibraryinformation(ifcexternalinformation):
	'''Entity ifclibraryinformation definition.

	:param name
	:type name:ifclabel

	:param version
	:type version:ifclabel

	:param publisher
	:type publisher:ifcactorselect

	:param versiondate
	:type versiondate:ifcdatetime

	:param location
	:type location:ifcurireference

	:param description
	:type description:ifctext

	:param libraryinfoforobjects
	:type libraryinfoforobjects:SET(0,None,'ifcrelassociateslibrary', scope = schema_scope)

	:param haslibraryreferences
	:type haslibraryreferences:SET(0,None,'ifclibraryreference', scope = schema_scope)
	'''
	def __init__( self , name,version,publisher,versiondate,location,description, ):
		ifcexternalinformation.__init__(self , )
		self.name = name
		self.version = version
		self.publisher = publisher
		self.versiondate = versiondate
		self.location = location
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def version():
		def fget( self ):
			return self._version
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._version = ifclabel(value)
				else:
					self._version = value
			else:
				self._version = value
		return property(**locals())

	@apply
	def publisher():
		def fget( self ):
			return self._publisher
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._publisher = ifcactorselect(value)
				else:
					self._publisher = value
			else:
				self._publisher = value
		return property(**locals())

	@apply
	def versiondate():
		def fget( self ):
			return self._versiondate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetime):
					self._versiondate = ifcdatetime(value)
				else:
					self._versiondate = value
			else:
				self._versiondate = value
		return property(**locals())

	@apply
	def location():
		def fget( self ):
			return self._location
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcurireference):
					self._location = ifcurireference(value)
				else:
					self._location = value
			else:
				self._location = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def libraryinfoforobjects():
		def fget( self ):
			return self._libraryinfoforobjects
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument libraryinfoforobjects is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def haslibraryreferences():
		def fget( self ):
			return self._haslibraryreferences
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument haslibraryreferences is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifclightsourcespot #
####################
class ifclightsourcespot(ifclightsourcepositional):
	'''Entity ifclightsourcespot definition.

	:param orientation
	:type orientation:ifcdirection

	:param concentrationexponent
	:type concentrationexponent:ifcreal

	:param spreadangle
	:type spreadangle:ifcpositiveplaneanglemeasure

	:param beamwidthangle
	:type beamwidthangle:ifcpositiveplaneanglemeasure
	'''
	def __init__( self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , inherited4__position , inherited5__radius , inherited6__constantattenuation , inherited7__distanceattenuation , inherited8__quadricattenuation , orientation,concentrationexponent,spreadangle,beamwidthangle, ):
		ifclightsourcepositional.__init__(self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , inherited4__position , inherited5__radius , inherited6__constantattenuation , inherited7__distanceattenuation , inherited8__quadricattenuation , )
		self.orientation = orientation
		self.concentrationexponent = concentrationexponent
		self.spreadangle = spreadangle
		self.beamwidthangle = beamwidthangle

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._orientation = ifcdirection(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def concentrationexponent():
		def fget( self ):
			return self._concentrationexponent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreal):
					self._concentrationexponent = ifcreal(value)
				else:
					self._concentrationexponent = value
			else:
				self._concentrationexponent = value
		return property(**locals())

	@apply
	def spreadangle():
		def fget( self ):
			return self._spreadangle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument spreadangle is mantatory and can not be set to None')
			if not check_type(value,ifcpositiveplaneanglemeasure):
				self._spreadangle = ifcpositiveplaneanglemeasure(value)
			else:
				self._spreadangle = value
		return property(**locals())

	@apply
	def beamwidthangle():
		def fget( self ):
			return self._beamwidthangle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument beamwidthangle is mantatory and can not be set to None')
			if not check_type(value,ifcpositiveplaneanglemeasure):
				self._beamwidthangle = ifcpositiveplaneanglemeasure(value)
			else:
				self._beamwidthangle = value
		return property(**locals())

####################
 # ENTITY ifcrecurrencepattern #
####################
class ifcrecurrencepattern(BaseEntityClass):
	'''Entity ifcrecurrencepattern definition.

	:param recurrencetype
	:type recurrencetype:ifcrecurrencetypeenum

	:param daycomponent
	:type daycomponent:SET(1,None,'INTEGER', scope = schema_scope)

	:param weekdaycomponent
	:type weekdaycomponent:SET(1,None,'INTEGER', scope = schema_scope)

	:param monthcomponent
	:type monthcomponent:SET(1,None,'INTEGER', scope = schema_scope)

	:param position
	:type position:ifcinteger

	:param interval
	:type interval:ifcinteger

	:param occurrences
	:type occurrences:ifcinteger

	:param timeperiods
	:type timeperiods:LIST(1,None,'ifctimeperiod', scope = schema_scope)
	'''
	def __init__( self , recurrencetype,daycomponent,weekdaycomponent,monthcomponent,position,interval,occurrences,timeperiods, ):
		self.recurrencetype = recurrencetype
		self.daycomponent = daycomponent
		self.weekdaycomponent = weekdaycomponent
		self.monthcomponent = monthcomponent
		self.position = position
		self.interval = interval
		self.occurrences = occurrences
		self.timeperiods = timeperiods

	@apply
	def recurrencetype():
		def fget( self ):
			return self._recurrencetype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument recurrencetype is mantatory and can not be set to None')
			if not check_type(value,ifcrecurrencetypeenum):
				self._recurrencetype = ifcrecurrencetypeenum(value)
			else:
				self._recurrencetype = value
		return property(**locals())

	@apply
	def daycomponent():
		def fget( self ):
			return self._daycomponent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'INTEGER', scope = schema_scope)):
					self._daycomponent = SET(value)
				else:
					self._daycomponent = value
			else:
				self._daycomponent = value
		return property(**locals())

	@apply
	def weekdaycomponent():
		def fget( self ):
			return self._weekdaycomponent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'INTEGER', scope = schema_scope)):
					self._weekdaycomponent = SET(value)
				else:
					self._weekdaycomponent = value
			else:
				self._weekdaycomponent = value
		return property(**locals())

	@apply
	def monthcomponent():
		def fget( self ):
			return self._monthcomponent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'INTEGER', scope = schema_scope)):
					self._monthcomponent = SET(value)
				else:
					self._monthcomponent = value
			else:
				self._monthcomponent = value
		return property(**locals())

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcinteger):
					self._position = ifcinteger(value)
				else:
					self._position = value
			else:
				self._position = value
		return property(**locals())

	@apply
	def interval():
		def fget( self ):
			return self._interval
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcinteger):
					self._interval = ifcinteger(value)
				else:
					self._interval = value
			else:
				self._interval = value
		return property(**locals())

	@apply
	def occurrences():
		def fget( self ):
			return self._occurrences
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcinteger):
					self._occurrences = ifcinteger(value)
				else:
					self._occurrences = value
			else:
				self._occurrences = value
		return property(**locals())

	@apply
	def timeperiods():
		def fget( self ):
			return self._timeperiods
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifctimeperiod', scope = schema_scope)):
					self._timeperiods = LIST(value)
				else:
					self._timeperiods = value
			else:
				self._timeperiods = value
		return property(**locals())

####################
 # ENTITY ifcstructuralsurfacemembervarying #
####################
class ifcstructuralsurfacemembervarying(ifcstructuralsurfacemember):
	'''Entity ifcstructuralsurfacemembervarying definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__predefinedtype , inherited8__thickness ,  ):
		ifcstructuralsurfacemember.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__predefinedtype , inherited8__thickness , )

####################
 # ENTITY ifctubebundle #
####################
class ifctubebundle(ifcenergyconversiondevice):
	'''Entity ifctubebundle definition.

	:param predefinedtype
	:type predefinedtype:ifctubebundletypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctubebundletypeenum):
					self._predefinedtype = ifctubebundletypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifctubebundletypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifctubebundletypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCTUBEBUNDLETYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifcprofileproperties #
####################
class ifcprofileproperties(ifcextendedproperties):
	'''Entity ifcprofileproperties definition.

	:param profiledefinition
	:type profiledefinition:ifcprofiledef
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__properties , profiledefinition, ):
		ifcextendedproperties.__init__(self , inherited0__name , inherited1__description , inherited2__properties , )
		self.profiledefinition = profiledefinition

	@apply
	def profiledefinition():
		def fget( self ):
			return self._profiledefinition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument profiledefinition is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._profiledefinition = ifcprofiledef(value)
			else:
				self._profiledefinition = value
		return property(**locals())

####################
 # ENTITY ifcrelassociatesdocument #
####################
class ifcrelassociatesdocument(ifcrelassociates):
	'''Entity ifcrelassociatesdocument definition.

	:param relatingdocument
	:type relatingdocument:ifcdocumentselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingdocument, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingdocument = relatingdocument

	@apply
	def relatingdocument():
		def fget( self ):
			return self._relatingdocument
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingdocument is mantatory and can not be set to None')
			if not check_type(value,ifcdocumentselect):
				self._relatingdocument = ifcdocumentselect(value)
			else:
				self._relatingdocument = value
		return property(**locals())

####################
 # ENTITY ifcfixedreferencesweptareasolid #
####################
class ifcfixedreferencesweptareasolid(ifcsweptareasolid):
	'''Entity ifcfixedreferencesweptareasolid definition.

	:param directrix
	:type directrix:ifccurve

	:param startparam
	:type startparam:ifcparametervalue

	:param endparam
	:type endparam:ifcparametervalue

	:param fixedreference
	:type fixedreference:ifcdirection
	'''
	def __init__( self , inherited0__sweptarea , inherited1__position , directrix,startparam,endparam,fixedreference, ):
		ifcsweptareasolid.__init__(self , inherited0__sweptarea , inherited1__position , )
		self.directrix = directrix
		self.startparam = startparam
		self.endparam = endparam
		self.fixedreference = fixedreference

	@apply
	def directrix():
		def fget( self ):
			return self._directrix
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directrix is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._directrix = ifccurve(value)
			else:
				self._directrix = value
		return property(**locals())

	@apply
	def startparam():
		def fget( self ):
			return self._startparam
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcparametervalue):
					self._startparam = ifcparametervalue(value)
				else:
					self._startparam = value
			else:
				self._startparam = value
		return property(**locals())

	@apply
	def endparam():
		def fget( self ):
			return self._endparam
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcparametervalue):
					self._endparam = ifcparametervalue(value)
				else:
					self._endparam = value
			else:
				self._endparam = value
		return property(**locals())

	@apply
	def fixedreference():
		def fget( self ):
			return self._fixedreference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fixedreference is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._fixedreference = ifcdirection(value)
			else:
				self._fixedreference = value
		return property(**locals())
	def directrixbounded(self):
		eval_directrixbounded_wr = ((EXISTS(self.startparam)  and  EXISTS(self.endparam))  or  (SIZEOF(['IFC4.IFCCONIC','IFC4.IFCBOUNDEDCURVE']  *  TYPEOF(self.directrix))  ==  1))
		if not eval_directrixbounded_wr:
			raise AssertionError('Rule directrixbounded violated')
		else:
			return eval_directrixbounded_wr


####################
 # ENTITY ifcpumptype #
####################
class ifcpumptype(ifcflowmovingdevicetype):
	'''Entity ifcpumptype definition.

	:param predefinedtype
	:type predefinedtype:ifcpumptypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowmovingdevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcpumptypeenum):
				self._predefinedtype = ifcpumptypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((self.predefinedtype  !=  ifcpumptypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcpumptypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr


####################
 # ENTITY ifcsphere #
####################
class ifcsphere(ifccsgprimitive3d):
	'''Entity ifcsphere definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , radius, ):
		ifccsgprimitive3d.__init__(self , inherited0__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY ifccurvestylefont #
####################
class ifccurvestylefont(ifcpresentationitem):
	'''Entity ifccurvestylefont definition.

	:param name
	:type name:ifclabel

	:param patternlist
	:type patternlist:LIST(1,None,'ifccurvestylefontpattern', scope = schema_scope)
	'''
	def __init__( self , name,patternlist, ):
		ifcpresentationitem.__init__(self , )
		self.name = name
		self.patternlist = patternlist

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def patternlist():
		def fget( self ):
			return self._patternlist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument patternlist is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifccurvestylefontpattern', scope = schema_scope)):
				self._patternlist = LIST(value)
			else:
				self._patternlist = value
		return property(**locals())

####################
 # ENTITY ifcramp #
####################
class ifcramp(ifcbuildingelement):
	'''Entity ifcramp definition.

	:param predefinedtype
	:type predefinedtype:ifcramptypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcramptypeenum):
					self._predefinedtype = ifcramptypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctshapedecomposition(self):
		eval_correctshapedecomposition_wr = ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  0)  or  ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  1)  and  (( not EXISTS(self.self.ifcproduct.self.representation))  or  (EXISTS(self.self.ifcproduct.self.representation)  and  (SIZEOF(None)  ==  0)))))
		if not eval_correctshapedecomposition_wr:
			raise AssertionError('Rule correctshapedecomposition violated')
		else:
			return eval_correctshapedecomposition_wr

	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcramptypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcramptypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCRAMPTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifctransformer #
####################
class ifctransformer(ifcenergyconversiondevice):
	'''Entity ifctransformer definition.

	:param predefinedtype
	:type predefinedtype:ifctransformertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcenergyconversiondevice.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctransformertypeenum):
					self._predefinedtype = ifctransformertypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifctransformertypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifctransformertypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCTRANFORMERTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # ENTITY ifccivilelement #
####################
class ifccivilelement(ifcelement):
	'''Entity ifccivilelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifccartesiantransformationoperator3dnonuniform #
####################
class ifccartesiantransformationoperator3dnonuniform(ifccartesiantransformationoperator3d):
	'''Entity ifccartesiantransformationoperator3dnonuniform definition.

	:param scale2
	:type scale2:REAL

	:param scale3
	:type scale3:REAL

	:param scl2
	:type scl2:REAL

	:param scl3
	:type scl3:REAL
	'''
	def __init__( self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , inherited4__axis3 , scale2,scale3, ):
		ifccartesiantransformationoperator3d.__init__(self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , inherited4__axis3 , )
		self.scale2 = scale2
		self.scale3 = scale3

	@apply
	def scale2():
		def fget( self ):
			return self._scale2
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._scale2 = REAL(value)
				else:
					self._scale2 = value
			else:
				self._scale2 = value
		return property(**locals())

	@apply
	def scale3():
		def fget( self ):
			return self._scale3
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._scale3 = REAL(value)
				else:
					self._scale3 = value
			else:
				self._scale3 = value
		return property(**locals())

	@apply
	def scl2():
		def fget( self ):
			attribute_eval = NVL(self.scale2,self.self.ifccartesiantransformationoperator.self.scl)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scl2 is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def scl3():
		def fget( self ):
			attribute_eval = NVL(self.scale3,self.self.ifccartesiantransformationoperator.self.scl)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scl3 is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def scale2greaterzero(self):
		eval_scale2greaterzero_wr = (self.scl2  >  0)
		if not eval_scale2greaterzero_wr:
			raise AssertionError('Rule scale2greaterzero violated')
		else:
			return eval_scale2greaterzero_wr

	def scale3greaterzero(self):
		eval_scale3greaterzero_wr = (self.scl3  >  0)
		if not eval_scale3greaterzero_wr:
			raise AssertionError('Rule scale3greaterzero violated')
		else:
			return eval_scale3greaterzero_wr


####################
 # ENTITY ifcchimney #
####################
class ifcchimney(ifcbuildingelement):
	'''Entity ifcchimney definition.

	:param predefinedtype
	:type predefinedtype:ifcchimneytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcchimneytypeenum):
					self._predefinedtype = ifcchimneytypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def correctpredefinedtype(self):
		eval_correctpredefinedtype_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcchimneytypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcchimneytypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_correctpredefinedtype_wr:
			raise AssertionError('Rule correctpredefinedtype violated')
		else:
			return eval_correctpredefinedtype_wr

	def correcttypeassigned(self):
		eval_correcttypeassigned_wr = ((SIZEOF(self.istypedby)  ==  0)  or  ('IFC4.IFCCHIMNEYTYPE'  ==  TYPEOF(self.self.ifcobject.self.istypedby[1].self.relatingtype)))
		if not eval_correcttypeassigned_wr:
			raise AssertionError('Rule correcttypeassigned violated')
		else:
			return eval_correcttypeassigned_wr


####################
 # FUNCTION ifcnormalise #
####################
def ifcnormalise(arg,):
	'''
	:param arg
	:type arg:ifcvectorordirection
	'''
	if ( not EXISTS(arg)):
		return  None 
	else:
		if ('IFC4.IFCVECTOR'  ==  TYPEOF(arg)):
			# begin/end block
			ndim = arg.ifcvector.dim
			v.directionratios = arg.ifcvector.orientation.directionratios
			vec.magnitude = arg.ifcvector.magnitude
			vec.orientation = v
			if (arg.ifcvector.magnitude  ==  0):
				return  None 
			else:
				vec.magnitude = 1
		else:
			# begin/end block
			ndim = arg.ifcdirection.dim
			v.directionratios = arg.ifcdirection.directionratios
		mag = 0
		for  i in range(1,ndim,1):
			mag = mag  +  (v.directionratios[i]  *  v.directionratios[i])
		if (mag  >  0):
			mag = SQRT(mag)
			for  i in range(1,ndim,1):
				v.directionratios[i] = v.directionratios[i] / mag
			if ('IFC4.IFCVECTOR'  ==  TYPEOF(arg)):
				vec.orientation = v
				result = vec
			else:
				result = v
		else:
			return  None 
	return result

####################
 # FUNCTION ifctaperedsweptareaprofiles #
####################
def ifctaperedsweptareaprofiles(startarea,endarea,):
	'''
	:param startarea
	:type startarea:ifcprofiledef
	:param endarea
	:type endarea:ifcprofiledef
	'''
	if ('IFC4.IFCPARAMETERIZEDPROFILEDEF'  ==  TYPEOF(startarea)):
		if ('IFC4.IFCDERIVEDPROFILEDEF'  ==  TYPEOF(endarea)):
			result = startarea  ==  endarea.ifcderivedprofiledef.parentprofile
		else:
			result = TYPEOF(startarea)  ==  TYPEOF(endarea)
	else:
		if ('IFC4.IFCDERIVEDPROFILEDEF'  ==  TYPEOF(endarea)):
			result = startarea  ==  endarea.ifcderivedprofiledef.parentprofile
		else:
			result = FALSE
	return result

####################
 # FUNCTION ifcsamevalue #
####################
def ifcsamevalue(value1,value2,epsilon,):
	'''
	:param value1
	:type value1:REAL
	:param value2
	:type value2:REAL
	:param epsilon
	:type epsilon:REAL
	'''
	valideps = NVL(epsilon,defaulteps)
	return ((value1  +  valideps)  >  value2)  and  (value1  <  (value2  +  valideps))

####################
 # FUNCTION ifcsamevalidprecision #
####################
def ifcsamevalidprecision(epsilon1,epsilon2,):
	'''
	:param epsilon1
	:type epsilon1:REAL
	:param epsilon2
	:type epsilon2:REAL
	'''
	valideps1 = NVL(epsilon1,defaulteps)
	valideps2 = NVL(epsilon2,defaulteps)
	return (((0  <  valideps1)  and  (valideps1  <=  (derivationofeps  *  valideps2)))  and  (valideps2  <=  (derivationofeps  *  valideps1)))  and  (valideps2  <  uppereps)

####################
 # FUNCTION ifcbuildaxes #
####################
def ifcbuildaxes(axis,refdirection,):
	'''
	:param axis
	:type axis:ifcdirection
	:param refdirection
	:type refdirection:ifcdirection
	'''
	d1 = NVL(ifcnormalise(axis),(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,0,1]))
	d2 = ifcfirstprojaxis(d1,refdirection)
	return [d2,ifcnormalise(ifccrossproduct(d1,d2)).ifcvector.orientation,d1]

####################
 # FUNCTION ifcvectorsum #
####################
def ifcvectorsum(arg1,arg2,):
	'''
	:param arg1
	:type arg1:ifcvectorordirection
	:param arg2
	:type arg2:ifcvectorordirection
	'''
	if ((( not EXISTS(arg1))  or  ( not EXISTS(arg2)))  or  (arg1.dim  !=  arg2.dim)):
		return  None 
	else:
		# begin/end block
		if ('IFC4.IFCVECTOR'  ==  TYPEOF(arg1)):
			mag1 = arg1.ifcvector.magnitude
			vec1 = arg1.ifcvector.orientation
		else:
			mag1 = 1
			vec1 = arg1
		if ('IFC4.IFCVECTOR'  ==  TYPEOF(arg2)):
			mag2 = arg2.ifcvector.magnitude
			vec2 = arg2.ifcvector.orientation
		else:
			mag2 = 1
			vec2 = arg2
		vec1 = ifcnormalise(vec1)
		vec2 = ifcnormalise(vec2)
		ndim = SIZEOF(vec1.directionratios)
		mag = 0
		res = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,ndim])
		for  i in range(1,ndim,1):
			res.directionratios[i] = (mag1  *  vec1.directionratios[i])  +  (mag2  *  vec2.directionratios[i])
			mag = mag  +  (res.directionratios[i]  *  res.directionratios[i])
		if (mag  >  0):
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(res,SQRT(mag))
		else:
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(vec1,0)
	return result

####################
 # FUNCTION ifcvectordifference #
####################
def ifcvectordifference(arg1,arg2,):
	'''
	:param arg1
	:type arg1:ifcvectorordirection
	:param arg2
	:type arg2:ifcvectorordirection
	'''
	if ((( not EXISTS(arg1))  or  ( not EXISTS(arg2)))  or  (arg1.dim  !=  arg2.dim)):
		return  None 
	else:
		# begin/end block
		if ('IFC4.IFCVECTOR'  ==  TYPEOF(arg1)):
			mag1 = arg1.ifcvector.magnitude
			vec1 = arg1.ifcvector.orientation
		else:
			mag1 = 1
			vec1 = arg1
		if ('IFC4.IFCVECTOR'  ==  TYPEOF(arg2)):
			mag2 = arg2.ifcvector.magnitude
			vec2 = arg2.ifcvector.orientation
		else:
			mag2 = 1
			vec2 = arg2
		vec1 = ifcnormalise(vec1)
		vec2 = ifcnormalise(vec2)
		ndim = SIZEOF(vec1.directionratios)
		mag = 0
		res = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,ndim])
		for  i in range(1,ndim,1):
			res.directionratios[i] = (mag1  *  vec1.directionratios[i]) - (mag2  *  vec2.directionratios[i])
			mag = mag  +  (res.directionratios[i]  *  res.directionratios[i])
		if (mag  >  0):
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(res,SQRT(mag))
		else:
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(vec1,0)
	return result

####################
 # FUNCTION ifccorrectlocalplacement #
####################
def ifccorrectlocalplacement(axisplacement,relplacement,):
	'''
	:param axisplacement
	:type axisplacement:ifcaxis2placement
	:param relplacement
	:type relplacement:ifcobjectplacement
	'''
	if (EXISTS(relplacement)):
		if ('IFC4.IFCGRIDPLACEMENT'  ==  TYPEOF(relplacement)):
			return  None 
		if ('IFC4.IFCLOCALPLACEMENT'  ==  TYPEOF(relplacement)):
			if ('IFC4.IFCAXIS2PLACEMENT2D'  ==  TYPEOF(axisplacement)):
				return TRUE
			if ('IFC4.IFCAXIS2PLACEMENT3D'  ==  TYPEOF(axisplacement)):
				if (relplacement.ifclocalplacement.relativeplacement.dim  ==  3):
					return TRUE
				else:
					return FALSE
	else:
		return TRUE
	return  None 

####################
 # FUNCTION ifccorrectfillareastyle #
####################
def ifccorrectfillareastyle(styles,):
	'''
	:param styles
	:type styles:(null)
	'''
	external = SIZEOF(None)
	hatching = SIZEOF(None)
	tiles = SIZEOF(None)
	colour = SIZEOF(None)
	if (external  >  1):
		return FALSE
	if ((external  ==  1)  and  (((hatching  >  0)  or  (tiles  >  0))  or  (colour  >  0))):
		return FALSE
	if (colour  >  1):
		return FALSE
	if ((hatching  >  0)  and  (tiles  >  0)):
		return FALSE
	return TRUE

####################
 # FUNCTION ifcuniquepropertytemplatenames #
####################
def ifcuniquepropertytemplatenames(properties,):
	'''
	:param properties
	:type properties:(null)
	'''
	for  i in range(1,HIINDEX(properties),1):
		names = names  +  properties[i].name
	return SIZEOF(names)  ==  SIZEOF(properties)

####################
 # FUNCTION ifcuniquepropertyname #
####################
def ifcuniquepropertyname(properties,):
	'''
	:param properties
	:type properties:(null)
	'''
	for  i in range(1,HIINDEX(properties),1):
		names = names  +  properties[i].name
	return SIZEOF(names)  ==  SIZEOF(properties)

####################
 # FUNCTION ifcmakearrayofarray #
####################
def ifcmakearrayofarray(lis,low1,u1,low2,u2,):
	'''
	:param lis
	:type lis:(null)
	:param low1
	:type low1:INTEGER
	:param u1
	:type u1:INTEGER
	:param low2
	:type low2:INTEGER
	:param u2
	:type u2:INTEGER
	'''
	if (((u1 - low1)  +  1)  !=  SIZEOF(lis)):
		return  None 
	if (((u2 - low2)  +  1)  !=  SIZEOF(lis[1])):
		return  None 
	res = [ifclisttoarray(lis[1],low2,u2),(u1 - low1)  +  1]
	for  i in range(2,HIINDEX(lis),1):
		if (((u2 - low2)  +  1)  !=  SIZEOF(lis[i])):
			return  None 
		res[(low1  +  i) - 1] = ifclisttoarray(lis[i],low2,u2)
	return res

####################
 # FUNCTION ifccurvedim #
####################
def ifccurvedim(curve,):
	'''
	:param curve
	:type curve:ifccurve
	'''
	if ('IFC4.IFCLINE'  ==  TYPEOF(curve)):
		return curve.ifcline.pnt.dim
	if ('IFC4.IFCCONIC'  ==  TYPEOF(curve)):
		return curve.ifcconic.position.dim
	if ('IFC4.IFCPOLYLINE'  ==  TYPEOF(curve)):
		return curve.ifcpolyline.points[1].dim
	if ('IFC4.IFCTRIMMEDCURVE'  ==  TYPEOF(curve)):
		return ifccurvedim(curve.ifctrimmedcurve.basiscurve)
	if ('IFC4.IFCCOMPOSITECURVE'  ==  TYPEOF(curve)):
		return curve.ifccompositecurve.segments[1].dim
	if ('IFC4.IFCBSPLINECURVE'  ==  TYPEOF(curve)):
		return curve.ifcbsplinecurve.controlpointslist[1].dim
	if ('IFC4.IFCOFFSETCURVE2D'  ==  TYPEOF(curve)):
		return 2
	if ('IFC4.IFCOFFSETCURVE3D'  ==  TYPEOF(curve)):
		return 3
	if ('IFC4.IFCPCURVE'  ==  TYPEOF(curve)):
		return 3
	return  None 

####################
 # FUNCTION ifcsamedirection #
####################
def ifcsamedirection(dir1,dir2,epsilon,):
	'''
	:param dir1
	:type dir1:ifcdirection
	:param dir2
	:type dir2:ifcdirection
	:param epsilon
	:type epsilon:REAL
	'''
	if (SIZEOF(dir1.directionratios)  >  2):
		dir1z = dir1.directionratios[3]
	if (SIZEOF(dir2.directionratios)  >  2):
		dir2z = dir2.directionratios[3]
	return (ifcsamevalue(dir1x,dir2x,epsilon)  and  ifcsamevalue(dir1y,dir2y,epsilon))  and  ifcsamevalue(dir1z,dir2z,epsilon)

####################
 # FUNCTION ifclisttoarray #
####################
def ifclisttoarray(lis,low,u,):
	'''
	:param lis
	:type lis:(null)
	:param low
	:type low:INTEGER
	:param u
	:type u:INTEGER
	'''
	n = SIZEOF(lis)
	if (n  !=  ((u - low)  +  1)):
		return  None 
	else:
		res = [lis[1],n]
		for  i in range(2,n,1):
			res[(low  +  i) - 1] = lis[i]
		return res

####################
 # FUNCTION ifctopologyrepresentationtypes #
####################
def ifctopologyrepresentationtypes(reptype,items,):
	'''
	:param reptype
	:type reptype:STRING
	:param items
	:type items:(null)
	'''
	case_selector = reptype
	if  case_selector == 'Vertex':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Edge':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Path':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Face':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Shell':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Undefined':
		return TRUE
	else:
		return  None 
	return count  ==  SIZEOF(items)

####################
 # FUNCTION ifccorrectunitassignment #
####################
def ifccorrectunitassignment(units,):
	'''
	:param units
	:type units:(null)
	'''
	namedunitnumber = SIZEOF(None)
	derivedunitnumber = SIZEOF(None)
	monetaryunitnumber = SIZEOF(None)
	for  i in range(1,SIZEOF(units),1):
		if (('IFC4.IFCNAMEDUNIT'  ==  TYPEOF(units[i]))  and  ( not (units[i].ifcnamedunit.unittype  ==  ifcunitenum.userdefined))):
			namedunitnames = namedunitnames  +  units[i].ifcnamedunit.unittype
		if (('IFC4.IFCDERIVEDUNIT'  ==  TYPEOF(units[i]))  and  ( not (units[i].ifcderivedunit.unittype  ==  ifcderivedunitenum.userdefined))):
			derivedunitnames = derivedunitnames  +  units[i].ifcderivedunit.unittype
	return ((SIZEOF(namedunitnames)  ==  namedunitnumber)  and  (SIZEOF(derivedunitnames)  ==  derivedunitnumber))  and  (monetaryunitnumber  <=  1)

####################
 # FUNCTION ifcdotproduct #
####################
def ifcdotproduct(arg1,arg2,):
	'''
	:param arg1
	:type arg1:ifcdirection
	:param arg2
	:type arg2:ifcdirection
	'''
	if (( not EXISTS(arg1))  or  ( not EXISTS(arg2))):
		scalar =  None 
	else:
		if (arg1.dim  !=  arg2.dim):
			scalar =  None 
		else:
			# begin/end block
			vec1 = ifcnormalise(arg1)
			vec2 = ifcnormalise(arg2)
			ndim = arg1.dim
			scalar = 0
			for  i in range(1,ndim,1):
				scalar = scalar  +  (vec1.directionratios[i]  *  vec2.directionratios[i])
	return scalar

####################
 # FUNCTION ifcfirstprojaxis #
####################
def ifcfirstprojaxis(zaxis,arg,):
	'''
	:param zaxis
	:type zaxis:ifcdirection
	:param arg
	:type arg:ifcdirection
	'''
	if ( not EXISTS(zaxis)):
		return  None 
	else:
		z = ifcnormalise(zaxis)
		if ( not EXISTS(arg)):
			if (z.directionratios  !=  [1,0,0]):
				v = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([1,0,0])
			else:
				v = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,1,0])
		else:
			if (arg.dim  !=  3):
				return  None 
			if (ifccrossproduct(arg,z).magnitude  ==  0):
				return  None 
			else:
				v = ifcnormalise(arg)
		xvec = ifcscalartimesvector(ifcdotproduct(v,z),z)
		xaxis = ifcvectordifference(v,xvec).orientation
		xaxis = ifcnormalise(xaxis)
	return xaxis

####################
 # FUNCTION ifcshaperepresentationtypes #
####################
def ifcshaperepresentationtypes(reptype,items,):
	'''
	:param reptype
	:type reptype:STRING
	:param items
	:type items:(null)
	'''
	case_selector = reptype
	if  case_selector == 'Point':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'PointCloud':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Curve':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Curve2D':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Curve3D':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Surface':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Surface2D':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Surface3D':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'FillArea':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Text':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'AdvancedSurface':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Annotation2D':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'GeometricSet':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'GeometricCurveSet':
		# begin/end block
		count = SIZEOF(None)
		for  i in range(1,HIINDEX(items),1):
			if ('IFC4.IFCGEOMETRICSET'  ==  TYPEOF(items[i])):
				if (SIZEOF(None)  >  0):
					count = count - 1
	elif case_selector == 'Tessellation':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'SurfaceOrSolidModel':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'SurfaceModel':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'SolidModel':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'SweptSolid':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'AdvancedSweptSolid':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'CSG':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Clipping':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Brep':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'AdvancedBrep':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'BoundingBox':
		# begin/end block
		count = SIZEOF(None)
		if (SIZEOF(items)  >  1):
			count = 0
	elif case_selector == 'SectionedSpine':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'LightSource':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'MappedRepresentation':
		# begin/end block
		count = SIZEOF(None)
	else:
		return  None 
	return count  ==  SIZEOF(items)

####################
 # FUNCTION ifcpathheadtotail #
####################
def ifcpathheadtotail(apath,):
	'''
	:param apath
	:type apath:ifcpath
	'''
	n = SIZEOF(apath.edgelist)
	for  i in range(2,n,1):
		p = p  and  (apath.edgelist[i - 1].edgeend  ==  apath.edgelist[i].edgestart)
	return p

####################
 # FUNCTION ifcsecondprojaxis #
####################
def ifcsecondprojaxis(zaxis,xaxis,arg,):
	'''
	:param zaxis
	:type zaxis:ifcdirection
	:param xaxis
	:type xaxis:ifcdirection
	:param arg
	:type arg:ifcdirection
	'''
	if ( not EXISTS(arg)):
		v = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,1,0])
	else:
		v = arg
	temp = ifcscalartimesvector(ifcdotproduct(v,zaxis),zaxis)
	yaxis = ifcvectordifference(v,temp)
	temp = ifcscalartimesvector(ifcdotproduct(v,xaxis),xaxis)
	yaxis = ifcvectordifference(yaxis,temp)
	yaxis = ifcnormalise(yaxis)
	return yaxis.orientation

####################
 # FUNCTION ifcderivedimensionalexponents #
####################
def ifcderivedimensionalexponents(unitelements,):
	'''
	:param unitelements
	:type unitelements:(null)
	'''
	for  i in range(LOINDEX(unitelements),HIINDEX(unitelements),1):
		result.lengthexponent = result.lengthexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.lengthexponent)
		result.massexponent = result.massexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.massexponent)
		result.timeexponent = result.timeexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.timeexponent)
		result.electriccurrentexponent = result.electriccurrentexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.electriccurrentexponent)
		result.thermodynamictemperatureexponent = result.thermodynamictemperatureexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.thermodynamictemperatureexponent)
		result.amountofsubstanceexponent = result.amountofsubstanceexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.amountofsubstanceexponent)
		result.luminousintensityexponent = result.luminousintensityexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.luminousintensityexponent)
	return result

####################
 # FUNCTION ifcbooleanchoose #
####################
def ifcbooleanchoose(b,choice1,choice2,):
	'''
	:param b
	:type b:BOOLEAN
	:param choice1
	:type choice1:(null)
	:param choice2
	:type choice2:(null)
	'''
	if (b):
		return choice1
	else:
		return choice2

####################
 # FUNCTION ifcscalartimesvector #
####################
def ifcscalartimesvector(scalar,vec,):
	'''
	:param scalar
	:type scalar:REAL
	:param vec
	:type vec:ifcvectorordirection
	'''
	if (( not EXISTS(scalar))  or  ( not EXISTS(vec))):
		return  None 
	else:
		if ('IFC4.IFCVECTOR'  ==  TYPEOF(vec)):
			v = vec.ifcvector.orientation
			mag = scalar  *  vec.ifcvector.magnitude
		else:
			v = vec
			mag = scalar
		if (mag  <  0):
			for  i in range(1,SIZEOF(v.directionratios),1):
				v.directionratios[i] = -v.directionratios[i]
			mag = -mag
		result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(ifcnormalise(v),mag)
	return result

####################
 # FUNCTION ifcgetbasissurface #
####################
def ifcgetbasissurface(c,):
	'''
	:param c
	:type c:ifccurveonsurface
	'''
	surfs = []
	if ('IFC4.IFCPCURVE'  ==  TYPEOF(c)):
		surfs = [c.ifcpcurve.basissurface]
	else:
		if ('IFC4.IFCCOMPOSITECURVEONSURFACE'  ==  TYPEOF(c)):
			n = SIZEOF(c.ifccompositecurve.segments)
			surfs = ifcgetbasissurface(c.ifccompositecurve.segments[1].parentcurve)
			if (n  >  1):
				for  i in range(2,n,1):
					surfs = surfs  *  ifcgetbasissurface(c.ifccompositecurve.segments[1].parentcurve)
	return surfs

####################
 # FUNCTION ifcuniquequantitynames #
####################
def ifcuniquequantitynames(properties,):
	'''
	:param properties
	:type properties:(null)
	'''
	for  i in range(1,HIINDEX(properties),1):
		names = names  +  properties[i].name
	return SIZEOF(names)  ==  SIZEOF(properties)

####################
 # FUNCTION ifcbaseaxis #
####################
def ifcbaseaxis(dim,axis1,axis2,axis3,):
	'''
	:param dim
	:type dim:INTEGER
	:param axis1
	:type axis1:ifcdirection
	:param axis2
	:type axis2:ifcdirection
	:param axis3
	:type axis3:ifcdirection
	'''
	if (dim  ==  3):
		d1 = NVL(ifcnormalise(axis3),(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,0,1]))
		d2 = ifcfirstprojaxis(d1,axis1)
		u = [d2,ifcsecondprojaxis(d1,d2,axis2),d1]
	else:
		if (EXISTS(axis1)):
			d1 = ifcnormalise(axis1)
			u = [d1,ifcorthogonalcomplement(d1)]
			if (EXISTS(axis2)):
				factor = ifcdotproduct(axis2,u[2])
				if (factor  <  0):
					u[2].directionratios[1] = -u[2].directionratios[1]
					u[2].directionratios[2] = -u[2].directionratios[2]
		else:
			if (EXISTS(axis2)):
				d1 = ifcnormalise(axis2)
				u = [ifcorthogonalcomplement(d1),d1]
				u[1].directionratios[1] = -u[1].directionratios[1]
				u[1].directionratios[2] = -u[1].directionratios[2]
			else:
				u = [(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([1,0]),(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,1])]
	return u

####################
 # FUNCTION ifcconvertdirectioninto2d #
####################
def ifcconvertdirectioninto2d(direction,):
	'''
	:param direction
	:type direction:ifcdirection
	'''
	direction2d.directionratios[1] = direction.directionratios[1]
	direction2d.directionratios[2] = direction.directionratios[2]
	return direction2d

####################
 # FUNCTION ifcorthogonalcomplement #
####################
def ifcorthogonalcomplement(vec,):
	'''
	:param vec
	:type vec:ifcdirection
	'''
	if (( not EXISTS(vec))  or  (vec.dim  !=  2)):
		return  None 
	else:
		result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([-vec.directionratios[2],vec.directionratios[1]])
		return result

####################
 # FUNCTION ifcloopheadtotail #
####################
def ifcloopheadtotail(aloop,):
	'''
	:param aloop
	:type aloop:ifcedgeloop
	'''
	n = SIZEOF(aloop.edgelist)
	for  i in range(2,n,1):
		p = p  and  (aloop.edgelist[i - 1].edgeend  ==  aloop.edgelist[i].edgestart)
	return p

####################
 # FUNCTION ifccorrectdimensions #
####################
def ifccorrectdimensions(m,dim,):
	'''
	:param m
	:type m:ifcunitenum
	:param dim
	:type dim:ifcdimensionalexponents
	'''
	case_selector = m
	if  case_selector == lengthunit:
		if (dim  ==  ifcdimensionalexponents(1,0,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == massunit:
		if (dim  ==  ifcdimensionalexponents(0,1,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == timeunit:
		if (dim  ==  ifcdimensionalexponents(0,0,1,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electriccurrentunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,1,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == thermodynamictemperatureunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,1,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == amountofsubstanceunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,0,1,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == luminousintensityunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,0,0,1)):
			return TRUE
		else:
			return FALSE
	elif case_selector == planeangleunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == solidangleunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == areaunit:
		if (dim  ==  ifcdimensionalexponents(2,0,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == volumeunit:
		if (dim  ==  ifcdimensionalexponents(3,0,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == absorbeddoseunit:
		if (dim  ==  ifcdimensionalexponents(2,0,-2,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == radioactivityunit:
		if (dim  ==  ifcdimensionalexponents(0,0,-1,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electriccapacitanceunit:
		if (dim  ==  ifcdimensionalexponents(-2,-1,4,2,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == doseequivalentunit:
		if (dim  ==  ifcdimensionalexponents(2,0,-2,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electricchargeunit:
		if (dim  ==  ifcdimensionalexponents(0,0,1,1,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electricconductanceunit:
		if (dim  ==  ifcdimensionalexponents(-2,-1,3,2,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electricvoltageunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-3,-1,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electricresistanceunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-3,-2,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == energyunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-2,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == forceunit:
		if (dim  ==  ifcdimensionalexponents(1,1,-2,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == frequencyunit:
		if (dim  ==  ifcdimensionalexponents(0,0,-1,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == inductanceunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-2,-2,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == illuminanceunit:
		if (dim  ==  ifcdimensionalexponents(-2,0,0,0,0,0,1)):
			return TRUE
		else:
			return FALSE
	elif case_selector == luminousfluxunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,0,0,1)):
			return TRUE
		else:
			return FALSE
	elif case_selector == magneticfluxunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-2,-1,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == magneticfluxdensityunit:
		if (dim  ==  ifcdimensionalexponents(0,1,-2,-1,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == powerunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-3,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == pressureunit:
		if (dim  ==  ifcdimensionalexponents(-1,1,-2,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	else:
		return UNKNOWN

####################
 # FUNCTION ifcdimensionsforsiunit #
####################
def ifcdimensionsforsiunit(n,):
	'''
	:param n
	:type n:ifcsiunitname
	'''
	case_selector = n
	if  case_selector == metre:
		return ifcdimensionalexponents(1,0,0,0,0,0,0)
	elif case_selector == square_metre:
		return ifcdimensionalexponents(2,0,0,0,0,0,0)
	elif case_selector == cubic_metre:
		return ifcdimensionalexponents(3,0,0,0,0,0,0)
	elif case_selector == gram:
		return ifcdimensionalexponents(0,1,0,0,0,0,0)
	elif case_selector == second:
		return ifcdimensionalexponents(0,0,1,0,0,0,0)
	elif case_selector == ampere:
		return ifcdimensionalexponents(0,0,0,1,0,0,0)
	elif case_selector == kelvin:
		return ifcdimensionalexponents(0,0,0,0,1,0,0)
	elif case_selector == mole:
		return ifcdimensionalexponents(0,0,0,0,0,1,0)
	elif case_selector == candela:
		return ifcdimensionalexponents(0,0,0,0,0,0,1)
	elif case_selector == radian:
		return ifcdimensionalexponents(0,0,0,0,0,0,0)
	elif case_selector == steradian:
		return ifcdimensionalexponents(0,0,0,0,0,0,0)
	elif case_selector == hertz:
		return ifcdimensionalexponents(0,0,-1,0,0,0,0)
	elif case_selector == newton:
		return ifcdimensionalexponents(1,1,-2,0,0,0,0)
	elif case_selector == pascal:
		return ifcdimensionalexponents(-1,1,-2,0,0,0,0)
	elif case_selector == joule:
		return ifcdimensionalexponents(2,1,-2,0,0,0,0)
	elif case_selector == watt:
		return ifcdimensionalexponents(2,1,-3,0,0,0,0)
	elif case_selector == coulomb:
		return ifcdimensionalexponents(0,0,1,1,0,0,0)
	elif case_selector == volt:
		return ifcdimensionalexponents(2,1,-3,-1,0,0,0)
	elif case_selector == farad:
		return ifcdimensionalexponents(-2,-1,4,2,0,0,0)
	elif case_selector == ohm:
		return ifcdimensionalexponents(2,1,-3,-2,0,0,0)
	elif case_selector == siemens:
		return ifcdimensionalexponents(-2,-1,3,2,0,0,0)
	elif case_selector == weber:
		return ifcdimensionalexponents(2,1,-2,-1,0,0,0)
	elif case_selector == tesla:
		return ifcdimensionalexponents(0,1,-2,-1,0,0,0)
	elif case_selector == henry:
		return ifcdimensionalexponents(2,1,-2,-2,0,0,0)
	elif case_selector == degree_celsius:
		return ifcdimensionalexponents(0,0,0,0,1,0,0)
	elif case_selector == lumen:
		return ifcdimensionalexponents(0,0,0,0,0,0,1)
	elif case_selector == lux:
		return ifcdimensionalexponents(-2,0,0,0,0,0,1)
	elif case_selector == becquerel:
		return ifcdimensionalexponents(0,0,-1,0,0,0,0)
	elif case_selector == gray:
		return ifcdimensionalexponents(2,0,-2,0,0,0,0)
	elif case_selector == sievert:
		return ifcdimensionalexponents(2,0,-2,0,0,0,0)
	else:
		return ifcdimensionalexponents(0,0,0,0,0,0,0)

####################
 # FUNCTION ifcmlstotalthickness #
####################
def ifcmlstotalthickness(layerset,):
	'''
	:param layerset
	:type layerset:ifcmateriallayerset
	'''
	if (SIZEOF(layerset.materiallayers)  >  1):
		for  i in range(2,HIINDEX(layerset.materiallayers),1):
			max = max  +  layerset.materiallayers[i].layerthickness
	return max

####################
 # FUNCTION ifccorrectobjectassignment #
####################
def ifccorrectobjectassignment(constraint,objects,):
	'''
	:param constraint
	:type constraint:ifcobjecttypeenum
	:param objects
	:type objects:(null)
	'''
	if ( not EXISTS(constraint)):
		return TRUE
	case_selector = constraint
	if  case_selector == ifcobjecttypeenum.notdefined:
		return TRUE
	elif case_selector == ifcobjecttypeenum.product:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.process:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.control:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.resource:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.actor:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.group:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.project:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	else:
		return  None 

####################
 # FUNCTION ifccurveweightspositive #
####################
def ifccurveweightspositive(b,):
	'''
	:param b
	:type b:ifcrationalbsplinecurvewithknots
	'''
	for  i in range(0,b.upperindexoncontrolpoints,1):
		if (b.weights[i]  <=  0):
			result = FALSE
			return result
	return result

####################
 # FUNCTION ifcsameaxis2placement #
####################
def ifcsameaxis2placement(ap1,ap2,epsilon,):
	'''
	:param ap1
	:type ap1:ifcaxis2placement
	:param ap2
	:type ap2:ifcaxis2placement
	:param epsilon
	:type epsilon:REAL
	'''
	return (ifcsamedirection(ap1.p[1],ap2.p[1],epsilon)  and  ifcsamedirection(ap1.p[2],ap2.p[2],epsilon))  and  ifcsamecartesianpoint(ap1.location,ap1.location,epsilon)

####################
 # FUNCTION ifcbuild2axes #
####################
def ifcbuild2axes(refdirection,):
	'''
	:param refdirection
	:type refdirection:ifcdirection
	'''
	return [d,ifcorthogonalcomplement(d)]

####################
 # FUNCTION ifcconstraintsparambspline #
####################
def ifcconstraintsparambspline(degree,upknots,upcp,knotmult,knots,):
	'''
	:param degree
	:type degree:INTEGER
	:param upknots
	:type upknots:INTEGER
	:param upcp
	:type upcp:INTEGER
	:param knotmult
	:type knotmult:(null)
	:param knots
	:type knots:(null)
	'''
	sum = knotmult[1]
	for  i in range(2,upknots,1):
		sum = sum  +  knotmult[i]
	if ((((degree  <  1)  or  (upknots  <  2))  or  (upcp  <  degree))  or  (sum  !=  ((degree  +  upcp)  +  2))):
		result = FALSE
		return result
	k = knotmult[1]
	if ((k  <  1)  or  (k  >  (degree  +  1))):
		result = FALSE
		return result
	for  i in range(2,upknots,1):
		if ((knotmult[i]  <  1)  or  (knots[i]  <=  knots[i - 1])):
			result = FALSE
			return result
		k = knotmult[i]
		if ((i  <  upknots)  and  (k  >  degree)):
			result = FALSE
			return result
		if ((i  ==  upknots)  and  (k  >  (degree  +  1))):
			result = FALSE
			return result
	return result

####################
 # FUNCTION ifccrossproduct #
####################
def ifccrossproduct(arg1,arg2,):
	'''
	:param arg1
	:type arg1:ifcdirection
	:param arg2
	:type arg2:ifcdirection
	'''
	if ((( not EXISTS(arg1))  or  (arg1.dim  ==  2))  or  (( not EXISTS(arg2))  or  (arg2.dim  ==  2))):
		return  None 
	else:
		# begin/end block
		v1 = ifcnormalise(arg1).ifcdirection.directionratios
		v2 = ifcnormalise(arg2).ifcdirection.directionratios
		res = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([(v1[2]  *  v2[3]) - (v1[3]  *  v2[2]),(v1[3]  *  v2[1]) - (v1[1]  *  v2[3]),(v1[1]  *  v2[2]) - (v1[2]  *  v2[1])])
		mag = 0
		for  i in range(1,3,1):
			mag = mag  +  (res.directionratios[i]  *  res.directionratios[i])
		if (mag  >  0):
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(res,SQRT(mag))
		else:
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(arg1,0)
		return result

####################
 # FUNCTION ifcsurfaceweightspositive #
####################
def ifcsurfaceweightspositive(b,):
	'''
	:param b
	:type b:ifcrationalbsplinesurfacewithknots
	'''
	for  i in range(0,b.ifcbsplinesurface.uupper,1):
		for  j in range(0,b.ifcbsplinesurface.vupper,1):
			if (b.weights[i][j]  <=  0):
				result = FALSE
				return result
	return result

####################
 # FUNCTION ifcsamecartesianpoint #
####################
def ifcsamecartesianpoint(cp1,cp2,epsilon,):
	'''
	:param cp1
	:type cp1:ifccartesianpoint
	:param cp2
	:type cp2:ifccartesianpoint
	:param epsilon
	:type epsilon:REAL
	'''
	if (SIZEOF(cp1.coordinates)  >  2):
		cp1z = cp1.coordinates[3]
	if (SIZEOF(cp2.coordinates)  >  2):
		cp2z = cp2.coordinates[3]
	return (ifcsamevalue(cp1x,cp2x,epsilon)  and  ifcsamevalue(cp1y,cp2y,epsilon))  and  ifcsamevalue(cp1z,cp2z,epsilon)

####################
 # RULE ifcsingleprojectinstance #
####################
ifcsingleprojectinstance = Rule()

####################
 # RULE ifcrepresentationcontextsamewcs #
####################
ifcrepresentationcontextsamewcs = Rule()
