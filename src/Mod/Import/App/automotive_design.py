# This file was generated by fedex_python.  You probably don't want to edit
# it since your modifications will be lost if fedex_plus is used to
# regenerate it.
import sys

from SCL.SCLBase import *
from SCL.SimpleDataTypes import *
from SCL.ConstructedDataTypes import *
from SCL.AggregationDataTypes import *
from SCL.TypeChecker import check_type
from SCL.Builtin import *
from SCL.Rules import *

schema_name = 'automotive_design'

schema_scope = sys.modules[__name__]

# SELECT TYPE characterized_definition
characterized_definition = SELECT(
	'characterized_object',
	'characterized_product_definition',
	'shape_definition',
	scope = schema_scope)
# Defined datatype parameter_value
class parameter_value(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype plane_angle_measure
class plane_angle_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype box_rotate_angle
class box_rotate_angle(plane_angle_measure):
	def __init__(self,*kargs):
		pass

# SELECT TYPE attribute_language_item
attribute_language_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'action_relationship',
	'alternate_product_relationship',
	'application_context',
	'approval_relationship',
	'assembly_component_usage_substitute',
	'attribute_value_assignment',
	'certification',
	'configuration_design',
	'configuration_item',
	'contract',
	'data_environment',
	'date_role',
	'date_time_role',
	'descriptive_representation_item',
	'document_relationship',
	'draughting_title',
	'effectivity',
	'effectivity_relationship',
	'event_occurrence',
	'external_source',
	'general_property',
	'general_property_relationship',
	'geometric_representation_item',
	'geometric_tolerance',
	'group',
	'group_relationship',
	'identification_role',
	'kinematic_pair',
	'mapped_item',
	'name_assignment',
	'organization_relationship',
	'organization_role',
	'organizational_project',
	'organizational_project_relationship',
	'pair_actuator',
	'person_and_organization_role',
	'presentation_layer_assignment',
	'process_product_association',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_relationship',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_substitute',
	'product_related_product_category',
	'property_definition',
	'property_definition_relationship',
	'representation',
	'representation_relationship',
	'requirement_for_action_resource',
	'resource_property',
	'resource_requirement_type',
	'security_classification',
	'shape_aspect',
	'shape_aspect_relationship',
	'styled_item',
	'time_interval_role',
	'topological_representation_item',
	'uncertainty_measure_with_unit',
	'uncertainty_qualifier',
	'versioned_action_request',
	'versioned_action_request_relationship',
	scope = schema_scope)
# SELECT TYPE configured_effectivity_context_item
configured_effectivity_context_item = SELECT(
	'product_concept_feature_association',
	scope = schema_scope)
# Defined datatype surface_tolerance_parameter
class surface_tolerance_parameter(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE font_select
font_select = SELECT(
	'pre_defined_text_font',
	'externally_defined_text_font',
	scope = schema_scope)
# Defined datatype text
class text(STRING):
	def __init__(self,*kargs):
		pass

# SELECT TYPE action_request_item
action_request_item = SELECT(
	'action',
	'action_method',
	'action_property',
	'action_relationship',
	'alternate_product_relationship',
	'assembly_component_usage_substitute',
	'configuration_design',
	'configuration_effectivity',
	'configuration_item',
	'configured_effectivity_assignment',
	'document_file',
	'draughting_model',
	'drawing_revision',
	'general_property',
	'material_designation',
	'mechanical_design_geometric_presentation_representation',
	'organizational_project',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_feature_category',
	'product_concept_feature_category_usage',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	'product_definition_substitute',
	'property_definition',
	'resource_property',
	'shape_aspect',
	'shape_representation',
	scope = schema_scope)
# SELECT TYPE draughting_callout_element
draughting_callout_element = SELECT(
	'annotation_text_occurrence',
	'annotation_symbol_occurrence',
	'annotation_curve_occurrence',
	scope = schema_scope)
# SELECT TYPE name_item
name_item = SELECT(
	'kinematic_joint',
	'kinematic_link',
	'kinematic_structure',
	scope = schema_scope)
# SELECT TYPE classification_item
classification_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'action_relationship',
	'approval_status',
	'class_',
	'configuration_item',
	'contract',
	'descriptive_representation_item',
	'document_file',
	'document_type',
	'effectivity',
	'executed_action',
	'feature_definition',
	'general_feature',
	'general_property',
	'material_designation',
	'organizational_project',
	'plus_minus_tolerance',
	'process_operation',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_category',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	'property_definition',
	'resource_property',
	'security_classification_level',
	'shape_aspect',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE curve_font_or_scaled_curve_font_select
curve_font_or_scaled_curve_font_select = SELECT(
	'curve_style_font_select',
	scope = schema_scope)
# SELECT TYPE translational_range_measure
translational_range_measure = SELECT(
	'length_measure',
	'unlimited_range',
	scope = schema_scope)
# Defined datatype year_number
class year_number(INTEGER):
	def __init__(self,*kargs):
		pass

# SELECT TYPE characterized_product_definition
characterized_product_definition = SELECT(
	'product_definition',
	'product_definition_relationship',
	scope = schema_scope)
# Defined datatype curve_tolerance_parameter
class curve_tolerance_parameter(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE reversible_topology_item
reversible_topology_item = SELECT(
	'edge',
	'path',
	'face',
	'face_bound',
	'closed_shell',
	'open_shell',
	scope = schema_scope)
# SELECT TYPE size_select
size_select = SELECT(
	'positive_length_measure',
	'measure_with_unit',
	'descriptive_measure',
	scope = schema_scope)
# SELECT TYPE axis2_placement
axis2_placement = SELECT(
	'axis2_placement_2d',
	'axis2_placement_3d',
	scope = schema_scope)
# SELECT TYPE symbol_style_select
symbol_style_select = SELECT(
	'symbol_colour',
	scope = schema_scope)
# SELECT TYPE presentation_style_select
presentation_style_select = SELECT(
	'pre_defined_presentation_style',
	'point_style',
	'curve_style',
	'surface_style_usage',
	'symbol_style',
	'fill_area_style',
	'text_style',
	'approximation_tolerance',
	'externally_defined_style',
	'null_style',
	scope = schema_scope)
set_of_reversible_topology_item = SET(0,None,'reversible_topology_item', scope = schema_scope)
# Defined datatype central_or_parallel
class central_or_parallel(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE action_item
action_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'action_relationship',
	'action_request_solution',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_classification_assignment',
	'applied_person_and_organization_assignment',
	'approval_status',
	'assembly_component_usage_substitute',
	'certification',
	'class_',
	'class_system',
	'configuration_design',
	'configuration_effectivity',
	'configuration_item',
	'configured_effectivity_assignment',
	'contract',
	'document_file',
	'draughting_model',
	'drawing_revision',
	'executed_action',
	'general_property',
	'material_designation',
	'mechanical_design_geometric_presentation_representation',
	'organization_relationship',
	'organizational_project',
	'person_and_organization',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_feature_category',
	'product_concept_feature_category_usage',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_substitute',
	'property_definition',
	'requirement_for_action_resource',
	'resource_property',
	'security_classification',
	'security_classification_level',
	'shape_aspect',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# Defined datatype limit_condition
class limit_condition(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype knot_type
class knot_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE rotational_range_measure
rotational_range_measure = SELECT(
	'plane_angle_measure',
	'unlimited_range',
	scope = schema_scope)
# SELECT TYPE specified_item
specified_item = SELECT(
	'drawing_revision',
	scope = schema_scope)
# Defined datatype thermodynamic_temperature_measure
class thermodynamic_temperature_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE presented_item_select
presented_item_select = SELECT(
	'action',
	'action_method',
	'action_relationship',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_category',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	scope = schema_scope)
set_representation_item = SET(1,None,'representation_item', scope = schema_scope)
# SELECT TYPE presentation_representation_select
presentation_representation_select = SELECT(
	'presentation_representation',
	'presentation_set',
	scope = schema_scope)
# SELECT TYPE text_or_character
text_or_character = SELECT(
	'annotation_text',
	'annotation_text_character',
	'defined_character_glyph',
	'composite_text',
	'text_literal',
	scope = schema_scope)
# Defined datatype minute_in_hour
class minute_in_hour(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <=  59))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype transition_code
class transition_code(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE character_style_select
character_style_select = SELECT(
	'text_style_for_defined_font',
	scope = schema_scope)
# SELECT TYPE annotation_symbol_occurrence_item
annotation_symbol_occurrence_item = SELECT(
	'annotation_symbol',
	'defined_symbol',
	scope = schema_scope)
# SELECT TYPE invisibility_context
invisibility_context = SELECT(
	'presentation_representation',
	'presentation_set',
	scope = schema_scope)
# SELECT TYPE external_identification_item
external_identification_item = SELECT(
	'document_file',
	'externally_defined_class',
	'externally_defined_general_property',
	'product_definition',
	scope = schema_scope)
# Defined datatype identifier
class identifier(STRING):
	def __init__(self,*kargs):
		pass

# SELECT TYPE language_item
language_item = SELECT(
	'representation',
	scope = schema_scope)
# SELECT TYPE compound_item_definition
compound_item_definition = SELECT(
	'list_representation_item',
	'set_representation_item',
	scope = schema_scope)
# SELECT TYPE draughting_model_item_association_select
draughting_model_item_association_select = SELECT(
	'annotation_occurrence',
	'draughting_callout',
	scope = schema_scope)
# Defined datatype non_negative_length_measure
class non_negative_length_measure(length_measure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE represented_definition
represented_definition = SELECT(
	'general_property',
	'property_definition',
	'property_definition_relationship',
	'shape_aspect',
	'shape_aspect_relationship',
	scope = schema_scope)
# SELECT TYPE text_string_representation_item
text_string_representation_item = SELECT(
	'text_literal',
	'annotation_text',
	'annotation_text_character',
	'defined_character_glyph',
	'composite_text',
	'axis2_placement',
	scope = schema_scope)
# SELECT TYPE event_occurrence_item
event_occurrence_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'action_relationship',
	'action_request_solution',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_classification_assignment',
	'applied_person_and_organization_assignment',
	'approval_status',
	'assembly_component_usage_substitute',
	'certification',
	'class_',
	'class_system',
	'configuration_design',
	'configuration_effectivity',
	'configuration_item',
	'configured_effectivity_assignment',
	'contract',
	'document_file',
	'draughting_model',
	'drawing_revision',
	'executed_action',
	'general_property',
	'material_designation',
	'mechanical_design_geometric_presentation_representation',
	'organization_relationship',
	'organizational_project',
	'person_and_organization',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_feature_category',
	'product_concept_feature_category_usage',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_substitute',
	'property_definition',
	'requirement_for_action_resource',
	'resource_property',
	'security_classification',
	'security_classification_level',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE measure_value
measure_value = SELECT(
	'amount_of_substance_measure',
	'area_measure',
	'celsius_temperature_measure',
	'context_dependent_measure',
	'count_measure',
	'descriptive_measure',
	'electric_current_measure',
	'length_measure',
	'luminous_intensity_measure',
	'mass_measure',
	'numeric_measure',
	'non_negative_length_measure',
	'parameter_value',
	'plane_angle_measure',
	'positive_length_measure',
	'positive_plane_angle_measure',
	'positive_ratio_measure',
	'ratio_measure',
	'solid_angle_measure',
	'thermodynamic_temperature_measure',
	'time_measure',
	'volume_measure',
	scope = schema_scope)
# SELECT TYPE person_organization_select
person_organization_select = SELECT(
	'person',
	'organization',
	'person_and_organization',
	scope = schema_scope)
# SELECT TYPE presentation_size_assignment_select
presentation_size_assignment_select = SELECT(
	'presentation_view',
	'presentation_area',
	'area_in_set',
	scope = schema_scope)
# SELECT TYPE date_and_time_item
date_and_time_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'action_relationship',
	'action_request_solution',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_classification_assignment',
	'applied_organization_assignment',
	'applied_person_and_organization_assignment',
	'approval_person_organization',
	'approval_status',
	'assembly_component_usage_substitute',
	'certification',
	'class_',
	'class_system',
	'configuration_design',
	'configuration_item',
	'configured_effectivity_assignment',
	'contract',
	'document_file',
	'draughting_model',
	'drawing_revision',
	'effectivity',
	'event_occurrence',
	'executed_action',
	'general_property',
	'material_designation',
	'mechanical_design_geometric_presentation_representation',
	'organization_relationship',
	'organizational_project',
	'person_and_organization',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_feature_category',
	'product_concept_feature_category_usage',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_substitute',
	'property_definition',
	'requirement_for_action_resource',
	'resource_property',
	'security_classification',
	'security_classification_level',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# Defined datatype preferred_surface_curve_representation
class preferred_surface_curve_representation(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE property_or_shape_select
property_or_shape_select = SELECT(
	'property_definition',
	'shape_definition',
	scope = schema_scope)
# SELECT TYPE rendering_properties_select
rendering_properties_select = SELECT(
	'surface_style_reflectance_ambient',
	'surface_style_transparent',
	scope = schema_scope)
# Defined datatype u_direction_count
class u_direction_count(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype dimension_count
class dimension_count(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE spatial_rotation
spatial_rotation = SELECT(
	'ypr_rotation',
	'rotation_about_direction',
	scope = schema_scope)
list_representation_item = LIST(1,None,'representation_item', scope = schema_scope)
# SELECT TYPE csg_select
csg_select = SELECT(
	'boolean_result',
	'csg_primitive',
	scope = schema_scope)
# Defined datatype curve_tolerance_deviation
class curve_tolerance_deviation(positive_length_measure):
	def __init__(self,*kargs):
		pass

# SELECT TYPE layered_item
layered_item = SELECT(
	'presentation_representation',
	'representation_item',
	scope = schema_scope)
# SELECT TYPE pcurve_or_surface
pcurve_or_surface = SELECT(
	'pcurve',
	'surface',
	scope = schema_scope)
# SELECT TYPE tolerance_deviation_select
tolerance_deviation_select = SELECT(
	'curve_tolerance_deviation',
	'surface_tolerance_deviation',
	scope = schema_scope)
# Defined datatype positive_length_measure
class positive_length_measure(non_negative_length_measure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype dimension_extent_usage
class dimension_extent_usage(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE attribute_type
attribute_type = SELECT(
	'label',
	'text',
	scope = schema_scope)
# Defined datatype box_width
class box_width(positive_ratio_measure):
	def __init__(self,*kargs):
		pass

# SELECT TYPE id_attribute_select
id_attribute_select = SELECT(
	'action',
	'address',
	'product_category',
	'property_definition',
	'shape_aspect',
	'shape_aspect_relationship',
	'application_context',
	'group',
	'organizational_project',
	'representation',
	scope = schema_scope)
# SELECT TYPE invisible_item
invisible_item = SELECT(
	'draughting_callout',
	'presentation_layer_assignment',
	'representation',
	'styled_item',
	scope = schema_scope)
# SELECT TYPE kinematic_frame_background
kinematic_frame_background = SELECT(
	'point',
	'curve',
	'surface',
	scope = schema_scope)
# Defined datatype numeric_measure
class numeric_measure(NUMBER):
	def __init__(self,*kargs):
		pass

# Defined datatype box_slant_angle
class box_slant_angle(plane_angle_measure):
	def __init__(self,*kargs):
		pass

# Defined datatype b_spline_curve_form
class b_spline_curve_form(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE effectivity_item
effectivity_item = SELECT(
	'action',
	'action_method',
	'action_method_relationship',
	'action_property',
	'action_relationship',
	'assembly_component_usage_substitute',
	'class_',
	'class_system',
	'configuration_design',
	'configuration_item',
	'configured_effectivity_assignment',
	'document_file',
	'draughting_model',
	'drawing_revision',
	'general_property',
	'material_designation',
	'mechanical_design_geometric_presentation_representation',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_feature_category',
	'product_concept_feature_category_usage',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_substitute',
	'property_definition',
	'requirement_for_action_resource',
	'resource_property',
	'security_classification',
	'shape_aspect',
	'shape_representation',
	scope = schema_scope)
# SELECT TYPE multi_language_attribute_item
multi_language_attribute_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'action_relationship',
	'alternate_product_relationship',
	'application_context',
	'approval_relationship',
	'assembly_component_usage_substitute',
	'certification',
	'configuration_design',
	'configuration_item',
	'contract',
	'data_environment',
	'date_role',
	'date_time_role',
	'descriptive_representation_item',
	'document_relationship',
	'draughting_title',
	'effectivity',
	'effectivity_relationship',
	'event_occurrence',
	'external_source',
	'general_property',
	'general_property_relationship',
	'geometric_representation_item',
	'geometric_tolerance',
	'group',
	'group_relationship',
	'identification_role',
	'kinematic_pair',
	'mapped_item',
	'name_assignment',
	'organization_relationship',
	'organization_role',
	'organizational_project',
	'organizational_project_relationship',
	'pair_actuator',
	'person_and_organization_role',
	'presentation_layer_assignment',
	'process_product_association',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_relationship',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_substitute',
	'product_related_product_category',
	'property_definition',
	'property_definition_relationship',
	'representation',
	'representation_relationship',
	'requirement_for_action_resource',
	'resource_property',
	'resource_requirement_type',
	'security_classification',
	'shape_aspect',
	'shape_aspect_relationship',
	'styled_item',
	'time_interval_role',
	'topological_representation_item',
	'uncertainty_measure_with_unit',
	'uncertainty_qualifier',
	'versioned_action_request',
	'versioned_action_request_relationship',
	scope = schema_scope)
# SELECT TYPE draughting_titled_item
draughting_titled_item = SELECT(
	'drawing_revision',
	'drawing_sheet_revision',
	scope = schema_scope)
# Defined datatype hour_in_day
class hour_in_day(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <  24))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE surface_style_element_select
surface_style_element_select = SELECT(
	'surface_style_fill_area',
	'surface_style_boundary',
	'surface_style_silhouette',
	'surface_style_segmentation_curve',
	'surface_style_control_grid',
	'surface_style_parameter_line',
	'surface_style_rendering',
	scope = schema_scope)
# Defined datatype v_direction_count
class v_direction_count(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype approximation_method
class approximation_method(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE security_classification_item
security_classification_item = SELECT(
	'action',
	'action_directive',
	'action_property',
	'applied_action_assignment',
	'assembly_component_usage_substitute',
	'class_system',
	'configuration_design',
	'configuration_effectivity',
	'configured_effectivity_assignment',
	'document_file',
	'draughting_model',
	'drawing_revision',
	'executed_action',
	'general_property',
	'material_designation',
	'mechanical_design_geometric_presentation_representation',
	'organizational_project',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_category',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	'property_definition',
	'resource_property',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE dimensional_characteristic
dimensional_characteristic = SELECT(
	'dimensional_location',
	'dimensional_size',
	scope = schema_scope)
# Defined datatype ratio_measure
class ratio_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE document_reference_item
document_reference_item = SELECT(
	'action_directive',
	'action_method',
	'action_relationship',
	'applied_action_assignment',
	'approval',
	'certification',
	'class_',
	'class_system',
	'configuration_design',
	'configuration_item',
	'contract',
	'descriptive_representation_item',
	'executed_action',
	'externally_defined_dimension_definition',
	'feature_definition',
	'general_property',
	'material_designation',
	'organization',
	'organizational_project',
	'person',
	'presentation_area',
	'process_plan',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_category',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_process',
	'product_definition_relationship',
	'product_definition_substitute',
	'product_related_product_category',
	'property_definition',
	'representation',
	'resource_requirement_type',
	'retention',
	'security_classification',
	'shape_aspect',
	'shape_aspect_relationship',
	'versioned_action_request',
	scope = schema_scope)
# Defined datatype si_unit_name
class si_unit_name(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype amount_of_substance_measure
class amount_of_substance_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE motion_parameter_measure
motion_parameter_measure = SELECT(
	'parameter_value',
	'measure_with_unit',
	scope = schema_scope)
# Defined datatype day_in_month_number
class day_in_month_number(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((1  <=  self)  and  (self  <=  31))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE area_or_view
area_or_view = SELECT(
	'presentation_area',
	'presentation_view',
	scope = schema_scope)
# Defined datatype electric_current_measure
class electric_current_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE founded_item_select
founded_item_select = SELECT(
	'founded_item',
	'representation_item',
	scope = schema_scope)
# SELECT TYPE style_context_select
style_context_select = SELECT(
	'group',
	'presentation_layer_assignment',
	'presentation_set',
	'representation',
	'representation_item',
	'shape_representation_relationship',
	scope = schema_scope)
# SELECT TYPE kinematic_analysis_definition
kinematic_analysis_definition = SELECT(
	'interpolated_configuration_sequence',
	scope = schema_scope)
# SELECT TYPE source_item
source_item = SELECT(
	'identifier',
	scope = schema_scope)
# Defined datatype trimming_preference
class trimming_preference(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE contract_item
contract_item = SELECT(
	'drawing_revision',
	'executed_action',
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE configured_effectivity_item
configured_effectivity_item = SELECT(
	'action_relationship',
	'process_plan',
	'product_definition',
	'product_process_plan',
	scope = schema_scope)
# SELECT TYPE date_time_or_event_occurrence
date_time_or_event_occurrence = SELECT(
	'date_time_select',
	'event_occurrence',
	scope = schema_scope)
# SELECT TYPE derived_property_select
derived_property_select = SELECT(
	'property_definition',
	'action_property',
	'resource_property',
	scope = schema_scope)
# SELECT TYPE fill_area_style_tile_shape_select
fill_area_style_tile_shape_select = SELECT(
	'fill_area_style_tile_symbol_with_style',
	scope = schema_scope)
# Defined datatype shading_surface_method
class shading_surface_method(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE vector_or_direction
vector_or_direction = SELECT(
	'vector',
	'direction',
	scope = schema_scope)
# SELECT TYPE approval_item
approval_item = SELECT(
	'action',
	'action_directive',
	'action_property',
	'action_request_solution',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_classification_assignment',
	'assembly_component_usage_substitute',
	'certification',
	'class_',
	'class_system',
	'configuration_design',
	'configuration_effectivity',
	'configured_effectivity_assignment',
	'contract',
	'document_file',
	'draughting_model',
	'drawing_revision',
	'executed_action',
	'general_property',
	'material_designation',
	'mechanical_design_geometric_presentation_representation',
	'organizational_project',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_feature_category',
	'product_concept_feature_category_usage',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	'product_definition_substitute',
	'property_definition',
	'resource_property',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# Defined datatype volume_measure
class volume_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE geometric_set_select
geometric_set_select = SELECT(
	'point',
	'curve',
	'surface',
	scope = schema_scope)
# Defined datatype positive_plane_angle_measure
class positive_plane_angle_measure(plane_angle_measure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype text_delineation
class text_delineation(label):
	def __init__(self,*kargs):
		pass

# SELECT TYPE category_usage_item
category_usage_item = SELECT(
	'product_class',
	scope = schema_scope)
# SELECT TYPE defined_symbol_select
defined_symbol_select = SELECT(
	'pre_defined_symbol',
	'externally_defined_symbol',
	scope = schema_scope)
# Defined datatype b_spline_surface_form
class b_spline_surface_form(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype null_style
class null_style(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype marker_type
class marker_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE shell
shell = SELECT(
	'open_shell',
	'closed_shell',
	scope = schema_scope)
# SELECT TYPE defined_glyph_select
defined_glyph_select = SELECT(
	'externally_defined_character_glyph',
	scope = schema_scope)
# SELECT TYPE transformation
transformation = SELECT(
	'item_defined_transformation',
	'functionally_defined_transformation',
	scope = schema_scope)
# Defined datatype unlimited_range
class unlimited_range(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE boolean_operand
boolean_operand = SELECT(
	'solid_model',
	'half_space_solid',
	'csg_primitive',
	'boolean_result',
	scope = schema_scope)
# Defined datatype text_path
class text_path(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE date_time_select
date_time_select = SELECT(
	'date',
	'date_and_time',
	'local_time',
	scope = schema_scope)
# Defined datatype solid_angle_measure
class solid_angle_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE csg_primitive
csg_primitive = SELECT(
	'sphere',
	'block',
	'right_angular_wedge',
	'torus',
	'right_circular_cone',
	'right_circular_cylinder',
	scope = schema_scope)
ypr_rotation = ARRAY(ypr_index(yaw),ypr_index(roll),'REAL', scope = schema_scope)
# SELECT TYPE marker_select
marker_select = SELECT(
	'marker_type',
	'pre_defined_marker',
	scope = schema_scope)
# Defined datatype surface_side
class surface_side(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype luminous_intensity_measure
class luminous_intensity_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE organization_item
organization_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'action_relationship',
	'action_request_solution',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_classification_assignment',
	'applied_identification_assignment',
	'applied_organization_assignment',
	'applied_person_and_organization_assignment',
	'approval',
	'approval_status',
	'assembly_component_usage_substitute',
	'certification',
	'class_',
	'class_system',
	'configuration_design',
	'configuration_effectivity',
	'configuration_item',
	'configured_effectivity_assignment',
	'contract',
	'document_file',
	'document_type',
	'draughting_model',
	'drawing_revision',
	'effectivity',
	'event_occurrence',
	'executed_action',
	'general_property',
	'material_designation',
	'mechanical_design_geometric_presentation_representation',
	'organization',
	'organization_relationship',
	'organizational_project',
	'person_and_organization',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_feature_category',
	'product_concept_feature_category_usage',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_substitute',
	'property_definition',
	'requirement_for_action_resource',
	'resource_property',
	'security_classification',
	'security_classification_level',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# Defined datatype presentable_text
class presentable_text(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = control_characters_free(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE product_or_formation_or_definition
product_or_formation_or_definition = SELECT(
	'product',
	'product_definition_formation',
	'product_definition',
	scope = schema_scope)
# Defined datatype time_measure
class time_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE curve_on_surface
curve_on_surface = SELECT(
	'pcurve',
	'surface_curve',
	'composite_curve_on_surface',
	scope = schema_scope)
# SELECT TYPE trimming_select
trimming_select = SELECT(
	'cartesian_point',
	'parameter_value',
	scope = schema_scope)
# SELECT TYPE curve_style_font_select
curve_style_font_select = SELECT(
	'curve_style_font',
	'pre_defined_curve_font',
	'externally_defined_curve_font',
	scope = schema_scope)
# SELECT TYPE role_select
role_select = SELECT(
	'action_assignment',
	'action_request_assignment',
	'approval_assignment',
	'approval_date_time',
	'certification_assignment',
	'contract_assignment',
	'document_reference',
	'effectivity_assignment',
	'group_assignment',
	'name_assignment',
	'security_classification_assignment',
	scope = schema_scope)
# Defined datatype ahead_or_behind
class ahead_or_behind(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype mass_measure
class mass_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE tolerance_parameter_select
tolerance_parameter_select = SELECT(
	'curve_tolerance_parameter',
	'surface_tolerance_parameter',
	scope = schema_scope)
# Defined datatype angle_relator
class angle_relator(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE characterized_action_definition
characterized_action_definition = SELECT(
	'action',
	'action_method',
	'action_method_relationship',
	'action_relationship',
	scope = schema_scope)
# SELECT TYPE tolerance_method_definition
tolerance_method_definition = SELECT(
	'tolerance_value',
	'limits_and_fits',
	scope = schema_scope)
# SELECT TYPE group_item
group_item = SELECT(
	'geometric_representation_item',
	'mapped_item',
	'product_concept_feature',
	'shape_aspect',
	'styled_item',
	'topological_representation_item',
	scope = schema_scope)
# SELECT TYPE plane_or_planar_box
plane_or_planar_box = SELECT(
	'plane',
	'planar_box',
	scope = schema_scope)
# Defined datatype positive_ratio_measure
class positive_ratio_measure(ratio_measure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE time_interval_item
time_interval_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'action_relationship',
	'action_request_solution',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_classification_assignment',
	'applied_person_and_organization_assignment',
	'approval_status',
	'assembly_component_usage_substitute',
	'certification',
	'class_',
	'class_system',
	'configuration_design',
	'configuration_effectivity',
	'configuration_item',
	'configured_effectivity_assignment',
	'contract',
	'document_file',
	'draughting_model',
	'drawing_revision',
	'executed_action',
	'general_property',
	'material_designation',
	'mechanical_design_geometric_presentation_representation',
	'organization_relationship',
	'organizational_project',
	'person_and_organization',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_feature_category',
	'product_concept_feature_category_usage',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_substitute',
	'property_definition',
	'requirement_for_action_resource',
	'resource_property',
	'security_classification',
	'security_classification_level',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE character_spacing_select
character_spacing_select = SELECT(
	'length_measure',
	'ratio_measure',
	'measure_with_unit',
	'descriptive_measure',
	scope = schema_scope)
# Defined datatype surface_tolerance_deviation
class surface_tolerance_deviation(positive_length_measure):
	def __init__(self,*kargs):
		pass

# Defined datatype shading_curve_method
class shading_curve_method(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE description_attribute_select
description_attribute_select = SELECT(
	'action_request_solution',
	'application_context',
	'approval_role',
	'configuration_design',
	'date_role',
	'date_time_role',
	'context_dependent_shape_representation',
	'effectivity',
	'external_source',
	'organization_role',
	'person_and_organization_role',
	'person_and_organization',
	'property_definition_representation',
	'representation',
	scope = schema_scope)
# Defined datatype descriptive_measure
class descriptive_measure(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype area_measure
class area_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE characterized_resource_definition
characterized_resource_definition = SELECT(
	'action_resource',
	'action_resource_requirement',
	scope = schema_scope)
# Defined datatype text_alignment
class text_alignment(label):
	def __init__(self,*kargs):
		pass

# SELECT TYPE kinematic_result
kinematic_result = SELECT(
	'interpolated_configuration_sequence',
	'resulting_path',
	scope = schema_scope)
# Defined datatype month_in_year_number
class month_in_year_number(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((1  <=  self)  and  (self  <=  12))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype box_height
class box_height(positive_ratio_measure):
	def __init__(self,*kargs):
		pass

# SELECT TYPE curve_or_render
curve_or_render = SELECT(
	'curve_style',
	'curve_style_rendering',
	scope = schema_scope)
# Defined datatype source
class source(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE name_attribute_select
name_attribute_select = SELECT(
	'action_request_solution',
	'address',
	'configuration_design',
	'context_dependent_shape_representation',
	'derived_unit',
	'effectivity',
	'person_and_organization',
	'product_definition',
	'product_definition_substitute',
	'property_definition_representation',
	scope = schema_scope)
# SELECT TYPE unit
unit = SELECT(
	'derived_unit',
	'named_unit',
	scope = schema_scope)
# SELECT TYPE characterized_material_property
characterized_material_property = SELECT(
	'material_property_representation',
	scope = schema_scope)
# SELECT TYPE date_item
date_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'action_relationship',
	'action_request_solution',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_classification_assignment',
	'applied_organization_assignment',
	'applied_person_and_organization_assignment',
	'approval_person_organization',
	'approval_status',
	'assembly_component_usage_substitute',
	'certification',
	'class_',
	'class_system',
	'configuration_design',
	'configuration_item',
	'configured_effectivity_assignment',
	'contract',
	'document_file',
	'draughting_model',
	'drawing_revision',
	'effectivity',
	'event_occurrence',
	'executed_action',
	'general_property',
	'material_designation',
	'mechanical_design_geometric_presentation_representation',
	'organization_relationship',
	'organizational_project',
	'person_and_organization',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_feature_category',
	'product_concept_feature_category_usage',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_substitute',
	'property_definition',
	'requirement_for_action_resource',
	'resource_property',
	'security_classification',
	'security_classification_level',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE reversible_topology
reversible_topology = SELECT(
	'reversible_topology_item',
	'list_of_reversible_topology_item',
	'set_of_reversible_topology_item',
	scope = schema_scope)
# SELECT TYPE shape_definition
shape_definition = SELECT(
	'product_definition_shape',
	'shape_aspect',
	'shape_aspect_relationship',
	scope = schema_scope)
# Defined datatype celsius_temperature_measure
class celsius_temperature_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype second_in_minute
class second_in_minute(REAL):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <=  60))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE annotation_text_occurrence_item
annotation_text_occurrence_item = SELECT(
	'text_literal',
	'annotation_text',
	'annotation_text_character',
	'defined_character_glyph',
	'composite_text',
	scope = schema_scope)
# Defined datatype label
class label(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype context_dependent_measure
class context_dependent_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE supported_item
supported_item = SELECT(
	'action_directive',
	'action',
	'action_method',
	scope = schema_scope)
# SELECT TYPE tolerance_select
tolerance_select = SELECT(
	'approximation_tolerance_deviation',
	'approximation_tolerance_parameter',
	scope = schema_scope)
# Defined datatype boolean_operator
class boolean_operator(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE organizational_project_item
organizational_project_item = SELECT(
	'assembly_component_usage',
	'configuration_item',
	'executed_action',
	'product',
	'product_concept',
	'product_definition',
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE person_and_organization_item
person_and_organization_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'action_relationship',
	'action_request_solution',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_classification_assignment',
	'applied_organization_assignment',
	'applied_person_and_organization_assignment',
	'approval_status',
	'assembly_component_usage_substitute',
	'certification',
	'class_',
	'class_system',
	'configuration_design',
	'configuration_effectivity',
	'configuration_item',
	'configured_effectivity_assignment',
	'contract',
	'document_file',
	'document_type',
	'draughting_model',
	'drawing_revision',
	'event_occurrence',
	'executed_action',
	'general_property',
	'material_designation',
	'mechanical_design_geometric_presentation_representation',
	'organization',
	'organization_relationship',
	'organizational_project',
	'person_and_organization',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_association',
	'product_concept_feature_category',
	'product_concept_feature_category_usage',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_substitute',
	'property_definition',
	'requirement_for_action_resource',
	'resource_property',
	'security_classification',
	'security_classification_level',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE box_characteristic_select
box_characteristic_select = SELECT(
	'box_height',
	'box_width',
	'box_slant_angle',
	'box_rotate_angle',
	scope = schema_scope)
# Defined datatype si_prefix
class si_prefix(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE certification_item
certification_item = SELECT(
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	scope = schema_scope)
# SELECT TYPE fill_style_select
fill_style_select = SELECT(
	'fill_area_style_colour',
	'externally_defined_tile_style',
	'fill_area_style_tiles',
	'externally_defined_hatch_style',
	'fill_area_style_hatching',
	scope = schema_scope)
# SELECT TYPE value_qualifier
value_qualifier = SELECT(
	'precision_qualifier',
	'type_qualifier',
	'uncertainty_qualifier',
	scope = schema_scope)
# Defined datatype ypr_enumeration
class ypr_enumeration(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype interpolation_type
class interpolation_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype length_measure
class length_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype count_measure
class count_measure(NUMBER):
	def __init__(self,*kargs):
		pass

# SELECT TYPE annotation_plane_element
annotation_plane_element = SELECT(
	'draughting_callout',
	'styled_item',
	scope = schema_scope)
# SELECT TYPE rigid_placement
rigid_placement = SELECT(
	'axis2_placement_3d',
	scope = schema_scope)
# SELECT TYPE identification_item
identification_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'applied_identification_assignment',
	'approval_status',
	'class_',
	'class_system',
	'configuration_item',
	'dimensional_size',
	'document_file',
	'document_type',
	'draughting_model',
	'effectivity',
	'general_property',
	'measure_representation_item',
	'mechanical_design_geometric_presentation_representation',
	'organization',
	'organizational_project',
	'person_and_organization',
	'presentation_area',
	'product',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_category',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	'property_definition',
	'property_definition_relationship',
	'security_classification_level',
	'shape_aspect_relationship',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE direction_count_select
direction_count_select = SELECT(
	'u_direction_count',
	'v_direction_count',
	scope = schema_scope)
# Defined datatype product_or_presentation_space
class product_or_presentation_space(ENUMERATION):
	def __init__(self,*kargs):
		pass

list_of_reversible_topology_item = LIST(0,None,'reversible_topology_item', scope = schema_scope)
# SELECT TYPE configuration_design_item
configuration_design_item = SELECT(
	'product_definition',
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE class_usage_effectivity_context_item
class_usage_effectivity_context_item = SELECT(
	'product_definition',
	scope = schema_scope)
# SELECT TYPE surface_side_style_select
surface_side_style_select = SELECT(
	'surface_side_style',
	scope = schema_scope)

####################
 # ENTITY founded_item #
####################
class founded_item(BaseEntityClass):
	'''Entity founded_item definition.

	:param users
	:type users:SET(0,None,'founded_item_select', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def users():
		def fget( self ):
			attribute_eval = using_items(self,[])
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument users is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.users)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not (self  ==  self.users))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY curve_style #
####################
class curve_style(founded_item):
	'''Entity curve_style definition.

	:param name
	:type name:label

	:param curve_font
	:type curve_font:curve_font_or_scaled_curve_font_select

	:param curve_width
	:type curve_width:size_select

	:param curve_colour
	:type curve_colour:colour
	'''
	def __init__( self , name,curve_font,curve_width,curve_colour, ):
		founded_item.__init__(self , )
		self.name = name
		self.curve_font = curve_font
		self.curve_width = curve_width
		self.curve_colour = curve_colour

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def curve_font():
		def fget( self ):
			return self._curve_font
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_font is mantatory and can not be set to None')
			if not check_type(value,curve_font_or_scaled_curve_font_select):
				self._curve_font = curve_font_or_scaled_curve_font_select(value)
			else:
				self._curve_font = value
		return property(**locals())

	@apply
	def curve_width():
		def fget( self ):
			return self._curve_width
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_width is mantatory and can not be set to None')
			if not check_type(value,size_select):
				self._curve_width = size_select(value)
			else:
				self._curve_width = value
		return property(**locals())

	@apply
	def curve_colour():
		def fget( self ):
			return self._curve_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._curve_colour = colour(value)
			else:
				self._curve_colour = value
		return property(**locals())

####################
 # ENTITY pair_value #
####################
class pair_value(BaseEntityClass):
	'''Entity pair_value definition.

	:param applies_to_pair
	:type applies_to_pair:kinematic_pair
	'''
	def __init__( self , applies_to_pair, ):
		self.applies_to_pair = applies_to_pair

	@apply
	def applies_to_pair():
		def fget( self ):
			return self._applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,kinematic_pair):
				self._applies_to_pair = kinematic_pair(value)
			else:
				self._applies_to_pair = value
		return property(**locals())

####################
 # ENTITY point_on_surface_pair_value #
####################
class point_on_surface_pair_value(pair_value):
	'''Entity point_on_surface_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:point_on_surface_pair

	:param actual_point_on_surface
	:type actual_point_on_surface:point_on_surface

	:param input_orientation
	:type input_orientation:spatial_rotation

	:param actual_orientation
	:type actual_orientation:ARRAY(ypr_index(yaw),ypr_index(roll),'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_point_on_surface,input_orientation, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_point_on_surface = actual_point_on_surface
		self.input_orientation = input_orientation

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,point_on_surface_pair):
				self._pair_value_applies_to_pair = point_on_surface_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_point_on_surface():
		def fget( self ):
			return self._actual_point_on_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_point_on_surface is mantatory and can not be set to None')
			if not check_type(value,point_on_surface):
				self._actual_point_on_surface = point_on_surface(value)
			else:
				self._actual_point_on_surface = value
		return property(**locals())

	@apply
	def input_orientation():
		def fget( self ):
			return self._input_orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument input_orientation is mantatory and can not be set to None')
			if not check_type(value,spatial_rotation):
				self._input_orientation = spatial_rotation(value)
			else:
				self._input_orientation = value
		return property(**locals())

	@apply
	def actual_orientation():
		def fget( self ):
			attribute_eval = convert_spatial_to_ypr_rotation(self.self.pair_value.self.applies_to_pair,self.input_orientation)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument actual_orientation is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.pair_value.self.applies_to_pair.self.point_on_surface_pair.self.pair_surface  ==  self.actual_point_on_surface.self.basis_surface)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY generic_expression #
####################
class generic_expression(BaseEntityClass):
	'''Entity generic_expression definition.
	'''
	# This class does not define any attribute.
	pass
	def wr1(self):
		eval_wr1_wr = is_acyclic(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY expression #
####################
class expression(generic_expression):
	'''Entity expression definition.
	'''
	def __init__( self ,  ):
		generic_expression.__init__(self , )

####################
 # ENTITY numeric_expression #
####################
class numeric_expression(expression):
	'''Entity numeric_expression definition.

	:param is_int
	:type is_int:BOOLEAN

	:param sql_mappable
	:type sql_mappable:BOOLEAN
	'''
	def __init__( self ,  ):
		expression.__init__(self , )

	@apply
	def is_int():
		def fget( self ):
			attribute_eval = is_int_expr(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument is_int is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def sql_mappable():
		def fget( self ):
			attribute_eval = is_sql_mappable(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument sql_mappable is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY simple_generic_expression #
####################
class simple_generic_expression(generic_expression):
	'''Entity simple_generic_expression definition.
	'''
	def __init__( self ,  ):
		generic_expression.__init__(self , )

####################
 # ENTITY simple_numeric_expression #
####################
class simple_numeric_expression(numeric_expression,simple_generic_expression):
	'''Entity simple_numeric_expression definition.
	'''
	def __init__( self ,  ):
		numeric_expression.__init__(self , )
		simple_generic_expression.__init__(self , )

####################
 # ENTITY generic_literal #
####################
class generic_literal(simple_generic_expression):
	'''Entity generic_literal definition.
	'''
	def __init__( self ,  ):
		simple_generic_expression.__init__(self , )

####################
 # ENTITY literal_number #
####################
class literal_number(simple_numeric_expression,generic_literal):
	'''Entity literal_number definition.

	:param the_value
	:type the_value:(null)
	'''
	def __init__( self , the_value, ):
		simple_numeric_expression.__init__(self , )
		generic_literal.__init__(self , )
		self.the_value = the_value

	@apply
	def the_value():
		def fget( self ):
			return self._the_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument the_value is mantatory and can not be set to None')
			if not check_type(value,(null)):
				self._the_value = (null)(value)
			else:
				self._the_value = value
		return property(**locals())

####################
 # ENTITY real_literal #
####################
class real_literal(literal_number):
	'''Entity real_literal definition.

	:param literal_number_the_value
	:type literal_number_the_value:REAL
	'''
	def __init__( self , inherited0__the_value , literal_number_the_value, ):
		literal_number.__init__(self , inherited0__the_value , )
		self.literal_number_the_value = literal_number_the_value

	@apply
	def literal_number_the_value():
		def fget( self ):
			return self._literal_number_the_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument literal_number_the_value is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._literal_number_the_value = REAL(value)
			else:
				self._literal_number_the_value = value
		return property(**locals())

####################
 # ENTITY representation_item #
####################
class representation_item(BaseEntityClass):
	'''Entity representation_item definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(using_representations(self))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY styled_item #
####################
class styled_item(representation_item):
	'''Entity styled_item definition.

	:param styles
	:type styles:SET(1,None,'presentation_style_assignment', scope = schema_scope)

	:param item
	:type item:representation_item
	'''
	def __init__( self , inherited0__name , styles,item, ):
		representation_item.__init__(self , inherited0__name , )
		self.styles = styles
		self.item = item

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'presentation_style_assignment', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())

	@apply
	def item():
		def fget( self ):
			return self._item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._item = representation_item(value)
			else:
				self._item = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.self.styles)  ==  1) XOR (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY annotation_occurrence #
####################
class annotation_occurrence(styled_item):
	'''Entity annotation_occurrence definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item ,  ):
		styled_item.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.GEOMETRIC_REPRESENTATION_ITEM'  ==  TYPEOF(self))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY annotation_fill_area_occurrence #
####################
class annotation_fill_area_occurrence(annotation_occurrence):
	'''Entity annotation_fill_area_occurrence definition.

	:param fill_style_target
	:type fill_style_target:point

	:param styled_item_item
	:type styled_item_item:annotation_fill_area
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , fill_style_target,styled_item_item, ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		self.fill_style_target = fill_style_target
		self.styled_item_item = styled_item_item

	@apply
	def fill_style_target():
		def fget( self ):
			return self._fill_style_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fill_style_target is mantatory and can not be set to None')
			if not check_type(value,point):
				self._fill_style_target = point(value)
			else:
				self._fill_style_target = value
		return property(**locals())

	@apply
	def styled_item_item():
		def fget( self ):
			return self._styled_item_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_item_item is mantatory and can not be set to None')
			if not check_type(value,annotation_fill_area):
				self._styled_item_item = annotation_fill_area(value)
			else:
				self._styled_item_item = value
		return property(**locals())

####################
 # ENTITY characterized_object #
####################
class characterized_object(BaseEntityClass):
	'''Entity characterized_object definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY feature_definition #
####################
class feature_definition(characterized_object):
	'''Entity feature_definition definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		characterized_object.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(None)  ==  0)  or  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not ((SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'BARRING_HOLE','AUTOMOTIVE_DESIGN.'  +  'BEAD','AUTOMOTIVE_DESIGN.'  +  'HOLE_IN_PANEL','AUTOMOTIVE_DESIGN.'  +  'FEATURE_IN_PANEL','AUTOMOTIVE_DESIGN.'  +  'JOGGLE','AUTOMOTIVE_DESIGN.'  +  'LOCATOR']  *  TYPEOF(self))  ==  1)  or  ((('AUTOMOTIVE_DESIGN.'  +  'COMPOUND_FEATURE')  ==  TYPEOF(self))  and  (SIZEOF(None)  ==  1))))  or  ((SIZEOF(None)  <=  1)  and  ((SIZEOF(None)  ==  0)  or  (SIZEOF(None)  ==  1))))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((SIZEOF(None)  ==  0)  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (( not ((SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'BOSS','AUTOMOTIVE_DESIGN.'  +  'RIB','AUTOMOTIVE_DESIGN.'  +  'SLOT','AUTOMOTIVE_DESIGN.'  +  'ROUND_HOLE','AUTOMOTIVE_DESIGN.'  +  'POCKET']  *  TYPEOF(self))  ==  1)  or  ((('AUTOMOTIVE_DESIGN.'  +  'COMPOUND_FEATURE')  ==  TYPEOF(self))  and  (SIZEOF(None)  ==  1))))  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1)))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'BEAD','AUTOMOTIVE_DESIGN.'  +  'BARRING_HOLE','AUTOMOTIVE_DESIGN.'  +  'BOSS','AUTOMOTIVE_DESIGN.'  +  'COMPOUND_FEATURE','AUTOMOTIVE_DESIGN.'  +  'EXTERNALLY_DEFINED_FEATURE_DEFINITION','AUTOMOTIVE_DESIGN.'  +  'FEATURE_IN_PANEL','AUTOMOTIVE_DESIGN.'  +  'GENERAL_FEATURE','AUTOMOTIVE_DESIGN.'  +  'HOLE_IN_PANEL','AUTOMOTIVE_DESIGN.'  +  'JOGGLE','AUTOMOTIVE_DESIGN.'  +  'LOCATOR','AUTOMOTIVE_DESIGN.'  +  'POCKET','AUTOMOTIVE_DESIGN.'  +  'RIB','AUTOMOTIVE_DESIGN.'  +  'REPLICATE_FEATURE','AUTOMOTIVE_DESIGN.'  +  'ROUND_HOLE','AUTOMOTIVE_DESIGN.'  +  'SLOT','AUTOMOTIVE_DESIGN.'  +  'THREAD']  *  TYPEOF(self))  <=  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY compound_feature #
####################
class compound_feature(feature_definition):
	'''Entity compound_feature definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = ((SIZEOF(None)  +  SIZEOF(None))  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY composite_hole #
####################
class composite_hole(compound_feature):
	'''Entity composite_hole definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		compound_feature.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (self.self.characterized_object.self.description  ==  ['counterbore','countersunk'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'countersunk')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY identification_role #
####################
class identification_role(BaseEntityClass):
	'''Entity identification_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY certification_assignment #
####################
class certification_assignment(BaseEntityClass):
	'''Entity certification_assignment definition.

	:param assigned_certification
	:type assigned_certification:certification

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_certification, ):
		self.assigned_certification = assigned_certification

	@apply
	def assigned_certification():
		def fget( self ):
			return self._assigned_certification
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_certification is mantatory and can not be set to None')
			if not check_type(value,certification):
				self._assigned_certification = certification(value)
			else:
				self._assigned_certification = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_certification_assignment #
####################
class applied_certification_assignment(certification_assignment):
	'''Entity applied_certification_assignment definition.

	:param items
	:type items:SET(1,None,'certification_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_certification , items, ):
		certification_assignment.__init__(self , inherited0__assigned_certification , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'certification_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY geometric_representation_item #
####################
class geometric_representation_item(representation_item):
	'''Entity geometric_representation_item definition.

	:param dim
	:type dim:dimension_count
	'''
	def __init__( self , inherited0__name ,  ):
		representation_item.__init__(self , inherited0__name , )

	@apply
	def dim():
		def fget( self ):
			attribute_eval = dimension_of(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY functionally_defined_transformation #
####################
class functionally_defined_transformation(BaseEntityClass):
	'''Entity functionally_defined_transformation definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY cartesian_transformation_operator #
####################
class cartesian_transformation_operator(geometric_representation_item,functionally_defined_transformation):
	'''Entity cartesian_transformation_operator definition.

	:param axis1
	:type axis1:direction

	:param axis2
	:type axis2:direction

	:param local_origin
	:type local_origin:cartesian_point

	:param scale
	:type scale:REAL

	:param scl
	:type scl:REAL
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__description , axis1,axis2,local_origin,scale, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		functionally_defined_transformation.__init__(self , inherited1__name , inherited2__description , )
		self.axis1 = axis1
		self.axis2 = axis2
		self.local_origin = local_origin
		self.scale = scale

	@apply
	def axis1():
		def fget( self ):
			return self._axis1
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._axis1 = direction(value)
				else:
					self._axis1 = value
			else:
				self._axis1 = value
		return property(**locals())

	@apply
	def axis2():
		def fget( self ):
			return self._axis2
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._axis2 = direction(value)
				else:
					self._axis2 = value
			else:
				self._axis2 = value
		return property(**locals())

	@apply
	def local_origin():
		def fget( self ):
			return self._local_origin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument local_origin is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._local_origin = cartesian_point(value)
			else:
				self._local_origin = value
		return property(**locals())

	@apply
	def scale():
		def fget( self ):
			return self._scale
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._scale = REAL(value)
				else:
					self._scale = value
			else:
				self._scale = value
		return property(**locals())

	@apply
	def scl():
		def fget( self ):
			attribute_eval = NVL(self.scale,1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scl is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.scl  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY cartesian_transformation_operator_3d #
####################
class cartesian_transformation_operator_3d(cartesian_transformation_operator):
	'''Entity cartesian_transformation_operator_3d definition.

	:param axis3
	:type axis3:direction

	:param u
	:type u:LIST(3,3,'direction', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__description , inherited3__axis1 , inherited4__axis2 , inherited5__local_origin , inherited6__scale , axis3, ):
		cartesian_transformation_operator.__init__(self , inherited0__name , inherited1__name , inherited2__description , inherited3__axis1 , inherited4__axis2 , inherited5__local_origin , inherited6__scale , )
		self.axis3 = axis3

	@apply
	def axis3():
		def fget( self ):
			return self._axis3
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._axis3 = direction(value)
				else:
					self._axis3 = value
			else:
				self._axis3 = value
		return property(**locals())

	@apply
	def u():
		def fget( self ):
			attribute_eval = base_axis(3,self.self.cartesian_transformation_operator.self.axis1,self.self.cartesian_transformation_operator.self.axis2,self.axis3)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument u is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY boolean_expression #
####################
class boolean_expression(expression):
	'''Entity boolean_expression definition.
	'''
	def __init__( self ,  ):
		expression.__init__(self , )

####################
 # ENTITY multiple_arity_generic_expression #
####################
class multiple_arity_generic_expression(generic_expression):
	'''Entity multiple_arity_generic_expression definition.

	:param operands
	:type operands:LIST(2,None,'generic_expression', scope = schema_scope)
	'''
	def __init__( self , operands, ):
		generic_expression.__init__(self , )
		self.operands = operands

	@apply
	def operands():
		def fget( self ):
			return self._operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'generic_expression', scope = schema_scope)):
				self._operands = LIST(value)
			else:
				self._operands = value
		return property(**locals())

####################
 # ENTITY multiple_arity_boolean_expression #
####################
class multiple_arity_boolean_expression(boolean_expression,multiple_arity_generic_expression):
	'''Entity multiple_arity_boolean_expression definition.

	:param multiple_arity_generic_expression_operands
	:type multiple_arity_generic_expression_operands:LIST(2,None,'boolean_expression', scope = schema_scope)
	'''
	def __init__( self , inherited0__operands , multiple_arity_generic_expression_operands, ):
		boolean_expression.__init__(self , )
		multiple_arity_generic_expression.__init__(self , inherited0__operands , )
		self.multiple_arity_generic_expression_operands = multiple_arity_generic_expression_operands

	@apply
	def multiple_arity_generic_expression_operands():
		def fget( self ):
			return self._multiple_arity_generic_expression_operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument multiple_arity_generic_expression_operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'boolean_expression', scope = schema_scope)):
				self._multiple_arity_generic_expression_operands = LIST(value)
			else:
				self._multiple_arity_generic_expression_operands = value
		return property(**locals())

####################
 # ENTITY or_expression #
####################
class or_expression(multiple_arity_boolean_expression):
	'''Entity or_expression definition.
	'''
	def __init__( self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands ,  ):
		multiple_arity_boolean_expression.__init__(self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands , )

####################
 # ENTITY versioned_action_request #
####################
class versioned_action_request(BaseEntityClass):
	'''Entity versioned_action_request definition.

	:param id
	:type id:identifier

	:param version
	:type version:label

	:param purpose
	:type purpose:text

	:param description
	:type description:text
	'''
	def __init__( self , id,version,purpose,description, ):
		self.id = id
		self.version = version
		self.purpose = purpose
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def version():
		def fget( self ):
			return self._version
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument version is mantatory and can not be set to None')
			if not check_type(value,label):
				self._version = label(value)
			else:
				self._version = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument purpose is mantatory and can not be set to None')
			if not check_type(value,text):
				self._purpose = text(value)
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY unary_generic_expression #
####################
class unary_generic_expression(generic_expression):
	'''Entity unary_generic_expression definition.

	:param operand
	:type operand:generic_expression
	'''
	def __init__( self , operand, ):
		generic_expression.__init__(self , )
		self.operand = operand

	@apply
	def operand():
		def fget( self ):
			return self._operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operand is mantatory and can not be set to None')
			if not check_type(value,generic_expression):
				self._operand = generic_expression(value)
			else:
				self._operand = value
		return property(**locals())

####################
 # ENTITY unary_numeric_expression #
####################
class unary_numeric_expression(numeric_expression,unary_generic_expression):
	'''Entity unary_numeric_expression definition.

	:param unary_generic_expression_operand
	:type unary_generic_expression_operand:numeric_expression
	'''
	def __init__( self , inherited0__operand , unary_generic_expression_operand, ):
		numeric_expression.__init__(self , )
		unary_generic_expression.__init__(self , inherited0__operand , )
		self.unary_generic_expression_operand = unary_generic_expression_operand

	@apply
	def unary_generic_expression_operand():
		def fget( self ):
			return self._unary_generic_expression_operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unary_generic_expression_operand is mantatory and can not be set to None')
			if not check_type(value,numeric_expression):
				self._unary_generic_expression_operand = numeric_expression(value)
			else:
				self._unary_generic_expression_operand = value
		return property(**locals())

####################
 # ENTITY unary_function_call #
####################
class unary_function_call(unary_numeric_expression):
	'''Entity unary_function_call definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_numeric_expression.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY asin_function #
####################
class asin_function(unary_function_call):
	'''Entity asin_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY geometric_tolerance #
####################
class geometric_tolerance(BaseEntityClass):
	'''Entity geometric_tolerance definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param magnitude
	:type magnitude:measure_with_unit

	:param toleranced_shape_aspect
	:type toleranced_shape_aspect:shape_aspect
	'''
	def __init__( self , name,description,magnitude,toleranced_shape_aspect, ):
		self.name = name
		self.description = description
		self.magnitude = magnitude
		self.toleranced_shape_aspect = toleranced_shape_aspect

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def magnitude():
		def fget( self ):
			return self._magnitude
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument magnitude is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._magnitude = measure_with_unit(value)
			else:
				self._magnitude = value
		return property(**locals())

	@apply
	def toleranced_shape_aspect():
		def fget( self ):
			return self._toleranced_shape_aspect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument toleranced_shape_aspect is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._toleranced_shape_aspect = shape_aspect(value)
			else:
				self._toleranced_shape_aspect = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('NUMBER'  ==  TYPEOF(self.magnitude.self.measure_with_unit.self.value_component))  and  (self.magnitude.self.measure_with_unit.self.value_component  >=  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY cylindricity_tolerance #
####################
class cylindricity_tolerance(geometric_tolerance):
	'''Entity cylindricity_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ( not (('AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY representation #
####################
class representation(BaseEntityClass):
	'''Entity representation definition.

	:param name
	:type name:label

	:param items
	:type items:SET(1,None,'representation_item', scope = schema_scope)

	:param context_of_items
	:type context_of_items:representation_context

	:param id
	:type id:identifier

	:param description
	:type description:text
	'''
	def __init__( self , name,items,context_of_items, ):
		self.name = name
		self.items = items
		self.context_of_items = context_of_items

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'representation_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def context_of_items():
		def fget( self ):
			return self._context_of_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument context_of_items is mantatory and can not be set to None')
			if not check_type(value,representation_context):
				self._context_of_items = representation_context(value)
			else:
				self._context_of_items = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY shape_representation #
####################
class shape_representation(representation):
	'''Entity shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )

####################
 # ENTITY manifold_surface_shape_representation #
####################
class manifold_surface_shape_representation(shape_representation):
	'''Entity manifold_surface_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(None)  ==  0)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = (SIZEOF(None)  ==  0)
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr


####################
 # ENTITY simple_pair_range #
####################
class simple_pair_range(BaseEntityClass):
	'''Entity simple_pair_range definition.

	:param applies_to_pair
	:type applies_to_pair:kinematic_pair
	'''
	def __init__( self , applies_to_pair, ):
		self.applies_to_pair = applies_to_pair

	@apply
	def applies_to_pair():
		def fget( self ):
			return self._applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,kinematic_pair):
				self._applies_to_pair = kinematic_pair(value)
			else:
				self._applies_to_pair = value
		return property(**locals())

####################
 # ENTITY planar_curve_pair_range #
####################
class planar_curve_pair_range(simple_pair_range):
	'''Entity planar_curve_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:planar_curve_pair

	:param range_on_curve_1
	:type range_on_curve_1:trimmed_curve

	:param range_on_curve_2
	:type range_on_curve_2:trimmed_curve
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,range_on_curve_1,range_on_curve_2, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.range_on_curve_1 = range_on_curve_1
		self.range_on_curve_2 = range_on_curve_2

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,planar_curve_pair):
				self._simple_pair_range_applies_to_pair = planar_curve_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def range_on_curve_1():
		def fget( self ):
			return self._range_on_curve_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument range_on_curve_1 is mantatory and can not be set to None')
			if not check_type(value,trimmed_curve):
				self._range_on_curve_1 = trimmed_curve(value)
			else:
				self._range_on_curve_1 = value
		return property(**locals())

	@apply
	def range_on_curve_2():
		def fget( self ):
			return self._range_on_curve_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument range_on_curve_2 is mantatory and can not be set to None')
			if not check_type(value,trimmed_curve):
				self._range_on_curve_2 = trimmed_curve(value)
			else:
				self._range_on_curve_2 = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.simple_pair_range.self.applies_to_pair.self.planar_curve_pair.self.curve_1  ==  self.range_on_curve_1.self.basis_curve)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.simple_pair_range.self.applies_to_pair.self.planar_curve_pair.self.curve_2  ==  self.range_on_curve_2.self.basis_curve)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY certification #
####################
class certification(BaseEntityClass):
	'''Entity certification definition.

	:param name
	:type name:label

	:param purpose
	:type purpose:text

	:param kind
	:type kind:certification_type
	'''
	def __init__( self , name,purpose,kind, ):
		self.name = name
		self.purpose = purpose
		self.kind = kind

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument purpose is mantatory and can not be set to None')
			if not check_type(value,text):
				self._purpose = text(value)
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def kind():
		def fget( self ):
			return self._kind
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument kind is mantatory and can not be set to None')
			if not check_type(value,certification_type):
				self._kind = certification_type(value)
			else:
				self._kind = value
		return property(**locals())

####################
 # ENTITY mechanical_design_geometric_presentation_representation #
####################
class mechanical_design_geometric_presentation_representation(representation):
	'''Entity mechanical_design_geometric_presentation_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(None)  ==  0)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = (SIZEOF(None)  ==  0)
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr


####################
 # ENTITY camera_model #
####################
class camera_model(geometric_representation_item):
	'''Entity camera_model definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ITEM_DEFINED_TRANSFORMATION.TRANSFORM_ITEM_1'))  +  SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.REPRESENTATION_MAP.MAPPING_ORIGIN')))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.STYLED_ITEM.ITEM'))  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY product_definition_relationship #
####################
class product_definition_relationship(BaseEntityClass):
	'''Entity product_definition_relationship definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_product_definition
	:type relating_product_definition:product_definition

	:param related_product_definition
	:type related_product_definition:product_definition
	'''
	def __init__( self , id,name,description,relating_product_definition,related_product_definition, ):
		self.id = id
		self.name = name
		self.description = description
		self.relating_product_definition = relating_product_definition
		self.related_product_definition = related_product_definition

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_product_definition():
		def fget( self ):
			return self._relating_product_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_product_definition is mantatory and can not be set to None')
			if not check_type(value,product_definition):
				self._relating_product_definition = product_definition(value)
			else:
				self._relating_product_definition = value
		return property(**locals())

	@apply
	def related_product_definition():
		def fget( self ):
			return self._related_product_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_product_definition is mantatory and can not be set to None')
			if not check_type(value,product_definition):
				self._related_product_definition = product_definition(value)
			else:
				self._related_product_definition = value
		return property(**locals())

####################
 # ENTITY product_definition_usage #
####################
class product_definition_usage(product_definition_relationship):
	'''Entity product_definition_usage definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )
	def wr1(self):
		eval_wr1_wr = acyclic_product_definition_relationship(self,[self.self.product_definition_relationship.self.related_product_definition],'AUTOMOTIVE_DESIGN.PRODUCT_DEFINITION_USAGE')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY assembly_component_usage #
####################
class assembly_component_usage(product_definition_usage):
	'''Entity assembly_component_usage definition.

	:param reference_designator
	:type reference_designator:identifier
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , reference_designator, ):
		product_definition_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )
		self.reference_designator = reference_designator

	@apply
	def reference_designator():
		def fget( self ):
			return self._reference_designator
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,identifier):
					self._reference_designator = identifier(value)
				else:
					self._reference_designator = value
			else:
				self._reference_designator = value
		return property(**locals())

####################
 # ENTITY quantified_assembly_component_usage #
####################
class quantified_assembly_component_usage(assembly_component_usage):
	'''Entity quantified_assembly_component_usage definition.

	:param quantity
	:type quantity:measure_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , quantity, ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )
		self.quantity = quantity

	@apply
	def quantity():
		def fget( self ):
			return self._quantity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument quantity is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._quantity = measure_with_unit(value)
			else:
				self._quantity = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not ('NUMBER'  ==  TYPEOF(self.quantity.self.value_component)))  or  (self.quantity.self.value_component  >  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY generic_variable #
####################
class generic_variable(simple_generic_expression):
	'''Entity generic_variable definition.

	:param interpretation
	:type interpretation:environment
	'''
	def __init__( self ,  ):
		simple_generic_expression.__init__(self , )

	@apply
	def interpretation():
		def fget( self ):
			return self._interpretation
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument interpretation is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY variable #
####################
class variable(generic_variable):
	'''Entity variable definition.
	'''
	def __init__( self ,  ):
		generic_variable.__init__(self , )

####################
 # ENTITY numeric_variable #
####################
class numeric_variable(simple_numeric_expression,variable):
	'''Entity numeric_variable definition.
	'''
	def __init__( self ,  ):
		simple_numeric_expression.__init__(self , )
		variable.__init__(self , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.INT_NUMERIC_VARIABLE'  ==  TYPEOF(self))  or  ('AUTOMOTIVE_DESIGN.REAL_NUMERIC_VARIABLE'  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY real_numeric_variable #
####################
class real_numeric_variable(numeric_variable):
	'''Entity real_numeric_variable definition.
	'''
	def __init__( self ,  ):
		numeric_variable.__init__(self , )

####################
 # ENTITY draughting_model #
####################
class draughting_model(representation):
	'''Entity draughting_model definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY externally_defined_item #
####################
class externally_defined_item(BaseEntityClass):
	'''Entity externally_defined_item definition.

	:param item_id
	:type item_id:source_item

	:param source
	:type source:external_source
	'''
	def __init__( self , item_id,source, ):
		self.item_id = item_id
		self.source = source

	@apply
	def item_id():
		def fget( self ):
			return self._item_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_id is mantatory and can not be set to None')
			if not check_type(value,source_item):
				self._item_id = source_item(value)
			else:
				self._item_id = value
		return property(**locals())

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source is mantatory and can not be set to None')
			if not check_type(value,external_source):
				self._source = external_source(value)
			else:
				self._source = value
		return property(**locals())

####################
 # ENTITY externally_defined_hatch_style #
####################
class externally_defined_hatch_style(externally_defined_item,geometric_representation_item):
	'''Entity externally_defined_hatch_style definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source , inherited2__name ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )
		geometric_representation_item.__init__(self , inherited2__name , )

####################
 # ENTITY solid_model #
####################
class solid_model(geometric_representation_item):
	'''Entity solid_model definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY manifold_solid_brep #
####################
class manifold_solid_brep(solid_model):
	'''Entity manifold_solid_brep definition.

	:param outer
	:type outer:closed_shell
	'''
	def __init__( self , inherited0__name , outer, ):
		solid_model.__init__(self , inherited0__name , )
		self.outer = outer

	@apply
	def outer():
		def fget( self ):
			return self._outer
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outer is mantatory and can not be set to None')
			if not check_type(value,closed_shell):
				self._outer = closed_shell(value)
			else:
				self._outer = value
		return property(**locals())

####################
 # ENTITY faceted_brep #
####################
class faceted_brep(manifold_solid_brep):
	'''Entity faceted_brep definition.
	'''
	def __init__( self , inherited0__name , inherited1__outer ,  ):
		manifold_solid_brep.__init__(self , inherited0__name , inherited1__outer , )

####################
 # ENTITY action_resource #
####################
class action_resource(BaseEntityClass):
	'''Entity action_resource definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param usage
	:type usage:SET(1,None,'supported_item', scope = schema_scope)

	:param kind
	:type kind:action_resource_type
	'''
	def __init__( self , name,description,usage,kind, ):
		self.name = name
		self.description = description
		self.usage = usage
		self.kind = kind

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def usage():
		def fget( self ):
			return self._usage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument usage is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'supported_item', scope = schema_scope)):
				self._usage = SET(value)
			else:
				self._usage = value
		return property(**locals())

	@apply
	def kind():
		def fget( self ):
			return self._kind
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument kind is mantatory and can not be set to None')
			if not check_type(value,action_resource_type):
				self._kind = action_resource_type(value)
			else:
				self._kind = value
		return property(**locals())

####################
 # ENTITY product_definition #
####################
class product_definition(BaseEntityClass):
	'''Entity product_definition definition.

	:param id
	:type id:identifier

	:param description
	:type description:text

	:param formation
	:type formation:product_definition_formation

	:param frame_of_reference
	:type frame_of_reference:product_definition_context

	:param name
	:type name:label
	'''
	def __init__( self , id,description,formation,frame_of_reference, ):
		self.id = id
		self.description = description
		self.formation = formation
		self.frame_of_reference = frame_of_reference

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def formation():
		def fget( self ):
			return self._formation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument formation is mantatory and can not be set to None')
			if not check_type(value,product_definition_formation):
				self._formation = product_definition_formation(value)
			else:
				self._formation = value
		return property(**locals())

	@apply
	def frame_of_reference():
		def fget( self ):
			return self._frame_of_reference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument frame_of_reference is mantatory and can not be set to None')
			if not check_type(value,product_definition_context):
				self._frame_of_reference = product_definition_context(value)
			else:
				self._frame_of_reference = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition_resource #
####################
class product_definition_resource(action_resource,product_definition):
	'''Entity product_definition_resource definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__usage , inherited3__kind , inherited4__id , inherited5__description , inherited6__formation , inherited7__frame_of_reference ,  ):
		action_resource.__init__(self , inherited0__name , inherited1__description , inherited2__usage , inherited3__kind , )
		product_definition.__init__(self , inherited4__id , inherited5__description , inherited6__formation , inherited7__frame_of_reference , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.REQUIREMENT_FOR_ACTION_RESOURCE.RESOURCES'))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.frame_of_reference.self.name  ==  ['part_definition','part occurrence','physical occurrence'])
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY resource_property_representation #
####################
class resource_property_representation(BaseEntityClass):
	'''Entity resource_property_representation definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param property
	:type property:resource_property

	:param representation
	:type representation:representation
	'''
	def __init__( self , name,description,property,representation, ):
		self.name = name
		self.description = description
		self.property = property
		self.representation = representation

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def property():
		def fget( self ):
			return self._property
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument property is mantatory and can not be set to None')
			if not check_type(value,resource_property):
				self._property = resource_property(value)
			else:
				self._property = value
		return property(**locals())

	@apply
	def representation():
		def fget( self ):
			return self._representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._representation = representation(value)
			else:
				self._representation = value
		return property(**locals())

####################
 # ENTITY time_interval #
####################
class time_interval(BaseEntityClass):
	'''Entity time_interval definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY time_interval_with_bounds #
####################
class time_interval_with_bounds(time_interval):
	'''Entity time_interval_with_bounds definition.

	:param primary_bound
	:type primary_bound:date_time_or_event_occurrence

	:param secondary_bound
	:type secondary_bound:date_time_or_event_occurrence

	:param duration
	:type duration:time_measure_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , primary_bound,secondary_bound,duration, ):
		time_interval.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
		self.primary_bound = primary_bound
		self.secondary_bound = secondary_bound
		self.duration = duration

	@apply
	def primary_bound():
		def fget( self ):
			return self._primary_bound
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,date_time_or_event_occurrence):
					self._primary_bound = date_time_or_event_occurrence(value)
				else:
					self._primary_bound = value
			else:
				self._primary_bound = value
		return property(**locals())

	@apply
	def secondary_bound():
		def fget( self ):
			return self._secondary_bound
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,date_time_or_event_occurrence):
					self._secondary_bound = date_time_or_event_occurrence(value)
				else:
					self._secondary_bound = value
			else:
				self._secondary_bound = value
		return property(**locals())

	@apply
	def duration():
		def fget( self ):
			return self._duration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,time_measure_with_unit):
					self._duration = time_measure_with_unit(value)
				else:
					self._duration = value
			else:
				self._duration = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not (EXISTS(self.secondary_bound)  and  EXISTS(self.duration)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (EXISTS(self.primary_bound)  or  EXISTS(self.secondary_bound))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY action_directive #
####################
class action_directive(BaseEntityClass):
	'''Entity action_directive definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param analysis
	:type analysis:text

	:param comment
	:type comment:text

	:param requests
	:type requests:SET(1,None,'versioned_action_request', scope = schema_scope)
	'''
	def __init__( self , name,description,analysis,comment,requests, ):
		self.name = name
		self.description = description
		self.analysis = analysis
		self.comment = comment
		self.requests = requests

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def analysis():
		def fget( self ):
			return self._analysis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument analysis is mantatory and can not be set to None')
			if not check_type(value,text):
				self._analysis = text(value)
			else:
				self._analysis = value
		return property(**locals())

	@apply
	def comment():
		def fget( self ):
			return self._comment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument comment is mantatory and can not be set to None')
			if not check_type(value,text):
				self._comment = text(value)
			else:
				self._comment = value
		return property(**locals())

	@apply
	def requests():
		def fget( self ):
			return self._requests
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument requests is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'versioned_action_request', scope = schema_scope)):
				self._requests = SET(value)
			else:
				self._requests = value
		return property(**locals())

####################
 # ENTITY event_occurrence_context_role #
####################
class event_occurrence_context_role(BaseEntityClass):
	'''Entity event_occurrence_context_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY shape_aspect #
####################
class shape_aspect(BaseEntityClass):
	'''Entity shape_aspect definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param of_shape
	:type of_shape:product_definition_shape

	:param product_definitional
	:type product_definitional:LOGICAL

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description,of_shape,product_definitional, ):
		self.name = name
		self.description = description
		self.of_shape = of_shape
		self.product_definitional = product_definitional

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def of_shape():
		def fget( self ):
			return self._of_shape
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument of_shape is mantatory and can not be set to None')
			if not check_type(value,product_definition_shape):
				self._of_shape = product_definition_shape(value)
			else:
				self._of_shape = value
		return property(**locals())

	@apply
	def product_definitional():
		def fget( self ):
			return self._product_definitional
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument product_definitional is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._product_definitional = LOGICAL(value)
			else:
				self._product_definitional = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY hole_bottom #
####################
class hole_bottom(shape_aspect):
	'''Entity hole_bottom definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.description  ==  ['through','flat','flat with taper','flat with radius','spherical','conical'])
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not (self.self.description  ==  ['through','flat']))  or  (SIZEOF(get_shape_aspect_property_definition_representations(self))  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not (self.self.description  ==  ['flat with radius','flat with taper','spherical','conical']))  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'flat with taper')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.description  !=  'conical')  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (( not (self.self.description  ==  ['flat with radius','spherical']))  or  (SIZEOF(None)  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = ((self.self.description  !=  'flat with radius')  or  (SIZEOF(None)  ==  1))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = ((self.self.description  !=  'spherical')  or  (SIZEOF(None)  ==  1))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = ((self.self.description  !=  'conical')  or  (SIZEOF(None)  ==  1))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = ((self.self.description  !=  'conical')  or  (SIZEOF(None)  ==  1))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = ((self.self.description  !=  'flat with taper')  or  (SIZEOF(None)  ==  1))
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = ((self.self.description  !=  'flat with taper')  or  (SIZEOF(None)  ==  1))
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = (SIZEOF(None)  ==  1)
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr

	def wr15(self):
		eval_wr15_wr = ((self.self.description  ==  'through')  or  (SIZEOF(None)  ==  1))
		if not eval_wr15_wr:
			raise AssertionError('Rule wr15 violated')
		else:
			return eval_wr15_wr


####################
 # ENTITY named_unit #
####################
class named_unit(BaseEntityClass):
	'''Entity named_unit definition.

	:param dimensions
	:type dimensions:dimensional_exponents
	'''
	def __init__( self , dimensions, ):
		self.dimensions = dimensions

	@apply
	def dimensions():
		def fget( self ):
			return self._dimensions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dimensions is mantatory and can not be set to None')
			if not check_type(value,dimensional_exponents):
				self._dimensions = dimensional_exponents(value)
			else:
				self._dimensions = value
		return property(**locals())

####################
 # ENTITY plane_angle_unit #
####################
class plane_angle_unit(named_unit):
	'''Entity plane_angle_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY configuration_definition #
####################
class configuration_definition(BaseEntityClass):
	'''Entity configuration_definition definition.

	:param pair_values
	:type pair_values:SET(1,None,'pair_value', scope = schema_scope)

	:param t_parameter
	:type t_parameter:motion_parameter_measure
	'''
	def __init__( self , pair_values,t_parameter, ):
		self.pair_values = pair_values
		self.t_parameter = t_parameter

	@apply
	def pair_values():
		def fget( self ):
			return self._pair_values
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_values is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'pair_value', scope = schema_scope)):
				self._pair_values = SET(value)
			else:
				self._pair_values = value
		return property(**locals())

	@apply
	def t_parameter():
		def fget( self ):
			return self._t_parameter
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument t_parameter is mantatory and can not be set to None')
			if not check_type(value,motion_parameter_measure):
				self._t_parameter = motion_parameter_measure(value)
			else:
				self._t_parameter = value
		return property(**locals())

####################
 # ENTITY annotation_symbol_occurrence #
####################
class annotation_symbol_occurrence(annotation_occurrence):
	'''Entity annotation_symbol_occurrence definition.

	:param styled_item_item
	:type styled_item_item:annotation_symbol_occurrence_item
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , styled_item_item, ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		self.styled_item_item = styled_item_item

	@apply
	def styled_item_item():
		def fget( self ):
			return self._styled_item_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_item_item is mantatory and can not be set to None')
			if not check_type(value,annotation_symbol_occurrence_item):
				self._styled_item_item = annotation_symbol_occurrence_item(value)
			else:
				self._styled_item_item = value
		return property(**locals())

####################
 # ENTITY terminator_symbol #
####################
class terminator_symbol(annotation_symbol_occurrence):
	'''Entity terminator_symbol definition.

	:param annotated_curve
	:type annotated_curve:annotation_curve_occurrence
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , annotated_curve, ):
		annotation_symbol_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , )
		self.annotated_curve = annotated_curve

	@apply
	def annotated_curve():
		def fget( self ):
			return self._annotated_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument annotated_curve is mantatory and can not be set to None')
			if not check_type(value,annotation_curve_occurrence):
				self._annotated_curve = annotation_curve_occurrence(value)
			else:
				self._annotated_curve = value
		return property(**locals())

####################
 # ENTITY leader_terminator #
####################
class leader_terminator(terminator_symbol):
	'''Entity leader_terminator definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , inherited4__annotated_curve ,  ):
		terminator_symbol.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , inherited4__annotated_curve , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.LEADER_CURVE'  ==  TYPEOF(self.self.terminator_symbol.self.annotated_curve))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY shape_aspect_relationship #
####################
class shape_aspect_relationship(BaseEntityClass):
	'''Entity shape_aspect_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_shape_aspect
	:type relating_shape_aspect:shape_aspect

	:param related_shape_aspect
	:type related_shape_aspect:shape_aspect

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description,relating_shape_aspect,related_shape_aspect, ):
		self.name = name
		self.description = description
		self.relating_shape_aspect = relating_shape_aspect
		self.related_shape_aspect = related_shape_aspect

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_shape_aspect():
		def fget( self ):
			return self._relating_shape_aspect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_shape_aspect is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._relating_shape_aspect = shape_aspect(value)
			else:
				self._relating_shape_aspect = value
		return property(**locals())

	@apply
	def related_shape_aspect():
		def fget( self ):
			return self._related_shape_aspect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_shape_aspect is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._related_shape_aspect = shape_aspect(value)
			else:
				self._related_shape_aspect = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY shape_aspect_transition #
####################
class shape_aspect_transition(shape_aspect_relationship):
	'''Entity shape_aspect_transition definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		shape_aspect_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (self.self.name  ==  ['g0','g1','g2'])
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY organization_assignment #
####################
class organization_assignment(BaseEntityClass):
	'''Entity organization_assignment definition.

	:param assigned_organization
	:type assigned_organization:organization

	:param role
	:type role:organization_role
	'''
	def __init__( self , assigned_organization,role, ):
		self.assigned_organization = assigned_organization
		self.role = role

	@apply
	def assigned_organization():
		def fget( self ):
			return self._assigned_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_organization is mantatory and can not be set to None')
			if not check_type(value,organization):
				self._assigned_organization = organization(value)
			else:
				self._assigned_organization = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,organization_role):
				self._role = organization_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_organization_assignment #
####################
class applied_organization_assignment(organization_assignment):
	'''Entity applied_organization_assignment definition.

	:param items
	:type items:SET(1,None,'organization_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_organization , inherited1__role , items, ):
		organization_assignment.__init__(self , inherited0__assigned_organization , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'organization_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (self.self.role.self.name  ==  'organization in contract'))  or  item_correlation(self.self.items,['CONTRACT']))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not (self.self.role.self.name  ==  'signing for contract'))  or  item_correlation(self.self.items,['APPLIED_ORGANIZATION_ASSIGNMENT']))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not (self.self.role.self.name  ==  'validity context'))  or  item_correlation(self.self.items,['ACTION_PROPERTY','RESOURCE_PROPERTY','PROPERTY_DEFINITION']))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not (self.self.role.self.name  ==  'alias scope'))  or  item_correlation(self.self.items,['APPLIED_IDENTIFICATION_ASSIGNMENT']))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY measure_with_unit #
####################
class measure_with_unit(BaseEntityClass):
	'''Entity measure_with_unit definition.

	:param value_component
	:type value_component:measure_value

	:param unit_component
	:type unit_component:unit
	'''
	def __init__( self , value_component,unit_component, ):
		self.value_component = value_component
		self.unit_component = unit_component

	@apply
	def value_component():
		def fget( self ):
			return self._value_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument value_component is mantatory and can not be set to None')
			if not check_type(value,measure_value):
				self._value_component = measure_value(value)
			else:
				self._value_component = value
		return property(**locals())

	@apply
	def unit_component():
		def fget( self ):
			return self._unit_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unit_component is mantatory and can not be set to None')
			if not check_type(value,unit):
				self._unit_component = unit(value)
			else:
				self._unit_component = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = valid_units(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY area_measure_with_unit #
####################
class area_measure_with_unit(measure_with_unit):
	'''Entity area_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.AREA_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY colour #
####################
class colour(BaseEntityClass):
	'''Entity colour definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY concept_feature_operator #
####################
class concept_feature_operator(BaseEntityClass):
	'''Entity concept_feature_operator definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY default_tolerance_table #
####################
class default_tolerance_table(representation):
	'''Entity default_tolerance_table definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (((SIZEOF(None)  ==  0)  and  (SIZEOF(None)  ==  0))  and  (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.REPRESENTATION_RELATIONSHIP.REP_2'))  ==  0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY property_definition #
####################
class property_definition(BaseEntityClass):
	'''Entity property_definition definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param definition
	:type definition:characterized_definition

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description,definition, ):
		self.name = name
		self.description = description
		self.definition = definition

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,characterized_definition):
				self._definition = characterized_definition(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition_shape #
####################
class product_definition_shape(property_definition):
	'''Entity product_definition_shape definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition ,  ):
		property_definition.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.CHARACTERIZED_PRODUCT_DEFINITION','AUTOMOTIVE_DESIGN.CHARACTERIZED_OBJECT']  *  TYPEOF(self.self.property_definition.self.definition))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY featured_shape #
####################
class featured_shape(product_definition_shape):
	'''Entity featured_shape definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition ,  ):
		product_definition_shape.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'PRODUCT_DEFINITION')  ==  TYPEOF(self.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  >=  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY founded_kinematic_path #
####################
class founded_kinematic_path(representation):
	'''Entity founded_kinematic_path definition.

	:param representation_items
	:type representation_items:SET(1,None,'kinematic_path', scope = schema_scope)

	:param representation_context_of_items
	:type representation_context_of_items:geometric_representation_context

	:param paths
	:type paths:SET(1,None,'kinematic_path', scope = schema_scope)

	:param founding
	:type founding:geometric_representation_context
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_items,representation_context_of_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_items = representation_items
		self.representation_context_of_items = representation_context_of_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'kinematic_path', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())

	@apply
	def representation_context_of_items():
		def fget( self ):
			return self._representation_context_of_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_context_of_items is mantatory and can not be set to None')
			if not check_type(value,geometric_representation_context):
				self._representation_context_of_items = geometric_representation_context(value)
			else:
				self._representation_context_of_items = value
		return property(**locals())

	@apply
	def paths():
		def fget( self ):
			attribute_eval = self.self.representation.self.items
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument paths is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def founding():
		def fget( self ):
			attribute_eval = self.self.representation.self.context_of_items
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument founding is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY item_defined_transformation #
####################
class item_defined_transformation(BaseEntityClass):
	'''Entity item_defined_transformation definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param transform_item_1
	:type transform_item_1:representation_item

	:param transform_item_2
	:type transform_item_2:representation_item
	'''
	def __init__( self , name,description,transform_item_1,transform_item_2, ):
		self.name = name
		self.description = description
		self.transform_item_1 = transform_item_1
		self.transform_item_2 = transform_item_2

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def transform_item_1():
		def fget( self ):
			return self._transform_item_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transform_item_1 is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._transform_item_1 = representation_item(value)
			else:
				self._transform_item_1 = value
		return property(**locals())

	@apply
	def transform_item_2():
		def fget( self ):
			return self._transform_item_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transform_item_2 is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._transform_item_2 = representation_item(value)
			else:
				self._transform_item_2 = value
		return property(**locals())

####################
 # ENTITY kinematic_pair #
####################
class kinematic_pair(item_defined_transformation):
	'''Entity kinematic_pair definition.

	:param joint
	:type joint:kinematic_joint

	:param pair_placement_in_first_link_context
	:type pair_placement_in_first_link_context:rigid_placement

	:param pair_placement_in_second_link_context
	:type pair_placement_in_second_link_context:rigid_placement
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , joint, ):
		item_defined_transformation.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , )
		self.joint = joint

	@apply
	def joint():
		def fget( self ):
			return self._joint
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument joint is mantatory and can not be set to None')
			if not check_type(value,kinematic_joint):
				self._joint = kinematic_joint(value)
			else:
				self._joint = value
		return property(**locals())

	@apply
	def pair_placement_in_first_link_context():
		def fget( self ):
			attribute_eval = self.self.item_defined_transformation.self.transform_item_1
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument pair_placement_in_first_link_context is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def pair_placement_in_second_link_context():
		def fget( self ):
			attribute_eval = self.self.item_defined_transformation.self.transform_item_2
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument pair_placement_in_second_link_context is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = coordinated_pair_link_representation(self.joint.self.first_link,self.pair_placement_in_first_link_context)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = coordinated_pair_link_representation(self.joint.self.second_link,self.pair_placement_in_second_link_context)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY gear_pair #
####################
class gear_pair(kinematic_pair):
	'''Entity gear_pair definition.

	:param radius_first_link
	:type radius_first_link:length_measure

	:param radius_second_link
	:type radius_second_link:length_measure

	:param bevel
	:type bevel:plane_angle_measure

	:param helical_angle
	:type helical_angle:plane_angle_measure

	:param gear_ratio
	:type gear_ratio:REAL
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , radius_first_link,radius_second_link,bevel,helical_angle,gear_ratio, ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )
		self.radius_first_link = radius_first_link
		self.radius_second_link = radius_second_link
		self.bevel = bevel
		self.helical_angle = helical_angle
		self.gear_ratio = gear_ratio

	@apply
	def radius_first_link():
		def fget( self ):
			return self._radius_first_link
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius_first_link is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._radius_first_link = length_measure(value)
			else:
				self._radius_first_link = value
		return property(**locals())

	@apply
	def radius_second_link():
		def fget( self ):
			return self._radius_second_link
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius_second_link is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._radius_second_link = length_measure(value)
			else:
				self._radius_second_link = value
		return property(**locals())

	@apply
	def bevel():
		def fget( self ):
			return self._bevel
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bevel is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._bevel = plane_angle_measure(value)
			else:
				self._bevel = value
		return property(**locals())

	@apply
	def helical_angle():
		def fget( self ):
			return self._helical_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument helical_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._helical_angle = plane_angle_measure(value)
			else:
				self._helical_angle = value
		return property(**locals())

	@apply
	def gear_ratio():
		def fget( self ):
			return self._gear_ratio
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument gear_ratio is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._gear_ratio = REAL(value)
			else:
				self._gear_ratio = value
		return property(**locals())

####################
 # ENTITY point_on_planar_curve_pair_range #
####################
class point_on_planar_curve_pair_range(simple_pair_range):
	'''Entity point_on_planar_curve_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:point_on_planar_curve_pair

	:param range_on_pair_curve
	:type range_on_pair_curve:trimmed_curve

	:param lower_limit_yaw
	:type lower_limit_yaw:rotational_range_measure

	:param upper_limit_yaw
	:type upper_limit_yaw:rotational_range_measure

	:param lower_limit_pitch
	:type lower_limit_pitch:rotational_range_measure

	:param upper_limit_pitch
	:type upper_limit_pitch:rotational_range_measure

	:param lower_limit_roll
	:type lower_limit_roll:rotational_range_measure

	:param upper_limit_roll
	:type upper_limit_roll:rotational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,range_on_pair_curve,lower_limit_yaw,upper_limit_yaw,lower_limit_pitch,upper_limit_pitch,lower_limit_roll,upper_limit_roll, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.range_on_pair_curve = range_on_pair_curve
		self.lower_limit_yaw = lower_limit_yaw
		self.upper_limit_yaw = upper_limit_yaw
		self.lower_limit_pitch = lower_limit_pitch
		self.upper_limit_pitch = upper_limit_pitch
		self.lower_limit_roll = lower_limit_roll
		self.upper_limit_roll = upper_limit_roll

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,point_on_planar_curve_pair):
				self._simple_pair_range_applies_to_pair = point_on_planar_curve_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def range_on_pair_curve():
		def fget( self ):
			return self._range_on_pair_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument range_on_pair_curve is mantatory and can not be set to None')
			if not check_type(value,trimmed_curve):
				self._range_on_pair_curve = trimmed_curve(value)
			else:
				self._range_on_pair_curve = value
		return property(**locals())

	@apply
	def lower_limit_yaw():
		def fget( self ):
			return self._lower_limit_yaw
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_yaw is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_yaw = rotational_range_measure(value)
			else:
				self._lower_limit_yaw = value
		return property(**locals())

	@apply
	def upper_limit_yaw():
		def fget( self ):
			return self._upper_limit_yaw
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_yaw is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_yaw = rotational_range_measure(value)
			else:
				self._upper_limit_yaw = value
		return property(**locals())

	@apply
	def lower_limit_pitch():
		def fget( self ):
			return self._lower_limit_pitch
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_pitch is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_pitch = rotational_range_measure(value)
			else:
				self._lower_limit_pitch = value
		return property(**locals())

	@apply
	def upper_limit_pitch():
		def fget( self ):
			return self._upper_limit_pitch
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_pitch is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_pitch = rotational_range_measure(value)
			else:
				self._upper_limit_pitch = value
		return property(**locals())

	@apply
	def lower_limit_roll():
		def fget( self ):
			return self._lower_limit_roll
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_roll is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_roll = rotational_range_measure(value)
			else:
				self._lower_limit_roll = value
		return property(**locals())

	@apply
	def upper_limit_roll():
		def fget( self ):
			return self._upper_limit_roll
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_roll is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_roll = rotational_range_measure(value)
			else:
				self._upper_limit_roll = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.simple_pair_range.self.applies_to_pair.self.point_on_planar_curve_pair.self.pair_curve  ==  self.range_on_pair_curve.self.basis_curve)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_yaw))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_yaw))) XOR (self.lower_limit_yaw  <  self.upper_limit_yaw))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_pitch))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_pitch))) XOR (self.lower_limit_pitch  <  self.upper_limit_pitch))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_roll))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_roll))) XOR (self.lower_limit_roll  <  self.upper_limit_roll))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY taper #
####################
class taper(shape_aspect):
	'''Entity taper definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.description  ==  ['angle taper','diameter taper','directed taper'])
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'angle taper')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.description  !=  'diameter taper')  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = ((self.self.description  !=  'directed taper')  or  (SIZEOF(None)  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = ((self.self.description  !=  'directed taper')  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1)))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr


####################
 # ENTITY barring_hole #
####################
class barring_hole(feature_definition):
	'''Entity barring_hole definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY fill_area_style_tile_symbol_with_style #
####################
class fill_area_style_tile_symbol_with_style(geometric_representation_item):
	'''Entity fill_area_style_tile_symbol_with_style definition.

	:param symbol
	:type symbol:annotation_symbol_occurrence
	'''
	def __init__( self , inherited0__name , symbol, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.symbol = symbol

	@apply
	def symbol():
		def fget( self ):
			return self._symbol
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument symbol is mantatory and can not be set to None')
			if not check_type(value,annotation_symbol_occurrence):
				self._symbol = annotation_symbol_occurrence(value)
			else:
				self._symbol = value
		return property(**locals())

####################
 # ENTITY draughting_callout #
####################
class draughting_callout(geometric_representation_item):
	'''Entity draughting_callout definition.

	:param contents
	:type contents:SET(1,None,'draughting_callout_element', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , contents, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.contents = contents

	@apply
	def contents():
		def fget( self ):
			return self._contents
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument contents is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'draughting_callout_element', scope = schema_scope)):
				self._contents = SET(value)
			else:
				self._contents = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((((SIZEOF(None)  ==  0)  or  (('AUTOMOTIVE_DESIGN.LEADER_DIRECTED_CALLOUT'  ==  TYPEOF(self))  and  (SIZEOF(None)  ==  0)))  or  (('AUTOMOTIVE_DESIGN.PROJECTION_DIRECTED_CALLOUT'  ==  TYPEOF(self))  and  (SIZEOF(None)  ==  0)))  or  ('AUTOMOTIVE_DESIGN.DIMENSION_CURVE_DIRECTED_CALLOUT'  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY leader_directed_callout #
####################
class leader_directed_callout(draughting_callout):
	'''Entity leader_directed_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.draughting_callout.self.contents)  >=  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY leader_directed_dimension #
####################
class leader_directed_dimension(leader_directed_callout):
	'''Entity leader_directed_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		leader_directed_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY presentation_representation #
####################
class presentation_representation(representation):
	'''Entity presentation_representation definition.

	:param representation_context_of_items
	:type representation_context_of_items:geometric_representation_context
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_context_of_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_context_of_items = representation_context_of_items

	@apply
	def representation_context_of_items():
		def fget( self ):
			return self._representation_context_of_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_context_of_items is mantatory and can not be set to None')
			if not check_type(value,geometric_representation_context):
				self._representation_context_of_items = geometric_representation_context(value)
			else:
				self._representation_context_of_items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.representation.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((('AUTOMOTIVE_DESIGN.PRESENTATION_AREA'  ==  TYPEOF(self))  or  (SIZEOF(None)  >  0))  or  (SIZEOF(None)  >  0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY presentation_area #
####################
class presentation_area(presentation_representation):
	'''Entity presentation_area definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items ,  ):
		presentation_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(None)  >  0)  or  (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.PRESENTATION_SIZE.UNIT'))  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY mechanical_design_geometric_presentation_area #
####################
class mechanical_design_geometric_presentation_area(presentation_area):
	'''Entity mechanical_design_geometric_presentation_area definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items ,  ):
		presentation_area.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((SIZEOF(None)  ==  0)  and  (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  0))  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY name_attribute #
####################
class name_attribute(BaseEntityClass):
	'''Entity name_attribute definition.

	:param attribute_value
	:type attribute_value:label

	:param named_item
	:type named_item:name_attribute_select
	'''
	def __init__( self , attribute_value,named_item, ):
		self.attribute_value = attribute_value
		self.named_item = named_item

	@apply
	def attribute_value():
		def fget( self ):
			return self._attribute_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_value is mantatory and can not be set to None')
			if not check_type(value,label):
				self._attribute_value = label(value)
			else:
				self._attribute_value = value
		return property(**locals())

	@apply
	def named_item():
		def fget( self ):
			return self._named_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument named_item is mantatory and can not be set to None')
			if not check_type(value,name_attribute_select):
				self._named_item = name_attribute_select(value)
			else:
				self._named_item = value
		return property(**locals())

####################
 # ENTITY planar_pair_range #
####################
class planar_pair_range(simple_pair_range):
	'''Entity planar_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:planar_pair

	:param lower_limit_actual_rotation
	:type lower_limit_actual_rotation:rotational_range_measure

	:param upper_limit_actual_rotation
	:type upper_limit_actual_rotation:rotational_range_measure

	:param lower_limit_actual_translation_x
	:type lower_limit_actual_translation_x:translational_range_measure

	:param upper_limit_actual_translation_x
	:type upper_limit_actual_translation_x:translational_range_measure

	:param lower_limit_actual_translation_y
	:type lower_limit_actual_translation_y:translational_range_measure

	:param upper_limit_actual_translation_y
	:type upper_limit_actual_translation_y:translational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,lower_limit_actual_rotation,upper_limit_actual_rotation,lower_limit_actual_translation_x,upper_limit_actual_translation_x,lower_limit_actual_translation_y,upper_limit_actual_translation_y, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.lower_limit_actual_rotation = lower_limit_actual_rotation
		self.upper_limit_actual_rotation = upper_limit_actual_rotation
		self.lower_limit_actual_translation_x = lower_limit_actual_translation_x
		self.upper_limit_actual_translation_x = upper_limit_actual_translation_x
		self.lower_limit_actual_translation_y = lower_limit_actual_translation_y
		self.upper_limit_actual_translation_y = upper_limit_actual_translation_y

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,planar_pair):
				self._simple_pair_range_applies_to_pair = planar_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def lower_limit_actual_rotation():
		def fget( self ):
			return self._lower_limit_actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_actual_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_actual_rotation = rotational_range_measure(value)
			else:
				self._lower_limit_actual_rotation = value
		return property(**locals())

	@apply
	def upper_limit_actual_rotation():
		def fget( self ):
			return self._upper_limit_actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_actual_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_actual_rotation = rotational_range_measure(value)
			else:
				self._upper_limit_actual_rotation = value
		return property(**locals())

	@apply
	def lower_limit_actual_translation_x():
		def fget( self ):
			return self._lower_limit_actual_translation_x
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_actual_translation_x is mantatory and can not be set to None')
			if not check_type(value,translational_range_measure):
				self._lower_limit_actual_translation_x = translational_range_measure(value)
			else:
				self._lower_limit_actual_translation_x = value
		return property(**locals())

	@apply
	def upper_limit_actual_translation_x():
		def fget( self ):
			return self._upper_limit_actual_translation_x
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_actual_translation_x is mantatory and can not be set to None')
			if not check_type(value,translational_range_measure):
				self._upper_limit_actual_translation_x = translational_range_measure(value)
			else:
				self._upper_limit_actual_translation_x = value
		return property(**locals())

	@apply
	def lower_limit_actual_translation_y():
		def fget( self ):
			return self._lower_limit_actual_translation_y
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_actual_translation_y is mantatory and can not be set to None')
			if not check_type(value,translational_range_measure):
				self._lower_limit_actual_translation_y = translational_range_measure(value)
			else:
				self._lower_limit_actual_translation_y = value
		return property(**locals())

	@apply
	def upper_limit_actual_translation_y():
		def fget( self ):
			return self._upper_limit_actual_translation_y
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_actual_translation_y is mantatory and can not be set to None')
			if not check_type(value,translational_range_measure):
				self._upper_limit_actual_translation_y = translational_range_measure(value)
			else:
				self._upper_limit_actual_translation_y = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_actual_rotation))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_actual_rotation))) XOR (self.lower_limit_actual_rotation  <  self.upper_limit_actual_rotation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_actual_translation_x))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_actual_translation_x))) XOR (self.lower_limit_actual_translation_x  <  self.upper_limit_actual_translation_x))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_actual_translation_y))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_actual_translation_y))) XOR (self.lower_limit_actual_translation_y  <  self.upper_limit_actual_translation_y))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY drawing_revision_sequence #
####################
class drawing_revision_sequence(BaseEntityClass):
	'''Entity drawing_revision_sequence definition.

	:param predecessor
	:type predecessor:drawing_revision

	:param successor
	:type successor:drawing_revision
	'''
	def __init__( self , predecessor,successor, ):
		self.predecessor = predecessor
		self.successor = successor

	@apply
	def predecessor():
		def fget( self ):
			return self._predecessor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predecessor is mantatory and can not be set to None')
			if not check_type(value,drawing_revision):
				self._predecessor = drawing_revision(value)
			else:
				self._predecessor = value
		return property(**locals())

	@apply
	def successor():
		def fget( self ):
			return self._successor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument successor is mantatory and can not be set to None')
			if not check_type(value,drawing_revision):
				self._successor = drawing_revision(value)
			else:
				self._successor = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.predecessor  !=  self.successor)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY effectivity #
####################
class effectivity(BaseEntityClass):
	'''Entity effectivity definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id, ):
		self.id = id

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY serial_numbered_effectivity #
####################
class serial_numbered_effectivity(effectivity):
	'''Entity serial_numbered_effectivity definition.

	:param effectivity_start_id
	:type effectivity_start_id:identifier

	:param effectivity_end_id
	:type effectivity_end_id:identifier
	'''
	def __init__( self , inherited0__id , effectivity_start_id,effectivity_end_id, ):
		effectivity.__init__(self , inherited0__id , )
		self.effectivity_start_id = effectivity_start_id
		self.effectivity_end_id = effectivity_end_id

	@apply
	def effectivity_start_id():
		def fget( self ):
			return self._effectivity_start_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument effectivity_start_id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._effectivity_start_id = identifier(value)
			else:
				self._effectivity_start_id = value
		return property(**locals())

	@apply
	def effectivity_end_id():
		def fget( self ):
			return self._effectivity_end_id
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,identifier):
					self._effectivity_end_id = identifier(value)
				else:
					self._effectivity_end_id = value
			else:
				self._effectivity_end_id = value
		return property(**locals())

####################
 # ENTITY product_concept_feature_association #
####################
class product_concept_feature_association(BaseEntityClass):
	'''Entity product_concept_feature_association definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param concept
	:type concept:product_concept

	:param feature
	:type feature:product_concept_feature
	'''
	def __init__( self , name,description,concept,feature, ):
		self.name = name
		self.description = description
		self.concept = concept
		self.feature = feature

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def concept():
		def fget( self ):
			return self._concept
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument concept is mantatory and can not be set to None')
			if not check_type(value,product_concept):
				self._concept = product_concept(value)
			else:
				self._concept = value
		return property(**locals())

	@apply
	def feature():
		def fget( self ):
			return self._feature
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument feature is mantatory and can not be set to None')
			if not check_type(value,product_concept_feature):
				self._feature = product_concept_feature(value)
			else:
				self._feature = value
		return property(**locals())

####################
 # ENTITY date_and_time_assignment #
####################
class date_and_time_assignment(BaseEntityClass):
	'''Entity date_and_time_assignment definition.

	:param assigned_date_and_time
	:type assigned_date_and_time:date_and_time

	:param role
	:type role:date_time_role
	'''
	def __init__( self , assigned_date_and_time,role, ):
		self.assigned_date_and_time = assigned_date_and_time
		self.role = role

	@apply
	def assigned_date_and_time():
		def fget( self ):
			return self._assigned_date_and_time
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_date_and_time is mantatory and can not be set to None')
			if not check_type(value,date_and_time):
				self._assigned_date_and_time = date_and_time(value)
			else:
				self._assigned_date_and_time = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,date_time_role):
				self._role = date_time_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_date_and_time_assignment #
####################
class applied_date_and_time_assignment(date_and_time_assignment):
	'''Entity applied_date_and_time_assignment definition.

	:param items
	:type items:SET(1,None,'date_and_time_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_date_and_time , inherited1__role , items, ):
		date_and_time_assignment.__init__(self , inherited0__assigned_date_and_time , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'date_and_time_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY multiple_arity_numeric_expression #
####################
class multiple_arity_numeric_expression(numeric_expression,multiple_arity_generic_expression):
	'''Entity multiple_arity_numeric_expression definition.

	:param multiple_arity_generic_expression_operands
	:type multiple_arity_generic_expression_operands:LIST(2,None,'numeric_expression', scope = schema_scope)
	'''
	def __init__( self , inherited0__operands , multiple_arity_generic_expression_operands, ):
		numeric_expression.__init__(self , )
		multiple_arity_generic_expression.__init__(self , inherited0__operands , )
		self.multiple_arity_generic_expression_operands = multiple_arity_generic_expression_operands

	@apply
	def multiple_arity_generic_expression_operands():
		def fget( self ):
			return self._multiple_arity_generic_expression_operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument multiple_arity_generic_expression_operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'numeric_expression', scope = schema_scope)):
				self._multiple_arity_generic_expression_operands = LIST(value)
			else:
				self._multiple_arity_generic_expression_operands = value
		return property(**locals())

####################
 # ENTITY screw_pair #
####################
class screw_pair(kinematic_pair):
	'''Entity screw_pair definition.

	:param pitch
	:type pitch:length_measure
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , pitch, ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )
		self.pitch = pitch

	@apply
	def pitch():
		def fget( self ):
			return self._pitch
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pitch is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._pitch = length_measure(value)
			else:
				self._pitch = value
		return property(**locals())

####################
 # ENTITY surface_pair #
####################
class surface_pair(kinematic_pair):
	'''Entity surface_pair definition.

	:param surface_1
	:type surface_1:surface

	:param surface_2
	:type surface_2:surface

	:param orientation
	:type orientation:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , surface_1,surface_2,orientation, ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )
		self.surface_1 = surface_1
		self.surface_2 = surface_2
		self.orientation = orientation

	@apply
	def surface_1():
		def fget( self ):
			return self._surface_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument surface_1 is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._surface_1 = surface(value)
			else:
				self._surface_1 = value
		return property(**locals())

	@apply
	def surface_2():
		def fget( self ):
			return self._surface_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument surface_2 is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._surface_2 = surface(value)
			else:
				self._surface_2 = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = frame_associated_to_background(self.self.kinematic_pair.self.pair_placement_in_first_link_context,self.surface_1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = frame_associated_to_background(self.self.kinematic_pair.self.pair_placement_in_second_link_context,self.surface_2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY sliding_surface_pair #
####################
class sliding_surface_pair(surface_pair):
	'''Entity sliding_surface_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , inherited5__surface_1 , inherited6__surface_2 , inherited7__orientation ,  ):
		surface_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , inherited5__surface_1 , inherited6__surface_2 , inherited7__orientation , )

####################
 # ENTITY mapped_item #
####################
class mapped_item(representation_item):
	'''Entity mapped_item definition.

	:param mapping_source
	:type mapping_source:representation_map

	:param mapping_target
	:type mapping_target:representation_item
	'''
	def __init__( self , inherited0__name , mapping_source,mapping_target, ):
		representation_item.__init__(self , inherited0__name , )
		self.mapping_source = mapping_source
		self.mapping_target = mapping_target

	@apply
	def mapping_source():
		def fget( self ):
			return self._mapping_source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapping_source is mantatory and can not be set to None')
			if not check_type(value,representation_map):
				self._mapping_source = representation_map(value)
			else:
				self._mapping_source = value
		return property(**locals())

	@apply
	def mapping_target():
		def fget( self ):
			return self._mapping_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapping_target is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._mapping_target = representation_item(value)
			else:
				self._mapping_target = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = acyclic_mapped_representation(using_representations(self),[self])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY annotation_text_character #
####################
class annotation_text_character(mapped_item):
	'''Entity annotation_text_character definition.

	:param alignment
	:type alignment:text_alignment

	:param mapped_item_mapping_target
	:type mapped_item_mapping_target:axis2_placement
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , alignment,mapped_item_mapping_target, ):
		mapped_item.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , )
		self.alignment = alignment
		self.mapped_item_mapping_target = mapped_item_mapping_target

	@apply
	def alignment():
		def fget( self ):
			return self._alignment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument alignment is mantatory and can not be set to None')
			if not check_type(value,text_alignment):
				self._alignment = text_alignment(value)
			else:
				self._alignment = value
		return property(**locals())

	@apply
	def mapped_item_mapping_target():
		def fget( self ):
			return self._mapped_item_mapping_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_target is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._mapped_item_mapping_target = axis2_placement(value)
			else:
				self._mapped_item_mapping_target = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.CHARACTER_GLYPH_SYMBOL'  ==  TYPEOF(self.self.mapped_item.self.mapping_source.self.mapped_representation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AUTOMOTIVE_DESIGN.GEOMETRIC_REPRESENTATION_ITEM'  ==  TYPEOF(self))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY surface #
####################
class surface(geometric_representation_item):
	'''Entity surface definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY oriented_surface #
####################
class oriented_surface(surface):
	'''Entity oriented_surface definition.

	:param orientation
	:type orientation:BOOLEAN
	'''
	def __init__( self , inherited0__name , orientation, ):
		surface.__init__(self , inherited0__name , )
		self.orientation = orientation

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY offset_surface #
####################
class offset_surface(surface):
	'''Entity offset_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param distance
	:type distance:length_measure

	:param self_intersect
	:type self_intersect:LOGICAL
	'''
	def __init__( self , inherited0__name , basis_surface,distance,self_intersect, ):
		surface.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.distance = distance
		self.self_intersect = self_intersect

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def distance():
		def fget( self ):
			return self._distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._distance = length_measure(value)
			else:
				self._distance = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())

####################
 # ENTITY placement #
####################
class placement(geometric_representation_item):
	'''Entity placement definition.

	:param location
	:type location:cartesian_point
	'''
	def __init__( self , inherited0__name , location, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.location = location

	@apply
	def location():
		def fget( self ):
			return self._location
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument location is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._location = cartesian_point(value)
			else:
				self._location = value
		return property(**locals())

####################
 # ENTITY axis2_placement_2d #
####################
class axis2_placement_2d(placement):
	'''Entity axis2_placement_2d definition.

	:param ref_direction
	:type ref_direction:direction

	:param p
	:type p:LIST(2,2,'direction', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__location , ref_direction, ):
		placement.__init__(self , inherited0__name , inherited1__location , )
		self.ref_direction = ref_direction

	@apply
	def ref_direction():
		def fget( self ):
			return self._ref_direction
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._ref_direction = direction(value)
				else:
					self._ref_direction = value
			else:
				self._ref_direction = value
		return property(**locals())

	@apply
	def p():
		def fget( self ):
			attribute_eval = build_2axes(self.ref_direction)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY composite_shape_aspect #
####################
class composite_shape_aspect(shape_aspect):
	'''Entity composite_shape_aspect definition.

	:param component_relationships
	:type component_relationships:SET(2,None,'shape_aspect_relationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )

	@apply
	def component_relationships():
		def fget( self ):
			return self._component_relationships
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument component_relationships is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY general_property #
####################
class general_property(BaseEntityClass):
	'''Entity general_property definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY general_material_property #
####################
class general_material_property(general_property):
	'''Entity general_material_property definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description ,  ):
		general_property.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_category #
####################
class product_category(BaseEntityClass):
	'''Entity product_category definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_related_product_category #
####################
class product_related_product_category(product_category):
	'''Entity product_related_product_category definition.

	:param products
	:type products:SET(1,None,'product', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , products, ):
		product_category.__init__(self , inherited0__name , inherited1__description , )
		self.products = products

	@apply
	def products():
		def fget( self ):
			return self._products
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument products is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'product', scope = schema_scope)):
				self._products = SET(value)
			else:
				self._products = value
		return property(**locals())

####################
 # ENTITY shape_representation_with_parameters #
####################
class shape_representation_with_parameters(shape_representation):
	'''Entity shape_representation_with_parameters definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  SIZEOF(self.self.items))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY curve #
####################
class curve(geometric_representation_item):
	'''Entity curve definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY conic #
####################
class conic(curve):
	'''Entity conic definition.

	:param position
	:type position:axis2_placement
	'''
	def __init__( self , inherited0__name , position, ):
		curve.__init__(self , inherited0__name , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._position = axis2_placement(value)
			else:
				self._position = value
		return property(**locals())

####################
 # ENTITY hyperbola #
####################
class hyperbola(conic):
	'''Entity hyperbola definition.

	:param semi_axis
	:type semi_axis:positive_length_measure

	:param semi_imag_axis
	:type semi_imag_axis:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , semi_axis,semi_imag_axis, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self.semi_axis = semi_axis
		self.semi_imag_axis = semi_imag_axis

	@apply
	def semi_axis():
		def fget( self ):
			return self._semi_axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_axis is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._semi_axis = positive_length_measure(value)
			else:
				self._semi_axis = value
		return property(**locals())

	@apply
	def semi_imag_axis():
		def fget( self ):
			return self._semi_imag_axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_imag_axis is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._semi_imag_axis = positive_length_measure(value)
			else:
				self._semi_imag_axis = value
		return property(**locals())

####################
 # ENTITY path_shape_representation #
####################
class path_shape_representation(shape_representation):
	'''Entity path_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY shape_aspect_deriving_relationship #
####################
class shape_aspect_deriving_relationship(shape_aspect_relationship):
	'''Entity shape_aspect_deriving_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		shape_aspect_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.DERIVED_SHAPE_ASPECT'  ==  TYPEOF(self.self.shape_aspect_relationship.self.relating_shape_aspect))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY tolerance_zone_form #
####################
class tolerance_zone_form(BaseEntityClass):
	'''Entity tolerance_zone_form definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY uncertainty_qualifier #
####################
class uncertainty_qualifier(BaseEntityClass):
	'''Entity uncertainty_qualifier definition.

	:param measure_name
	:type measure_name:label

	:param description
	:type description:text
	'''
	def __init__( self , measure_name,description, ):
		self.measure_name = measure_name
		self.description = description

	@apply
	def measure_name():
		def fget( self ):
			return self._measure_name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument measure_name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._measure_name = label(value)
			else:
				self._measure_name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY composite_text #
####################
class composite_text(geometric_representation_item):
	'''Entity composite_text definition.

	:param collected_text
	:type collected_text:SET(2,None,'text_or_character', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , collected_text, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.collected_text = collected_text

	@apply
	def collected_text():
		def fget( self ):
			return self._collected_text
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument collected_text is mantatory and can not be set to None')
			if not check_type(value,SET(2,None,'text_or_character', scope = schema_scope)):
				self._collected_text = SET(value)
			else:
				self._collected_text = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = acyclic_composite_text(self,self.self.collected_text)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY composite_text_with_extent #
####################
class composite_text_with_extent(composite_text):
	'''Entity composite_text_with_extent definition.

	:param extent
	:type extent:planar_extent
	'''
	def __init__( self , inherited0__name , inherited1__collected_text , extent, ):
		composite_text.__init__(self , inherited0__name , inherited1__collected_text , )
		self.extent = extent

	@apply
	def extent():
		def fget( self ):
			return self._extent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extent is mantatory and can not be set to None')
			if not check_type(value,planar_extent):
				self._extent = planar_extent(value)
			else:
				self._extent = value
		return property(**locals())

####################
 # ENTITY address #
####################
class address(BaseEntityClass):
	'''Entity address definition.

	:param internal_location
	:type internal_location:label

	:param street_number
	:type street_number:label

	:param street
	:type street:label

	:param postal_box
	:type postal_box:label

	:param town
	:type town:label

	:param region
	:type region:label

	:param postal_code
	:type postal_code:label

	:param country
	:type country:label

	:param facsimile_number
	:type facsimile_number:label

	:param telephone_number
	:type telephone_number:label

	:param electronic_mail_address
	:type electronic_mail_address:label

	:param telex_number
	:type telex_number:label

	:param name
	:type name:label

	:param url
	:type url:identifier
	'''
	def __init__( self , internal_location,street_number,street,postal_box,town,region,postal_code,country,facsimile_number,telephone_number,electronic_mail_address,telex_number, ):
		self.internal_location = internal_location
		self.street_number = street_number
		self.street = street
		self.postal_box = postal_box
		self.town = town
		self.region = region
		self.postal_code = postal_code
		self.country = country
		self.facsimile_number = facsimile_number
		self.telephone_number = telephone_number
		self.electronic_mail_address = electronic_mail_address
		self.telex_number = telex_number

	@apply
	def internal_location():
		def fget( self ):
			return self._internal_location
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._internal_location = label(value)
				else:
					self._internal_location = value
			else:
				self._internal_location = value
		return property(**locals())

	@apply
	def street_number():
		def fget( self ):
			return self._street_number
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._street_number = label(value)
				else:
					self._street_number = value
			else:
				self._street_number = value
		return property(**locals())

	@apply
	def street():
		def fget( self ):
			return self._street
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._street = label(value)
				else:
					self._street = value
			else:
				self._street = value
		return property(**locals())

	@apply
	def postal_box():
		def fget( self ):
			return self._postal_box
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._postal_box = label(value)
				else:
					self._postal_box = value
			else:
				self._postal_box = value
		return property(**locals())

	@apply
	def town():
		def fget( self ):
			return self._town
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._town = label(value)
				else:
					self._town = value
			else:
				self._town = value
		return property(**locals())

	@apply
	def region():
		def fget( self ):
			return self._region
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._region = label(value)
				else:
					self._region = value
			else:
				self._region = value
		return property(**locals())

	@apply
	def postal_code():
		def fget( self ):
			return self._postal_code
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._postal_code = label(value)
				else:
					self._postal_code = value
			else:
				self._postal_code = value
		return property(**locals())

	@apply
	def country():
		def fget( self ):
			return self._country
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._country = label(value)
				else:
					self._country = value
			else:
				self._country = value
		return property(**locals())

	@apply
	def facsimile_number():
		def fget( self ):
			return self._facsimile_number
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._facsimile_number = label(value)
				else:
					self._facsimile_number = value
			else:
				self._facsimile_number = value
		return property(**locals())

	@apply
	def telephone_number():
		def fget( self ):
			return self._telephone_number
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._telephone_number = label(value)
				else:
					self._telephone_number = value
			else:
				self._telephone_number = value
		return property(**locals())

	@apply
	def electronic_mail_address():
		def fget( self ):
			return self._electronic_mail_address
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._electronic_mail_address = label(value)
				else:
					self._electronic_mail_address = value
			else:
				self._electronic_mail_address = value
		return property(**locals())

	@apply
	def telex_number():
		def fget( self ):
			return self._telex_number
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._telex_number = label(value)
				else:
					self._telex_number = value
			else:
				self._telex_number = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def url():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument url is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((((((((((EXISTS(self.internal_location)  or  EXISTS(self.street_number))  or  EXISTS(self.street))  or  EXISTS(self.postal_box))  or  EXISTS(self.town))  or  EXISTS(self.region))  or  EXISTS(self.postal_code))  or  EXISTS(self.country))  or  EXISTS(self.facsimile_number))  or  EXISTS(self.telephone_number))  or  EXISTS(self.electronic_mail_address))  or  EXISTS(self.telex_number))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY organizational_address #
####################
class organizational_address(address):
	'''Entity organizational_address definition.

	:param organizations
	:type organizations:SET(1,None,'organization', scope = schema_scope)

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , organizations,description, ):
		address.__init__(self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , )
		self.organizations = organizations
		self.description = description

	@apply
	def organizations():
		def fget( self ):
			return self._organizations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument organizations is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'organization', scope = schema_scope)):
				self._organizations = SET(value)
			else:
				self._organizations = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY bounded_surface #
####################
class bounded_surface(surface):
	'''Entity bounded_surface definition.
	'''
	def __init__( self , inherited0__name ,  ):
		surface.__init__(self , inherited0__name , )

####################
 # ENTITY b_spline_surface #
####################
class b_spline_surface(bounded_surface):
	'''Entity b_spline_surface definition.

	:param u_degree
	:type u_degree:INTEGER

	:param v_degree
	:type v_degree:INTEGER

	:param control_points_list
	:type control_points_list:LIST(2,None,LIST(2,None,'cartesian_point', scope = schema_scope))

	:param surface_form
	:type surface_form:b_spline_surface_form

	:param u_closed
	:type u_closed:LOGICAL

	:param v_closed
	:type v_closed:LOGICAL

	:param self_intersect
	:type self_intersect:LOGICAL

	:param u_upper
	:type u_upper:INTEGER

	:param v_upper
	:type v_upper:INTEGER

	:param control_points
	:type control_points:ARRAY(0,u_upper,ARRAY(0,v_upper,'cartesian_point', scope = schema_scope))
	'''
	def __init__( self , inherited0__name , u_degree,v_degree,control_points_list,surface_form,u_closed,v_closed,self_intersect, ):
		bounded_surface.__init__(self , inherited0__name , )
		self.u_degree = u_degree
		self.v_degree = v_degree
		self.control_points_list = control_points_list
		self.surface_form = surface_form
		self.u_closed = u_closed
		self.v_closed = v_closed
		self.self_intersect = self_intersect

	@apply
	def u_degree():
		def fget( self ):
			return self._u_degree
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_degree is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._u_degree = INTEGER(value)
			else:
				self._u_degree = value
		return property(**locals())

	@apply
	def v_degree():
		def fget( self ):
			return self._v_degree
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_degree is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._v_degree = INTEGER(value)
			else:
				self._v_degree = value
		return property(**locals())

	@apply
	def control_points_list():
		def fget( self ):
			return self._control_points_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument control_points_list is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,LIST(2,None,'cartesian_point', scope = schema_scope))):
				self._control_points_list = LIST(value)
			else:
				self._control_points_list = value
		return property(**locals())

	@apply
	def surface_form():
		def fget( self ):
			return self._surface_form
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument surface_form is mantatory and can not be set to None')
			if not check_type(value,b_spline_surface_form):
				self._surface_form = b_spline_surface_form(value)
			else:
				self._surface_form = value
		return property(**locals())

	@apply
	def u_closed():
		def fget( self ):
			return self._u_closed
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_closed is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._u_closed = LOGICAL(value)
			else:
				self._u_closed = value
		return property(**locals())

	@apply
	def v_closed():
		def fget( self ):
			return self._v_closed
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_closed is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._v_closed = LOGICAL(value)
			else:
				self._v_closed = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())

	@apply
	def u_upper():
		def fget( self ):
			attribute_eval = (SIZEOF(self.control_points_list) - 1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument u_upper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def v_upper():
		def fget( self ):
			attribute_eval = (SIZEOF(self.control_points_list[1]) - 1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument v_upper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def control_points():
		def fget( self ):
			attribute_eval = make_array_of_array(self.control_points_list,0,self.u_upper,0,self.v_upper)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument control_points is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((('AUTOMOTIVE_DESIGN.UNIFORM_SURFACE'  ==  TYPEOF(self))  or  ('AUTOMOTIVE_DESIGN.QUASI_UNIFORM_SURFACE'  ==  TYPEOF(self)))  or  ('AUTOMOTIVE_DESIGN.BEZIER_SURFACE'  ==  TYPEOF(self)))  or  ('AUTOMOTIVE_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS'  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY uniform_surface #
####################
class uniform_surface(b_spline_surface):
	'''Entity uniform_surface definition.
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect ,  ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )

####################
 # ENTITY geometrically_bounded_surface_shape_representation #
####################
class geometrically_bounded_surface_shape_representation(shape_representation):
	'''Entity geometrically_bounded_surface_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  >  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY line_profile_tolerance #
####################
class line_profile_tolerance(geometric_tolerance):
	'''Entity line_profile_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))  or  (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY text_style #
####################
class text_style(founded_item):
	'''Entity text_style definition.

	:param name
	:type name:label

	:param character_appearance
	:type character_appearance:character_style_select
	'''
	def __init__( self , name,character_appearance, ):
		founded_item.__init__(self , )
		self.name = name
		self.character_appearance = character_appearance

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def character_appearance():
		def fget( self ):
			return self._character_appearance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument character_appearance is mantatory and can not be set to None')
			if not check_type(value,character_style_select):
				self._character_appearance = character_style_select(value)
			else:
				self._character_appearance = value
		return property(**locals())

####################
 # ENTITY axis1_placement #
####################
class axis1_placement(placement):
	'''Entity axis1_placement definition.

	:param axis
	:type axis:direction

	:param z
	:type z:direction
	'''
	def __init__( self , inherited0__name , inherited1__location , axis, ):
		placement.__init__(self , inherited0__name , inherited1__location , )
		self.axis = axis

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._axis = direction(value)
				else:
					self._axis = value
			else:
				self._axis = value
		return property(**locals())

	@apply
	def z():
		def fget( self ):
			attribute_eval = NVL(normalise(self.axis),self.dummy_gri  ==  direction([0,0,1]))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument z is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY symbol_representation #
####################
class symbol_representation(representation):
	'''Entity symbol_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )

####################
 # ENTITY generic_character_glyph_symbol #
####################
class generic_character_glyph_symbol(symbol_representation):
	'''Entity generic_character_glyph_symbol definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		symbol_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )

####################
 # ENTITY string_expression #
####################
class string_expression(expression):
	'''Entity string_expression definition.
	'''
	def __init__( self ,  ):
		expression.__init__(self , )

####################
 # ENTITY binary_generic_expression #
####################
class binary_generic_expression(generic_expression):
	'''Entity binary_generic_expression definition.

	:param operands
	:type operands:LIST(2,2,'generic_expression', scope = schema_scope)
	'''
	def __init__( self , operands, ):
		generic_expression.__init__(self , )
		self.operands = operands

	@apply
	def operands():
		def fget( self ):
			return self._operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'generic_expression', scope = schema_scope)):
				self._operands = LIST(value)
			else:
				self._operands = value
		return property(**locals())

####################
 # ENTITY index_expression #
####################
class index_expression(string_expression,binary_generic_expression):
	'''Entity index_expression definition.

	:param operand
	:type operand:generic_expression

	:param index
	:type index:generic_expression
	'''
	def __init__( self , inherited0__operands ,  ):
		string_expression.__init__(self , )
		binary_generic_expression.__init__(self , inherited0__operands , )

	@apply
	def operand():
		def fget( self ):
			attribute_eval = self.self.binary_generic_expression.self.operands[1]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument operand is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def index():
		def fget( self ):
			attribute_eval = self.self.binary_generic_expression.self.operands[2]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument index is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.STRING_EXPRESSION'  ==  TYPEOF(self.operand))  and  ('AUTOMOTIVE_DESIGN.NUMERIC_EXPRESSION'  ==  TYPEOF(self.index)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = is_int_expr(self.index)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY identification_assignment #
####################
class identification_assignment(BaseEntityClass):
	'''Entity identification_assignment definition.

	:param assigned_id
	:type assigned_id:identifier

	:param role
	:type role:identification_role
	'''
	def __init__( self , assigned_id,role, ):
		self.assigned_id = assigned_id
		self.role = role

	@apply
	def assigned_id():
		def fget( self ):
			return self._assigned_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._assigned_id = identifier(value)
			else:
				self._assigned_id = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,identification_role):
				self._role = identification_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY external_identification_assignment #
####################
class external_identification_assignment(identification_assignment):
	'''Entity external_identification_assignment definition.

	:param source
	:type source:external_source
	'''
	def __init__( self , inherited0__assigned_id , inherited1__role , source, ):
		identification_assignment.__init__(self , inherited0__assigned_id , inherited1__role , )
		self.source = source

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source is mantatory and can not be set to None')
			if not check_type(value,external_source):
				self._source = external_source(value)
			else:
				self._source = value
		return property(**locals())

####################
 # ENTITY applied_external_identification_assignment #
####################
class applied_external_identification_assignment(external_identification_assignment):
	'''Entity applied_external_identification_assignment definition.

	:param items
	:type items:SET(1,None,'external_identification_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_id , inherited1__role , inherited2__source , items, ):
		external_identification_assignment.__init__(self , inherited0__assigned_id , inherited1__role , inherited2__source , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'external_identification_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (self.self.role.self.name  ==  'alternative document id and location'))  or  item_correlation(self.self.items,['DOCUMENT_FILE']))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not (self.self.role.self.name  ==  'version'))  or  item_correlation(self.self.items,['EXTERNALLY_DEFINED_CLASS','EXTERNALLY_DEFINED_GENERAL_PROPERTY']))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY csg_shape_representation #
####################
class csg_shape_representation(shape_representation):
	'''Entity csg_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  >  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY defined_function #
####################
class defined_function(BaseEntityClass):
	'''Entity defined_function definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY numeric_defined_function #
####################
class numeric_defined_function(numeric_expression,defined_function):
	'''Entity numeric_defined_function definition.
	'''
	def __init__( self ,  ):
		numeric_expression.__init__(self , )
		defined_function.__init__(self , )

####################
 # ENTITY integer_defined_function #
####################
class integer_defined_function(numeric_defined_function):
	'''Entity integer_defined_function definition.
	'''
	def __init__( self ,  ):
		numeric_defined_function.__init__(self , )

####################
 # ENTITY pre_defined_item #
####################
class pre_defined_item(BaseEntityClass):
	'''Entity pre_defined_item definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY pre_defined_symbol #
####################
class pre_defined_symbol(pre_defined_item):
	'''Entity pre_defined_symbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )

####################
 # ENTITY pre_defined_dimension_symbol #
####################
class pre_defined_dimension_symbol(pre_defined_symbol):
	'''Entity pre_defined_dimension_symbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_symbol.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['arc length','conical taper','counterbore','countersink','depth','diameter','plus minus','radius','slope','spherical diameter','spherical radius','square'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY bounded_curve #
####################
class bounded_curve(curve):
	'''Entity bounded_curve definition.
	'''
	def __init__( self , inherited0__name ,  ):
		curve.__init__(self , inherited0__name , )

####################
 # ENTITY b_spline_curve #
####################
class b_spline_curve(bounded_curve):
	'''Entity b_spline_curve definition.

	:param degree
	:type degree:INTEGER

	:param control_points_list
	:type control_points_list:LIST(2,None,'cartesian_point', scope = schema_scope)

	:param curve_form
	:type curve_form:b_spline_curve_form

	:param closed_curve
	:type closed_curve:LOGICAL

	:param self_intersect
	:type self_intersect:LOGICAL

	:param upper_index_on_control_points
	:type upper_index_on_control_points:INTEGER

	:param control_points
	:type control_points:ARRAY(0,upper_index_on_control_points,'cartesian_point', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , degree,control_points_list,curve_form,closed_curve,self_intersect, ):
		bounded_curve.__init__(self , inherited0__name , )
		self.degree = degree
		self.control_points_list = control_points_list
		self.curve_form = curve_form
		self.closed_curve = closed_curve
		self.self_intersect = self_intersect

	@apply
	def degree():
		def fget( self ):
			return self._degree
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument degree is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._degree = INTEGER(value)
			else:
				self._degree = value
		return property(**locals())

	@apply
	def control_points_list():
		def fget( self ):
			return self._control_points_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument control_points_list is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'cartesian_point', scope = schema_scope)):
				self._control_points_list = LIST(value)
			else:
				self._control_points_list = value
		return property(**locals())

	@apply
	def curve_form():
		def fget( self ):
			return self._curve_form
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_form is mantatory and can not be set to None')
			if not check_type(value,b_spline_curve_form):
				self._curve_form = b_spline_curve_form(value)
			else:
				self._curve_form = value
		return property(**locals())

	@apply
	def closed_curve():
		def fget( self ):
			return self._closed_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument closed_curve is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._closed_curve = LOGICAL(value)
			else:
				self._closed_curve = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())

	@apply
	def upper_index_on_control_points():
		def fget( self ):
			attribute_eval = (SIZEOF(self.control_points_list) - 1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument upper_index_on_control_points is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def control_points():
		def fget( self ):
			attribute_eval = list_to_array(self.control_points_list,0,self.upper_index_on_control_points)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument control_points is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((('AUTOMOTIVE_DESIGN.UNIFORM_CURVE'  ==  TYPEOF(self))  or  ('AUTOMOTIVE_DESIGN.QUASI_UNIFORM_CURVE'  ==  TYPEOF(self)))  or  ('AUTOMOTIVE_DESIGN.BEZIER_CURVE'  ==  TYPEOF(self)))  or  ('AUTOMOTIVE_DESIGN.B_SPLINE_CURVE_WITH_KNOTS'  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rational_b_spline_curve #
####################
class rational_b_spline_curve(b_spline_curve):
	'''Entity rational_b_spline_curve definition.

	:param weights_data
	:type weights_data:LIST(2,None,'REAL', scope = schema_scope)

	:param weights
	:type weights:ARRAY(0,upper_index_on_control_points,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , weights_data, ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )
		self.weights_data = weights_data

	@apply
	def weights_data():
		def fget( self ):
			return self._weights_data
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument weights_data is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._weights_data = LIST(value)
			else:
				self._weights_data = value
		return property(**locals())

	@apply
	def weights():
		def fget( self ):
			attribute_eval = list_to_array(self.weights_data,0,self.upper_index_on_control_points)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument weights is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.weights_data)  ==  SIZEOF(self.self.b_spline_curve.self.control_points_list))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = curve_weights_positive(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY topological_representation_item #
####################
class topological_representation_item(representation_item):
	'''Entity topological_representation_item definition.
	'''
	def __init__( self , inherited0__name ,  ):
		representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY edge #
####################
class edge(topological_representation_item):
	'''Entity edge definition.

	:param edge_start
	:type edge_start:vertex

	:param edge_end
	:type edge_end:vertex
	'''
	def __init__( self , inherited0__name , edge_start,edge_end, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.edge_start = edge_start
		self.edge_end = edge_end

	@apply
	def edge_start():
		def fget( self ):
			return self._edge_start
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edge_start is mantatory and can not be set to None')
			if not check_type(value,vertex):
				self._edge_start = vertex(value)
			else:
				self._edge_start = value
		return property(**locals())

	@apply
	def edge_end():
		def fget( self ):
			return self._edge_end
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edge_end is mantatory and can not be set to None')
			if not check_type(value,vertex):
				self._edge_end = vertex(value)
			else:
				self._edge_end = value
		return property(**locals())

####################
 # ENTITY subedge #
####################
class subedge(edge):
	'''Entity subedge definition.

	:param parent_edge
	:type parent_edge:edge
	'''
	def __init__( self , inherited0__name , inherited1__edge_start , inherited2__edge_end , parent_edge, ):
		edge.__init__(self , inherited0__name , inherited1__edge_start , inherited2__edge_end , )
		self.parent_edge = parent_edge

	@apply
	def parent_edge():
		def fget( self ):
			return self._parent_edge
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_edge is mantatory and can not be set to None')
			if not check_type(value,edge):
				self._parent_edge = edge(value)
			else:
				self._parent_edge = value
		return property(**locals())

####################
 # ENTITY comparison_expression #
####################
class comparison_expression(boolean_expression,binary_generic_expression):
	'''Entity comparison_expression definition.

	:param binary_generic_expression_operands
	:type binary_generic_expression_operands:LIST(2,2,'expression', scope = schema_scope)
	'''
	def __init__( self , inherited0__operands , binary_generic_expression_operands, ):
		boolean_expression.__init__(self , )
		binary_generic_expression.__init__(self , inherited0__operands , )
		self.binary_generic_expression_operands = binary_generic_expression_operands

	@apply
	def binary_generic_expression_operands():
		def fget( self ):
			return self._binary_generic_expression_operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument binary_generic_expression_operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'expression', scope = schema_scope)):
				self._binary_generic_expression_operands = LIST(value)
			else:
				self._binary_generic_expression_operands = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((('AUTOMOTIVE_DESIGN.NUMERIC_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[1]))  and  ('AUTOMOTIVE_DESIGN.NUMERIC_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[2])))  or  (('AUTOMOTIVE_DESIGN.BOOLEAN_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[1]))  and  ('AUTOMOTIVE_DESIGN.BOOLEAN_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[2]))))  or  (('AUTOMOTIVE_DESIGN.STRING_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[1]))  and  ('AUTOMOTIVE_DESIGN.STRING_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[2]))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY comparison_greater #
####################
class comparison_greater(comparison_expression):
	'''Entity comparison_greater definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		comparison_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY geometric_tolerance_with_datum_reference #
####################
class geometric_tolerance_with_datum_reference(geometric_tolerance):
	'''Entity geometric_tolerance_with_datum_reference definition.

	:param datum_system
	:type datum_system:SET(1,None,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , datum_system, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
		self.datum_system = datum_system

	@apply
	def datum_system():
		def fget( self ):
			return self._datum_system
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument datum_system is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'datum_reference', scope = schema_scope)):
				self._datum_system = SET(value)
			else:
				self._datum_system = value
		return property(**locals())

####################
 # ENTITY symmetry_tolerance #
####################
class symmetry_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity symmetry_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_request_assignment #
####################
class action_request_assignment(BaseEntityClass):
	'''Entity action_request_assignment definition.

	:param assigned_action_request
	:type assigned_action_request:versioned_action_request

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_action_request, ):
		self.assigned_action_request = assigned_action_request

	@apply
	def assigned_action_request():
		def fget( self ):
			return self._assigned_action_request
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_action_request is mantatory and can not be set to None')
			if not check_type(value,versioned_action_request):
				self._assigned_action_request = versioned_action_request(value)
			else:
				self._assigned_action_request = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_area #
####################
class applied_area(shape_aspect):
	'''Entity applied_area definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY unary_boolean_expression #
####################
class unary_boolean_expression(boolean_expression,unary_generic_expression):
	'''Entity unary_boolean_expression definition.
	'''
	def __init__( self , inherited0__operand ,  ):
		boolean_expression.__init__(self , )
		unary_generic_expression.__init__(self , inherited0__operand , )

####################
 # ENTITY odd_function #
####################
class odd_function(unary_boolean_expression):
	'''Entity odd_function definition.

	:param unary_generic_expression_operand
	:type unary_generic_expression_operand:numeric_expression
	'''
	def __init__( self , inherited0__operand , unary_generic_expression_operand, ):
		unary_boolean_expression.__init__(self , inherited0__operand , )
		self.unary_generic_expression_operand = unary_generic_expression_operand

	@apply
	def unary_generic_expression_operand():
		def fget( self ):
			return self._unary_generic_expression_operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unary_generic_expression_operand is mantatory and can not be set to None')
			if not check_type(value,numeric_expression):
				self._unary_generic_expression_operand = numeric_expression(value)
			else:
				self._unary_generic_expression_operand = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = is_int_expr(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY dimensional_location #
####################
class dimensional_location(shape_aspect_relationship):
	'''Entity dimensional_location definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		shape_aspect_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )

####################
 # ENTITY directed_dimensional_location #
####################
class directed_dimensional_location(dimensional_location):
	'''Entity directed_dimensional_location definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		dimensional_location.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )

####################
 # ENTITY context_dependent_unit #
####################
class context_dependent_unit(named_unit):
	'''Entity context_dependent_unit definition.

	:param name
	:type name:label
	'''
	def __init__( self , inherited0__dimensions , name, ):
		named_unit.__init__(self , inherited0__dimensions , )
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY variable_semantics #
####################
class variable_semantics(BaseEntityClass):
	'''Entity variable_semantics definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY expression_conversion_based_unit #
####################
class expression_conversion_based_unit(context_dependent_unit,variable_semantics):
	'''Entity expression_conversion_based_unit definition.

	:param associated_variable_environment
	:type associated_variable_environment:environment
	'''
	def __init__( self , inherited0__dimensions , inherited1__name ,  ):
		context_dependent_unit.__init__(self , inherited0__dimensions , inherited1__name , )
		variable_semantics.__init__(self , )

	@apply
	def associated_variable_environment():
		def fget( self ):
			return self._associated_variable_environment
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument associated_variable_environment is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY face_bound #
####################
class face_bound(topological_representation_item):
	'''Entity face_bound definition.

	:param bound
	:type bound:loop

	:param orientation
	:type orientation:BOOLEAN
	'''
	def __init__( self , inherited0__name , bound,orientation, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.bound = bound
		self.orientation = orientation

	@apply
	def bound():
		def fget( self ):
			return self._bound
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bound is mantatory and can not be set to None')
			if not check_type(value,loop):
				self._bound = loop(value)
			else:
				self._bound = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY length_measure_with_unit #
####################
class length_measure_with_unit(measure_with_unit):
	'''Entity length_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.LENGTH_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY text_string_representation #
####################
class text_string_representation(representation):
	'''Entity text_string_representation definition.

	:param representation_items
	:type representation_items:SET(1,None,'text_string_representation_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_items = representation_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'text_string_representation_item', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY annotation_subfigure_occurrence #
####################
class annotation_subfigure_occurrence(annotation_symbol_occurrence):
	'''Entity annotation_subfigure_occurrence definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item ,  ):
		annotation_symbol_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ('AUTOMOTIVE_DESIGN.ANNOTATION_SYMBOL'  ==  TYPEOF(self.self.item))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ('AUTOMOTIVE_DESIGN.DRAUGHTING_SUBFIGURE_REPRESENTATION'  ==  TYPEOF(self.self.item.self.mapped_item.self.mapping_source.self.mapped_representation))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY data_environment #
####################
class data_environment(BaseEntityClass):
	'''Entity data_environment definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param elements
	:type elements:SET(1,None,'property_definition_representation', scope = schema_scope)
	'''
	def __init__( self , name,description,elements, ):
		self.name = name
		self.description = description
		self.elements = elements

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument elements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'property_definition_representation', scope = schema_scope)):
				self._elements = SET(value)
			else:
				self._elements = value
		return property(**locals())

####################
 # ENTITY format_function #
####################
class format_function(string_expression,binary_generic_expression):
	'''Entity format_function definition.

	:param value_to_format
	:type value_to_format:generic_expression

	:param format_string
	:type format_string:generic_expression
	'''
	def __init__( self , inherited0__operands ,  ):
		string_expression.__init__(self , )
		binary_generic_expression.__init__(self , inherited0__operands , )

	@apply
	def value_to_format():
		def fget( self ):
			attribute_eval = self.self.binary_generic_expression.self.operands[1]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument value_to_format is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def format_string():
		def fget( self ):
			attribute_eval = self.self.binary_generic_expression.self.operands[2]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument format_string is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.NUMERIC_EXPRESSION'  ==  TYPEOF(self.value_to_format))  and  ('AUTOMOTIVE_DESIGN.STRING_EXPRESSION'  ==  TYPEOF(self.format_string)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY visual_appearance_representation #
####################
class visual_appearance_representation(representation):
	'''Entity visual_appearance_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (((2  <=  SIZEOF(self.self.items))  and  (SIZEOF(self.self.items)  <=  5))  and  (SIZEOF(None)  ==  SIZEOF(self.self.items)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  <=  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  <=  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  <=  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY dated_effectivity #
####################
class dated_effectivity(effectivity):
	'''Entity dated_effectivity definition.

	:param effectivity_end_date
	:type effectivity_end_date:date_time_or_event_occurrence

	:param effectivity_start_date
	:type effectivity_start_date:date_time_or_event_occurrence
	'''
	def __init__( self , inherited0__id , effectivity_end_date,effectivity_start_date, ):
		effectivity.__init__(self , inherited0__id , )
		self.effectivity_end_date = effectivity_end_date
		self.effectivity_start_date = effectivity_start_date

	@apply
	def effectivity_end_date():
		def fget( self ):
			return self._effectivity_end_date
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,date_time_or_event_occurrence):
					self._effectivity_end_date = date_time_or_event_occurrence(value)
				else:
					self._effectivity_end_date = value
			else:
				self._effectivity_end_date = value
		return property(**locals())

	@apply
	def effectivity_start_date():
		def fget( self ):
			return self._effectivity_start_date
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument effectivity_start_date is mantatory and can not be set to None')
			if not check_type(value,date_time_or_event_occurrence):
				self._effectivity_start_date = date_time_or_event_occurrence(value)
			else:
				self._effectivity_start_date = value
		return property(**locals())

####################
 # ENTITY direction #
####################
class direction(geometric_representation_item):
	'''Entity direction definition.

	:param direction_ratios
	:type direction_ratios:LIST(2,3,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , direction_ratios, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.direction_ratios = direction_ratios

	@apply
	def direction_ratios():
		def fget( self ):
			return self._direction_ratios
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument direction_ratios is mantatory and can not be set to None')
			if not check_type(value,LIST(2,3,'REAL', scope = schema_scope)):
				self._direction_ratios = LIST(value)
			else:
				self._direction_ratios = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY kinematic_analysis_result #
####################
class kinematic_analysis_result(BaseEntityClass):
	'''Entity kinematic_analysis_result definition.

	:param analysed_mechanism
	:type analysed_mechanism:mechanism

	:param contained_kinematic_results
	:type contained_kinematic_results:SET(1,None,'kinematic_result', scope = schema_scope)
	'''
	def __init__( self , analysed_mechanism,contained_kinematic_results, ):
		self.analysed_mechanism = analysed_mechanism
		self.contained_kinematic_results = contained_kinematic_results

	@apply
	def analysed_mechanism():
		def fget( self ):
			return self._analysed_mechanism
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument analysed_mechanism is mantatory and can not be set to None')
			if not check_type(value,mechanism):
				self._analysed_mechanism = mechanism(value)
			else:
				self._analysed_mechanism = value
		return property(**locals())

	@apply
	def contained_kinematic_results():
		def fget( self ):
			return self._contained_kinematic_results
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument contained_kinematic_results is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'kinematic_result', scope = schema_scope)):
				self._contained_kinematic_results = SET(value)
			else:
				self._contained_kinematic_results = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(None)  >  0) XOR (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY kinematic_link #
####################
class kinematic_link(BaseEntityClass):
	'''Entity kinematic_link definition.
	'''
	# This class does not define any attribute.
	pass
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.KINEMATIC_JOINT.FIRST_LINK')  +  USEDIN(self,'AUTOMOTIVE_DESIGN.KINEMATIC_JOINT.SECOND_LINK'))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = unique_link_usage(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY product_concept #
####################
class product_concept(BaseEntityClass):
	'''Entity product_concept definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param market_context
	:type market_context:product_concept_context
	'''
	def __init__( self , id,name,description,market_context, ):
		self.id = id
		self.name = name
		self.description = description
		self.market_context = market_context

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def market_context():
		def fget( self ):
			return self._market_context
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument market_context is mantatory and can not be set to None')
			if not check_type(value,product_concept_context):
				self._market_context = product_concept_context(value)
			else:
				self._market_context = value
		return property(**locals())

####################
 # ENTITY product_class #
####################
class product_class(product_concept,characterized_object):
	'''Entity product_class definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__market_context , inherited4__name , inherited5__description ,  ):
		product_concept.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__market_context , )
		characterized_object.__init__(self , inherited4__name , inherited5__description , )

####################
 # ENTITY text_style_for_defined_font #
####################
class text_style_for_defined_font(BaseEntityClass):
	'''Entity text_style_for_defined_font definition.

	:param text_colour
	:type text_colour:colour
	'''
	def __init__( self , text_colour, ):
		self.text_colour = text_colour

	@apply
	def text_colour():
		def fget( self ):
			return self._text_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument text_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._text_colour = colour(value)
			else:
				self._text_colour = value
		return property(**locals())

####################
 # ENTITY light_source #
####################
class light_source(geometric_representation_item):
	'''Entity light_source definition.

	:param light_colour
	:type light_colour:colour
	'''
	def __init__( self , inherited0__name , light_colour, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.light_colour = light_colour

	@apply
	def light_colour():
		def fget( self ):
			return self._light_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument light_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._light_colour = colour(value)
			else:
				self._light_colour = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.STYLED_ITEM.ITEM'))  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY light_source_positional #
####################
class light_source_positional(light_source):
	'''Entity light_source_positional definition.

	:param position
	:type position:cartesian_point

	:param constant_attenuation
	:type constant_attenuation:REAL

	:param distance_attenuation
	:type distance_attenuation:REAL
	'''
	def __init__( self , inherited0__name , inherited1__light_colour , position,constant_attenuation,distance_attenuation, ):
		light_source.__init__(self , inherited0__name , inherited1__light_colour , )
		self.position = position
		self.constant_attenuation = constant_attenuation
		self.distance_attenuation = distance_attenuation

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._position = cartesian_point(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def constant_attenuation():
		def fget( self ):
			return self._constant_attenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constant_attenuation is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._constant_attenuation = REAL(value)
			else:
				self._constant_attenuation = value
		return property(**locals())

	@apply
	def distance_attenuation():
		def fget( self ):
			return self._distance_attenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance_attenuation is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._distance_attenuation = REAL(value)
			else:
				self._distance_attenuation = value
		return property(**locals())

####################
 # ENTITY boolean_result #
####################
class boolean_result(geometric_representation_item):
	'''Entity boolean_result definition.

	:param operator
	:type operator:boolean_operator

	:param first_operand
	:type first_operand:boolean_operand

	:param second_operand
	:type second_operand:boolean_operand
	'''
	def __init__( self , inherited0__name , operator,first_operand,second_operand, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.operator = operator
		self.first_operand = first_operand
		self.second_operand = second_operand

	@apply
	def operator():
		def fget( self ):
			return self._operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operator is mantatory and can not be set to None')
			if not check_type(value,boolean_operator):
				self._operator = boolean_operator(value)
			else:
				self._operator = value
		return property(**locals())

	@apply
	def first_operand():
		def fget( self ):
			return self._first_operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument first_operand is mantatory and can not be set to None')
			if not check_type(value,boolean_operand):
				self._first_operand = boolean_operand(value)
			else:
				self._first_operand = value
		return property(**locals())

	@apply
	def second_operand():
		def fget( self ):
			return self._second_operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument second_operand is mantatory and can not be set to None')
			if not check_type(value,boolean_operand):
				self._second_operand = boolean_operand(value)
			else:
				self._second_operand = value
		return property(**locals())

####################
 # ENTITY group_relationship #
####################
class group_relationship(BaseEntityClass):
	'''Entity group_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_group
	:type relating_group:group

	:param related_group
	:type related_group:group
	'''
	def __init__( self , name,description,relating_group,related_group, ):
		self.name = name
		self.description = description
		self.relating_group = relating_group
		self.related_group = related_group

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_group():
		def fget( self ):
			return self._relating_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_group is mantatory and can not be set to None')
			if not check_type(value,group):
				self._relating_group = group(value)
			else:
				self._relating_group = value
		return property(**locals())

	@apply
	def related_group():
		def fget( self ):
			return self._related_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_group is mantatory and can not be set to None')
			if not check_type(value,group):
				self._related_group = group(value)
			else:
				self._related_group = value
		return property(**locals())

####################
 # ENTITY item_identified_representation_usage #
####################
class item_identified_representation_usage(BaseEntityClass):
	'''Entity item_identified_representation_usage definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param definition
	:type definition:represented_definition

	:param used_representation
	:type used_representation:representation

	:param identified_item
	:type identified_item:representation_item
	'''
	def __init__( self , name,description,definition,used_representation,identified_item, ):
		self.name = name
		self.description = description
		self.definition = definition
		self.used_representation = used_representation
		self.identified_item = identified_item

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,represented_definition):
				self._definition = represented_definition(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def used_representation():
		def fget( self ):
			return self._used_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument used_representation is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._used_representation = representation(value)
			else:
				self._used_representation = value
		return property(**locals())

	@apply
	def identified_item():
		def fget( self ):
			return self._identified_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument identified_item is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._identified_item = representation_item(value)
			else:
				self._identified_item = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.used_representation  ==  using_representations(self.self.identified_item))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition_formation_relationship #
####################
class product_definition_formation_relationship(BaseEntityClass):
	'''Entity product_definition_formation_relationship definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_product_definition_formation
	:type relating_product_definition_formation:product_definition_formation

	:param related_product_definition_formation
	:type related_product_definition_formation:product_definition_formation
	'''
	def __init__( self , id,name,description,relating_product_definition_formation,related_product_definition_formation, ):
		self.id = id
		self.name = name
		self.description = description
		self.relating_product_definition_formation = relating_product_definition_formation
		self.related_product_definition_formation = related_product_definition_formation

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_product_definition_formation():
		def fget( self ):
			return self._relating_product_definition_formation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_product_definition_formation is mantatory and can not be set to None')
			if not check_type(value,product_definition_formation):
				self._relating_product_definition_formation = product_definition_formation(value)
			else:
				self._relating_product_definition_formation = value
		return property(**locals())

	@apply
	def related_product_definition_formation():
		def fget( self ):
			return self._related_product_definition_formation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_product_definition_formation is mantatory and can not be set to None')
			if not check_type(value,product_definition_formation):
				self._related_product_definition_formation = product_definition_formation(value)
			else:
				self._related_product_definition_formation = value
		return property(**locals())

####################
 # ENTITY representation_relationship #
####################
class representation_relationship(BaseEntityClass):
	'''Entity representation_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param rep_1
	:type rep_1:representation

	:param rep_2
	:type rep_2:representation
	'''
	def __init__( self , name,description,rep_1,rep_2, ):
		self.name = name
		self.description = description
		self.rep_1 = rep_1
		self.rep_2 = rep_2

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def rep_1():
		def fget( self ):
			return self._rep_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rep_1 is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._rep_1 = representation(value)
			else:
				self._rep_1 = value
		return property(**locals())

	@apply
	def rep_2():
		def fget( self ):
			return self._rep_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rep_2 is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._rep_2 = representation(value)
			else:
				self._rep_2 = value
		return property(**locals())

####################
 # ENTITY motion_link_relationship #
####################
class motion_link_relationship(representation_relationship):
	'''Entity motion_link_relationship definition.

	:param representation_relationship_rep_1
	:type representation_relationship_rep_1:founded_kinematic_path

	:param representation_relationship_rep_2
	:type representation_relationship_rep_2:kinematic_link_representation

	:param related_frame
	:type related_frame:rigid_placement

	:param motion
	:type motion:founded_kinematic_path

	:param frame_link
	:type frame_link:kinematic_link_representation
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , representation_relationship_rep_1,representation_relationship_rep_2,related_frame, ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
		self.representation_relationship_rep_1 = representation_relationship_rep_1
		self.representation_relationship_rep_2 = representation_relationship_rep_2
		self.related_frame = related_frame

	@apply
	def representation_relationship_rep_1():
		def fget( self ):
			return self._representation_relationship_rep_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_rep_1 is mantatory and can not be set to None')
			if not check_type(value,founded_kinematic_path):
				self._representation_relationship_rep_1 = founded_kinematic_path(value)
			else:
				self._representation_relationship_rep_1 = value
		return property(**locals())

	@apply
	def representation_relationship_rep_2():
		def fget( self ):
			return self._representation_relationship_rep_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_rep_2 is mantatory and can not be set to None')
			if not check_type(value,kinematic_link_representation):
				self._representation_relationship_rep_2 = kinematic_link_representation(value)
			else:
				self._representation_relationship_rep_2 = value
		return property(**locals())

	@apply
	def related_frame():
		def fget( self ):
			return self._related_frame
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_frame is mantatory and can not be set to None')
			if not check_type(value,rigid_placement):
				self._related_frame = rigid_placement(value)
			else:
				self._related_frame = value
		return property(**locals())

	@apply
	def motion():
		def fget( self ):
			attribute_eval = self.self.representation_relationship.self.rep_1
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument motion is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def frame_link():
		def fget( self ):
			attribute_eval = self.self.representation_relationship.self.rep_2
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument frame_link is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.related_frame  ==  self.frame_link.self.representation.self.items)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY universal_pair #
####################
class universal_pair(kinematic_pair):
	'''Entity universal_pair definition.

	:param input_skew_angle
	:type input_skew_angle:plane_angle_measure

	:param skew_angle
	:type skew_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , input_skew_angle, ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )
		self.input_skew_angle = input_skew_angle

	@apply
	def input_skew_angle():
		def fget( self ):
			return self._input_skew_angle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,plane_angle_measure):
					self._input_skew_angle = plane_angle_measure(value)
				else:
					self._input_skew_angle = value
			else:
				self._input_skew_angle = value
		return property(**locals())

	@apply
	def skew_angle():
		def fget( self ):
			attribute_eval = NVL(self.input_skew_angle,0)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument skew_angle is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (COS(plane_angle_for_pair_in_radian(self,self.skew_angle))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY event_occurrence_assignment #
####################
class event_occurrence_assignment(BaseEntityClass):
	'''Entity event_occurrence_assignment definition.

	:param assigned_event_occurrence
	:type assigned_event_occurrence:event_occurrence

	:param role
	:type role:event_occurrence_role
	'''
	def __init__( self , assigned_event_occurrence,role, ):
		self.assigned_event_occurrence = assigned_event_occurrence
		self.role = role

	@apply
	def assigned_event_occurrence():
		def fget( self ):
			return self._assigned_event_occurrence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_event_occurrence is mantatory and can not be set to None')
			if not check_type(value,event_occurrence):
				self._assigned_event_occurrence = event_occurrence(value)
			else:
				self._assigned_event_occurrence = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,event_occurrence_role):
				self._role = event_occurrence_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_event_occurrence_assignment #
####################
class applied_event_occurrence_assignment(event_occurrence_assignment):
	'''Entity applied_event_occurrence_assignment definition.

	:param items
	:type items:SET(1,None,'event_occurrence_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_event_occurrence , inherited1__role , items, ):
		event_occurrence_assignment.__init__(self , inherited0__assigned_event_occurrence , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'event_occurrence_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY camera_model_d2 #
####################
class camera_model_d2(camera_model):
	'''Entity camera_model_d2 definition.

	:param view_window
	:type view_window:planar_box

	:param view_window_clipping
	:type view_window_clipping:BOOLEAN
	'''
	def __init__( self , inherited0__name , view_window,view_window_clipping, ):
		camera_model.__init__(self , inherited0__name , )
		self.view_window = view_window
		self.view_window_clipping = view_window_clipping

	@apply
	def view_window():
		def fget( self ):
			return self._view_window
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument view_window is mantatory and can not be set to None')
			if not check_type(value,planar_box):
				self._view_window = planar_box(value)
			else:
				self._view_window = value
		return property(**locals())

	@apply
	def view_window_clipping():
		def fget( self ):
			return self._view_window_clipping
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument view_window_clipping is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._view_window_clipping = BOOLEAN(value)
			else:
				self._view_window_clipping = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not ('AUTOMOTIVE_DESIGN.CAMERA_IMAGE_2D_WITH_SCALE'  ==  TYPEOF(self)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY group_assignment #
####################
class group_assignment(BaseEntityClass):
	'''Entity group_assignment definition.

	:param assigned_group
	:type assigned_group:group

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_group, ):
		self.assigned_group = assigned_group

	@apply
	def assigned_group():
		def fget( self ):
			return self._assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_group is mantatory and can not be set to None')
			if not check_type(value,group):
				self._assigned_group = group(value)
			else:
				self._assigned_group = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY next_assembly_usage_occurrence #
####################
class next_assembly_usage_occurrence(assembly_component_usage):
	'''Entity next_assembly_usage_occurrence definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator ,  ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )

####################
 # ENTITY prismatic_pair_value #
####################
class prismatic_pair_value(pair_value):
	'''Entity prismatic_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:prismatic_pair

	:param actual_translation
	:type actual_translation:length_measure
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_translation, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_translation = actual_translation

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,prismatic_pair):
				self._pair_value_applies_to_pair = prismatic_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_translation():
		def fget( self ):
			return self._actual_translation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_translation is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._actual_translation = length_measure(value)
			else:
				self._actual_translation = value
		return property(**locals())

####################
 # ENTITY rolling_surface_pair_value #
####################
class rolling_surface_pair_value(pair_value):
	'''Entity rolling_surface_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:rolling_surface_pair

	:param actual_point_on_surface
	:type actual_point_on_surface:point_on_surface

	:param actual_rotation
	:type actual_rotation:plane_angle_measure
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_point_on_surface,actual_rotation, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_point_on_surface = actual_point_on_surface
		self.actual_rotation = actual_rotation

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,rolling_surface_pair):
				self._pair_value_applies_to_pair = rolling_surface_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_point_on_surface():
		def fget( self ):
			return self._actual_point_on_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_point_on_surface is mantatory and can not be set to None')
			if not check_type(value,point_on_surface):
				self._actual_point_on_surface = point_on_surface(value)
			else:
				self._actual_point_on_surface = value
		return property(**locals())

	@apply
	def actual_rotation():
		def fget( self ):
			return self._actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_rotation is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._actual_rotation = plane_angle_measure(value)
			else:
				self._actual_rotation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.pair_value.self.applies_to_pair.self.surface_pair.self.surface_1  ==  self.actual_point_on_surface.self.basis_surface)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY time_unit #
####################
class time_unit(named_unit):
	'''Entity time_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  1))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY camera_model_d3 #
####################
class camera_model_d3(camera_model):
	'''Entity camera_model_d3 definition.

	:param view_reference_system
	:type view_reference_system:axis2_placement_3d

	:param perspective_of_volume
	:type perspective_of_volume:view_volume
	'''
	def __init__( self , inherited0__name , view_reference_system,perspective_of_volume, ):
		camera_model.__init__(self , inherited0__name , )
		self.view_reference_system = view_reference_system
		self.perspective_of_volume = perspective_of_volume

	@apply
	def view_reference_system():
		def fget( self ):
			return self._view_reference_system
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument view_reference_system is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._view_reference_system = axis2_placement_3d(value)
			else:
				self._view_reference_system = value
		return property(**locals())

	@apply
	def perspective_of_volume():
		def fget( self ):
			return self._perspective_of_volume
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument perspective_of_volume is mantatory and can not be set to None')
			if not check_type(value,view_volume):
				self._perspective_of_volume = view_volume(value)
			else:
				self._perspective_of_volume = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((dot_product(self.self.view_reference_system.self.p[3],self.self.perspective_of_volume.self.view_window.self.placement.self.p[3])  ==  1)  and  (self.self.view_reference_system.self.location.self.coordinates[3]  ==  self.self.perspective_of_volume.self.view_window.self.placement.self.location.self.coordinates[3]))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY interval_expression #
####################
class interval_expression(boolean_expression,multiple_arity_generic_expression):
	'''Entity interval_expression definition.

	:param interval_low
	:type interval_low:generic_expression

	:param interval_item
	:type interval_item:generic_expression

	:param interval_high
	:type interval_high:generic_expression
	'''
	def __init__( self , inherited0__operands ,  ):
		boolean_expression.__init__(self , )
		multiple_arity_generic_expression.__init__(self , inherited0__operands , )

	@apply
	def interval_low():
		def fget( self ):
			attribute_eval = self.self.multiple_arity_generic_expression.self.operands[1]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument interval_low is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def interval_item():
		def fget( self ):
			attribute_eval = self.self.multiple_arity_generic_expression.self.operands[2]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument interval_item is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def interval_high():
		def fget( self ):
			attribute_eval = self.self.multiple_arity_generic_expression.self.operands[3]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument interval_high is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.EXPRESSION'  ==  TYPEOF(self.interval_low))  and  ('AUTOMOTIVE_DESIGN.EXPRESSION'  ==  TYPEOF(self.interval_item)))  and  ('AUTOMOTIVE_DESIGN.EXPRESSION'  ==  TYPEOF(self.interval_high)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (((('AUTOMOTIVE_DESIGN.STRING_EXPRESSION'  ==  TYPEOF(self.self.interval_low))  and  ('AUTOMOTIVE_DESIGN.STRING_EXPRESSION'  ==  TYPEOF(self.self.interval_high)))  and  ('AUTOMOTIVE_DESIGN.STRING_EXPRESSION'  ==  TYPEOF(self.self.interval_item)))  or  ((('AUTOMOTIVE_DESIGN.STRING_EXPRESSION'  ==  TYPEOF(self.self.interval_low))  and  ('AUTOMOTIVE_DESIGN.NUMERIC_EXPRESSION'  ==  TYPEOF(self.self.interval_item)))  and  ('AUTOMOTIVE_DESIGN.NUMERIC_EXPRESSION'  ==  TYPEOF(self.self.interval_high))))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY oriented_edge #
####################
class oriented_edge(edge):
	'''Entity oriented_edge definition.

	:param edge_element
	:type edge_element:edge

	:param orientation
	:type orientation:BOOLEAN

	:param edge_edge_start
	:type edge_edge_start:vertex

	:param edge_edge_end
	:type edge_edge_end:vertex
	'''
	def __init__( self , inherited0__name , inherited1__edge_start , inherited2__edge_end , edge_element,orientation, ):
		edge.__init__(self , inherited0__name , inherited1__edge_start , inherited2__edge_end , )
		self.edge_element = edge_element
		self.orientation = orientation

	@apply
	def edge_element():
		def fget( self ):
			return self._edge_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edge_element is mantatory and can not be set to None')
			if not check_type(value,edge):
				self._edge_element = edge(value)
			else:
				self._edge_element = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def edge_edge_start():
		def fget( self ):
			attribute_eval = boolean_choose(self.self.orientation,self.self.edge_element.self.edge_start,self.self.edge_element.self.edge_end)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument edge_edge_start is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def edge_edge_end():
		def fget( self ):
			attribute_eval = boolean_choose(self.self.orientation,self.self.edge_element.self.edge_end,self.self.edge_element.self.edge_start)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument edge_edge_end is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AUTOMOTIVE_DESIGN.ORIENTED_EDGE'  ==  TYPEOF(self.self.edge_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY person #
####################
class person(BaseEntityClass):
	'''Entity person definition.

	:param id
	:type id:identifier

	:param last_name
	:type last_name:label

	:param first_name
	:type first_name:label

	:param middle_names
	:type middle_names:LIST(1,None,'STRING', scope = schema_scope)

	:param prefix_titles
	:type prefix_titles:LIST(1,None,'STRING', scope = schema_scope)

	:param suffix_titles
	:type suffix_titles:LIST(1,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , id,last_name,first_name,middle_names,prefix_titles,suffix_titles, ):
		self.id = id
		self.last_name = last_name
		self.first_name = first_name
		self.middle_names = middle_names
		self.prefix_titles = prefix_titles
		self.suffix_titles = suffix_titles

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def last_name():
		def fget( self ):
			return self._last_name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._last_name = label(value)
				else:
					self._last_name = value
			else:
				self._last_name = value
		return property(**locals())

	@apply
	def first_name():
		def fget( self ):
			return self._first_name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._first_name = label(value)
				else:
					self._first_name = value
			else:
				self._first_name = value
		return property(**locals())

	@apply
	def middle_names():
		def fget( self ):
			return self._middle_names
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._middle_names = LIST(value)
				else:
					self._middle_names = value
			else:
				self._middle_names = value
		return property(**locals())

	@apply
	def prefix_titles():
		def fget( self ):
			return self._prefix_titles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._prefix_titles = LIST(value)
				else:
					self._prefix_titles = value
			else:
				self._prefix_titles = value
		return property(**locals())

	@apply
	def suffix_titles():
		def fget( self ):
			return self._suffix_titles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._suffix_titles = LIST(value)
				else:
					self._suffix_titles = value
			else:
				self._suffix_titles = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.last_name)  or  EXISTS(self.first_name))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY camera_image #
####################
class camera_image(mapped_item):
	'''Entity camera_image definition.

	:param mapped_item_mapping_source
	:type mapped_item_mapping_source:camera_usage

	:param mapped_item_mapping_target
	:type mapped_item_mapping_target:planar_box
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , mapped_item_mapping_source,mapped_item_mapping_target, ):
		mapped_item.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , )
		self.mapped_item_mapping_source = mapped_item_mapping_source
		self.mapped_item_mapping_target = mapped_item_mapping_target

	@apply
	def mapped_item_mapping_source():
		def fget( self ):
			return self._mapped_item_mapping_source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_source is mantatory and can not be set to None')
			if not check_type(value,camera_usage):
				self._mapped_item_mapping_source = camera_usage(value)
			else:
				self._mapped_item_mapping_source = value
		return property(**locals())

	@apply
	def mapped_item_mapping_target():
		def fget( self ):
			return self._mapped_item_mapping_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_target is mantatory and can not be set to None')
			if not check_type(value,planar_box):
				self._mapped_item_mapping_target = planar_box(value)
			else:
				self._mapped_item_mapping_target = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.GEOMETRIC_REPRESENTATION_ITEM'  ==  TYPEOF(self))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY camera_image_3d_with_scale #
####################
class camera_image_3d_with_scale(camera_image):
	'''Entity camera_image_3d_with_scale definition.

	:param scale
	:type scale:positive_ratio_measure
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , inherited3__mapped_item_mapping_source , inherited4__mapped_item_mapping_target ,  ):
		camera_image.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , inherited3__mapped_item_mapping_source , inherited4__mapped_item_mapping_target , )

	@apply
	def scale():
		def fget( self ):
			attribute_eval = (self.self.mapped_item.self.mapping_target.self.planar_extent.self.size_in_x / self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.view_window.self.size_in_x)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scale is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.CAMERA_MODEL_D3'  ==  TYPEOF(self.self.mapped_item.self.mapping_source.self.mapping_origin))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (aspect_ratio(self.self.mapped_item.self.mapping_target)  ==  aspect_ratio(self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.view_window))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.front_plane_clipping  and  self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.view_volume_sides_clipping)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.mapped_item.self.mapping_target.self.planar_extent.self.size_in_x  >  0)  and  (self.self.mapped_item.self.mapping_target.self.planar_extent.self.size_in_y  >  0))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.view_window.self.size_in_x  >  0)  and  (self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.view_window.self.size_in_y  >  0))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((('AUTOMOTIVE_DESIGN.'  +  'AXIS2_PLACEMENT_2D')  ==  TYPEOF(self.self.mapped_item.self.mapping_target.self.planar_box.self.placement))  and  ( not (('AUTOMOTIVE_DESIGN.'  +  'AXIS2_PLACEMENT_3D')  ==  TYPEOF(self.self.mapped_item.self.mapping_target.self.planar_box.self.placement))))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY effectivity_assignment #
####################
class effectivity_assignment(BaseEntityClass):
	'''Entity effectivity_assignment definition.

	:param assigned_effectivity
	:type assigned_effectivity:effectivity

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_effectivity, ):
		self.assigned_effectivity = assigned_effectivity

	@apply
	def assigned_effectivity():
		def fget( self ):
			return self._assigned_effectivity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_effectivity is mantatory and can not be set to None')
			if not check_type(value,effectivity):
				self._assigned_effectivity = effectivity(value)
			else:
				self._assigned_effectivity = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY configured_effectivity_assignment #
####################
class configured_effectivity_assignment(effectivity_assignment):
	'''Entity configured_effectivity_assignment definition.

	:param items
	:type items:SET(1,None,'configured_effectivity_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_effectivity , items, ):
		effectivity_assignment.__init__(self , inherited0__assigned_effectivity , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'configured_effectivity_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'EFFECTIVITY']  *  TYPEOF(self.self.assigned_effectivity))  ==  1)  and  (self.self.assigned_effectivity.self.id  ==  'configuration validity'))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.items)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (self.self.role.self.name  ==  ['design','usage'])
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.role.self.name  !=  'design')  or  (SIZEOF(None)  ==  0))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.role.self.name  !=  'usage')  or  (SIZEOF(None)  ==  0))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (self.self.role.self.description  ==  ['exception','inherited','local'])
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr


####################
 # ENTITY classification_assignment #
####################
class classification_assignment(BaseEntityClass):
	'''Entity classification_assignment definition.

	:param assigned_class
	:type assigned_class:group

	:param role
	:type role:classification_role
	'''
	def __init__( self , assigned_class,role, ):
		self.assigned_class = assigned_class
		self.role = role

	@apply
	def assigned_class():
		def fget( self ):
			return self._assigned_class
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_class is mantatory and can not be set to None')
			if not check_type(value,group):
				self._assigned_class = group(value)
			else:
				self._assigned_class = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,classification_role):
				self._role = classification_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY language_assignment #
####################
class language_assignment(classification_assignment):
	'''Entity language_assignment definition.

	:param items
	:type items:SET(1,None,'language_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_class , inherited1__role , items, ):
		classification_assignment.__init__(self , inherited0__assigned_class , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'language_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'LANGUAGE')  ==  TYPEOF(self.self.assigned_class))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.role.self.name  ==  'language')
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(self.self.items)  ==  SIZEOF(None))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY action #
####################
class action(BaseEntityClass):
	'''Entity action definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param chosen_method
	:type chosen_method:action_method

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description,chosen_method, ):
		self.name = name
		self.description = description
		self.chosen_method = chosen_method

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def chosen_method():
		def fget( self ):
			return self._chosen_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument chosen_method is mantatory and can not be set to None')
			if not check_type(value,action_method):
				self._chosen_method = action_method(value)
			else:
				self._chosen_method = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY property_process #
####################
class property_process(action):
	'''Entity property_process definition.

	:param identification
	:type identification:identifier

	:param properties
	:type properties:SET(1,None,'process_property_association', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method , identification, ):
		action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )
		self.identification = identification

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument identification is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._identification = identifier(value)
			else:
				self._identification = value
		return property(**locals())

	@apply
	def properties():
		def fget( self ):
			return self._properties
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument properties is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY swept_area_solid #
####################
class swept_area_solid(solid_model):
	'''Entity swept_area_solid definition.

	:param swept_area
	:type swept_area:curve_bounded_surface
	'''
	def __init__( self , inherited0__name , swept_area, ):
		solid_model.__init__(self , inherited0__name , )
		self.swept_area = swept_area

	@apply
	def swept_area():
		def fget( self ):
			return self._swept_area
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument swept_area is mantatory and can not be set to None')
			if not check_type(value,curve_bounded_surface):
				self._swept_area = curve_bounded_surface(value)
			else:
				self._swept_area = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.PLANE'  ==  TYPEOF(self.swept_area.self.basis_surface))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY revolved_area_solid #
####################
class revolved_area_solid(swept_area_solid):
	'''Entity revolved_area_solid definition.

	:param axis
	:type axis:axis1_placement

	:param angle
	:type angle:plane_angle_measure

	:param axis_line
	:type axis_line:line
	'''
	def __init__( self , inherited0__name , inherited1__swept_area , axis,angle, ):
		swept_area_solid.__init__(self , inherited0__name , inherited1__swept_area , )
		self.axis = axis
		self.angle = angle

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axis is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._axis = axis1_placement(value)
			else:
				self._axis = value
		return property(**locals())

	@apply
	def angle():
		def fget( self ):
			return self._angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._angle = plane_angle_measure(value)
			else:
				self._angle = value
		return property(**locals())

	@apply
	def axis_line():
		def fget( self ):
			attribute_eval = (((representation_item('')  ==  geometric_representation_item())  ==  curve())  ==  line(self.axis.self.location,(representation_item('')  ==  geometric_representation_item())  ==  vector(self.axis.self.z,1)))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument axis_line is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY conversion_based_unit #
####################
class conversion_based_unit(named_unit):
	'''Entity conversion_based_unit definition.

	:param name
	:type name:label

	:param conversion_factor
	:type conversion_factor:measure_with_unit

	:param named_unit_dimensions
	:type named_unit_dimensions:dimensional_exponents
	'''
	def __init__( self , inherited0__dimensions , name,conversion_factor, ):
		named_unit.__init__(self , inherited0__dimensions , )
		self.name = name
		self.conversion_factor = conversion_factor

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def conversion_factor():
		def fget( self ):
			return self._conversion_factor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument conversion_factor is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._conversion_factor = measure_with_unit(value)
			else:
				self._conversion_factor = value
		return property(**locals())

	@apply
	def named_unit_dimensions():
		def fget( self ):
			attribute_eval = derive_dimensional_exponents(self.conversion_factor.self.measure_with_unit.self.unit_component)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument named_unit_dimensions is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY point #
####################
class point(geometric_representation_item):
	'''Entity point definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY point_on_surface #
####################
class point_on_surface(point):
	'''Entity point_on_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param point_parameter_u
	:type point_parameter_u:parameter_value

	:param point_parameter_v
	:type point_parameter_v:parameter_value
	'''
	def __init__( self , inherited0__name , basis_surface,point_parameter_u,point_parameter_v, ):
		point.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.point_parameter_u = point_parameter_u
		self.point_parameter_v = point_parameter_v

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def point_parameter_u():
		def fget( self ):
			return self._point_parameter_u
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument point_parameter_u is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._point_parameter_u = parameter_value(value)
			else:
				self._point_parameter_u = value
		return property(**locals())

	@apply
	def point_parameter_v():
		def fget( self ):
			return self._point_parameter_v
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument point_parameter_v is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._point_parameter_v = parameter_value(value)
			else:
				self._point_parameter_v = value
		return property(**locals())

####################
 # ENTITY product_definition_formation #
####################
class product_definition_formation(BaseEntityClass):
	'''Entity product_definition_formation definition.

	:param id
	:type id:identifier

	:param description
	:type description:text

	:param of_product
	:type of_product:product
	'''
	def __init__( self , id,description,of_product, ):
		self.id = id
		self.description = description
		self.of_product = of_product

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def of_product():
		def fget( self ):
			return self._of_product
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument of_product is mantatory and can not be set to None')
			if not check_type(value,product):
				self._of_product = product(value)
			else:
				self._of_product = value
		return property(**locals())

####################
 # ENTITY surface_curve_swept_area_solid #
####################
class surface_curve_swept_area_solid(swept_area_solid):
	'''Entity surface_curve_swept_area_solid definition.

	:param directrix
	:type directrix:curve

	:param start_param
	:type start_param:REAL

	:param end_param
	:type end_param:REAL

	:param reference_surface
	:type reference_surface:surface
	'''
	def __init__( self , inherited0__name , inherited1__swept_area , directrix,start_param,end_param,reference_surface, ):
		swept_area_solid.__init__(self , inherited0__name , inherited1__swept_area , )
		self.directrix = directrix
		self.start_param = start_param
		self.end_param = end_param
		self.reference_surface = reference_surface

	@apply
	def directrix():
		def fget( self ):
			return self._directrix
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directrix is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._directrix = curve(value)
			else:
				self._directrix = value
		return property(**locals())

	@apply
	def start_param():
		def fget( self ):
			return self._start_param
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument start_param is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._start_param = REAL(value)
			else:
				self._start_param = value
		return property(**locals())

	@apply
	def end_param():
		def fget( self ):
			return self._end_param
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument end_param is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._end_param = REAL(value)
			else:
				self._end_param = value
		return property(**locals())

	@apply
	def reference_surface():
		def fget( self ):
			return self._reference_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reference_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._reference_surface = surface(value)
			else:
				self._reference_surface = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not ('AUTOMOTIVE_DESIGN.SURFACE_CURVE'  ==  TYPEOF(self.directrix)))  or  (self.reference_surface  ==  self.directrix.self.surface_curve.self.basis_surface))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY descriptive_representation_item #
####################
class descriptive_representation_item(representation_item):
	'''Entity descriptive_representation_item definition.

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__name , description, ):
		representation_item.__init__(self , inherited0__name , )
		self.description = description

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY offset_curve_3d #
####################
class offset_curve_3d(curve):
	'''Entity offset_curve_3d definition.

	:param basis_curve
	:type basis_curve:curve

	:param distance
	:type distance:length_measure

	:param self_intersect
	:type self_intersect:LOGICAL

	:param ref_direction
	:type ref_direction:direction
	'''
	def __init__( self , inherited0__name , basis_curve,distance,self_intersect,ref_direction, ):
		curve.__init__(self , inherited0__name , )
		self.basis_curve = basis_curve
		self.distance = distance
		self.self_intersect = self_intersect
		self.ref_direction = ref_direction

	@apply
	def basis_curve():
		def fget( self ):
			return self._basis_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._basis_curve = curve(value)
			else:
				self._basis_curve = value
		return property(**locals())

	@apply
	def distance():
		def fget( self ):
			return self._distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._distance = length_measure(value)
			else:
				self._distance = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())

	@apply
	def ref_direction():
		def fget( self ):
			return self._ref_direction
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ref_direction is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._ref_direction = direction(value)
			else:
				self._ref_direction = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.basis_curve.self.dim  ==  3)  and  (self.ref_direction.self.dim  ==  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY point_style #
####################
class point_style(founded_item):
	'''Entity point_style definition.

	:param name
	:type name:label

	:param marker
	:type marker:marker_select

	:param marker_size
	:type marker_size:size_select

	:param marker_colour
	:type marker_colour:colour
	'''
	def __init__( self , name,marker,marker_size,marker_colour, ):
		founded_item.__init__(self , )
		self.name = name
		self.marker = marker
		self.marker_size = marker_size
		self.marker_colour = marker_colour

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def marker():
		def fget( self ):
			return self._marker
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument marker is mantatory and can not be set to None')
			if not check_type(value,marker_select):
				self._marker = marker_select(value)
			else:
				self._marker = value
		return property(**locals())

	@apply
	def marker_size():
		def fget( self ):
			return self._marker_size
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument marker_size is mantatory and can not be set to None')
			if not check_type(value,size_select):
				self._marker_size = size_select(value)
			else:
				self._marker_size = value
		return property(**locals())

	@apply
	def marker_colour():
		def fget( self ):
			return self._marker_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument marker_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._marker_colour = colour(value)
			else:
				self._marker_colour = value
		return property(**locals())

####################
 # ENTITY approval #
####################
class approval(BaseEntityClass):
	'''Entity approval definition.

	:param status
	:type status:approval_status

	:param level
	:type level:label
	'''
	def __init__( self , status,level, ):
		self.status = status
		self.level = level

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument status is mantatory and can not be set to None')
			if not check_type(value,approval_status):
				self._status = approval_status(value)
			else:
				self._status = value
		return property(**locals())

	@apply
	def level():
		def fget( self ):
			return self._level
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument level is mantatory and can not be set to None')
			if not check_type(value,label):
				self._level = label(value)
			else:
				self._level = value
		return property(**locals())

####################
 # ENTITY composite_curve #
####################
class composite_curve(bounded_curve):
	'''Entity composite_curve definition.

	:param segments
	:type segments:LIST(1,None,'composite_curve_segment', scope = schema_scope)

	:param self_intersect
	:type self_intersect:LOGICAL

	:param n_segments
	:type n_segments:INTEGER

	:param closed_curve
	:type closed_curve:LOGICAL
	'''
	def __init__( self , inherited0__name , segments,self_intersect, ):
		bounded_curve.__init__(self , inherited0__name , )
		self.segments = segments
		self.self_intersect = self_intersect

	@apply
	def segments():
		def fget( self ):
			return self._segments
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument segments is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'composite_curve_segment', scope = schema_scope)):
				self._segments = LIST(value)
			else:
				self._segments = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())

	@apply
	def n_segments():
		def fget( self ):
			attribute_eval = SIZEOF(self.segments)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument n_segments is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def closed_curve():
		def fget( self ):
			attribute_eval = (self.segments[self.n_segments].self.transition  !=  discontinuous)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument closed_curve is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((( not self.closed_curve)  and  (SIZEOF(None)  ==  1))  or  (self.closed_curve  and  (SIZEOF(None)  ==  0)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY composite_curve_on_surface #
####################
class composite_curve_on_surface(composite_curve):
	'''Entity composite_curve_on_surface definition.

	:param basis_surface
	:type basis_surface:SET(0,2,'surface', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__segments , inherited2__self_intersect ,  ):
		composite_curve.__init__(self , inherited0__name , inherited1__segments , inherited2__self_intersect , )

	@apply
	def basis_surface():
		def fget( self ):
			attribute_eval = get_basis_surface(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument basis_surface is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.basis_surface)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = constraints_composite_curve_on_surface(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY boundary_curve #
####################
class boundary_curve(composite_curve_on_surface):
	'''Entity boundary_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__segments , inherited2__self_intersect ,  ):
		composite_curve_on_surface.__init__(self , inherited0__name , inherited1__segments , inherited2__self_intersect , )
	def wr1(self):
		eval_wr1_wr = self.self.composite_curve.self.closed_curve
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY event_occurrence_role #
####################
class event_occurrence_role(BaseEntityClass):
	'''Entity event_occurrence_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY representation_context #
####################
class representation_context(BaseEntityClass):
	'''Entity representation_context definition.

	:param context_identifier
	:type context_identifier:identifier

	:param context_type
	:type context_type:text

	:param representations_in_context
	:type representations_in_context:SET(1,None,'representation', scope = schema_scope)
	'''
	def __init__( self , context_identifier,context_type, ):
		self.context_identifier = context_identifier
		self.context_type = context_type

	@apply
	def context_identifier():
		def fget( self ):
			return self._context_identifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument context_identifier is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._context_identifier = identifier(value)
			else:
				self._context_identifier = value
		return property(**locals())

	@apply
	def context_type():
		def fget( self ):
			return self._context_type
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument context_type is mantatory and can not be set to None')
			if not check_type(value,text):
				self._context_type = text(value)
			else:
				self._context_type = value
		return property(**locals())

	@apply
	def representations_in_context():
		def fget( self ):
			return self._representations_in_context
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument representations_in_context is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY geometric_representation_context #
####################
class geometric_representation_context(representation_context):
	'''Entity geometric_representation_context definition.

	:param coordinate_space_dimension
	:type coordinate_space_dimension:dimension_count
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type , coordinate_space_dimension, ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )
		self.coordinate_space_dimension = coordinate_space_dimension

	@apply
	def coordinate_space_dimension():
		def fget( self ):
			return self._coordinate_space_dimension
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordinate_space_dimension is mantatory and can not be set to None')
			if not check_type(value,dimension_count):
				self._coordinate_space_dimension = dimension_count(value)
			else:
				self._coordinate_space_dimension = value
		return property(**locals())

####################
 # ENTITY string_defined_function #
####################
class string_defined_function(defined_function,string_expression):
	'''Entity string_defined_function definition.
	'''
	def __init__( self ,  ):
		defined_function.__init__(self , )
		string_expression.__init__(self , )

####################
 # ENTITY date_assignment #
####################
class date_assignment(BaseEntityClass):
	'''Entity date_assignment definition.

	:param assigned_date
	:type assigned_date:date

	:param role
	:type role:date_role
	'''
	def __init__( self , assigned_date,role, ):
		self.assigned_date = assigned_date
		self.role = role

	@apply
	def assigned_date():
		def fget( self ):
			return self._assigned_date
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_date is mantatory and can not be set to None')
			if not check_type(value,date):
				self._assigned_date = date(value)
			else:
				self._assigned_date = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,date_role):
				self._role = date_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_date_assignment #
####################
class applied_date_assignment(date_assignment):
	'''Entity applied_date_assignment definition.

	:param items
	:type items:SET(1,None,'date_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_date , inherited1__role , items, ):
		date_assignment.__init__(self , inherited0__assigned_date , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'date_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (self.self.role.self.name  ==  'actual end'))  or  item_correlation(self.self.items,['ACTION','ORGANIZATIONAL_PROJECT','EFFECTIVITY']))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY celsius_temperature_measure_with_unit #
####################
class celsius_temperature_measure_with_unit(measure_with_unit):
	'''Entity celsius_temperature_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.THERMODYNAMIC_TEMPERATURE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY draughting_annotation_occurrence #
####################
class draughting_annotation_occurrence(annotation_occurrence):
	'''Entity draughting_annotation_occurrence definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item ,  ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
	def wr1(self):
		eval_wr1_wr = (( not ('AUTOMOTIVE_DESIGN.ANNOTATION_CURVE_OCCURRENCE'  ==  TYPEOF(self)))  or  (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not ('AUTOMOTIVE_DESIGN.ANNOTATION_FILL_AREA_OCCURRENCE'  ==  TYPEOF(self)))  or  (SIZEOF(None)  ==  0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not ('AUTOMOTIVE_DESIGN.ANNOTATION_FILL_AREA_OCCURRENCE'  ==  TYPEOF(self)))  or  (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not ('AUTOMOTIVE_DESIGN.ANNOTATION_SYMBOL_OCCURRENCE'  ==  TYPEOF(self)))  or  (SIZEOF(None)  ==  0))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (( not (('AUTOMOTIVE_DESIGN.ANNOTATION_SYMBOL_OCCURRENCE'  ==  TYPEOF(self))  and  ('AUTOMOTIVE_DESIGN.ANNOTATION_SYMBOL'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'DRAUGHTING_SYMBOL_REPRESENTATION','AUTOMOTIVE_DESIGN.'  +  'DRAUGHTING_SUBFIGURE_REPRESENTATION']  *  TYPEOF(self.self.item.self.mapped_item.self.mapping_source.self.mapped_representation))  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (( not ('AUTOMOTIVE_DESIGN.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self)))  or  (SIZEOF(None)  ==  0))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (('AUTOMOTIVE_DESIGN.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  or  (SIZEOF(TYPEOF(self.self.item)  *  ['AUTOMOTIVE_DESIGN.COMPOSITE_TEXT','AUTOMOTIVE_DESIGN.TEXT_LITERAL'])  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (( not (('AUTOMOTIVE_DESIGN.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AUTOMOTIVE_DESIGN.COMPOSITE_TEXT'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(None)  ==  0))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (( not (('AUTOMOTIVE_DESIGN.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AUTOMOTIVE_DESIGN.TEXT_LITERAL'  ==  TYPEOF(self.self.item))))  or  (self.self.item.self.text_literal.self.alignment  ==  ['baseline left','baseline centre','baseline right']))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (( not (('AUTOMOTIVE_DESIGN.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AUTOMOTIVE_DESIGN.COMPOSITE_TEXT'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(None)  ==  0))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (( not (('AUTOMOTIVE_DESIGN.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AUTOMOTIVE_DESIGN.COMPOSITE_TEXT'  ==  TYPEOF(self.self.item))))  or  check_text_alignment(self.self.item))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (( not (('AUTOMOTIVE_DESIGN.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AUTOMOTIVE_DESIGN.COMPOSITE_TEXT'  ==  TYPEOF(self.self.item))))  or  check_text_font(self.self.item))
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (( not (('AUTOMOTIVE_DESIGN.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AUTOMOTIVE_DESIGN.COMPOSITE_TEXT'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(None)  ==  0))
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = (( not (('AUTOMOTIVE_DESIGN.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AUTOMOTIVE_DESIGN.TEXT_LITERAL_WITH_ASSOCIATED_CURVES'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(None)  ==  0))
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr

	def wr15(self):
		eval_wr15_wr = (( not (('AUTOMOTIVE_DESIGN.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AUTOMOTIVE_DESIGN.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(None)  ==  0))
		if not eval_wr15_wr:
			raise AssertionError('Rule wr15 violated')
		else:
			return eval_wr15_wr

	def wr16(self):
		eval_wr16_wr = (SIZEOF(None)  ==  0)
		if not eval_wr16_wr:
			raise AssertionError('Rule wr16 violated')
		else:
			return eval_wr16_wr

	def wr17(self):
		eval_wr17_wr = (SIZEOF(None)  ==  0)
		if not eval_wr17_wr:
			raise AssertionError('Rule wr17 violated')
		else:
			return eval_wr17_wr

	def wr18(self):
		eval_wr18_wr = (SIZEOF(None)  ==  0)
		if not eval_wr18_wr:
			raise AssertionError('Rule wr18 violated')
		else:
			return eval_wr18_wr

	def wr19(self):
		eval_wr19_wr = (SIZEOF(None)  ==  0)
		if not eval_wr19_wr:
			raise AssertionError('Rule wr19 violated')
		else:
			return eval_wr19_wr

	def wr20(self):
		eval_wr20_wr = (SIZEOF(None)  ==  0)
		if not eval_wr20_wr:
			raise AssertionError('Rule wr20 violated')
		else:
			return eval_wr20_wr


####################
 # ENTITY path_feature_component #
####################
class path_feature_component(shape_aspect):
	'''Entity path_feature_component definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.description  ==  ['partial circular','complete circular','linear','complex'])
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'partial circular')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.description  !=  'partial circular')  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = ((self.self.description  !=  'partial circular')  or  (SIZEOF(None)  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = ((self.self.description  !=  'complete circular')  or  (SIZEOF(None)  ==  1))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = ((self.self.description  !=  'complete circular')  or  (SIZEOF(None)  ==  1))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = ((self.self.description  !=  'linear')  or  (SIZEOF(None)  ==  1))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = ((self.self.description  !=  'linear')  or  (SIZEOF(None)  ==  1))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = ((self.self.description  !=  'complex')  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1)))
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = ((self.self.description  !=  'complex')  or  (SIZEOF(None)  ==  1))
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr


####################
 # ENTITY derived_unit #
####################
class derived_unit(BaseEntityClass):
	'''Entity derived_unit definition.

	:param elements
	:type elements:SET(1,None,'derived_unit_element', scope = schema_scope)

	:param name
	:type name:label
	'''
	def __init__( self , elements, ):
		self.elements = elements

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument elements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'derived_unit_element', scope = schema_scope)):
				self._elements = SET(value)
			else:
				self._elements = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.elements)  >  1)  or  ((SIZEOF(self.elements)  ==  1)  and  (self.elements[1].self.exponent  !=  1)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY derived_unit_variable #
####################
class derived_unit_variable(derived_unit,variable_semantics):
	'''Entity derived_unit_variable definition.

	:param associated_variable_environment
	:type associated_variable_environment:environment
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
		variable_semantics.__init__(self , )

	@apply
	def associated_variable_environment():
		def fget( self ):
			return self._associated_variable_environment
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument associated_variable_environment is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY log_function #
####################
class log_function(unary_function_call):
	'''Entity log_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY compound_representation_item #
####################
class compound_representation_item(representation_item):
	'''Entity compound_representation_item definition.

	:param item_element
	:type item_element:compound_item_definition
	'''
	def __init__( self , inherited0__name , item_element, ):
		representation_item.__init__(self , inherited0__name , )
		self.item_element = item_element

	@apply
	def item_element():
		def fget( self ):
			return self._item_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_element is mantatory and can not be set to None')
			if not check_type(value,compound_item_definition):
				self._item_element = compound_item_definition(value)
			else:
				self._item_element = value
		return property(**locals())

####################
 # ENTITY value_range #
####################
class value_range(compound_representation_item):
	'''Entity value_range definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.'  +  'SET_REPRESENTATION_ITEM')  ==  TYPEOF(self.item_element))  and  value_range_wr1(self.item_element))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = value_range_wr2(self.item_element)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = value_range_wr3(self.item_element)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY boss #
####################
class boss(feature_definition):
	'''Entity boss definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (self.self.description  ==  ['circular','rectangular','complex'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((self.self.description  !=  'circular')  or  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((self.self.description  !=  'complex')  or  (SIZEOF(None)  ==  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.description  !=  'rectangular')  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  ==  0))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  1)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (( not (self.self.description  ==  ['rectangular','complex']))  or  (SIZEOF(None)  <=  1))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = ((self.self.description  !=  'circular')  or  (SIZEOF(None)  <=  1))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY surface_style_reflectance_ambient #
####################
class surface_style_reflectance_ambient(BaseEntityClass):
	'''Entity surface_style_reflectance_ambient definition.

	:param ambient_reflectance
	:type ambient_reflectance:REAL
	'''
	def __init__( self , ambient_reflectance, ):
		self.ambient_reflectance = ambient_reflectance

	@apply
	def ambient_reflectance():
		def fget( self ):
			return self._ambient_reflectance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ambient_reflectance is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._ambient_reflectance = REAL(value)
			else:
				self._ambient_reflectance = value
		return property(**locals())

####################
 # ENTITY surface_style_reflectance_ambient_diffuse #
####################
class surface_style_reflectance_ambient_diffuse(surface_style_reflectance_ambient):
	'''Entity surface_style_reflectance_ambient_diffuse definition.

	:param diffuse_reflectance
	:type diffuse_reflectance:REAL
	'''
	def __init__( self , inherited0__ambient_reflectance , diffuse_reflectance, ):
		surface_style_reflectance_ambient.__init__(self , inherited0__ambient_reflectance , )
		self.diffuse_reflectance = diffuse_reflectance

	@apply
	def diffuse_reflectance():
		def fget( self ):
			return self._diffuse_reflectance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument diffuse_reflectance is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._diffuse_reflectance = REAL(value)
			else:
				self._diffuse_reflectance = value
		return property(**locals())

####################
 # ENTITY action_status #
####################
class action_status(BaseEntityClass):
	'''Entity action_status definition.

	:param status
	:type status:label

	:param assigned_action
	:type assigned_action:executed_action
	'''
	def __init__( self , status,assigned_action, ):
		self.status = status
		self.assigned_action = assigned_action

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument status is mantatory and can not be set to None')
			if not check_type(value,label):
				self._status = label(value)
			else:
				self._status = value
		return property(**locals())

	@apply
	def assigned_action():
		def fget( self ):
			return self._assigned_action
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_action is mantatory and can not be set to None')
			if not check_type(value,executed_action):
				self._assigned_action = executed_action(value)
			else:
				self._assigned_action = value
		return property(**locals())

####################
 # ENTITY draughting_callout_relationship #
####################
class draughting_callout_relationship(BaseEntityClass):
	'''Entity draughting_callout_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_draughting_callout
	:type relating_draughting_callout:draughting_callout

	:param related_draughting_callout
	:type related_draughting_callout:draughting_callout
	'''
	def __init__( self , name,description,relating_draughting_callout,related_draughting_callout, ):
		self.name = name
		self.description = description
		self.relating_draughting_callout = relating_draughting_callout
		self.related_draughting_callout = related_draughting_callout

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_draughting_callout():
		def fget( self ):
			return self._relating_draughting_callout
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_draughting_callout is mantatory and can not be set to None')
			if not check_type(value,draughting_callout):
				self._relating_draughting_callout = draughting_callout(value)
			else:
				self._relating_draughting_callout = value
		return property(**locals())

	@apply
	def related_draughting_callout():
		def fget( self ):
			return self._related_draughting_callout
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_draughting_callout is mantatory and can not be set to None')
			if not check_type(value,draughting_callout):
				self._related_draughting_callout = draughting_callout(value)
			else:
				self._related_draughting_callout = value
		return property(**locals())

####################
 # ENTITY dimension_pair #
####################
class dimension_pair(draughting_callout_relationship):
	'''Entity dimension_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout ,  ):
		draughting_callout_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['chained','parallel'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(TYPEOF(self.self.relating_draughting_callout)  *  ['AUTOMOTIVE_DESIGN.ANGULAR_DIMENSION','AUTOMOTIVE_DESIGN.CURVE_DIMENSION','AUTOMOTIVE_DESIGN.DIAMETER_DIMENSION','AUTOMOTIVE_DESIGN.LINEAR_DIMENSION','AUTOMOTIVE_DESIGN.ORDINATE_DIMENSION','AUTOMOTIVE_DESIGN.RADIUS_DIMENSION'])  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(TYPEOF(self.self.related_draughting_callout)  *  ['AUTOMOTIVE_DESIGN.ANGULAR_DIMENSION','AUTOMOTIVE_DESIGN.CURVE_DIMENSION','AUTOMOTIVE_DESIGN.DIAMETER_DIMENSION','AUTOMOTIVE_DESIGN.LINEAR_DIMENSION','AUTOMOTIVE_DESIGN.ORDINATE_DIMENSION','AUTOMOTIVE_DESIGN.RADIUS_DIMENSION'])  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY draughting_title #
####################
class draughting_title(BaseEntityClass):
	'''Entity draughting_title definition.

	:param items
	:type items:SET(1,None,'draughting_titled_item', scope = schema_scope)

	:param language
	:type language:label

	:param contents
	:type contents:text
	'''
	def __init__( self , items,language,contents, ):
		self.items = items
		self.language = language
		self.contents = contents

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'draughting_titled_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def language():
		def fget( self ):
			return self._language
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument language is mantatory and can not be set to None')
			if not check_type(value,label):
				self._language = label(value)
			else:
				self._language = value
		return property(**locals())

	@apply
	def contents():
		def fget( self ):
			return self._contents
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument contents is mantatory and can not be set to None')
			if not check_type(value,text):
				self._contents = text(value)
			else:
				self._contents = value
		return property(**locals())

####################
 # ENTITY application_context #
####################
class application_context(BaseEntityClass):
	'''Entity application_context definition.

	:param application
	:type application:label

	:param description
	:type description:text

	:param id
	:type id:identifier

	:param context_elements
	:type context_elements:SET(1,None,'application_context_element', scope = schema_scope)
	'''
	def __init__( self , application, ):
		self.application = application

	@apply
	def application():
		def fget( self ):
			return self._application
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument application is mantatory and can not be set to None')
			if not check_type(value,label):
				self._application = label(value)
			else:
				self._application = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def context_elements():
		def fget( self ):
			return self._context_elements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument context_elements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY presented_item #
####################
class presented_item(BaseEntityClass):
	'''Entity presented_item definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY applied_presented_item #
####################
class applied_presented_item(presented_item):
	'''Entity applied_presented_item definition.

	:param items
	:type items:SET(1,None,'presented_item_select', scope = schema_scope)
	'''
	def __init__( self , items, ):
		presented_item.__init__(self , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'presented_item_select', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY date_and_time #
####################
class date_and_time(BaseEntityClass):
	'''Entity date_and_time definition.

	:param date_component
	:type date_component:date

	:param time_component
	:type time_component:local_time
	'''
	def __init__( self , date_component,time_component, ):
		self.date_component = date_component
		self.time_component = time_component

	@apply
	def date_component():
		def fget( self ):
			return self._date_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument date_component is mantatory and can not be set to None')
			if not check_type(value,date):
				self._date_component = date(value)
			else:
				self._date_component = value
		return property(**locals())

	@apply
	def time_component():
		def fget( self ):
			return self._time_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument time_component is mantatory and can not be set to None')
			if not check_type(value,local_time):
				self._time_component = local_time(value)
			else:
				self._time_component = value
		return property(**locals())

####################
 # ENTITY feature_component_relationship #
####################
class feature_component_relationship(shape_aspect_relationship):
	'''Entity feature_component_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		shape_aspect_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.'  +  'TRANSITION_FEATURE')  ==  TYPEOF(self.self.related_shape_aspect))  or  (SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'FEATURE_DEFINITION','AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION']  *  TYPEOF(self.self.related_shape_aspect.self.of_shape.self.definition))  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY pattern_omit_membership #
####################
class pattern_omit_membership(feature_component_relationship):
	'''Entity pattern_omit_membership definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		feature_component_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'CIRCULAR_PATTERN','AUTOMOTIVE_DESIGN.'  +  'RECTANGULAR_PATTERN']  *  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition))  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(get_property_definition_representations(self.self.related_shape_aspect.self.of_shape.self.definition))  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'CIRCULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'CIRCULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'RECTANGULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'RECTANGULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'RECTANGULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr


####################
 # ENTITY derived_shape_aspect #
####################
class derived_shape_aspect(shape_aspect):
	'''Entity derived_shape_aspect definition.

	:param deriving_relationships
	:type deriving_relationships:SET(1,None,'shape_aspect_relationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )

	@apply
	def deriving_relationships():
		def fget( self ):
			return self._deriving_relationships
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument deriving_relationships is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY apex #
####################
class apex(derived_shape_aspect):
	'''Entity apex definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )

####################
 # ENTITY tolerance_value #
####################
class tolerance_value(BaseEntityClass):
	'''Entity tolerance_value definition.

	:param lower_bound
	:type lower_bound:measure_with_unit

	:param upper_bound
	:type upper_bound:measure_with_unit
	'''
	def __init__( self , lower_bound,upper_bound, ):
		self.lower_bound = lower_bound
		self.upper_bound = upper_bound

	@apply
	def lower_bound():
		def fget( self ):
			return self._lower_bound
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_bound is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._lower_bound = measure_with_unit(value)
			else:
				self._lower_bound = value
		return property(**locals())

	@apply
	def upper_bound():
		def fget( self ):
			return self._upper_bound
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_bound is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._upper_bound = measure_with_unit(value)
			else:
				self._upper_bound = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.upper_bound.self.measure_with_unit.self.value_component  >  self.lower_bound.self.measure_with_unit.self.value_component)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.upper_bound.self.measure_with_unit.self.unit_component  ==  self.lower_bound.self.measure_with_unit.self.unit_component)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY approval_date_time #
####################
class approval_date_time(BaseEntityClass):
	'''Entity approval_date_time definition.

	:param date_time
	:type date_time:date_time_select

	:param dated_approval
	:type dated_approval:approval

	:param role
	:type role:object_role
	'''
	def __init__( self , date_time,dated_approval, ):
		self.date_time = date_time
		self.dated_approval = dated_approval

	@apply
	def date_time():
		def fget( self ):
			return self._date_time
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument date_time is mantatory and can not be set to None')
			if not check_type(value,date_time_select):
				self._date_time = date_time_select(value)
			else:
				self._date_time = value
		return property(**locals())

	@apply
	def dated_approval():
		def fget( self ):
			return self._dated_approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dated_approval is mantatory and can not be set to None')
			if not check_type(value,approval):
				self._dated_approval = approval(value)
			else:
				self._dated_approval = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY approval_role #
####################
class approval_role(BaseEntityClass):
	'''Entity approval_role definition.

	:param role
	:type role:label

	:param description
	:type description:text
	'''
	def __init__( self , role, ):
		self.role = role

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,label):
				self._role = label(value)
			else:
				self._role = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY application_context_element #
####################
class application_context_element(BaseEntityClass):
	'''Entity application_context_element definition.

	:param name
	:type name:label

	:param frame_of_reference
	:type frame_of_reference:application_context
	'''
	def __init__( self , name,frame_of_reference, ):
		self.name = name
		self.frame_of_reference = frame_of_reference

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def frame_of_reference():
		def fget( self ):
			return self._frame_of_reference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument frame_of_reference is mantatory and can not be set to None')
			if not check_type(value,application_context):
				self._frame_of_reference = application_context(value)
			else:
				self._frame_of_reference = value
		return property(**locals())

####################
 # ENTITY product_context #
####################
class product_context(application_context_element):
	'''Entity product_context definition.

	:param discipline_type
	:type discipline_type:label
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , discipline_type, ):
		application_context_element.__init__(self , inherited0__name , inherited1__frame_of_reference , )
		self.discipline_type = discipline_type

	@apply
	def discipline_type():
		def fget( self ):
			return self._discipline_type
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument discipline_type is mantatory and can not be set to None')
			if not check_type(value,label):
				self._discipline_type = label(value)
			else:
				self._discipline_type = value
		return property(**locals())

####################
 # ENTITY elementary_surface #
####################
class elementary_surface(surface):
	'''Entity elementary_surface definition.

	:param position
	:type position:axis2_placement_3d
	'''
	def __init__( self , inherited0__name , position, ):
		surface.__init__(self , inherited0__name , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._position = axis2_placement_3d(value)
			else:
				self._position = value
		return property(**locals())

####################
 # ENTITY spherical_surface #
####################
class spherical_surface(elementary_surface):
	'''Entity spherical_surface definition.

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY annotation_curve_occurrence #
####################
class annotation_curve_occurrence(annotation_occurrence):
	'''Entity annotation_curve_occurrence definition.

	:param styled_item_item
	:type styled_item_item:curve
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , styled_item_item, ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		self.styled_item_item = styled_item_item

	@apply
	def styled_item_item():
		def fget( self ):
			return self._styled_item_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_item_item is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._styled_item_item = curve(value)
			else:
				self._styled_item_item = value
		return property(**locals())

####################
 # ENTITY projection_curve #
####################
class projection_curve(annotation_curve_occurrence):
	'''Entity projection_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item ,  ):
		annotation_curve_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , )

####################
 # ENTITY application_protocol_definition #
####################
class application_protocol_definition(BaseEntityClass):
	'''Entity application_protocol_definition definition.

	:param status
	:type status:label

	:param application_interpreted_model_schema_name
	:type application_interpreted_model_schema_name:label

	:param application_protocol_year
	:type application_protocol_year:year_number

	:param application
	:type application:application_context
	'''
	def __init__( self , status,application_interpreted_model_schema_name,application_protocol_year,application, ):
		self.status = status
		self.application_interpreted_model_schema_name = application_interpreted_model_schema_name
		self.application_protocol_year = application_protocol_year
		self.application = application

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument status is mantatory and can not be set to None')
			if not check_type(value,label):
				self._status = label(value)
			else:
				self._status = value
		return property(**locals())

	@apply
	def application_interpreted_model_schema_name():
		def fget( self ):
			return self._application_interpreted_model_schema_name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument application_interpreted_model_schema_name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._application_interpreted_model_schema_name = label(value)
			else:
				self._application_interpreted_model_schema_name = value
		return property(**locals())

	@apply
	def application_protocol_year():
		def fget( self ):
			return self._application_protocol_year
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument application_protocol_year is mantatory and can not be set to None')
			if not check_type(value,year_number):
				self._application_protocol_year = year_number(value)
			else:
				self._application_protocol_year = value
		return property(**locals())

	@apply
	def application():
		def fget( self ):
			return self._application
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument application is mantatory and can not be set to None')
			if not check_type(value,application_context):
				self._application = application_context(value)
			else:
				self._application = value
		return property(**locals())

####################
 # ENTITY dimensional_size #
####################
class dimensional_size(BaseEntityClass):
	'''Entity dimensional_size definition.

	:param applies_to
	:type applies_to:shape_aspect

	:param name
	:type name:label
	'''
	def __init__( self , applies_to,name, ):
		self.applies_to = applies_to
		self.name = name

	@apply
	def applies_to():
		def fget( self ):
			return self._applies_to
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applies_to is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._applies_to = shape_aspect(value)
			else:
				self._applies_to = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.applies_to.self.product_definitional  ==  TRUE)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY externally_defined_dimension_definition #
####################
class externally_defined_dimension_definition(dimensional_size,externally_defined_item):
	'''Entity externally_defined_dimension_definition definition.
	'''
	def __init__( self , inherited0__applies_to , inherited1__name , inherited2__item_id , inherited3__source ,  ):
		dimensional_size.__init__(self , inherited0__applies_to , inherited1__name , )
		externally_defined_item.__init__(self , inherited2__item_id , inherited3__source , )
	def wr1(self):
		eval_wr1_wr = ((self.self.externally_defined_item.self.item_id  ==  'external size dimension')  and  (self.self.externally_defined_item.self.source.self.source_id  ==  'external size dimension specification'))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (1  >=  SIZEOF(None))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY swept_disk_solid #
####################
class swept_disk_solid(solid_model):
	'''Entity swept_disk_solid definition.

	:param directrix
	:type directrix:curve

	:param radius
	:type radius:positive_length_measure

	:param inner_radius
	:type inner_radius:positive_length_measure

	:param start_param
	:type start_param:REAL

	:param end_param
	:type end_param:REAL
	'''
	def __init__( self , inherited0__name , directrix,radius,inner_radius,start_param,end_param, ):
		solid_model.__init__(self , inherited0__name , )
		self.directrix = directrix
		self.radius = radius
		self.inner_radius = inner_radius
		self.start_param = start_param
		self.end_param = end_param

	@apply
	def directrix():
		def fget( self ):
			return self._directrix
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directrix is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._directrix = curve(value)
			else:
				self._directrix = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def inner_radius():
		def fget( self ):
			return self._inner_radius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,positive_length_measure):
					self._inner_radius = positive_length_measure(value)
				else:
					self._inner_radius = value
			else:
				self._inner_radius = value
		return property(**locals())

	@apply
	def start_param():
		def fget( self ):
			return self._start_param
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument start_param is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._start_param = REAL(value)
			else:
				self._start_param = value
		return property(**locals())

	@apply
	def end_param():
		def fget( self ):
			return self._end_param
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument end_param is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._end_param = REAL(value)
			else:
				self._end_param = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.directrix.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.inner_radius))  or  (self.radius  >  self.inner_radius))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY dimension_callout_relationship #
####################
class dimension_callout_relationship(draughting_callout_relationship):
	'''Entity dimension_callout_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout ,  ):
		draughting_callout_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['primary','secondary'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(TYPEOF(self.self.relating_draughting_callout)  *  ['AUTOMOTIVE_DESIGN.ANGULAR_DIMENSION','AUTOMOTIVE_DESIGN.CURVE_DIMENSION','AUTOMOTIVE_DESIGN.DIAMETER_DIMENSION','AUTOMOTIVE_DESIGN.LEADER_DIRECTED_DIMENSION','AUTOMOTIVE_DESIGN.LINEAR_DIMENSION','AUTOMOTIVE_DESIGN.ORDINATE_DIMENSION','AUTOMOTIVE_DESIGN.RADIUS_DIMENSION'])  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(TYPEOF(self.self.related_draughting_callout)  *  ['AUTOMOTIVE_DESIGN.DIMENSION_CURVE_DIRECTED_CALLOUT','AUTOMOTIVE_DESIGN.PROJECTION_DIRECTED_CALLOUT','AUTOMOTIVE_DESIGN.LEADER_DIRECTED_CALLOUT'])  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.related_draughting_callout.self.contents  *  self.self.relating_draughting_callout.self.contents)  ==  self.self.related_draughting_callout.self.contents)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY process_property_association #
####################
class process_property_association(BaseEntityClass):
	'''Entity process_property_association definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param process
	:type process:property_process

	:param property_or_shape
	:type property_or_shape:property_or_shape_select
	'''
	def __init__( self , name,description,process,property_or_shape, ):
		self.name = name
		self.description = description
		self.process = process
		self.property_or_shape = property_or_shape

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def process():
		def fget( self ):
			return self._process
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument process is mantatory and can not be set to None')
			if not check_type(value,property_process):
				self._process = property_process(value)
			else:
				self._process = value
		return property(**locals())

	@apply
	def property_or_shape():
		def fget( self ):
			return self._property_or_shape
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument property_or_shape is mantatory and can not be set to None')
			if not check_type(value,property_or_shape_select):
				self._property_or_shape = property_or_shape_select(value)
			else:
				self._property_or_shape = value
		return property(**locals())

####################
 # ENTITY specified_higher_usage_occurrence #
####################
class specified_higher_usage_occurrence(assembly_component_usage):
	'''Entity specified_higher_usage_occurrence definition.

	:param upper_usage
	:type upper_usage:assembly_component_usage

	:param next_usage
	:type next_usage:next_assembly_usage_occurrence
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , upper_usage,next_usage, ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )
		self.upper_usage = upper_usage
		self.next_usage = next_usage

	@apply
	def upper_usage():
		def fget( self ):
			return self._upper_usage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_usage is mantatory and can not be set to None')
			if not check_type(value,assembly_component_usage):
				self._upper_usage = assembly_component_usage(value)
			else:
				self._upper_usage = value
		return property(**locals())

	@apply
	def next_usage():
		def fget( self ):
			return self._next_usage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument next_usage is mantatory and can not be set to None')
			if not check_type(value,next_assembly_usage_occurrence):
				self._next_usage = next_assembly_usage_occurrence(value)
			else:
				self._next_usage = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self  !=  self.upper_usage)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.product_definition_relationship.self.relating_product_definition  ==  self.upper_usage.self.relating_product_definition)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.product_definition_relationship.self.related_product_definition  ==  self.next_usage.self.related_product_definition)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.upper_usage.self.related_product_definition  ==  self.next_usage.self.relating_product_definition)  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.NEXT_ASSEMBLY_USAGE_OCCURRENCE','AUTOMOTIVE_DESIGN.SPECIFIED_HIGHER_USAGE_OCCURRENCE']  *  TYPEOF(self.upper_usage))  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY dimensional_location_with_path #
####################
class dimensional_location_with_path(dimensional_location):
	'''Entity dimensional_location_with_path definition.

	:param path
	:type path:shape_aspect
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , path, ):
		dimensional_location.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
		self.path = path

	@apply
	def path():
		def fget( self ):
			return self._path
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument path is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._path = shape_aspect(value)
			else:
				self._path = value
		return property(**locals())

####################
 # ENTITY feature_in_panel #
####################
class feature_in_panel(feature_definition):
	'''Entity feature_in_panel definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (self.self.description  ==  ['pocket','boss','stairstep'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  <=  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  SIZEOF(None))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  SIZEOF(None))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  ==  0))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = ((SIZEOF(None)  ==  0)  or  (SIZEOF(None)  ==  1))
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr


####################
 # ENTITY pattern_offset_membership #
####################
class pattern_offset_membership(feature_component_relationship):
	'''Entity pattern_offset_membership definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		feature_component_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'CIRCULAR_PATTERN','AUTOMOTIVE_DESIGN.'  +  'RECTANGULAR_PATTERN']  *  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition))  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(get_property_definition_representations(self.self.related_shape_aspect.self.of_shape.self.definition))  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'CIRCULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'CIRCULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'CIRCULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'RECTANGULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'RECTANGULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'RECTANGULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'RECTANGULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'RECTANGULAR_PATTERN')  ==  TYPEOF(self.self.relating_shape_aspect.self.of_shape.self.definition)))  or  (SIZEOF(None)  ==  1))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY product_definition_formation_with_specified_source #
####################
class product_definition_formation_with_specified_source(product_definition_formation):
	'''Entity product_definition_formation_with_specified_source definition.

	:param make_or_buy
	:type make_or_buy:source
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__of_product , make_or_buy, ):
		product_definition_formation.__init__(self , inherited0__id , inherited1__description , inherited2__of_product , )
		self.make_or_buy = make_or_buy

	@apply
	def make_or_buy():
		def fget( self ):
			return self._make_or_buy
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument make_or_buy is mantatory and can not be set to None')
			if not check_type(value,source):
				self._make_or_buy = source(value)
			else:
				self._make_or_buy = value
		return property(**locals())

####################
 # ENTITY surface_style_transparent #
####################
class surface_style_transparent(BaseEntityClass):
	'''Entity surface_style_transparent definition.

	:param transparency
	:type transparency:REAL
	'''
	def __init__( self , transparency, ):
		self.transparency = transparency

	@apply
	def transparency():
		def fget( self ):
			return self._transparency
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transparency is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._transparency = REAL(value)
			else:
				self._transparency = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((0  <=  self.transparency)  and  (self.transparency  <=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY amount_of_substance_measure_with_unit #
####################
class amount_of_substance_measure_with_unit(measure_with_unit):
	'''Entity amount_of_substance_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.AMOUNT_OF_SUBSTANCE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY cylindrical_pair_range #
####################
class cylindrical_pair_range(simple_pair_range):
	'''Entity cylindrical_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:cylindrical_pair

	:param lower_limit_actual_translation
	:type lower_limit_actual_translation:translational_range_measure

	:param upper_limit_actual_translation
	:type upper_limit_actual_translation:translational_range_measure

	:param lower_limit_actual_rotation
	:type lower_limit_actual_rotation:rotational_range_measure

	:param upper_limit_actual_rotation
	:type upper_limit_actual_rotation:rotational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,lower_limit_actual_translation,upper_limit_actual_translation,lower_limit_actual_rotation,upper_limit_actual_rotation, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.lower_limit_actual_translation = lower_limit_actual_translation
		self.upper_limit_actual_translation = upper_limit_actual_translation
		self.lower_limit_actual_rotation = lower_limit_actual_rotation
		self.upper_limit_actual_rotation = upper_limit_actual_rotation

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,cylindrical_pair):
				self._simple_pair_range_applies_to_pair = cylindrical_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def lower_limit_actual_translation():
		def fget( self ):
			return self._lower_limit_actual_translation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_actual_translation is mantatory and can not be set to None')
			if not check_type(value,translational_range_measure):
				self._lower_limit_actual_translation = translational_range_measure(value)
			else:
				self._lower_limit_actual_translation = value
		return property(**locals())

	@apply
	def upper_limit_actual_translation():
		def fget( self ):
			return self._upper_limit_actual_translation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_actual_translation is mantatory and can not be set to None')
			if not check_type(value,translational_range_measure):
				self._upper_limit_actual_translation = translational_range_measure(value)
			else:
				self._upper_limit_actual_translation = value
		return property(**locals())

	@apply
	def lower_limit_actual_rotation():
		def fget( self ):
			return self._lower_limit_actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_actual_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_actual_rotation = rotational_range_measure(value)
			else:
				self._lower_limit_actual_rotation = value
		return property(**locals())

	@apply
	def upper_limit_actual_rotation():
		def fget( self ):
			return self._upper_limit_actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_actual_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_actual_rotation = rotational_range_measure(value)
			else:
				self._upper_limit_actual_rotation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_actual_translation))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_actual_translation))) XOR (self.lower_limit_actual_translation  <  self.upper_limit_actual_translation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_actual_rotation))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_actual_rotation))) XOR (self.lower_limit_actual_rotation  <  self.upper_limit_actual_rotation))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY description_attribute #
####################
class description_attribute(BaseEntityClass):
	'''Entity description_attribute definition.

	:param attribute_value
	:type attribute_value:text

	:param described_item
	:type described_item:description_attribute_select
	'''
	def __init__( self , attribute_value,described_item, ):
		self.attribute_value = attribute_value
		self.described_item = described_item

	@apply
	def attribute_value():
		def fget( self ):
			return self._attribute_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_value is mantatory and can not be set to None')
			if not check_type(value,text):
				self._attribute_value = text(value)
			else:
				self._attribute_value = value
		return property(**locals())

	@apply
	def described_item():
		def fget( self ):
			return self._described_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument described_item is mantatory and can not be set to None')
			if not check_type(value,description_attribute_select):
				self._described_item = description_attribute_select(value)
			else:
				self._described_item = value
		return property(**locals())

####################
 # ENTITY half_space_solid #
####################
class half_space_solid(geometric_representation_item):
	'''Entity half_space_solid definition.

	:param base_surface
	:type base_surface:surface

	:param agreement_flag
	:type agreement_flag:BOOLEAN
	'''
	def __init__( self , inherited0__name , base_surface,agreement_flag, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.base_surface = base_surface
		self.agreement_flag = agreement_flag

	@apply
	def base_surface():
		def fget( self ):
			return self._base_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._base_surface = surface(value)
			else:
				self._base_surface = value
		return property(**locals())

	@apply
	def agreement_flag():
		def fget( self ):
			return self._agreement_flag
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument agreement_flag is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._agreement_flag = BOOLEAN(value)
			else:
				self._agreement_flag = value
		return property(**locals())

####################
 # ENTITY action_request_solution #
####################
class action_request_solution(BaseEntityClass):
	'''Entity action_request_solution definition.

	:param method
	:type method:action_method

	:param request
	:type request:versioned_action_request

	:param description
	:type description:text

	:param name
	:type name:label
	'''
	def __init__( self , method,request, ):
		self.method = method
		self.request = request

	@apply
	def method():
		def fget( self ):
			return self._method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument method is mantatory and can not be set to None')
			if not check_type(value,action_method):
				self._method = action_method(value)
			else:
				self._method = value
		return property(**locals())

	@apply
	def request():
		def fget( self ):
			return self._request
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument request is mantatory and can not be set to None')
			if not check_type(value,versioned_action_request):
				self._request = versioned_action_request(value)
			else:
				self._request = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY group #
####################
class group(BaseEntityClass):
	'''Entity group definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_concept_feature_category #
####################
class product_concept_feature_category(group):
	'''Entity product_concept_feature_category definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY exclusive_product_concept_feature_category #
####################
class exclusive_product_concept_feature_category(product_concept_feature_category):
	'''Entity exclusive_product_concept_feature_category definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		product_concept_feature_category.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY over_riding_styled_item #
####################
class over_riding_styled_item(styled_item):
	'''Entity over_riding_styled_item definition.

	:param over_ridden_style
	:type over_ridden_style:styled_item
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , over_ridden_style, ):
		styled_item.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		self.over_ridden_style = over_ridden_style

	@apply
	def over_ridden_style():
		def fget( self ):
			return self._over_ridden_style
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument over_ridden_style is mantatory and can not be set to None')
			if not check_type(value,styled_item):
				self._over_ridden_style = styled_item(value)
			else:
				self._over_ridden_style = value
		return property(**locals())

####################
 # ENTITY context_dependent_over_riding_styled_item #
####################
class context_dependent_over_riding_styled_item(over_riding_styled_item):
	'''Entity context_dependent_over_riding_styled_item definition.

	:param style_context
	:type style_context:LIST(1,None,'style_context_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__over_ridden_style , style_context, ):
		over_riding_styled_item.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__over_ridden_style , )
		self.style_context = style_context

	@apply
	def style_context():
		def fget( self ):
			return self._style_context
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_context is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'style_context_select', scope = schema_scope)):
				self._style_context = LIST(value)
			else:
				self._style_context = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((SIZEOF(None)  ==  1)  or  (SIZEOF(None)  ==  SIZEOF(self.style_context)))  or  (SIZEOF(None)  ==  SIZEOF(self.style_context)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY hidden_element_over_riding_styled_item #
####################
class hidden_element_over_riding_styled_item(context_dependent_over_riding_styled_item):
	'''Entity hidden_element_over_riding_styled_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__over_ridden_style , inherited4__style_context ,  ):
		context_dependent_over_riding_styled_item.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__over_ridden_style , inherited4__style_context , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.style_context)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('AUTOMOTIVE_DESIGN.'  +  'PRESENTATION_VIEW')  ==  TYPEOF(self.self.style_context[1]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (('AUTOMOTIVE_DESIGN.'  +  'CAMERA_IMAGE')  ==  TYPEOF(self.self.item))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (('AUTOMOTIVE_DESIGN.'  +  'CAMERA_MODEL_D3_WITH_HLHSR')  ==  TYPEOF(self.self.item.self.mapped_item.self.mapping_source.self.mapping_origin))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  >  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY presentation_size #
####################
class presentation_size(BaseEntityClass):
	'''Entity presentation_size definition.

	:param unit
	:type unit:presentation_size_assignment_select

	:param size
	:type size:planar_box
	'''
	def __init__( self , unit,size, ):
		self.unit = unit
		self.size = size

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unit is mantatory and can not be set to None')
			if not check_type(value,presentation_size_assignment_select):
				self._unit = presentation_size_assignment_select(value)
			else:
				self._unit = value
		return property(**locals())

	@apply
	def size():
		def fget( self ):
			return self._size
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument size is mantatory and can not be set to None')
			if not check_type(value,planar_box):
				self._size = planar_box(value)
			else:
				self._size = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.PRESENTATION_REPRESENTATION'  ==  TYPEOF(self.self.unit))  and  item_in_context(self.self.size,self.self.unit.self.representation.self.context_of_items))  or  (('AUTOMOTIVE_DESIGN.AREA_IN_SET'  ==  TYPEOF(self.self.unit))  and  (SIZEOF(None)  ==  0)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY uncertainty_measure_with_unit #
####################
class uncertainty_measure_with_unit(measure_with_unit):
	'''Entity uncertainty_measure_with_unit definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component , name,description, ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = valid_measure_value(self.self.measure_with_unit.self.value_component)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY edge_based_wireframe_model #
####################
class edge_based_wireframe_model(geometric_representation_item):
	'''Entity edge_based_wireframe_model definition.

	:param ebwm_boundary
	:type ebwm_boundary:SET(1,None,'connected_edge_set', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , ebwm_boundary, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.ebwm_boundary = ebwm_boundary

	@apply
	def ebwm_boundary():
		def fget( self ):
			return self._ebwm_boundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ebwm_boundary is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'connected_edge_set', scope = schema_scope)):
				self._ebwm_boundary = SET(value)
			else:
				self._ebwm_boundary = value
		return property(**locals())

####################
 # ENTITY rack_and_pinion_pair_value #
####################
class rack_and_pinion_pair_value(pair_value):
	'''Entity rack_and_pinion_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:rack_and_pinion_pair

	:param actual_displacement
	:type actual_displacement:length_measure

	:param actual_rotation
	:type actual_rotation:plane_angle_measure
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_displacement, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_displacement = actual_displacement

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,rack_and_pinion_pair):
				self._pair_value_applies_to_pair = rack_and_pinion_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_displacement():
		def fget( self ):
			return self._actual_displacement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_displacement is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._actual_displacement = length_measure(value)
			else:
				self._actual_displacement = value
		return property(**locals())

	@apply
	def actual_rotation():
		def fget( self ):
			attribute_eval = convert_plane_angle_for_pair_from_radian(self.self.pair_value.self.applies_to_pair,(-self.actual_displacement) / self.self.pair_value.self.applies_to_pair.self.rack_and_pinion_pair.self.pinion_radius)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument actual_rotation is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY pre_defined_colour #
####################
class pre_defined_colour(pre_defined_item,colour):
	'''Entity pre_defined_colour definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )
		colour.__init__(self , )

####################
 # ENTITY draughting_pre_defined_colour #
####################
class draughting_pre_defined_colour(pre_defined_colour):
	'''Entity draughting_pre_defined_colour definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_colour.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['red','green','blue','yellow','magenta','cyan','black','white'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY path #
####################
class path(topological_representation_item):
	'''Entity path definition.

	:param edge_list
	:type edge_list:LIST(1,None,'oriented_edge', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , edge_list, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.edge_list = edge_list

	@apply
	def edge_list():
		def fget( self ):
			return self._edge_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edge_list is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'oriented_edge', scope = schema_scope)):
				self._edge_list = LIST(value)
			else:
				self._edge_list = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = path_head_to_tail(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY feature_component_definition #
####################
class feature_component_definition(characterized_object):
	'''Entity feature_component_definition definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		characterized_object.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(get_shape_aspects(self))  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY connected_face_set #
####################
class connected_face_set(topological_representation_item):
	'''Entity connected_face_set definition.

	:param cfs_faces
	:type cfs_faces:SET(1,None,'face', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , cfs_faces, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.cfs_faces = cfs_faces

	@apply
	def cfs_faces():
		def fget( self ):
			return self._cfs_faces
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument cfs_faces is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'face', scope = schema_scope)):
				self._cfs_faces = SET(value)
			else:
				self._cfs_faces = value
		return property(**locals())

####################
 # ENTITY open_shell #
####################
class open_shell(connected_face_set):
	'''Entity open_shell definition.
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces ,  ):
		connected_face_set.__init__(self , inherited0__name , inherited1__cfs_faces , )

####################
 # ENTITY oriented_open_shell #
####################
class oriented_open_shell(open_shell):
	'''Entity oriented_open_shell definition.

	:param open_shell_element
	:type open_shell_element:open_shell

	:param orientation
	:type orientation:BOOLEAN

	:param connected_face_set_cfs_faces
	:type connected_face_set_cfs_faces:SET(1,None,'face', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces , open_shell_element,orientation, ):
		open_shell.__init__(self , inherited0__name , inherited1__cfs_faces , )
		self.open_shell_element = open_shell_element
		self.orientation = orientation

	@apply
	def open_shell_element():
		def fget( self ):
			return self._open_shell_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument open_shell_element is mantatory and can not be set to None')
			if not check_type(value,open_shell):
				self._open_shell_element = open_shell(value)
			else:
				self._open_shell_element = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def connected_face_set_cfs_faces():
		def fget( self ):
			attribute_eval = conditional_reverse(self.self.orientation,self.self.open_shell_element.self.cfs_faces)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument connected_face_set_cfs_faces is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AUTOMOTIVE_DESIGN.ORIENTED_OPEN_SHELL'  ==  TYPEOF(self.self.open_shell_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY tolerance_zone #
####################
class tolerance_zone(shape_aspect):
	'''Entity tolerance_zone definition.

	:param defining_tolerance
	:type defining_tolerance:SET(1,None,'geometric_tolerance', scope = schema_scope)

	:param form
	:type form:tolerance_zone_form
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , defining_tolerance,form, ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		self.defining_tolerance = defining_tolerance
		self.form = form

	@apply
	def defining_tolerance():
		def fget( self ):
			return self._defining_tolerance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument defining_tolerance is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'geometric_tolerance', scope = schema_scope)):
				self._defining_tolerance = SET(value)
			else:
				self._defining_tolerance = value
		return property(**locals())

	@apply
	def form():
		def fget( self ):
			return self._form
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument form is mantatory and can not be set to None')
			if not check_type(value,tolerance_zone_form):
				self._form = tolerance_zone_form(value)
			else:
				self._form = value
		return property(**locals())

####################
 # ENTITY right_circular_cylinder #
####################
class right_circular_cylinder(geometric_representation_item):
	'''Entity right_circular_cylinder definition.

	:param position
	:type position:axis1_placement

	:param height
	:type height:positive_length_measure

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , position,height,radius, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.position = position
		self.height = height
		self.radius = radius

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._position = axis1_placement(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._height = positive_length_measure(value)
			else:
				self._height = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY solid_angle_unit #
####################
class solid_angle_unit(named_unit):
	'''Entity solid_angle_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY boolean_defined_function #
####################
class boolean_defined_function(defined_function,boolean_expression):
	'''Entity boolean_defined_function definition.
	'''
	def __init__( self ,  ):
		defined_function.__init__(self , )
		boolean_expression.__init__(self , )

####################
 # ENTITY luminous_intensity_measure_with_unit #
####################
class luminous_intensity_measure_with_unit(measure_with_unit):
	'''Entity luminous_intensity_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.LUMINOUS_INTENSITY_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY representation_relationship_with_transformation #
####################
class representation_relationship_with_transformation(representation_relationship):
	'''Entity representation_relationship_with_transformation definition.

	:param transformation_operator
	:type transformation_operator:transformation
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , transformation_operator, ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
		self.transformation_operator = transformation_operator

	@apply
	def transformation_operator():
		def fget( self ):
			return self._transformation_operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transformation_operator is mantatory and can not be set to None')
			if not check_type(value,transformation):
				self._transformation_operator = transformation(value)
			else:
				self._transformation_operator = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.representation_relationship.self.rep_1.self.context_of_items  !=  self.self.representation_relationship.self.rep_2.self.context_of_items)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY mechanism_base_placement #
####################
class mechanism_base_placement(representation_relationship_with_transformation):
	'''Entity mechanism_base_placement definition.

	:param base_of_mechanism
	:type base_of_mechanism:mechanism

	:param representation_relationship_with_transformation_transformation_operator
	:type representation_relationship_with_transformation_transformation_operator:cartesian_transformation_operator_3d

	:param representation_relationship_rep_2
	:type representation_relationship_rep_2:kinematic_link_representation
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , inherited4__transformation_operator , base_of_mechanism,representation_relationship_with_transformation_transformation_operator, ):
		representation_relationship_with_transformation.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , inherited4__transformation_operator , )
		self.base_of_mechanism = base_of_mechanism
		self.representation_relationship_with_transformation_transformation_operator = representation_relationship_with_transformation_transformation_operator

	@apply
	def base_of_mechanism():
		def fget( self ):
			return self._base_of_mechanism
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base_of_mechanism is mantatory and can not be set to None')
			if not check_type(value,mechanism):
				self._base_of_mechanism = mechanism(value)
			else:
				self._base_of_mechanism = value
		return property(**locals())

	@apply
	def representation_relationship_with_transformation_transformation_operator():
		def fget( self ):
			return self._representation_relationship_with_transformation_transformation_operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_with_transformation_transformation_operator is mantatory and can not be set to None')
			if not check_type(value,cartesian_transformation_operator_3d):
				self._representation_relationship_with_transformation_transformation_operator = cartesian_transformation_operator_3d(value)
			else:
				self._representation_relationship_with_transformation_transformation_operator = value
		return property(**locals())

	@apply
	def representation_relationship_rep_2():
		def fget( self ):
			attribute_eval = representation_of_link(self.base_of_mechanism.self.base)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument representation_relationship_rep_2 is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.KINEMATIC_GROUND_REPRESENTATION'  ==  TYPEOF(self.self.representation_relationship.self.rep_1))  or  ('AUTOMOTIVE_DESIGN.KINEMATIC_LINK_REPRESENTATION'  ==  TYPEOF(self.self.representation_relationship.self.rep_1)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = suitably_based_mechanism(self,self.base_of_mechanism)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.representation_relationship_with_transformation.self.transformation_operator  ==  self.self.representation_relationship.self.rep_1.self.items)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY role_association #
####################
class role_association(BaseEntityClass):
	'''Entity role_association definition.

	:param role
	:type role:object_role

	:param item_with_role
	:type item_with_role:role_select
	'''
	def __init__( self , role,item_with_role, ):
		self.role = role
		self.item_with_role = item_with_role

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,object_role):
				self._role = object_role(value)
			else:
				self._role = value
		return property(**locals())

	@apply
	def item_with_role():
		def fget( self ):
			return self._item_with_role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_with_role is mantatory and can not be set to None')
			if not check_type(value,role_select):
				self._item_with_role = role_select(value)
			else:
				self._item_with_role = value
		return property(**locals())

####################
 # ENTITY rectangular_closed_profile #
####################
class rectangular_closed_profile(shape_aspect):
	'''Entity rectangular_closed_profile definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr


####################
 # ENTITY comparison_less #
####################
class comparison_less(comparison_expression):
	'''Entity comparison_less definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		comparison_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY coordinated_universal_time_offset #
####################
class coordinated_universal_time_offset(BaseEntityClass):
	'''Entity coordinated_universal_time_offset definition.

	:param hour_offset
	:type hour_offset:INTEGER

	:param minute_offset
	:type minute_offset:INTEGER

	:param sense
	:type sense:ahead_or_behind

	:param actual_minute_offset
	:type actual_minute_offset:INTEGER
	'''
	def __init__( self , hour_offset,minute_offset,sense, ):
		self.hour_offset = hour_offset
		self.minute_offset = minute_offset
		self.sense = sense

	@apply
	def hour_offset():
		def fget( self ):
			return self._hour_offset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hour_offset is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._hour_offset = INTEGER(value)
			else:
				self._hour_offset = value
		return property(**locals())

	@apply
	def minute_offset():
		def fget( self ):
			return self._minute_offset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,INTEGER):
					self._minute_offset = INTEGER(value)
				else:
					self._minute_offset = value
			else:
				self._minute_offset = value
		return property(**locals())

	@apply
	def sense():
		def fget( self ):
			return self._sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sense is mantatory and can not be set to None')
			if not check_type(value,ahead_or_behind):
				self._sense = ahead_or_behind(value)
			else:
				self._sense = value
		return property(**locals())

	@apply
	def actual_minute_offset():
		def fget( self ):
			attribute_eval = NVL(self.minute_offset,0)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument actual_minute_offset is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((0  <=  self.hour_offset)  and  (self.hour_offset  <  24))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((0  <=  self.actual_minute_offset)  and  (self.actual_minute_offset  <=  59))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ( not (((self.hour_offset  !=  0)  or  (self.actual_minute_offset  !=  0))  and  (self.sense  ==  exact)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY curve_replica #
####################
class curve_replica(curve):
	'''Entity curve_replica definition.

	:param parent_curve
	:type parent_curve:curve

	:param transformation
	:type transformation:cartesian_transformation_operator
	'''
	def __init__( self , inherited0__name , parent_curve,transformation, ):
		curve.__init__(self , inherited0__name , )
		self.parent_curve = parent_curve
		self.transformation = transformation

	@apply
	def parent_curve():
		def fget( self ):
			return self._parent_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._parent_curve = curve(value)
			else:
				self._parent_curve = value
		return property(**locals())

	@apply
	def transformation():
		def fget( self ):
			return self._transformation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transformation is mantatory and can not be set to None')
			if not check_type(value,cartesian_transformation_operator):
				self._transformation = cartesian_transformation_operator(value)
			else:
				self._transformation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.transformation.self.dim  ==  self.parent_curve.self.dim)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = acyclic_curve_replica(self,self.parent_curve)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY swept_face_solid #
####################
class swept_face_solid(solid_model):
	'''Entity swept_face_solid definition.

	:param swept_face
	:type swept_face:face_surface
	'''
	def __init__( self , inherited0__name , swept_face, ):
		solid_model.__init__(self , inherited0__name , )
		self.swept_face = swept_face

	@apply
	def swept_face():
		def fget( self ):
			return self._swept_face
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument swept_face is mantatory and can not be set to None')
			if not check_type(value,face_surface):
				self._swept_face = face_surface(value)
			else:
				self._swept_face = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.PLANE'  ==  TYPEOF(self.swept_face.self.face_geometry))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY extruded_face_solid #
####################
class extruded_face_solid(swept_face_solid):
	'''Entity extruded_face_solid definition.

	:param extruded_direction
	:type extruded_direction:direction

	:param depth
	:type depth:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__swept_face , extruded_direction,depth, ):
		swept_face_solid.__init__(self , inherited0__name , inherited1__swept_face , )
		self.extruded_direction = extruded_direction
		self.depth = depth

	@apply
	def extruded_direction():
		def fget( self ):
			return self._extruded_direction
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extruded_direction is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._extruded_direction = direction(value)
			else:
				self._extruded_direction = value
		return property(**locals())

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._depth = positive_length_measure(value)
			else:
				self._depth = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (dot_product(self.self.swept_face_solid.self.swept_face.self.face_geometry.self.elementary_surface.self.position.self.p[3],self.extruded_direction)  !=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY quasi_uniform_surface #
####################
class quasi_uniform_surface(b_spline_surface):
	'''Entity quasi_uniform_surface definition.
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect ,  ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )

####################
 # ENTITY surface_curve #
####################
class surface_curve(curve):
	'''Entity surface_curve definition.

	:param curve_3d
	:type curve_3d:curve

	:param associated_geometry
	:type associated_geometry:LIST(1,2,'pcurve_or_surface', scope = schema_scope)

	:param master_representation
	:type master_representation:preferred_surface_curve_representation

	:param basis_surface
	:type basis_surface:SET(1,2,'surface', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , curve_3d,associated_geometry,master_representation, ):
		curve.__init__(self , inherited0__name , )
		self.curve_3d = curve_3d
		self.associated_geometry = associated_geometry
		self.master_representation = master_representation

	@apply
	def curve_3d():
		def fget( self ):
			return self._curve_3d
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_3d is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._curve_3d = curve(value)
			else:
				self._curve_3d = value
		return property(**locals())

	@apply
	def associated_geometry():
		def fget( self ):
			return self._associated_geometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument associated_geometry is mantatory and can not be set to None')
			if not check_type(value,LIST(1,2,'pcurve_or_surface', scope = schema_scope)):
				self._associated_geometry = LIST(value)
			else:
				self._associated_geometry = value
		return property(**locals())

	@apply
	def master_representation():
		def fget( self ):
			return self._master_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument master_representation is mantatory and can not be set to None')
			if not check_type(value,preferred_surface_curve_representation):
				self._master_representation = preferred_surface_curve_representation(value)
			else:
				self._master_representation = value
		return property(**locals())

	@apply
	def basis_surface():
		def fget( self ):
			attribute_eval = get_basis_surface(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument basis_surface is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.curve_3d.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(self.associated_geometry[1]))  or  (self.master_representation  !=  pcurve_s1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(self.associated_geometry[2]))  or  (self.master_representation  !=  pcurve_s2))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ( not ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(self.curve_3d)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY surface_style_rendering #
####################
class surface_style_rendering(BaseEntityClass):
	'''Entity surface_style_rendering definition.

	:param rendering_method
	:type rendering_method:shading_surface_method

	:param surface_colour
	:type surface_colour:colour
	'''
	def __init__( self , rendering_method,surface_colour, ):
		self.rendering_method = rendering_method
		self.surface_colour = surface_colour

	@apply
	def rendering_method():
		def fget( self ):
			return self._rendering_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rendering_method is mantatory and can not be set to None')
			if not check_type(value,shading_surface_method):
				self._rendering_method = shading_surface_method(value)
			else:
				self._rendering_method = value
		return property(**locals())

	@apply
	def surface_colour():
		def fget( self ):
			return self._surface_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument surface_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._surface_colour = colour(value)
			else:
				self._surface_colour = value
		return property(**locals())

####################
 # ENTITY action_request_status #
####################
class action_request_status(BaseEntityClass):
	'''Entity action_request_status definition.

	:param status
	:type status:label

	:param assigned_request
	:type assigned_request:versioned_action_request
	'''
	def __init__( self , status,assigned_request, ):
		self.status = status
		self.assigned_request = assigned_request

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument status is mantatory and can not be set to None')
			if not check_type(value,label):
				self._status = label(value)
			else:
				self._status = value
		return property(**locals())

	@apply
	def assigned_request():
		def fget( self ):
			return self._assigned_request
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_request is mantatory and can not be set to None')
			if not check_type(value,versioned_action_request):
				self._assigned_request = versioned_action_request(value)
			else:
				self._assigned_request = value
		return property(**locals())

####################
 # ENTITY fill_area_style #
####################
class fill_area_style(founded_item):
	'''Entity fill_area_style definition.

	:param name
	:type name:label

	:param fill_styles
	:type fill_styles:SET(1,None,'fill_style_select', scope = schema_scope)
	'''
	def __init__( self , name,fill_styles, ):
		founded_item.__init__(self , )
		self.name = name
		self.fill_styles = fill_styles

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def fill_styles():
		def fget( self ):
			return self._fill_styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fill_styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'fill_style_select', scope = schema_scope)):
				self._fill_styles = SET(value)
			else:
				self._fill_styles = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY universal_pair_range #
####################
class universal_pair_range(simple_pair_range):
	'''Entity universal_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:universal_pair

	:param lower_limit_first_rotation
	:type lower_limit_first_rotation:rotational_range_measure

	:param upper_limit_first_rotation
	:type upper_limit_first_rotation:rotational_range_measure

	:param lower_limit_second_rotation
	:type lower_limit_second_rotation:rotational_range_measure

	:param upper_limit_second_rotation
	:type upper_limit_second_rotation:rotational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,lower_limit_first_rotation,upper_limit_first_rotation,lower_limit_second_rotation,upper_limit_second_rotation, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.lower_limit_first_rotation = lower_limit_first_rotation
		self.upper_limit_first_rotation = upper_limit_first_rotation
		self.lower_limit_second_rotation = lower_limit_second_rotation
		self.upper_limit_second_rotation = upper_limit_second_rotation

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,universal_pair):
				self._simple_pair_range_applies_to_pair = universal_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def lower_limit_first_rotation():
		def fget( self ):
			return self._lower_limit_first_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_first_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_first_rotation = rotational_range_measure(value)
			else:
				self._lower_limit_first_rotation = value
		return property(**locals())

	@apply
	def upper_limit_first_rotation():
		def fget( self ):
			return self._upper_limit_first_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_first_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_first_rotation = rotational_range_measure(value)
			else:
				self._upper_limit_first_rotation = value
		return property(**locals())

	@apply
	def lower_limit_second_rotation():
		def fget( self ):
			return self._lower_limit_second_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_second_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_second_rotation = rotational_range_measure(value)
			else:
				self._lower_limit_second_rotation = value
		return property(**locals())

	@apply
	def upper_limit_second_rotation():
		def fget( self ):
			return self._upper_limit_second_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_second_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_second_rotation = rotational_range_measure(value)
			else:
				self._upper_limit_second_rotation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_first_rotation))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_first_rotation))) XOR (self.lower_limit_first_rotation  <  self.upper_limit_first_rotation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_second_rotation))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_second_rotation))) XOR (self.lower_limit_second_rotation  <  self.upper_limit_second_rotation))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY planar_pair_value #
####################
class planar_pair_value(pair_value):
	'''Entity planar_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:planar_pair

	:param actual_rotation
	:type actual_rotation:plane_angle_measure

	:param actual_translation_x
	:type actual_translation_x:length_measure

	:param actual_translation_y
	:type actual_translation_y:length_measure
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_rotation,actual_translation_x,actual_translation_y, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_rotation = actual_rotation
		self.actual_translation_x = actual_translation_x
		self.actual_translation_y = actual_translation_y

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,planar_pair):
				self._pair_value_applies_to_pair = planar_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_rotation():
		def fget( self ):
			return self._actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_rotation is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._actual_rotation = plane_angle_measure(value)
			else:
				self._actual_rotation = value
		return property(**locals())

	@apply
	def actual_translation_x():
		def fget( self ):
			return self._actual_translation_x
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_translation_x is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._actual_translation_x = length_measure(value)
			else:
				self._actual_translation_x = value
		return property(**locals())

	@apply
	def actual_translation_y():
		def fget( self ):
			return self._actual_translation_y
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_translation_y is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._actual_translation_y = length_measure(value)
			else:
				self._actual_translation_y = value
		return property(**locals())

####################
 # ENTITY action_resource_requirement #
####################
class action_resource_requirement(BaseEntityClass):
	'''Entity action_resource_requirement definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param kind
	:type kind:resource_requirement_type

	:param operations
	:type operations:SET(1,None,'characterized_action_definition', scope = schema_scope)
	'''
	def __init__( self , name,description,kind,operations, ):
		self.name = name
		self.description = description
		self.kind = kind
		self.operations = operations

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def kind():
		def fget( self ):
			return self._kind
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument kind is mantatory and can not be set to None')
			if not check_type(value,resource_requirement_type):
				self._kind = resource_requirement_type(value)
			else:
				self._kind = value
		return property(**locals())

	@apply
	def operations():
		def fget( self ):
			return self._operations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operations is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'characterized_action_definition', scope = schema_scope)):
				self._operations = SET(value)
			else:
				self._operations = value
		return property(**locals())

####################
 # ENTITY requirement_for_action_resource #
####################
class requirement_for_action_resource(action_resource_requirement):
	'''Entity requirement_for_action_resource definition.

	:param resources
	:type resources:SET(1,None,'action_resource', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__kind , inherited3__operations , resources, ):
		action_resource_requirement.__init__(self , inherited0__name , inherited1__description , inherited2__kind , inherited3__operations , )
		self.resources = resources

	@apply
	def resources():
		def fget( self ):
			return self._resources
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument resources is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'action_resource', scope = schema_scope)):
				self._resources = SET(value)
			else:
				self._resources = value
		return property(**locals())

####################
 # ENTITY slot_end #
####################
class slot_end(shape_aspect):
	'''Entity slot_end definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.description  ==  ['open','radiused','flat','woodruff'])
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((self.self.description  ==  ['open','radiused']) XOR (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not (self.self.description  ==  ['flat','woodruff'])) XOR (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'flat')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.description  !=  'flat')  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = ((self.self.description  !=  'flat')  or  (SIZEOF(None)  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = ((self.self.description  !=  'woodruff')  or  (SIZEOF(None)  ==  1))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = ((self.self.description  !=  'woodruff')  or  (SIZEOF(None)  ==  1))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  1)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr


####################
 # ENTITY closed_path_profile #
####################
class closed_path_profile(shape_aspect):
	'''Entity closed_path_profile definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY hole_in_panel #
####################
class hole_in_panel(feature_definition):
	'''Entity hole_in_panel definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(get_property_definition_representations(self))  ==  SIZEOF(None))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY transition_feature #
####################
class transition_feature(shape_aspect):
	'''Entity transition_feature definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'PRODUCT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'CHAMFER','AUTOMOTIVE_DESIGN.'  +  'EDGE_ROUND','AUTOMOTIVE_DESIGN.'  +  'FILLET']  *  TYPEOF(self))  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY edge_round #
####################
class edge_round(transition_feature):
	'''Entity edge_round definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		transition_feature.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = ((self.self.description  !=  'constant radius') XOR (SIZEOF(None)  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((self.self.description  !=  'constant radius')  or  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((self.self.description  !=  'constant radius')  or  (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.description  !=  'constant radius')  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'constant radius')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.description  !=  'constant radius')  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  1)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr


####################
 # ENTITY kinematic_frame_background_representation_association #
####################
class kinematic_frame_background_representation_association(representation_relationship_with_transformation):
	'''Entity kinematic_frame_background_representation_association definition.

	:param representation_relationship_with_transformation_transformation_operator
	:type representation_relationship_with_transformation_transformation_operator:kinematic_frame_based_transformation
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , inherited4__transformation_operator , representation_relationship_with_transformation_transformation_operator, ):
		representation_relationship_with_transformation.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , inherited4__transformation_operator , )
		self.representation_relationship_with_transformation_transformation_operator = representation_relationship_with_transformation_transformation_operator

	@apply
	def representation_relationship_with_transformation_transformation_operator():
		def fget( self ):
			return self._representation_relationship_with_transformation_transformation_operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_with_transformation_transformation_operator is mantatory and can not be set to None')
			if not check_type(value,kinematic_frame_based_transformation):
				self._representation_relationship_with_transformation_transformation_operator = kinematic_frame_based_transformation(value)
			else:
				self._representation_relationship_with_transformation_transformation_operator = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.KINEMATIC_LINK_REPRESENTATION'  ==  TYPEOF(self.self.representation_relationship.self.rep_1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AUTOMOTIVE_DESIGN.KINEMATIC_FRAME_BACKGROUND_REPRESENTATION'  ==  TYPEOF(self.self.representation_relationship.self.rep_2))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.representation_relationship_with_transformation.self.transformation_operator.self.kinematic_frame_based_transformation.self.transformator  ==  self.self.representation_relationship.self.rep_1.self.items)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY composite_curve_segment #
####################
class composite_curve_segment(founded_item):
	'''Entity composite_curve_segment definition.

	:param transition
	:type transition:transition_code

	:param same_sense
	:type same_sense:BOOLEAN

	:param parent_curve
	:type parent_curve:curve

	:param using_curves
	:type using_curves:BAG(1,None,'composite_curve', scope = schema_scope)
	'''
	def __init__( self , transition,same_sense,parent_curve, ):
		founded_item.__init__(self , )
		self.transition = transition
		self.same_sense = same_sense
		self.parent_curve = parent_curve

	@apply
	def transition():
		def fget( self ):
			return self._transition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transition is mantatory and can not be set to None')
			if not check_type(value,transition_code):
				self._transition = transition_code(value)
			else:
				self._transition = value
		return property(**locals())

	@apply
	def same_sense():
		def fget( self ):
			return self._same_sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument same_sense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._same_sense = BOOLEAN(value)
			else:
				self._same_sense = value
		return property(**locals())

	@apply
	def parent_curve():
		def fget( self ):
			return self._parent_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._parent_curve = curve(value)
			else:
				self._parent_curve = value
		return property(**locals())

	@apply
	def using_curves():
		def fget( self ):
			return self._using_curves
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument using_curves is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.BOUNDED_CURVE'  ==  TYPEOF(self.parent_curve))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY reparametrised_composite_curve_segment #
####################
class reparametrised_composite_curve_segment(composite_curve_segment):
	'''Entity reparametrised_composite_curve_segment definition.

	:param param_length
	:type param_length:parameter_value
	'''
	def __init__( self , inherited0__transition , inherited1__same_sense , inherited2__parent_curve , param_length, ):
		composite_curve_segment.__init__(self , inherited0__transition , inherited1__same_sense , inherited2__parent_curve , )
		self.param_length = param_length

	@apply
	def param_length():
		def fget( self ):
			return self._param_length
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument param_length is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._param_length = parameter_value(value)
			else:
				self._param_length = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.param_length  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY class #
####################
class class_(group):
	'''Entity class definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY person_and_organization_role #
####################
class person_and_organization_role(BaseEntityClass):
	'''Entity person_and_organization_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY presentation_layer_assignment #
####################
class presentation_layer_assignment(BaseEntityClass):
	'''Entity presentation_layer_assignment definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param assigned_items
	:type assigned_items:SET(1,None,'layered_item', scope = schema_scope)
	'''
	def __init__( self , name,description,assigned_items, ):
		self.name = name
		self.description = description
		self.assigned_items = assigned_items

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def assigned_items():
		def fget( self ):
			return self._assigned_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'layered_item', scope = schema_scope)):
				self._assigned_items = SET(value)
			else:
				self._assigned_items = value
		return property(**locals())

####################
 # ENTITY quasi_uniform_curve #
####################
class quasi_uniform_curve(b_spline_curve):
	'''Entity quasi_uniform_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect ,  ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )

####################
 # ENTITY swept_surface #
####################
class swept_surface(surface):
	'''Entity swept_surface definition.

	:param swept_curve
	:type swept_curve:curve
	'''
	def __init__( self , inherited0__name , swept_curve, ):
		surface.__init__(self , inherited0__name , )
		self.swept_curve = swept_curve

	@apply
	def swept_curve():
		def fget( self ):
			return self._swept_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument swept_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._swept_curve = curve(value)
			else:
				self._swept_curve = value
		return property(**locals())

####################
 # ENTITY concept_feature_relationship #
####################
class concept_feature_relationship(BaseEntityClass):
	'''Entity concept_feature_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_product_concept_feature
	:type relating_product_concept_feature:product_concept_feature

	:param related_product_concept_feature
	:type related_product_concept_feature:product_concept_feature
	'''
	def __init__( self , name,description,relating_product_concept_feature,related_product_concept_feature, ):
		self.name = name
		self.description = description
		self.relating_product_concept_feature = relating_product_concept_feature
		self.related_product_concept_feature = related_product_concept_feature

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_product_concept_feature():
		def fget( self ):
			return self._relating_product_concept_feature
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_product_concept_feature is mantatory and can not be set to None')
			if not check_type(value,product_concept_feature):
				self._relating_product_concept_feature = product_concept_feature(value)
			else:
				self._relating_product_concept_feature = value
		return property(**locals())

	@apply
	def related_product_concept_feature():
		def fget( self ):
			return self._related_product_concept_feature
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_product_concept_feature is mantatory and can not be set to None')
			if not check_type(value,product_concept_feature):
				self._related_product_concept_feature = product_concept_feature(value)
			else:
				self._related_product_concept_feature = value
		return property(**locals())

####################
 # ENTITY concept_feature_relationship_with_condition #
####################
class concept_feature_relationship_with_condition(concept_feature_relationship):
	'''Entity concept_feature_relationship_with_condition definition.

	:param conditional_operator
	:type conditional_operator:concept_feature_operator
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_product_concept_feature , inherited3__related_product_concept_feature , conditional_operator, ):
		concept_feature_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_product_concept_feature , inherited3__related_product_concept_feature , )
		self.conditional_operator = conditional_operator

	@apply
	def conditional_operator():
		def fget( self ):
			return self._conditional_operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument conditional_operator is mantatory and can not be set to None')
			if not check_type(value,concept_feature_operator):
				self._conditional_operator = concept_feature_operator(value)
			else:
				self._conditional_operator = value
		return property(**locals())

####################
 # ENTITY kinematic_link_representation #
####################
class kinematic_link_representation(representation):
	'''Entity kinematic_link_representation definition.

	:param representation_context_of_items
	:type representation_context_of_items:geometric_representation_context

	:param link_frame
	:type link_frame:geometric_representation_context

	:param link_representation_relation
	:type link_representation_relation:kinematic_link_representation_relation
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_context_of_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_context_of_items = representation_context_of_items

	@apply
	def representation_context_of_items():
		def fget( self ):
			return self._representation_context_of_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_context_of_items is mantatory and can not be set to None')
			if not check_type(value,geometric_representation_context):
				self._representation_context_of_items = geometric_representation_context(value)
			else:
				self._representation_context_of_items = value
		return property(**locals())

	@apply
	def link_frame():
		def fget( self ):
			attribute_eval = self.self.representation.self.context_of_items
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument link_frame is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def link_representation_relation():
		def fget( self ):
			return self._link_representation_relation
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument link_representation_relation is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY presented_item_representation #
####################
class presented_item_representation(BaseEntityClass):
	'''Entity presented_item_representation definition.

	:param presentation
	:type presentation:presentation_representation_select

	:param item
	:type item:presented_item
	'''
	def __init__( self , presentation,item, ):
		self.presentation = presentation
		self.item = item

	@apply
	def presentation():
		def fget( self ):
			return self._presentation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument presentation is mantatory and can not be set to None')
			if not check_type(value,presentation_representation_select):
				self._presentation = presentation_representation_select(value)
			else:
				self._presentation = value
		return property(**locals())

	@apply
	def item():
		def fget( self ):
			return self._item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item is mantatory and can not be set to None')
			if not check_type(value,presented_item):
				self._item = presented_item(value)
			else:
				self._item = value
		return property(**locals())

####################
 # ENTITY straightness_tolerance #
####################
class straightness_tolerance(geometric_tolerance):
	'''Entity straightness_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ( not (('AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY angular_location #
####################
class angular_location(dimensional_location):
	'''Entity angular_location definition.

	:param angle_selection
	:type angle_selection:angle_relator
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , angle_selection, ):
		dimensional_location.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
		self.angle_selection = angle_selection

	@apply
	def angle_selection():
		def fget( self ):
			return self._angle_selection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle_selection is mantatory and can not be set to None')
			if not check_type(value,angle_relator):
				self._angle_selection = angle_relator(value)
			else:
				self._angle_selection = value
		return property(**locals())

####################
 # ENTITY applied_action_request_assignment #
####################
class applied_action_request_assignment(action_request_assignment):
	'''Entity applied_action_request_assignment definition.

	:param items
	:type items:SET(1,None,'action_request_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action_request , items, ):
		action_request_assignment.__init__(self , inherited0__assigned_action_request , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'action_request_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY event_occurrence #
####################
class event_occurrence(BaseEntityClass):
	'''Entity event_occurrence definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY relative_event_occurrence #
####################
class relative_event_occurrence(event_occurrence):
	'''Entity relative_event_occurrence definition.

	:param base_event
	:type base_event:event_occurrence

	:param offset
	:type offset:time_measure_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , base_event,offset, ):
		event_occurrence.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
		self.base_event = base_event
		self.offset = offset

	@apply
	def base_event():
		def fget( self ):
			return self._base_event
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base_event is mantatory and can not be set to None')
			if not check_type(value,event_occurrence):
				self._base_event = event_occurrence(value)
			else:
				self._base_event = value
		return property(**locals())

	@apply
	def offset():
		def fget( self ):
			return self._offset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offset is mantatory and can not be set to None')
			if not check_type(value,time_measure_with_unit):
				self._offset = time_measure_with_unit(value)
			else:
				self._offset = value
		return property(**locals())

####################
 # ENTITY spherical_pair_range #
####################
class spherical_pair_range(simple_pair_range):
	'''Entity spherical_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:spherical_pair

	:param lower_limit_yaw
	:type lower_limit_yaw:rotational_range_measure

	:param upper_limit_yaw
	:type upper_limit_yaw:rotational_range_measure

	:param lower_limit_pitch
	:type lower_limit_pitch:rotational_range_measure

	:param upper_limit_pitch
	:type upper_limit_pitch:rotational_range_measure

	:param lower_limit_roll
	:type lower_limit_roll:rotational_range_measure

	:param upper_limit_roll
	:type upper_limit_roll:rotational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,lower_limit_yaw,upper_limit_yaw,lower_limit_pitch,upper_limit_pitch,lower_limit_roll,upper_limit_roll, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.lower_limit_yaw = lower_limit_yaw
		self.upper_limit_yaw = upper_limit_yaw
		self.lower_limit_pitch = lower_limit_pitch
		self.upper_limit_pitch = upper_limit_pitch
		self.lower_limit_roll = lower_limit_roll
		self.upper_limit_roll = upper_limit_roll

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,spherical_pair):
				self._simple_pair_range_applies_to_pair = spherical_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def lower_limit_yaw():
		def fget( self ):
			return self._lower_limit_yaw
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_yaw is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_yaw = rotational_range_measure(value)
			else:
				self._lower_limit_yaw = value
		return property(**locals())

	@apply
	def upper_limit_yaw():
		def fget( self ):
			return self._upper_limit_yaw
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_yaw is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_yaw = rotational_range_measure(value)
			else:
				self._upper_limit_yaw = value
		return property(**locals())

	@apply
	def lower_limit_pitch():
		def fget( self ):
			return self._lower_limit_pitch
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_pitch is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_pitch = rotational_range_measure(value)
			else:
				self._lower_limit_pitch = value
		return property(**locals())

	@apply
	def upper_limit_pitch():
		def fget( self ):
			return self._upper_limit_pitch
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_pitch is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_pitch = rotational_range_measure(value)
			else:
				self._upper_limit_pitch = value
		return property(**locals())

	@apply
	def lower_limit_roll():
		def fget( self ):
			return self._lower_limit_roll
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_roll is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_roll = rotational_range_measure(value)
			else:
				self._lower_limit_roll = value
		return property(**locals())

	@apply
	def upper_limit_roll():
		def fget( self ):
			return self._upper_limit_roll
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_roll is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_roll = rotational_range_measure(value)
			else:
				self._upper_limit_roll = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_yaw))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_yaw))) XOR (self.lower_limit_yaw  <  self.upper_limit_yaw))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_pitch))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_pitch))) XOR (self.lower_limit_pitch  <  self.upper_limit_pitch))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_roll))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_roll))) XOR (self.lower_limit_roll  <  self.upper_limit_roll))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY applied_group_assignment #
####################
class applied_group_assignment(group_assignment):
	'''Entity applied_group_assignment definition.

	:param items
	:type items:SET(1,None,'group_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_group , items, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'group_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (self.self.role.self.name  ==  'exclusiveness'))  or  item_correlation(self.self.items,['ACTION']))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not (self.self.role.self.name  ==  'simultaneity'))  or  item_correlation(self.self.items,['ACTION']))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not (self.self.role.self.name  ==  'specification category member'))  or  item_correlation(self.self.items,['PRODUCT_CONCEPT_FEATURE']))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not (self.self.role.self.name  ==  'group membership'))  or  item_correlation(self.self.items,['GEOMETRIC_REPRESENTATION_ITEM','SHAPE_ASPECT']))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((( not (self.self.role.self.name  ==  'group membership'))  or  (SIZEOF(self.self.items)  ==  SIZEOF(None)))  or  (SIZEOF(self.self.items)  ==  SIZEOF(None)))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY configuration_item #
####################
class configuration_item(BaseEntityClass):
	'''Entity configuration_item definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param item_concept
	:type item_concept:product_concept

	:param purpose
	:type purpose:label
	'''
	def __init__( self , id,name,description,item_concept,purpose, ):
		self.id = id
		self.name = name
		self.description = description
		self.item_concept = item_concept
		self.purpose = purpose

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def item_concept():
		def fget( self ):
			return self._item_concept
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_concept is mantatory and can not be set to None')
			if not check_type(value,product_concept):
				self._item_concept = product_concept(value)
			else:
				self._item_concept = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._purpose = label(value)
				else:
					self._purpose = value
			else:
				self._purpose = value
		return property(**locals())

####################
 # ENTITY configurable_item #
####################
class configurable_item(configuration_item):
	'''Entity configurable_item definition.

	:param item_concept_feature
	:type item_concept_feature:SET(1,None,'product_concept_feature_association', scope = schema_scope)
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , item_concept_feature, ):
		configuration_item.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , )
		self.item_concept_feature = item_concept_feature

	@apply
	def item_concept_feature():
		def fget( self ):
			return self._item_concept_feature
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_concept_feature is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'product_concept_feature_association', scope = schema_scope)):
				self._item_concept_feature = SET(value)
			else:
				self._item_concept_feature = value
		return property(**locals())

####################
 # ENTITY global_uncertainty_assigned_context #
####################
class global_uncertainty_assigned_context(representation_context):
	'''Entity global_uncertainty_assigned_context definition.

	:param uncertainty
	:type uncertainty:SET(1,None,'uncertainty_measure_with_unit', scope = schema_scope)
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type , uncertainty, ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )
		self.uncertainty = uncertainty

	@apply
	def uncertainty():
		def fget( self ):
			return self._uncertainty
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uncertainty is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'uncertainty_measure_with_unit', scope = schema_scope)):
				self._uncertainty = SET(value)
			else:
				self._uncertainty = value
		return property(**locals())

####################
 # ENTITY pre_defined_surface_condition_symbol #
####################
class pre_defined_surface_condition_symbol(pre_defined_symbol):
	'''Entity pre_defined_surface_condition_symbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_symbol.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['000','010','020','030','040','050','060','070','001','011','021','031','041','051','061','071','100','110','120','130','140','150','160','170','101','111','121','131','141','151','161','171','200','210','220','230','240','250','260','270','201','211','221','231','241','251','261','271'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ngon_closed_profile #
####################
class ngon_closed_profile(shape_aspect):
	'''Entity ngon_closed_profile definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr


####################
 # ENTITY runout_zone_orientation #
####################
class runout_zone_orientation(BaseEntityClass):
	'''Entity runout_zone_orientation definition.

	:param angle
	:type angle:measure_with_unit
	'''
	def __init__( self , angle, ):
		self.angle = angle

	@apply
	def angle():
		def fget( self ):
			return self._angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._angle = measure_with_unit(value)
			else:
				self._angle = value
		return property(**locals())

####################
 # ENTITY runout_zone_orientation_reference_direction #
####################
class runout_zone_orientation_reference_direction(runout_zone_orientation):
	'''Entity runout_zone_orientation_reference_direction definition.

	:param orientation_defining_relationship
	:type orientation_defining_relationship:shape_aspect_relationship
	'''
	def __init__( self , inherited0__angle , orientation_defining_relationship, ):
		runout_zone_orientation.__init__(self , inherited0__angle , )
		self.orientation_defining_relationship = orientation_defining_relationship

	@apply
	def orientation_defining_relationship():
		def fget( self ):
			return self._orientation_defining_relationship
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation_defining_relationship is mantatory and can not be set to None')
			if not check_type(value,shape_aspect_relationship):
				self._orientation_defining_relationship = shape_aspect_relationship(value)
			else:
				self._orientation_defining_relationship = value
		return property(**locals())

####################
 # ENTITY text_style_with_box_characteristics #
####################
class text_style_with_box_characteristics(text_style):
	'''Entity text_style_with_box_characteristics definition.

	:param characteristics
	:type characteristics:SET(1,4,'box_characteristic_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__character_appearance , characteristics, ):
		text_style.__init__(self , inherited0__name , inherited1__character_appearance , )
		self.characteristics = characteristics

	@apply
	def characteristics():
		def fget( self ):
			return self._characteristics
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument characteristics is mantatory and can not be set to None')
			if not check_type(value,SET(1,4,'box_characteristic_select', scope = schema_scope)):
				self._characteristics = SET(value)
			else:
				self._characteristics = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_resource_type #
####################
class action_resource_type(BaseEntityClass):
	'''Entity action_resource_type definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY chamfer_offset #
####################
class chamfer_offset(shape_aspect):
	'''Entity chamfer_offset definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (self.self.description  ==  ['first offset','second offset'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.description  !=  'first offset')  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'second offset')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  >=  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = ((self.self.description  !=  'first offset')  or  (SIZEOF(None)  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = ((self.self.description  !=  'second offset')  or  (SIZEOF(None)  ==  1))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr


####################
 # ENTITY connected_face_sub_set #
####################
class connected_face_sub_set(connected_face_set):
	'''Entity connected_face_sub_set definition.

	:param parent_face_set
	:type parent_face_set:connected_face_set
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces , parent_face_set, ):
		connected_face_set.__init__(self , inherited0__name , inherited1__cfs_faces , )
		self.parent_face_set = parent_face_set

	@apply
	def parent_face_set():
		def fget( self ):
			return self._parent_face_set
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_face_set is mantatory and can not be set to None')
			if not check_type(value,connected_face_set):
				self._parent_face_set = connected_face_set(value)
			else:
				self._parent_face_set = value
		return property(**locals())

####################
 # ENTITY organization_relationship #
####################
class organization_relationship(BaseEntityClass):
	'''Entity organization_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_organization
	:type relating_organization:organization

	:param related_organization
	:type related_organization:organization
	'''
	def __init__( self , name,description,relating_organization,related_organization, ):
		self.name = name
		self.description = description
		self.relating_organization = relating_organization
		self.related_organization = related_organization

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_organization():
		def fget( self ):
			return self._relating_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_organization is mantatory and can not be set to None')
			if not check_type(value,organization):
				self._relating_organization = organization(value)
			else:
				self._relating_organization = value
		return property(**locals())

	@apply
	def related_organization():
		def fget( self ):
			return self._related_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_organization is mantatory and can not be set to None')
			if not check_type(value,organization):
				self._related_organization = organization(value)
			else:
				self._related_organization = value
		return property(**locals())

####################
 # ENTITY substring_expression #
####################
class substring_expression(string_expression,multiple_arity_generic_expression):
	'''Entity substring_expression definition.

	:param operand
	:type operand:generic_expression

	:param index1
	:type index1:generic_expression

	:param index2
	:type index2:generic_expression
	'''
	def __init__( self , inherited0__operands ,  ):
		string_expression.__init__(self , )
		multiple_arity_generic_expression.__init__(self , inherited0__operands , )

	@apply
	def operand():
		def fget( self ):
			attribute_eval = self.self.multiple_arity_generic_expression.self.operands[1]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument operand is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def index1():
		def fget( self ):
			attribute_eval = self.self.multiple_arity_generic_expression.self.operands[2]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument index1 is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def index2():
		def fget( self ):
			attribute_eval = self.self.multiple_arity_generic_expression.self.operands[3]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument index2 is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.STRING_EXPRESSION'  ==  TYPEOF(self.operand))  and  ('AUTOMOTIVE_DESIGN.NUMERIC_EXPRESSION'  ==  TYPEOF(self.index1)))  and  ('AUTOMOTIVE_DESIGN.NUMERIC_EXPRESSION'  ==  TYPEOF(self.index2)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.multiple_arity_generic_expression.self.operands)  ==  3)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = is_int_expr(self.index1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = is_int_expr(self.index2)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY light_source_ambient #
####################
class light_source_ambient(light_source):
	'''Entity light_source_ambient definition.
	'''
	def __init__( self , inherited0__name , inherited1__light_colour ,  ):
		light_source.__init__(self , inherited0__name , inherited1__light_colour , )

####################
 # ENTITY named_unit_variable #
####################
class named_unit_variable(named_unit,variable_semantics):
	'''Entity named_unit_variable definition.

	:param associated_variable_environment
	:type associated_variable_environment:environment
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
		variable_semantics.__init__(self , )

	@apply
	def associated_variable_environment():
		def fget( self ):
			return self._associated_variable_environment
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument associated_variable_environment is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY parabola #
####################
class parabola(conic):
	'''Entity parabola definition.

	:param focal_dist
	:type focal_dist:length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , focal_dist, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self.focal_dist = focal_dist

	@apply
	def focal_dist():
		def fget( self ):
			return self._focal_dist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument focal_dist is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._focal_dist = length_measure(value)
			else:
				self._focal_dist = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.focal_dist  !=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rectangular_composite_surface #
####################
class rectangular_composite_surface(bounded_surface):
	'''Entity rectangular_composite_surface definition.

	:param segments
	:type segments:LIST(1,None,LIST(1,None,'surface_patch', scope = schema_scope))

	:param n_u
	:type n_u:INTEGER

	:param n_v
	:type n_v:INTEGER
	'''
	def __init__( self , inherited0__name , segments, ):
		bounded_surface.__init__(self , inherited0__name , )
		self.segments = segments

	@apply
	def segments():
		def fget( self ):
			return self._segments
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument segments is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,LIST(1,None,'surface_patch', scope = schema_scope))):
				self._segments = LIST(value)
			else:
				self._segments = value
		return property(**locals())

	@apply
	def n_u():
		def fget( self ):
			attribute_eval = SIZEOF(self.segments)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument n_u is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def n_v():
		def fget( self ):
			attribute_eval = SIZEOF(self.segments[1])
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument n_v is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = constraints_rectangular_composite_surface(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY externally_defined_text_font #
####################
class externally_defined_text_font(externally_defined_item):
	'''Entity externally_defined_text_font definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )

####################
 # ENTITY face #
####################
class face(topological_representation_item):
	'''Entity face definition.

	:param bounds
	:type bounds:SET(1,None,'face_bound', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , bounds, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.bounds = bounds

	@apply
	def bounds():
		def fget( self ):
			return self._bounds
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bounds is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'face_bound', scope = schema_scope)):
				self._bounds = SET(value)
			else:
				self._bounds = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not mixed_loop_type_set(list_to_set(list_face_loops(self))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY subface #
####################
class subface(face):
	'''Entity subface definition.

	:param parent_face
	:type parent_face:face
	'''
	def __init__( self , inherited0__name , inherited1__bounds , parent_face, ):
		face.__init__(self , inherited0__name , inherited1__bounds , )
		self.parent_face = parent_face

	@apply
	def parent_face():
		def fget( self ):
			return self._parent_face
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_face is mantatory and can not be set to None')
			if not check_type(value,face):
				self._parent_face = face(value)
			else:
				self._parent_face = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not mixed_loop_type_set(list_to_set(list_face_loops(self))  +  list_to_set(list_face_loops(self.parent_face))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY flatness_tolerance #
####################
class flatness_tolerance(geometric_tolerance):
	'''Entity flatness_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ( not (('AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY pre_defined_text_font #
####################
class pre_defined_text_font(pre_defined_item):
	'''Entity pre_defined_text_font definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )

####################
 # ENTITY draughting_pre_defined_text_font #
####################
class draughting_pre_defined_text_font(pre_defined_text_font):
	'''Entity draughting_pre_defined_text_font definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_text_font.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['ISO 3098'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY externally_defined_symbol #
####################
class externally_defined_symbol(externally_defined_item):
	'''Entity externally_defined_symbol definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )

####################
 # ENTITY planar_curve_pair #
####################
class planar_curve_pair(kinematic_pair):
	'''Entity planar_curve_pair definition.

	:param curve_1
	:type curve_1:curve

	:param curve_2
	:type curve_2:curve

	:param orientation
	:type orientation:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , curve_1,curve_2,orientation, ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )
		self.curve_1 = curve_1
		self.curve_2 = curve_2
		self.orientation = orientation

	@apply
	def curve_1():
		def fget( self ):
			return self._curve_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_1 is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._curve_1 = curve(value)
			else:
				self._curve_1 = value
		return property(**locals())

	@apply
	def curve_2():
		def fget( self ):
			return self._curve_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_2 is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._curve_2 = curve(value)
			else:
				self._curve_2 = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = frame_associated_to_background(self.self.kinematic_pair.self.pair_placement_in_first_link_context,self.curve_1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = frame_associated_to_background(self.self.kinematic_pair.self.pair_placement_in_second_link_context,self.curve_2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY amount_of_substance_unit #
####################
class amount_of_substance_unit(named_unit):
	'''Entity amount_of_substance_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  1))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY one_direction_repeat_factor #
####################
class one_direction_repeat_factor(geometric_representation_item):
	'''Entity one_direction_repeat_factor definition.

	:param repeat_factor
	:type repeat_factor:vector
	'''
	def __init__( self , inherited0__name , repeat_factor, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.repeat_factor = repeat_factor

	@apply
	def repeat_factor():
		def fget( self ):
			return self._repeat_factor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument repeat_factor is mantatory and can not be set to None')
			if not check_type(value,vector):
				self._repeat_factor = vector(value)
			else:
				self._repeat_factor = value
		return property(**locals())

####################
 # ENTITY action_method #
####################
class action_method(BaseEntityClass):
	'''Entity action_method definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param consequence
	:type consequence:text

	:param purpose
	:type purpose:text
	'''
	def __init__( self , name,description,consequence,purpose, ):
		self.name = name
		self.description = description
		self.consequence = consequence
		self.purpose = purpose

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def consequence():
		def fget( self ):
			return self._consequence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument consequence is mantatory and can not be set to None')
			if not check_type(value,text):
				self._consequence = text(value)
			else:
				self._consequence = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument purpose is mantatory and can not be set to None')
			if not check_type(value,text):
				self._purpose = text(value)
			else:
				self._purpose = value
		return property(**locals())

####################
 # ENTITY process_operation #
####################
class process_operation(action_method):
	'''Entity process_operation definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__consequence , inherited3__purpose ,  ):
		action_method.__init__(self , inherited0__name , inherited1__description , inherited2__consequence , inherited3__purpose , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY unconstrained_pair #
####################
class unconstrained_pair(kinematic_pair):
	'''Entity unconstrained_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint ,  ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )

####################
 # ENTITY lot_effectivity #
####################
class lot_effectivity(effectivity):
	'''Entity lot_effectivity definition.

	:param effectivity_lot_id
	:type effectivity_lot_id:identifier

	:param effectivity_lot_size
	:type effectivity_lot_size:measure_with_unit
	'''
	def __init__( self , inherited0__id , effectivity_lot_id,effectivity_lot_size, ):
		effectivity.__init__(self , inherited0__id , )
		self.effectivity_lot_id = effectivity_lot_id
		self.effectivity_lot_size = effectivity_lot_size

	@apply
	def effectivity_lot_id():
		def fget( self ):
			return self._effectivity_lot_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument effectivity_lot_id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._effectivity_lot_id = identifier(value)
			else:
				self._effectivity_lot_id = value
		return property(**locals())

	@apply
	def effectivity_lot_size():
		def fget( self ):
			return self._effectivity_lot_size
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument effectivity_lot_size is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._effectivity_lot_size = measure_with_unit(value)
			else:
				self._effectivity_lot_size = value
		return property(**locals())

####################
 # ENTITY surface_of_linear_extrusion #
####################
class surface_of_linear_extrusion(swept_surface):
	'''Entity surface_of_linear_extrusion definition.

	:param extrusion_axis
	:type extrusion_axis:vector
	'''
	def __init__( self , inherited0__name , inherited1__swept_curve , extrusion_axis, ):
		swept_surface.__init__(self , inherited0__name , inherited1__swept_curve , )
		self.extrusion_axis = extrusion_axis

	@apply
	def extrusion_axis():
		def fget( self ):
			return self._extrusion_axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extrusion_axis is mantatory and can not be set to None')
			if not check_type(value,vector):
				self._extrusion_axis = vector(value)
			else:
				self._extrusion_axis = value
		return property(**locals())

####################
 # ENTITY environment #
####################
class environment(BaseEntityClass):
	'''Entity environment definition.

	:param syntactic_representation
	:type syntactic_representation:generic_variable

	:param semantics
	:type semantics:variable_semantics
	'''
	def __init__( self , syntactic_representation,semantics, ):
		self.syntactic_representation = syntactic_representation
		self.semantics = semantics

	@apply
	def syntactic_representation():
		def fget( self ):
			return self._syntactic_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument syntactic_representation is mantatory and can not be set to None')
			if not check_type(value,generic_variable):
				self._syntactic_representation = generic_variable(value)
			else:
				self._syntactic_representation = value
		return property(**locals())

	@apply
	def semantics():
		def fget( self ):
			return self._semantics
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semantics is mantatory and can not be set to None')
			if not check_type(value,variable_semantics):
				self._semantics = variable_semantics(value)
			else:
				self._semantics = value
		return property(**locals())

####################
 # ENTITY geometric_tolerance_relationship #
####################
class geometric_tolerance_relationship(BaseEntityClass):
	'''Entity geometric_tolerance_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_geometric_tolerance
	:type relating_geometric_tolerance:geometric_tolerance

	:param related_geometric_tolerance
	:type related_geometric_tolerance:geometric_tolerance
	'''
	def __init__( self , name,description,relating_geometric_tolerance,related_geometric_tolerance, ):
		self.name = name
		self.description = description
		self.relating_geometric_tolerance = relating_geometric_tolerance
		self.related_geometric_tolerance = related_geometric_tolerance

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_geometric_tolerance():
		def fget( self ):
			return self._relating_geometric_tolerance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_geometric_tolerance is mantatory and can not be set to None')
			if not check_type(value,geometric_tolerance):
				self._relating_geometric_tolerance = geometric_tolerance(value)
			else:
				self._relating_geometric_tolerance = value
		return property(**locals())

	@apply
	def related_geometric_tolerance():
		def fget( self ):
			return self._related_geometric_tolerance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_geometric_tolerance is mantatory and can not be set to None')
			if not check_type(value,geometric_tolerance):
				self._related_geometric_tolerance = geometric_tolerance(value)
			else:
				self._related_geometric_tolerance = value
		return property(**locals())

####################
 # ENTITY shape_defining_relationship #
####################
class shape_defining_relationship(shape_aspect_relationship):
	'''Entity shape_defining_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		shape_aspect_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ((self.self.shape_aspect_relationship.self.description  !=  'profile usage')  or  (SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'RECTANGULAR_CLOSED_PROFILE','AUTOMOTIVE_DESIGN.'  +  'CIRCULAR_CLOSED_PROFILE','AUTOMOTIVE_DESIGN.'  +  'NGON_CLOSED_PROFILE','AUTOMOTIVE_DESIGN.'  +  'CLOSED_PATH_PROFILE','AUTOMOTIVE_DESIGN.'  +  'OPEN_PATH_PROFILE','AUTOMOTIVE_DESIGN.'  +  'PARTIAL_CIRCULAR_PROFILE','AUTOMOTIVE_DESIGN.'  +  'ROUNDED_U_PROFILE','AUTOMOTIVE_DESIGN.'  +  'SQUARE_U_PROFILE','AUTOMOTIVE_DESIGN.'  +  'TEE_PROFILE','AUTOMOTIVE_DESIGN.'  +  'VEE_PROFILE']  *  TYPEOF(self.self.shape_aspect_relationship.self.relating_shape_aspect))  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((self.self.shape_aspect_relationship.self.description  !=  'path feature component usage')  or  (('AUTOMOTIVE_DESIGN.'  +  'PATH_FEATURE_COMPONENT')  ==  TYPEOF(self.self.shape_aspect_relationship.self.relating_shape_aspect)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY contract_assignment #
####################
class contract_assignment(BaseEntityClass):
	'''Entity contract_assignment definition.

	:param assigned_contract
	:type assigned_contract:contract

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_contract, ):
		self.assigned_contract = assigned_contract

	@apply
	def assigned_contract():
		def fget( self ):
			return self._assigned_contract
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_contract is mantatory and can not be set to None')
			if not check_type(value,contract):
				self._assigned_contract = contract(value)
			else:
				self._assigned_contract = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_contract_assignment #
####################
class applied_contract_assignment(contract_assignment):
	'''Entity applied_contract_assignment definition.

	:param items
	:type items:SET(1,None,'contract_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_contract , items, ):
		contract_assignment.__init__(self , inherited0__assigned_contract , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'contract_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY shell_based_surface_model #
####################
class shell_based_surface_model(geometric_representation_item):
	'''Entity shell_based_surface_model definition.

	:param sbsm_boundary
	:type sbsm_boundary:SET(1,None,'shell', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , sbsm_boundary, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.sbsm_boundary = sbsm_boundary

	@apply
	def sbsm_boundary():
		def fget( self ):
			return self._sbsm_boundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sbsm_boundary is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'shell', scope = schema_scope)):
				self._sbsm_boundary = SET(value)
			else:
				self._sbsm_boundary = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = constraints_geometry_shell_based_surface_model(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY uniform_curve #
####################
class uniform_curve(b_spline_curve):
	'''Entity uniform_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect ,  ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )

####################
 # ENTITY bezier_curve #
####################
class bezier_curve(b_spline_curve):
	'''Entity bezier_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect ,  ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )

####################
 # ENTITY loop #
####################
class loop(topological_representation_item):
	'''Entity loop definition.
	'''
	def __init__( self , inherited0__name ,  ):
		topological_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY edge_loop #
####################
class edge_loop(loop,path):
	'''Entity edge_loop definition.

	:param ne
	:type ne:INTEGER
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__edge_list ,  ):
		loop.__init__(self , inherited0__name , )
		path.__init__(self , inherited1__name , inherited2__edge_list , )

	@apply
	def ne():
		def fget( self ):
			attribute_eval = SIZEOF(self.self.path.self.edge_list)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ne is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.path.self.edge_list[1].self.edge_start  ==  self.self.path.self.edge_list[self.ne].self.edge_end)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY kinematic_analysis_consistency #
####################
class kinematic_analysis_consistency(BaseEntityClass):
	'''Entity kinematic_analysis_consistency definition.

	:param control
	:type control:kinematic_control

	:param result
	:type result:kinematic_analysis_result
	'''
	def __init__( self , control,result, ):
		self.control = control
		self.result = result

	@apply
	def control():
		def fget( self ):
			return self._control
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument control is mantatory and can not be set to None')
			if not check_type(value,kinematic_control):
				self._control = kinematic_control(value)
			else:
				self._control = value
		return property(**locals())

	@apply
	def result():
		def fget( self ):
			return self._result
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument result is mantatory and can not be set to None')
			if not check_type(value,kinematic_analysis_result):
				self._result = kinematic_analysis_result(value)
			else:
				self._result = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.control.self.controlled_mechanism  ==  self.result.self.analysed_mechanism)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rack_and_pinion_pair #
####################
class rack_and_pinion_pair(kinematic_pair):
	'''Entity rack_and_pinion_pair definition.

	:param pinion_radius
	:type pinion_radius:length_measure
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , pinion_radius, ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )
		self.pinion_radius = pinion_radius

	@apply
	def pinion_radius():
		def fget( self ):
			return self._pinion_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pinion_radius is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._pinion_radius = length_measure(value)
			else:
				self._pinion_radius = value
		return property(**locals())

####################
 # ENTITY date #
####################
class date(BaseEntityClass):
	'''Entity date definition.

	:param year_component
	:type year_component:year_number
	'''
	def __init__( self , year_component, ):
		self.year_component = year_component

	@apply
	def year_component():
		def fget( self ):
			return self._year_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument year_component is mantatory and can not be set to None')
			if not check_type(value,year_number):
				self._year_component = year_number(value)
			else:
				self._year_component = value
		return property(**locals())

####################
 # ENTITY calendar_date #
####################
class calendar_date(date):
	'''Entity calendar_date definition.

	:param day_component
	:type day_component:day_in_month_number

	:param month_component
	:type month_component:month_in_year_number
	'''
	def __init__( self , inherited0__year_component , day_component,month_component, ):
		date.__init__(self , inherited0__year_component , )
		self.day_component = day_component
		self.month_component = month_component

	@apply
	def day_component():
		def fget( self ):
			return self._day_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument day_component is mantatory and can not be set to None')
			if not check_type(value,day_in_month_number):
				self._day_component = day_in_month_number(value)
			else:
				self._day_component = value
		return property(**locals())

	@apply
	def month_component():
		def fget( self ):
			return self._month_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument month_component is mantatory and can not be set to None')
			if not check_type(value,month_in_year_number):
				self._month_component = month_in_year_number(value)
			else:
				self._month_component = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = valid_calendar_date(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY concat_expression #
####################
class concat_expression(string_expression,multiple_arity_generic_expression):
	'''Entity concat_expression definition.

	:param multiple_arity_generic_expression_operands
	:type multiple_arity_generic_expression_operands:LIST(2,None,'string_expression', scope = schema_scope)
	'''
	def __init__( self , inherited0__operands , multiple_arity_generic_expression_operands, ):
		string_expression.__init__(self , )
		multiple_arity_generic_expression.__init__(self , inherited0__operands , )
		self.multiple_arity_generic_expression_operands = multiple_arity_generic_expression_operands

	@apply
	def multiple_arity_generic_expression_operands():
		def fget( self ):
			return self._multiple_arity_generic_expression_operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument multiple_arity_generic_expression_operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'string_expression', scope = schema_scope)):
				self._multiple_arity_generic_expression_operands = LIST(value)
			else:
				self._multiple_arity_generic_expression_operands = value
		return property(**locals())

####################
 # ENTITY dimension_curve_terminator #
####################
class dimension_curve_terminator(terminator_symbol):
	'''Entity dimension_curve_terminator definition.

	:param role
	:type role:dimension_extent_usage
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , inherited4__annotated_curve , role, ):
		terminator_symbol.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , inherited4__annotated_curve , )
		self.role = role

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,dimension_extent_usage):
				self._role = dimension_extent_usage(value)
			else:
				self._role = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.DIMENSION_CURVE'  ==  TYPEOF(self.self.terminator_symbol.self.annotated_curve))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY externally_defined_curve_font #
####################
class externally_defined_curve_font(externally_defined_item):
	'''Entity externally_defined_curve_font definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )

####################
 # ENTITY toroidal_surface #
####################
class toroidal_surface(elementary_surface):
	'''Entity toroidal_surface definition.

	:param major_radius
	:type major_radius:positive_length_measure

	:param minor_radius
	:type minor_radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , major_radius,minor_radius, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self.major_radius = major_radius
		self.minor_radius = minor_radius

	@apply
	def major_radius():
		def fget( self ):
			return self._major_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument major_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._major_radius = positive_length_measure(value)
			else:
				self._major_radius = value
		return property(**locals())

	@apply
	def minor_radius():
		def fget( self ):
			return self._minor_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument minor_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._minor_radius = positive_length_measure(value)
			else:
				self._minor_radius = value
		return property(**locals())

####################
 # ENTITY promissory_usage_occurrence #
####################
class promissory_usage_occurrence(assembly_component_usage):
	'''Entity promissory_usage_occurrence definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator ,  ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )

####################
 # ENTITY kinematic_frame_background_representation #
####################
class kinematic_frame_background_representation(representation):
	'''Entity kinematic_frame_background_representation definition.

	:param representation_items
	:type representation_items:SET(1,None,'kinematic_frame_background', scope = schema_scope)

	:param representation_context_of_items
	:type representation_context_of_items:geometric_representation_context
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_items,representation_context_of_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_items = representation_items
		self.representation_context_of_items = representation_context_of_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'kinematic_frame_background', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())

	@apply
	def representation_context_of_items():
		def fget( self ):
			return self._representation_context_of_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_context_of_items is mantatory and can not be set to None')
			if not check_type(value,geometric_representation_context):
				self._representation_context_of_items = geometric_representation_context(value)
			else:
				self._representation_context_of_items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.representation.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_concept_feature #
####################
class product_concept_feature(BaseEntityClass):
	'''Entity product_concept_feature definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY package_product_concept_feature #
####################
class package_product_concept_feature(product_concept_feature):
	'''Entity package_product_concept_feature definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description ,  ):
		product_concept_feature.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
	def wr1(self):
		eval_wr1_wr = ( not (('AUTOMOTIVE_DESIGN.'  +  'CONDITIONAL_CONCEPT_FEATURE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY approval_assignment #
####################
class approval_assignment(BaseEntityClass):
	'''Entity approval_assignment definition.

	:param assigned_approval
	:type assigned_approval:approval

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_approval, ):
		self.assigned_approval = assigned_approval

	@apply
	def assigned_approval():
		def fget( self ):
			return self._assigned_approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_approval is mantatory and can not be set to None')
			if not check_type(value,approval):
				self._assigned_approval = approval(value)
			else:
				self._assigned_approval = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rotation_about_direction #
####################
class rotation_about_direction(BaseEntityClass):
	'''Entity rotation_about_direction definition.

	:param direction_of_axis
	:type direction_of_axis:direction

	:param rotation_angle
	:type rotation_angle:plane_angle_measure
	'''
	def __init__( self , direction_of_axis,rotation_angle, ):
		self.direction_of_axis = direction_of_axis
		self.rotation_angle = rotation_angle

	@apply
	def direction_of_axis():
		def fget( self ):
			return self._direction_of_axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument direction_of_axis is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._direction_of_axis = direction(value)
			else:
				self._direction_of_axis = value
		return property(**locals())

	@apply
	def rotation_angle():
		def fget( self ):
			return self._rotation_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rotation_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._rotation_angle = plane_angle_measure(value)
			else:
				self._rotation_angle = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.direction_of_axis.self.direction_ratios)  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY character_glyph_symbol #
####################
class character_glyph_symbol(generic_character_glyph_symbol):
	'''Entity character_glyph_symbol definition.

	:param character_box
	:type character_box:planar_extent

	:param baseline_ratio
	:type baseline_ratio:ratio_measure

	:param box_height
	:type box_height:length_measure
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , character_box,baseline_ratio, ):
		generic_character_glyph_symbol.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.character_box = character_box
		self.baseline_ratio = baseline_ratio

	@apply
	def character_box():
		def fget( self ):
			return self._character_box
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument character_box is mantatory and can not be set to None')
			if not check_type(value,planar_extent):
				self._character_box = planar_extent(value)
			else:
				self._character_box = value
		return property(**locals())

	@apply
	def baseline_ratio():
		def fget( self ):
			return self._baseline_ratio
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument baseline_ratio is mantatory and can not be set to None')
			if not check_type(value,ratio_measure):
				self._baseline_ratio = ratio_measure(value)
			else:
				self._baseline_ratio = value
		return property(**locals())

	@apply
	def box_height():
		def fget( self ):
			attribute_eval = self.character_box.self.size_in_y
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument box_height is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((0  <=  self.baseline_ratio)  and  (self.baseline_ratio  <=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = item_in_context(self.self.character_box,self.self.representation.self.context_of_items)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ('AUTOMOTIVE_DESIGN.POSITIVE_LENGTH_MEASURE'  ==  TYPEOF(self.self.box_height))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY configuration_interpolation #
####################
class configuration_interpolation(BaseEntityClass):
	'''Entity configuration_interpolation definition.

	:param previous_configuration_definition
	:type previous_configuration_definition:configuration_definition

	:param next_configuration_definition
	:type next_configuration_definition:configuration_definition

	:param interpolation
	:type interpolation:interpolation_type
	'''
	def __init__( self , previous_configuration_definition,next_configuration_definition,interpolation, ):
		self.previous_configuration_definition = previous_configuration_definition
		self.next_configuration_definition = next_configuration_definition
		self.interpolation = interpolation

	@apply
	def previous_configuration_definition():
		def fget( self ):
			return self._previous_configuration_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument previous_configuration_definition is mantatory and can not be set to None')
			if not check_type(value,configuration_definition):
				self._previous_configuration_definition = configuration_definition(value)
			else:
				self._previous_configuration_definition = value
		return property(**locals())

	@apply
	def next_configuration_definition():
		def fget( self ):
			return self._next_configuration_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument next_configuration_definition is mantatory and can not be set to None')
			if not check_type(value,configuration_definition):
				self._next_configuration_definition = configuration_definition(value)
			else:
				self._next_configuration_definition = value
		return property(**locals())

	@apply
	def interpolation():
		def fget( self ):
			return self._interpolation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument interpolation is mantatory and can not be set to None')
			if not check_type(value,interpolation_type):
				self._interpolation = interpolation_type(value)
			else:
				self._interpolation = value
		return property(**locals())

####################
 # ENTITY curve_style_font #
####################
class curve_style_font(founded_item):
	'''Entity curve_style_font definition.

	:param name
	:type name:label

	:param pattern_list
	:type pattern_list:LIST(1,None,'curve_style_font_pattern', scope = schema_scope)
	'''
	def __init__( self , name,pattern_list, ):
		founded_item.__init__(self , )
		self.name = name
		self.pattern_list = pattern_list

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def pattern_list():
		def fget( self ):
			return self._pattern_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pattern_list is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'curve_style_font_pattern', scope = schema_scope)):
				self._pattern_list = LIST(value)
			else:
				self._pattern_list = value
		return property(**locals())

####################
 # ENTITY kinematic_structure #
####################
class kinematic_structure(BaseEntityClass):
	'''Entity kinematic_structure definition.

	:param joints
	:type joints:SET(1,None,'kinematic_joint', scope = schema_scope)
	'''
	def __init__( self , joints, ):
		self.joints = joints

	@apply
	def joints():
		def fget( self ):
			return self._joints
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument joints is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'kinematic_joint', scope = schema_scope)):
				self._joints = SET(value)
			else:
				self._joints = value
		return property(**locals())

####################
 # ENTITY rolling_curve_pair #
####################
class rolling_curve_pair(planar_curve_pair):
	'''Entity rolling_curve_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , inherited5__curve_1 , inherited6__curve_2 , inherited7__orientation ,  ):
		planar_curve_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , inherited5__curve_1 , inherited6__curve_2 , inherited7__orientation , )

####################
 # ENTITY value_representation_item #
####################
class value_representation_item(representation_item):
	'''Entity value_representation_item definition.

	:param value_component
	:type value_component:measure_value
	'''
	def __init__( self , inherited0__name , value_component, ):
		representation_item.__init__(self , inherited0__name , )
		self.value_component = value_component

	@apply
	def value_component():
		def fget( self ):
			return self._value_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument value_component is mantatory and can not be set to None')
			if not check_type(value,measure_value):
				self._value_component = measure_value(value)
			else:
				self._value_component = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY circular_closed_profile #
####################
class circular_closed_profile(shape_aspect):
	'''Entity circular_closed_profile definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY binary_numeric_expression #
####################
class binary_numeric_expression(numeric_expression,binary_generic_expression):
	'''Entity binary_numeric_expression definition.

	:param binary_generic_expression_operands
	:type binary_generic_expression_operands:LIST(2,2,'numeric_expression', scope = schema_scope)
	'''
	def __init__( self , inherited0__operands , binary_generic_expression_operands, ):
		numeric_expression.__init__(self , )
		binary_generic_expression.__init__(self , inherited0__operands , )
		self.binary_generic_expression_operands = binary_generic_expression_operands

	@apply
	def binary_generic_expression_operands():
		def fget( self ):
			return self._binary_generic_expression_operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument binary_generic_expression_operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'numeric_expression', scope = schema_scope)):
				self._binary_generic_expression_operands = LIST(value)
			else:
				self._binary_generic_expression_operands = value
		return property(**locals())

####################
 # ENTITY minus_expression #
####################
class minus_expression(binary_numeric_expression):
	'''Entity minus_expression definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		binary_numeric_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY position_tolerance #
####################
class position_tolerance(geometric_tolerance):
	'''Entity position_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))  or  (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition_substitute #
####################
class product_definition_substitute(BaseEntityClass):
	'''Entity product_definition_substitute definition.

	:param description
	:type description:text

	:param context_relationship
	:type context_relationship:product_definition_relationship

	:param substitute_definition
	:type substitute_definition:product_definition

	:param name
	:type name:label
	'''
	def __init__( self , description,context_relationship,substitute_definition, ):
		self.description = description
		self.context_relationship = context_relationship
		self.substitute_definition = substitute_definition

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def context_relationship():
		def fget( self ):
			return self._context_relationship
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument context_relationship is mantatory and can not be set to None')
			if not check_type(value,product_definition_relationship):
				self._context_relationship = product_definition_relationship(value)
			else:
				self._context_relationship = value
		return property(**locals())

	@apply
	def substitute_definition():
		def fget( self ):
			return self._substitute_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument substitute_definition is mantatory and can not be set to None')
			if not check_type(value,product_definition):
				self._substitute_definition = product_definition(value)
			else:
				self._substitute_definition = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.context_relationship.self.related_product_definition  !=  self.substitute_definition)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY representation_map #
####################
class representation_map(BaseEntityClass):
	'''Entity representation_map definition.

	:param mapping_origin
	:type mapping_origin:representation_item

	:param mapped_representation
	:type mapped_representation:representation

	:param map_usage
	:type map_usage:SET(1,None,'mapped_item', scope = schema_scope)
	'''
	def __init__( self , mapping_origin,mapped_representation, ):
		self.mapping_origin = mapping_origin
		self.mapped_representation = mapped_representation

	@apply
	def mapping_origin():
		def fget( self ):
			return self._mapping_origin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapping_origin is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._mapping_origin = representation_item(value)
			else:
				self._mapping_origin = value
		return property(**locals())

	@apply
	def mapped_representation():
		def fget( self ):
			return self._mapped_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_representation is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._mapped_representation = representation(value)
			else:
				self._mapped_representation = value
		return property(**locals())

	@apply
	def map_usage():
		def fget( self ):
			return self._map_usage
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument map_usage is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = item_in_context(self.self.mapping_origin,self.self.mapped_representation.self.context_of_items)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY symbol_representation_map #
####################
class symbol_representation_map(representation_map):
	'''Entity symbol_representation_map definition.

	:param representation_map_mapped_representation
	:type representation_map_mapped_representation:symbol_representation

	:param representation_map_mapping_origin
	:type representation_map_mapping_origin:axis2_placement
	'''
	def __init__( self , inherited0__mapping_origin , inherited1__mapped_representation , representation_map_mapped_representation,representation_map_mapping_origin, ):
		representation_map.__init__(self , inherited0__mapping_origin , inherited1__mapped_representation , )
		self.representation_map_mapped_representation = representation_map_mapped_representation
		self.representation_map_mapping_origin = representation_map_mapping_origin

	@apply
	def representation_map_mapped_representation():
		def fget( self ):
			return self._representation_map_mapped_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_map_mapped_representation is mantatory and can not be set to None')
			if not check_type(value,symbol_representation):
				self._representation_map_mapped_representation = symbol_representation(value)
			else:
				self._representation_map_mapped_representation = value
		return property(**locals())

	@apply
	def representation_map_mapping_origin():
		def fget( self ):
			return self._representation_map_mapping_origin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_map_mapping_origin is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._representation_map_mapping_origin = axis2_placement(value)
			else:
				self._representation_map_mapping_origin = value
		return property(**locals())

####################
 # ENTITY vector #
####################
class vector(geometric_representation_item):
	'''Entity vector definition.

	:param orientation
	:type orientation:direction

	:param magnitude
	:type magnitude:length_measure
	'''
	def __init__( self , inherited0__name , orientation,magnitude, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.orientation = orientation
		self.magnitude = magnitude

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._orientation = direction(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def magnitude():
		def fget( self ):
			return self._magnitude
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument magnitude is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._magnitude = length_measure(value)
			else:
				self._magnitude = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.magnitude  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY annotation_text #
####################
class annotation_text(mapped_item):
	'''Entity annotation_text definition.

	:param mapped_item_mapping_target
	:type mapped_item_mapping_target:axis2_placement
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , mapped_item_mapping_target, ):
		mapped_item.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , )
		self.mapped_item_mapping_target = mapped_item_mapping_target

	@apply
	def mapped_item_mapping_target():
		def fget( self ):
			return self._mapped_item_mapping_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_target is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._mapped_item_mapping_target = axis2_placement(value)
			else:
				self._mapped_item_mapping_target = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.TEXT_STRING_REPRESENTATION'  ==  TYPEOF(self.self.mapped_item.self.mapping_source.self.mapped_representation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AUTOMOTIVE_DESIGN.GEOMETRIC_REPRESENTATION_ITEM'  ==  TYPEOF(self))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY pcurve #
####################
class pcurve(curve):
	'''Entity pcurve definition.

	:param basis_surface
	:type basis_surface:surface

	:param reference_to_curve
	:type reference_to_curve:definitional_representation
	'''
	def __init__( self , inherited0__name , basis_surface,reference_to_curve, ):
		curve.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.reference_to_curve = reference_to_curve

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def reference_to_curve():
		def fget( self ):
			return self._reference_to_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reference_to_curve is mantatory and can not be set to None')
			if not check_type(value,definitional_representation):
				self._reference_to_curve = definitional_representation(value)
			else:
				self._reference_to_curve = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.reference_to_curve.self.representation.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AUTOMOTIVE_DESIGN.CURVE'  ==  TYPEOF(self.reference_to_curve.self.representation.self.items[1]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.reference_to_curve.self.representation.self.items[1].self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY bounded_pcurve #
####################
class bounded_pcurve(pcurve,bounded_curve):
	'''Entity bounded_pcurve definition.
	'''
	def __init__( self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , inherited3__name ,  ):
		pcurve.__init__(self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , )
		bounded_curve.__init__(self , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.BOUNDED_CURVE'  ==  TYPEOF(self.self.pcurve.self.reference_to_curve.self.items[1]))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY intersection_curve #
####################
class intersection_curve(surface_curve):
	'''Entity intersection_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation ,  ):
		surface_curve.__init__(self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.surface_curve.self.associated_geometry)  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (associated_surface(self.self.surface_curve.self.associated_geometry[1])  !=  associated_surface(self.self.surface_curve.self.associated_geometry[2]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY presentation_set #
####################
class presentation_set(BaseEntityClass):
	'''Entity presentation_set definition.

	:param areas
	:type areas:SET(1,None,'area_in_set', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def areas():
		def fget( self ):
			return self._areas
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument areas is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY trimmed_curve #
####################
class trimmed_curve(bounded_curve):
	'''Entity trimmed_curve definition.

	:param basis_curve
	:type basis_curve:curve

	:param trim_1
	:type trim_1:SET(1,2,'trimming_select', scope = schema_scope)

	:param trim_2
	:type trim_2:SET(1,2,'trimming_select', scope = schema_scope)

	:param sense_agreement
	:type sense_agreement:BOOLEAN

	:param master_representation
	:type master_representation:trimming_preference
	'''
	def __init__( self , inherited0__name , basis_curve,trim_1,trim_2,sense_agreement,master_representation, ):
		bounded_curve.__init__(self , inherited0__name , )
		self.basis_curve = basis_curve
		self.trim_1 = trim_1
		self.trim_2 = trim_2
		self.sense_agreement = sense_agreement
		self.master_representation = master_representation

	@apply
	def basis_curve():
		def fget( self ):
			return self._basis_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._basis_curve = curve(value)
			else:
				self._basis_curve = value
		return property(**locals())

	@apply
	def trim_1():
		def fget( self ):
			return self._trim_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument trim_1 is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'trimming_select', scope = schema_scope)):
				self._trim_1 = SET(value)
			else:
				self._trim_1 = value
		return property(**locals())

	@apply
	def trim_2():
		def fget( self ):
			return self._trim_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument trim_2 is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'trimming_select', scope = schema_scope)):
				self._trim_2 = SET(value)
			else:
				self._trim_2 = value
		return property(**locals())

	@apply
	def sense_agreement():
		def fget( self ):
			return self._sense_agreement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sense_agreement is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._sense_agreement = BOOLEAN(value)
			else:
				self._sense_agreement = value
		return property(**locals())

	@apply
	def master_representation():
		def fget( self ):
			return self._master_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument master_representation is mantatory and can not be set to None')
			if not check_type(value,trimming_preference):
				self._master_representation = trimming_preference(value)
			else:
				self._master_representation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.trim_1)  ==  1)  or  (TYPEOF(self.trim_1[1])  !=  TYPEOF(self.trim_1[2])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((HIINDEX(self.trim_2)  ==  1)  or  (TYPEOF(self.trim_2[1])  !=  TYPEOF(self.trim_2[2])))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY projection_directed_callout #
####################
class projection_directed_callout(draughting_callout):
	'''Entity projection_directed_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.draughting_callout.self.contents)  >=  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ordinate_dimension #
####################
class ordinate_dimension(projection_directed_callout):
	'''Entity ordinate_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		projection_directed_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY perpendicular_to #
####################
class perpendicular_to(derived_shape_aspect):
	'''Entity perpendicular_to definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition_context #
####################
class product_definition_context(application_context_element):
	'''Entity product_definition_context definition.

	:param life_cycle_stage
	:type life_cycle_stage:label
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , life_cycle_stage, ):
		application_context_element.__init__(self , inherited0__name , inherited1__frame_of_reference , )
		self.life_cycle_stage = life_cycle_stage

	@apply
	def life_cycle_stage():
		def fget( self ):
			return self._life_cycle_stage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument life_cycle_stage is mantatory and can not be set to None')
			if not check_type(value,label):
				self._life_cycle_stage = label(value)
			else:
				self._life_cycle_stage = value
		return property(**locals())

####################
 # ENTITY tan_function #
####################
class tan_function(unary_function_call):
	'''Entity tan_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY geometric_alignment #
####################
class geometric_alignment(derived_shape_aspect):
	'''Entity geometric_alignment definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  >  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY geometric_intersection #
####################
class geometric_intersection(derived_shape_aspect):
	'''Entity geometric_intersection definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  >  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY presentation_view #
####################
class presentation_view(presentation_representation):
	'''Entity presentation_view definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items ,  ):
		presentation_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , )

####################
 # ENTITY sin_function #
####################
class sin_function(unary_function_call):
	'''Entity sin_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY text_literal #
####################
class text_literal(geometric_representation_item):
	'''Entity text_literal definition.

	:param literal
	:type literal:presentable_text

	:param placement
	:type placement:axis2_placement

	:param alignment
	:type alignment:text_alignment

	:param path
	:type path:text_path

	:param font
	:type font:font_select
	'''
	def __init__( self , inherited0__name , literal,placement,alignment,path,font, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.literal = literal
		self.placement = placement
		self.alignment = alignment
		self.path = path
		self.font = font

	@apply
	def literal():
		def fget( self ):
			return self._literal
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument literal is mantatory and can not be set to None')
			if not check_type(value,presentable_text):
				self._literal = presentable_text(value)
			else:
				self._literal = value
		return property(**locals())

	@apply
	def placement():
		def fget( self ):
			return self._placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placement is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._placement = axis2_placement(value)
			else:
				self._placement = value
		return property(**locals())

	@apply
	def alignment():
		def fget( self ):
			return self._alignment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument alignment is mantatory and can not be set to None')
			if not check_type(value,text_alignment):
				self._alignment = text_alignment(value)
			else:
				self._alignment = value
		return property(**locals())

	@apply
	def path():
		def fget( self ):
			return self._path
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument path is mantatory and can not be set to None')
			if not check_type(value,text_path):
				self._path = text_path(value)
			else:
				self._path = value
		return property(**locals())

	@apply
	def font():
		def fget( self ):
			return self._font
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument font is mantatory and can not be set to None')
			if not check_type(value,font_select):
				self._font = font_select(value)
			else:
				self._font = value
		return property(**locals())

####################
 # ENTITY text_literal_with_delineation #
####################
class text_literal_with_delineation(text_literal):
	'''Entity text_literal_with_delineation definition.

	:param delineation
	:type delineation:text_delineation
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , delineation, ):
		text_literal.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , )
		self.delineation = delineation

	@apply
	def delineation():
		def fget( self ):
			return self._delineation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument delineation is mantatory and can not be set to None')
			if not check_type(value,text_delineation):
				self._delineation = text_delineation(value)
			else:
				self._delineation = value
		return property(**locals())

####################
 # ENTITY contact_ratio_representation #
####################
class contact_ratio_representation(representation):
	'''Entity contact_ratio_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.self.items)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY dimensional_characteristic_representation #
####################
class dimensional_characteristic_representation(BaseEntityClass):
	'''Entity dimensional_characteristic_representation definition.

	:param dimension
	:type dimension:dimensional_characteristic

	:param representation
	:type representation:shape_dimension_representation
	'''
	def __init__( self , dimension,representation, ):
		self.dimension = dimension
		self.representation = representation

	@apply
	def dimension():
		def fget( self ):
			return self._dimension
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dimension is mantatory and can not be set to None')
			if not check_type(value,dimensional_characteristic):
				self._dimension = dimensional_characteristic(value)
			else:
				self._dimension = value
		return property(**locals())

	@apply
	def representation():
		def fget( self ):
			return self._representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation is mantatory and can not be set to None')
			if not check_type(value,shape_dimension_representation):
				self._representation = shape_dimension_representation(value)
			else:
				self._representation = value
		return property(**locals())

####################
 # ENTITY joggle_termination #
####################
class joggle_termination(shape_aspect):
	'''Entity joggle_termination definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.description  ==  ['value termination','face termination'])
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((self.self.description  ==  'value termination') XOR (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.description  !=  'value termination')  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'value termination')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.description  !=  'value termination')  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY tolerance_zone_definition #
####################
class tolerance_zone_definition(BaseEntityClass):
	'''Entity tolerance_zone_definition definition.

	:param zone
	:type zone:tolerance_zone

	:param boundaries
	:type boundaries:SET(1,None,'shape_aspect', scope = schema_scope)
	'''
	def __init__( self , zone,boundaries, ):
		self.zone = zone
		self.boundaries = boundaries

	@apply
	def zone():
		def fget( self ):
			return self._zone
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zone is mantatory and can not be set to None')
			if not check_type(value,tolerance_zone):
				self._zone = tolerance_zone(value)
			else:
				self._zone = value
		return property(**locals())

	@apply
	def boundaries():
		def fget( self ):
			return self._boundaries
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument boundaries is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'shape_aspect', scope = schema_scope)):
				self._boundaries = SET(value)
			else:
				self._boundaries = value
		return property(**locals())

####################
 # ENTITY projected_zone_definition #
####################
class projected_zone_definition(tolerance_zone_definition):
	'''Entity projected_zone_definition definition.

	:param projection_end
	:type projection_end:shape_aspect

	:param projected_length
	:type projected_length:measure_with_unit
	'''
	def __init__( self , inherited0__zone , inherited1__boundaries , projection_end,projected_length, ):
		tolerance_zone_definition.__init__(self , inherited0__zone , inherited1__boundaries , )
		self.projection_end = projection_end
		self.projected_length = projected_length

	@apply
	def projection_end():
		def fget( self ):
			return self._projection_end
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument projection_end is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._projection_end = shape_aspect(value)
			else:
				self._projection_end = value
		return property(**locals())

	@apply
	def projected_length():
		def fget( self ):
			return self._projected_length
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument projected_length is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._projected_length = measure_with_unit(value)
			else:
				self._projected_length = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('NUMBER'  ==  TYPEOF(self.projected_length.self.measure_with_unit.self.value_component))  and  (self.projected_length.self.measure_with_unit.self.value_component  >  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (derive_dimensional_exponents(self.projected_length.self.measure_with_unit.self.unit_component)  ==  dimensional_exponents(1,0,0,0,0,0,0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY qualitative_uncertainty #
####################
class qualitative_uncertainty(uncertainty_qualifier):
	'''Entity qualitative_uncertainty definition.

	:param uncertainty_value
	:type uncertainty_value:text
	'''
	def __init__( self , inherited0__measure_name , inherited1__description , uncertainty_value, ):
		uncertainty_qualifier.__init__(self , inherited0__measure_name , inherited1__description , )
		self.uncertainty_value = uncertainty_value

	@apply
	def uncertainty_value():
		def fget( self ):
			return self._uncertainty_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uncertainty_value is mantatory and can not be set to None')
			if not check_type(value,text):
				self._uncertainty_value = text(value)
			else:
				self._uncertainty_value = value
		return property(**locals())

####################
 # ENTITY applied_classification_assignment #
####################
class applied_classification_assignment(classification_assignment):
	'''Entity applied_classification_assignment definition.

	:param items
	:type items:SET(1,None,'classification_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_class , inherited1__role , items, ):
		classification_assignment.__init__(self , inherited0__assigned_class , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'classification_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'CLASS')  ==  TYPEOF(self.self.assigned_class)))  or  (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not (((('AUTOMOTIVE_DESIGN.'  +  'GROUP')  ==  TYPEOF(self.self.assigned_class))  and  (self.self.assigned_class.self.group.self.name  ==  'E'))  and  (self.self.assigned_class.self.group.self.description  ==  'dimensioning principle')))  or  (SIZEOF(None)  ==  0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not ((('AUTOMOTIVE_DESIGN.'  +  'CLASS_SYSTEM')  ==  TYPEOF(self.self.assigned_class))  and  (self.self.role.self.name  ==  'class system membership')))  or  (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY circular_runout_tolerance #
####################
class circular_runout_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity circular_runout_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY bounded_surface_curve #
####################
class bounded_surface_curve(surface_curve,bounded_curve):
	'''Entity bounded_surface_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , inherited4__name ,  ):
		surface_curve.__init__(self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , )
		bounded_curve.__init__(self , inherited4__name , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.BOUNDED_CURVE'  ==  TYPEOF(self.self.surface_curve.self.curve_3d))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY document #
####################
class document(BaseEntityClass):
	'''Entity document definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param kind
	:type kind:document_type

	:param representation_types
	:type representation_types:SET(0,None,'document_representation_type', scope = schema_scope)
	'''
	def __init__( self , id,name,description,kind, ):
		self.id = id
		self.name = name
		self.description = description
		self.kind = kind

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def kind():
		def fget( self ):
			return self._kind
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument kind is mantatory and can not be set to None')
			if not check_type(value,document_type):
				self._kind = document_type(value)
			else:
				self._kind = value
		return property(**locals())

	@apply
	def representation_types():
		def fget( self ):
			return self._representation_types
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument representation_types is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY document_file #
####################
class document_file(document,characterized_object):
	'''Entity document_file definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__kind , inherited4__name , inherited5__description ,  ):
		document.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__kind , )
		characterized_object.__init__(self , inherited4__name , inherited5__description , )
	def wr1(self):
		eval_wr1_wr = (self.self.characterized_object.self.name  ==  '')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.characterized_object.self.description))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY versioned_action_request_relationship #
####################
class versioned_action_request_relationship(BaseEntityClass):
	'''Entity versioned_action_request_relationship definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_versioned_action_request
	:type relating_versioned_action_request:versioned_action_request

	:param related_versioned_action_request
	:type related_versioned_action_request:versioned_action_request
	'''
	def __init__( self , id,name,description,relating_versioned_action_request,related_versioned_action_request, ):
		self.id = id
		self.name = name
		self.description = description
		self.relating_versioned_action_request = relating_versioned_action_request
		self.related_versioned_action_request = related_versioned_action_request

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_versioned_action_request():
		def fget( self ):
			return self._relating_versioned_action_request
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_versioned_action_request is mantatory and can not be set to None')
			if not check_type(value,versioned_action_request):
				self._relating_versioned_action_request = versioned_action_request(value)
			else:
				self._relating_versioned_action_request = value
		return property(**locals())

	@apply
	def related_versioned_action_request():
		def fget( self ):
			return self._related_versioned_action_request
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_versioned_action_request is mantatory and can not be set to None')
			if not check_type(value,versioned_action_request):
				self._related_versioned_action_request = versioned_action_request(value)
			else:
				self._related_versioned_action_request = value
		return property(**locals())

####################
 # ENTITY class_system #
####################
class class_system(group):
	'''Entity class_system definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY multiple_arity_function_call #
####################
class multiple_arity_function_call(multiple_arity_numeric_expression):
	'''Entity multiple_arity_function_call definition.
	'''
	def __init__( self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands ,  ):
		multiple_arity_numeric_expression.__init__(self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands , )

####################
 # ENTITY maximum_function #
####################
class maximum_function(multiple_arity_function_call):
	'''Entity maximum_function definition.
	'''
	def __init__( self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands ,  ):
		multiple_arity_function_call.__init__(self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands , )

####################
 # ENTITY mechanism #
####################
class mechanism(BaseEntityClass):
	'''Entity mechanism definition.

	:param structure_definition
	:type structure_definition:kinematic_structure

	:param base
	:type base:kinematic_link

	:param containing_property
	:type containing_property:kinematic_property_definition
	'''
	def __init__( self , structure_definition,base,containing_property, ):
		self.structure_definition = structure_definition
		self.base = base
		self.containing_property = containing_property

	@apply
	def structure_definition():
		def fget( self ):
			return self._structure_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument structure_definition is mantatory and can not be set to None')
			if not check_type(value,kinematic_structure):
				self._structure_definition = kinematic_structure(value)
			else:
				self._structure_definition = value
		return property(**locals())

	@apply
	def base():
		def fget( self ):
			return self._base
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base is mantatory and can not be set to None')
			if not check_type(value,kinematic_link):
				self._base = kinematic_link(value)
			else:
				self._base = value
		return property(**locals())

	@apply
	def containing_property():
		def fget( self ):
			return self._containing_property
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument containing_property is mantatory and can not be set to None')
			if not check_type(value,kinematic_property_definition):
				self._containing_property = kinematic_property_definition(value)
			else:
				self._containing_property = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_category_relationship #
####################
class product_category_relationship(BaseEntityClass):
	'''Entity product_category_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param category
	:type category:product_category

	:param sub_category
	:type sub_category:product_category
	'''
	def __init__( self , name,description,category,sub_category, ):
		self.name = name
		self.description = description
		self.category = category
		self.sub_category = sub_category

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def category():
		def fget( self ):
			return self._category
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument category is mantatory and can not be set to None')
			if not check_type(value,product_category):
				self._category = product_category(value)
			else:
				self._category = value
		return property(**locals())

	@apply
	def sub_category():
		def fget( self ):
			return self._sub_category
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sub_category is mantatory and can not be set to None')
			if not check_type(value,product_category):
				self._sub_category = product_category(value)
			else:
				self._sub_category = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = acyclic_product_category_relationship(self,[self.self.sub_category])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_condition_callout #
####################
class surface_condition_callout(draughting_callout):
	'''Entity surface_condition_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY text_literal_with_blanking_box #
####################
class text_literal_with_blanking_box(text_literal):
	'''Entity text_literal_with_blanking_box definition.

	:param blanking
	:type blanking:planar_box
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , blanking, ):
		text_literal.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , )
		self.blanking = blanking

	@apply
	def blanking():
		def fget( self ):
			return self._blanking
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument blanking is mantatory and can not be set to None')
			if not check_type(value,planar_box):
				self._blanking = planar_box(value)
			else:
				self._blanking = value
		return property(**locals())

####################
 # ENTITY curve_style_font_pattern #
####################
class curve_style_font_pattern(founded_item):
	'''Entity curve_style_font_pattern definition.

	:param visible_segment_length
	:type visible_segment_length:positive_length_measure

	:param invisible_segment_length
	:type invisible_segment_length:positive_length_measure
	'''
	def __init__( self , visible_segment_length,invisible_segment_length, ):
		founded_item.__init__(self , )
		self.visible_segment_length = visible_segment_length
		self.invisible_segment_length = invisible_segment_length

	@apply
	def visible_segment_length():
		def fget( self ):
			return self._visible_segment_length
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument visible_segment_length is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._visible_segment_length = positive_length_measure(value)
			else:
				self._visible_segment_length = value
		return property(**locals())

	@apply
	def invisible_segment_length():
		def fget( self ):
			return self._invisible_segment_length
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument invisible_segment_length is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._invisible_segment_length = positive_length_measure(value)
			else:
				self._invisible_segment_length = value
		return property(**locals())

####################
 # ENTITY kinematic_frame_based_transformation #
####################
class kinematic_frame_based_transformation(geometric_representation_item,functionally_defined_transformation):
	'''Entity kinematic_frame_based_transformation definition.

	:param transformator
	:type transformator:rigid_placement
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__description , transformator, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		functionally_defined_transformation.__init__(self , inherited1__name , inherited2__description , )
		self.transformator = transformator

	@apply
	def transformator():
		def fget( self ):
			return self._transformator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transformator is mantatory and can not be set to None')
			if not check_type(value,rigid_placement):
				self._transformator = rigid_placement(value)
			else:
				self._transformator = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY constructive_geometry_representation #
####################
class constructive_geometry_representation(representation):
	'''Entity constructive_geometry_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_REPRESENTATION_CONTEXT')  ==  TYPEOF(self.self.context_of_items))  and  ((2  <=  self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension)  and  (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  <=  3)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.REPRESENTATION_RELATIONSHIP.REP_2'))  >  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.REPRESENTATION_MAP.MAPPED_REPRESENTATION'))  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY plane_angle_measure_with_unit #
####################
class plane_angle_measure_with_unit(measure_with_unit):
	'''Entity plane_angle_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.PLANE_ANGLE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY right_angular_wedge #
####################
class right_angular_wedge(geometric_representation_item):
	'''Entity right_angular_wedge definition.

	:param position
	:type position:axis2_placement_3d

	:param x
	:type x:positive_length_measure

	:param y
	:type y:positive_length_measure

	:param z
	:type z:positive_length_measure

	:param ltx
	:type ltx:length_measure
	'''
	def __init__( self , inherited0__name , position,x,y,z,ltx, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.position = position
		self.x = x
		self.y = y
		self.z = z
		self.ltx = ltx

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._position = axis2_placement_3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def x():
		def fget( self ):
			return self._x
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument x is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._x = positive_length_measure(value)
			else:
				self._x = value
		return property(**locals())

	@apply
	def y():
		def fget( self ):
			return self._y
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument y is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._y = positive_length_measure(value)
			else:
				self._y = value
		return property(**locals())

	@apply
	def z():
		def fget( self ):
			return self._z
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument z is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._z = positive_length_measure(value)
			else:
				self._z = value
		return property(**locals())

	@apply
	def ltx():
		def fget( self ):
			return self._ltx
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ltx is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._ltx = length_measure(value)
			else:
				self._ltx = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((0  <=  self.ltx)  and  (self.ltx  <  self.x))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY text_style_with_spacing #
####################
class text_style_with_spacing(text_style):
	'''Entity text_style_with_spacing definition.

	:param character_spacing
	:type character_spacing:character_spacing_select
	'''
	def __init__( self , inherited0__name , inherited1__character_appearance , character_spacing, ):
		text_style.__init__(self , inherited0__name , inherited1__character_appearance , )
		self.character_spacing = character_spacing

	@apply
	def character_spacing():
		def fget( self ):
			return self._character_spacing
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument character_spacing is mantatory and can not be set to None')
			if not check_type(value,character_spacing_select):
				self._character_spacing = character_spacing_select(value)
			else:
				self._character_spacing = value
		return property(**locals())

####################
 # ENTITY vertex #
####################
class vertex(topological_representation_item):
	'''Entity vertex definition.
	'''
	def __init__( self , inherited0__name ,  ):
		topological_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY attribute_classification_assignment #
####################
class attribute_classification_assignment(BaseEntityClass):
	'''Entity attribute_classification_assignment definition.

	:param assigned_class
	:type assigned_class:group

	:param attribute_name
	:type attribute_name:label

	:param role
	:type role:classification_role
	'''
	def __init__( self , assigned_class,attribute_name,role, ):
		self.assigned_class = assigned_class
		self.attribute_name = attribute_name
		self.role = role

	@apply
	def assigned_class():
		def fget( self ):
			return self._assigned_class
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_class is mantatory and can not be set to None')
			if not check_type(value,group):
				self._assigned_class = group(value)
			else:
				self._assigned_class = value
		return property(**locals())

	@apply
	def attribute_name():
		def fget( self ):
			return self._attribute_name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._attribute_name = label(value)
			else:
				self._attribute_name = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,classification_role):
				self._role = classification_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY point_on_planar_curve_pair #
####################
class point_on_planar_curve_pair(kinematic_pair):
	'''Entity point_on_planar_curve_pair definition.

	:param pair_curve
	:type pair_curve:curve

	:param orientation
	:type orientation:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , pair_curve,orientation, ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )
		self.pair_curve = pair_curve
		self.orientation = orientation

	@apply
	def pair_curve():
		def fget( self ):
			return self._pair_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._pair_curve = curve(value)
			else:
				self._pair_curve = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = frame_associated_to_background(self.self.kinematic_pair.self.pair_placement_in_first_link_context,self.pair_curve)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY abs_function #
####################
class abs_function(unary_function_call):
	'''Entity abs_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY electric_current_unit #
####################
class electric_current_unit(named_unit):
	'''Entity electric_current_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  1))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY plus_expression #
####################
class plus_expression(multiple_arity_numeric_expression):
	'''Entity plus_expression definition.
	'''
	def __init__( self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands ,  ):
		multiple_arity_numeric_expression.__init__(self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands , )

####################
 # ENTITY application_context_relationship #
####################
class application_context_relationship(BaseEntityClass):
	'''Entity application_context_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_context
	:type relating_context:application_context

	:param related_context
	:type related_context:application_context
	'''
	def __init__( self , name,description,relating_context,related_context, ):
		self.name = name
		self.description = description
		self.relating_context = relating_context
		self.related_context = related_context

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_context():
		def fget( self ):
			return self._relating_context
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_context is mantatory and can not be set to None')
			if not check_type(value,application_context):
				self._relating_context = application_context(value)
			else:
				self._relating_context = value
		return property(**locals())

	@apply
	def related_context():
		def fget( self ):
			return self._related_context
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_context is mantatory and can not be set to None')
			if not check_type(value,application_context):
				self._related_context = application_context(value)
			else:
				self._related_context = value
		return property(**locals())

####################
 # ENTITY product_definition_effectivity #
####################
class product_definition_effectivity(effectivity):
	'''Entity product_definition_effectivity definition.

	:param usage
	:type usage:product_definition_relationship
	'''
	def __init__( self , inherited0__id , usage, ):
		effectivity.__init__(self , inherited0__id , )
		self.usage = usage

	@apply
	def usage():
		def fget( self ):
			return self._usage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument usage is mantatory and can not be set to None')
			if not check_type(value,product_definition_relationship):
				self._usage = product_definition_relationship(value)
			else:
				self._usage = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY'))  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY configuration_effectivity #
####################
class configuration_effectivity(product_definition_effectivity):
	'''Entity configuration_effectivity definition.

	:param configuration
	:type configuration:configuration_design
	'''
	def __init__( self , inherited0__id , inherited1__usage , configuration, ):
		product_definition_effectivity.__init__(self , inherited0__id , inherited1__usage , )
		self.configuration = configuration

	@apply
	def configuration():
		def fget( self ):
			return self._configuration
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument configuration is mantatory and can not be set to None')
			if not check_type(value,configuration_design):
				self._configuration = configuration_design(value)
			else:
				self._configuration = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.PRODUCT_DEFINITION_USAGE'  ==  TYPEOF(self.self.product_definition_effectivity.self.usage))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ellipse #
####################
class ellipse(conic):
	'''Entity ellipse definition.

	:param semi_axis_1
	:type semi_axis_1:positive_length_measure

	:param semi_axis_2
	:type semi_axis_2:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , semi_axis_1,semi_axis_2, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self.semi_axis_1 = semi_axis_1
		self.semi_axis_2 = semi_axis_2

	@apply
	def semi_axis_1():
		def fget( self ):
			return self._semi_axis_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_axis_1 is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._semi_axis_1 = positive_length_measure(value)
			else:
				self._semi_axis_1 = value
		return property(**locals())

	@apply
	def semi_axis_2():
		def fget( self ):
			return self._semi_axis_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_axis_2 is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._semi_axis_2 = positive_length_measure(value)
			else:
				self._semi_axis_2 = value
		return property(**locals())

####################
 # ENTITY geometric_tolerance_with_defined_unit #
####################
class geometric_tolerance_with_defined_unit(geometric_tolerance):
	'''Entity geometric_tolerance_with_defined_unit definition.

	:param unit_size
	:type unit_size:measure_with_unit
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , unit_size, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
		self.unit_size = unit_size

	@apply
	def unit_size():
		def fget( self ):
			return self._unit_size
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unit_size is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._unit_size = measure_with_unit(value)
			else:
				self._unit_size = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('NUMBER'  ==  TYPEOF(self.unit_size.self.measure_with_unit.self.value_component))  and  (self.unit_size.self.measure_with_unit.self.value_component  >  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_style_fill_area #
####################
class surface_style_fill_area(founded_item):
	'''Entity surface_style_fill_area definition.

	:param fill_area
	:type fill_area:fill_area_style
	'''
	def __init__( self , fill_area, ):
		founded_item.__init__(self , )
		self.fill_area = fill_area

	@apply
	def fill_area():
		def fget( self ):
			return self._fill_area
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fill_area is mantatory and can not be set to None')
			if not check_type(value,fill_area_style):
				self._fill_area = fill_area_style(value)
			else:
				self._fill_area = value
		return property(**locals())

####################
 # ENTITY simple_boolean_expression #
####################
class simple_boolean_expression(boolean_expression,simple_generic_expression):
	'''Entity simple_boolean_expression definition.
	'''
	def __init__( self ,  ):
		boolean_expression.__init__(self , )
		simple_generic_expression.__init__(self , )

####################
 # ENTITY boolean_variable #
####################
class boolean_variable(simple_boolean_expression,variable):
	'''Entity boolean_variable definition.
	'''
	def __init__( self ,  ):
		simple_boolean_expression.__init__(self , )
		variable.__init__(self , )

####################
 # ENTITY camera_usage #
####################
class camera_usage(representation_map):
	'''Entity camera_usage definition.

	:param representation_map_mapping_origin
	:type representation_map_mapping_origin:camera_model
	'''
	def __init__( self , inherited0__mapping_origin , inherited1__mapped_representation , representation_map_mapping_origin, ):
		representation_map.__init__(self , inherited0__mapping_origin , inherited1__mapped_representation , )
		self.representation_map_mapping_origin = representation_map_mapping_origin

	@apply
	def representation_map_mapping_origin():
		def fget( self ):
			return self._representation_map_mapping_origin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_map_mapping_origin is mantatory and can not be set to None')
			if not check_type(value,camera_model):
				self._representation_map_mapping_origin = camera_model(value)
			else:
				self._representation_map_mapping_origin = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AUTOMOTIVE_DESIGN.PRESENTATION_REPRESENTATION'  ==  TYPEOF(self.self.representation_map.self.mapped_representation)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY geometrically_bounded_2d_wireframe_representation #
####################
class geometrically_bounded_2d_wireframe_representation(shape_representation):
	'''Entity geometrically_bounded_2d_wireframe_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  >=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY bead_end #
####################
class bead_end(shape_aspect):
	'''Entity bead_end definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.description  ==  ['linear','open','radiused'])
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((self.self.description  !=  'linear') XOR (SIZEOF(None)  >  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.description  !=  'linear')  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'linear')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.description  !=  'linear')  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY comparison_greater_equal #
####################
class comparison_greater_equal(comparison_expression):
	'''Entity comparison_greater_equal definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		comparison_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY externally_defined_item_relationship #
####################
class externally_defined_item_relationship(BaseEntityClass):
	'''Entity externally_defined_item_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_item
	:type relating_item:externally_defined_item

	:param related_item
	:type related_item:externally_defined_item
	'''
	def __init__( self , name,description,relating_item,related_item, ):
		self.name = name
		self.description = description
		self.relating_item = relating_item
		self.related_item = related_item

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_item():
		def fget( self ):
			return self._relating_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_item is mantatory and can not be set to None')
			if not check_type(value,externally_defined_item):
				self._relating_item = externally_defined_item(value)
			else:
				self._relating_item = value
		return property(**locals())

	@apply
	def related_item():
		def fget( self ):
			return self._related_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_item is mantatory and can not be set to None')
			if not check_type(value,externally_defined_item):
				self._related_item = externally_defined_item(value)
			else:
				self._related_item = value
		return property(**locals())

####################
 # ENTITY int_literal #
####################
class int_literal(literal_number):
	'''Entity int_literal definition.

	:param literal_number_the_value
	:type literal_number_the_value:INTEGER
	'''
	def __init__( self , inherited0__the_value , literal_number_the_value, ):
		literal_number.__init__(self , inherited0__the_value , )
		self.literal_number_the_value = literal_number_the_value

	@apply
	def literal_number_the_value():
		def fget( self ):
			return self._literal_number_the_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument literal_number_the_value is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._literal_number_the_value = INTEGER(value)
			else:
				self._literal_number_the_value = value
		return property(**locals())

####################
 # ENTITY point_on_surface_pair #
####################
class point_on_surface_pair(kinematic_pair):
	'''Entity point_on_surface_pair definition.

	:param pair_surface
	:type pair_surface:surface
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , pair_surface, ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )
		self.pair_surface = pair_surface

	@apply
	def pair_surface():
		def fget( self ):
			return self._pair_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._pair_surface = surface(value)
			else:
				self._pair_surface = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = frame_associated_to_background(self.self.kinematic_pair.self.pair_placement_in_first_link_context,self.pair_surface)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY uncertainty_assigned_representation #
####################
class uncertainty_assigned_representation(representation):
	'''Entity uncertainty_assigned_representation definition.

	:param uncertainty
	:type uncertainty:SET(1,None,'uncertainty_measure_with_unit', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , uncertainty, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.uncertainty = uncertainty

	@apply
	def uncertainty():
		def fget( self ):
			return self._uncertainty
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uncertainty is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'uncertainty_measure_with_unit', scope = schema_scope)):
				self._uncertainty = SET(value)
			else:
				self._uncertainty = value
		return property(**locals())

####################
 # ENTITY value_function #
####################
class value_function(numeric_expression,unary_generic_expression):
	'''Entity value_function definition.

	:param unary_generic_expression_operand
	:type unary_generic_expression_operand:string_expression
	'''
	def __init__( self , inherited0__operand , unary_generic_expression_operand, ):
		numeric_expression.__init__(self , )
		unary_generic_expression.__init__(self , inherited0__operand , )
		self.unary_generic_expression_operand = unary_generic_expression_operand

	@apply
	def unary_generic_expression_operand():
		def fget( self ):
			return self._unary_generic_expression_operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unary_generic_expression_operand is mantatory and can not be set to None')
			if not check_type(value,string_expression):
				self._unary_generic_expression_operand = string_expression(value)
			else:
				self._unary_generic_expression_operand = value
		return property(**locals())

####################
 # ENTITY alternate_product_relationship #
####################
class alternate_product_relationship(BaseEntityClass):
	'''Entity alternate_product_relationship definition.

	:param name
	:type name:label

	:param definition
	:type definition:text

	:param alternate
	:type alternate:product

	:param base
	:type base:product

	:param basis
	:type basis:text
	'''
	def __init__( self , name,definition,alternate,base,basis, ):
		self.name = name
		self.definition = definition
		self.alternate = alternate
		self.base = base
		self.basis = basis

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._definition = text(value)
				else:
					self._definition = value
			else:
				self._definition = value
		return property(**locals())

	@apply
	def alternate():
		def fget( self ):
			return self._alternate
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument alternate is mantatory and can not be set to None')
			if not check_type(value,product):
				self._alternate = product(value)
			else:
				self._alternate = value
		return property(**locals())

	@apply
	def base():
		def fget( self ):
			return self._base
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base is mantatory and can not be set to None')
			if not check_type(value,product):
				self._base = product(value)
			else:
				self._base = value
		return property(**locals())

	@apply
	def basis():
		def fget( self ):
			return self._basis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis is mantatory and can not be set to None')
			if not check_type(value,text):
				self._basis = text(value)
			else:
				self._basis = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.alternate  !=  self.base)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY document_type #
####################
class document_type(BaseEntityClass):
	'''Entity document_type definition.

	:param product_data_type
	:type product_data_type:label
	'''
	def __init__( self , product_data_type, ):
		self.product_data_type = product_data_type

	@apply
	def product_data_type():
		def fget( self ):
			return self._product_data_type
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument product_data_type is mantatory and can not be set to None')
			if not check_type(value,label):
				self._product_data_type = label(value)
			else:
				self._product_data_type = value
		return property(**locals())

####################
 # ENTITY externally_defined_style #
####################
class externally_defined_style(externally_defined_item,founded_item):
	'''Entity externally_defined_style definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )
		founded_item.__init__(self , )

####################
 # ENTITY document_reference #
####################
class document_reference(BaseEntityClass):
	'''Entity document_reference definition.

	:param assigned_document
	:type assigned_document:document

	:param source
	:type source:label

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_document,source, ):
		self.assigned_document = assigned_document
		self.source = source

	@apply
	def assigned_document():
		def fget( self ):
			return self._assigned_document
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_document is mantatory and can not be set to None')
			if not check_type(value,document):
				self._assigned_document = document(value)
			else:
				self._assigned_document = value
		return property(**locals())

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source is mantatory and can not be set to None')
			if not check_type(value,label):
				self._source = label(value)
			else:
				self._source = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY binary_boolean_expression #
####################
class binary_boolean_expression(boolean_expression,binary_generic_expression):
	'''Entity binary_boolean_expression definition.
	'''
	def __init__( self , inherited0__operands ,  ):
		boolean_expression.__init__(self , )
		binary_generic_expression.__init__(self , inherited0__operands , )

####################
 # ENTITY equals_expression #
####################
class equals_expression(binary_boolean_expression):
	'''Entity equals_expression definition.
	'''
	def __init__( self , inherited0__operands ,  ):
		binary_boolean_expression.__init__(self , inherited0__operands , )

####################
 # ENTITY seam_edge #
####################
class seam_edge(oriented_edge):
	'''Entity seam_edge definition.

	:param pcurve_reference
	:type pcurve_reference:pcurve
	'''
	def __init__( self , inherited0__name , inherited1__edge_start , inherited2__edge_end , inherited3__edge_element , inherited4__orientation , pcurve_reference, ):
		oriented_edge.__init__(self , inherited0__name , inherited1__edge_start , inherited2__edge_end , inherited3__edge_element , inherited4__orientation , )
		self.pcurve_reference = pcurve_reference

	@apply
	def pcurve_reference():
		def fget( self ):
			return self._pcurve_reference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pcurve_reference is mantatory and can not be set to None')
			if not check_type(value,pcurve):
				self._pcurve_reference = pcurve(value)
			else:
				self._pcurve_reference = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.EDGE_CURVE'  ==  TYPEOF(self.edge_element))  and  ('AUTOMOTIVE_DESIGN.SEAM_CURVE'  ==  TYPEOF(self.edge_element.self.edge_curve.self.edge_geometry)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.pcurve_reference  ==  self.edge_element.self.edge_curve.self.edge_geometry.self.surface_curve.self.associated_geometry)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY acos_function #
####################
class acos_function(unary_function_call):
	'''Entity acos_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY like_expression #
####################
class like_expression(comparison_expression):
	'''Entity like_expression definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		comparison_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.STRING_EXPRESSION'  ==  TYPEOF(self.self.comparison_expression.self.operands[1]))  and  ('AUTOMOTIVE_DESIGN.STRING_EXPRESSION'  ==  TYPEOF(self.self.comparison_expression.self.operands[2])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY draughting_symbol_representation #
####################
class draughting_symbol_representation(symbol_representation):
	'''Entity draughting_symbol_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		symbol_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  >  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ( not acyclic_mapped_item_usage(self))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(self.self.context_of_items.self.representations_in_context)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY planar_extent #
####################
class planar_extent(geometric_representation_item):
	'''Entity planar_extent definition.

	:param size_in_x
	:type size_in_x:length_measure

	:param size_in_y
	:type size_in_y:length_measure
	'''
	def __init__( self , inherited0__name , size_in_x,size_in_y, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.size_in_x = size_in_x
		self.size_in_y = size_in_y

	@apply
	def size_in_x():
		def fget( self ):
			return self._size_in_x
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument size_in_x is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._size_in_x = length_measure(value)
			else:
				self._size_in_x = value
		return property(**locals())

	@apply
	def size_in_y():
		def fget( self ):
			return self._size_in_y
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument size_in_y is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._size_in_y = length_measure(value)
			else:
				self._size_in_y = value
		return property(**locals())

####################
 # ENTITY planar_box #
####################
class planar_box(planar_extent):
	'''Entity planar_box definition.

	:param placement
	:type placement:axis2_placement
	'''
	def __init__( self , inherited0__name , inherited1__size_in_x , inherited2__size_in_y , placement, ):
		planar_extent.__init__(self , inherited0__name , inherited1__size_in_x , inherited2__size_in_y , )
		self.placement = placement

	@apply
	def placement():
		def fget( self ):
			return self._placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placement is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._placement = axis2_placement(value)
			else:
				self._placement = value
		return property(**locals())

####################
 # ENTITY slot #
####################
class slot(feature_definition):
	'''Entity slot definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY manifold_subsurface_shape_representation #
####################
class manifold_subsurface_shape_representation(shape_representation):
	'''Entity manifold_subsurface_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr


####################
 # ENTITY perpendicularity_tolerance #
####################
class perpendicularity_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity perpendicularity_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY plus_minus_tolerance #
####################
class plus_minus_tolerance(BaseEntityClass):
	'''Entity plus_minus_tolerance definition.

	:param range
	:type range:tolerance_method_definition

	:param toleranced_dimension
	:type toleranced_dimension:dimensional_characteristic
	'''
	def __init__( self , range,toleranced_dimension, ):
		self.range = range
		self.toleranced_dimension = toleranced_dimension

	@apply
	def range():
		def fget( self ):
			return self._range
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument range is mantatory and can not be set to None')
			if not check_type(value,tolerance_method_definition):
				self._range = tolerance_method_definition(value)
			else:
				self._range = value
		return property(**locals())

	@apply
	def toleranced_dimension():
		def fget( self ):
			return self._toleranced_dimension
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument toleranced_dimension is mantatory and can not be set to None')
			if not check_type(value,dimensional_characteristic):
				self._toleranced_dimension = dimensional_characteristic(value)
			else:
				self._toleranced_dimension = value
		return property(**locals())

####################
 # ENTITY drawing_sheet_layout #
####################
class drawing_sheet_layout(draughting_symbol_representation):
	'''Entity drawing_sheet_layout definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		draughting_symbol_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )

####################
 # ENTITY effectivity_relationship #
####################
class effectivity_relationship(BaseEntityClass):
	'''Entity effectivity_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param related_effectivity
	:type related_effectivity:effectivity

	:param relating_effectivity
	:type relating_effectivity:effectivity
	'''
	def __init__( self , name,description,related_effectivity,relating_effectivity, ):
		self.name = name
		self.description = description
		self.related_effectivity = related_effectivity
		self.relating_effectivity = relating_effectivity

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def related_effectivity():
		def fget( self ):
			return self._related_effectivity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_effectivity is mantatory and can not be set to None')
			if not check_type(value,effectivity):
				self._related_effectivity = effectivity(value)
			else:
				self._related_effectivity = value
		return property(**locals())

	@apply
	def relating_effectivity():
		def fget( self ):
			return self._relating_effectivity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_effectivity is mantatory and can not be set to None')
			if not check_type(value,effectivity):
				self._relating_effectivity = effectivity(value)
			else:
				self._relating_effectivity = value
		return property(**locals())

####################
 # ENTITY square_u_profile #
####################
class square_u_profile(shape_aspect):
	'''Entity square_u_profile definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY applied_identification_assignment #
####################
class applied_identification_assignment(identification_assignment):
	'''Entity applied_identification_assignment definition.

	:param items
	:type items:SET(1,None,'identification_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_id , inherited1__role , items, ):
		identification_assignment.__init__(self , inherited0__assigned_id , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'identification_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (self.self.role.self.name  ==  'version'))  or  item_correlation(self.self.items,['ACTION','ACTION_DIRECTIVE','SHAPE_REPRESENTATION','EFFECTIVITY','PRODUCT_CONCEPT','CONFIGURATION_ITEM','PRODUCT_DEFINITION','PRODUCT_CONCEPT_FEATURE','DOCUMENT_FILE','CLASS','APPLIED_IDENTIFICATION_ASSIGNMENT','DRAUGHTING_MODEL','MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION','PRESENTATION_AREA']))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not (self.self.role.self.name  ==  'lot context'))  or  item_correlation(self.self.items,['PRODUCT']))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not (self.self.role.self.name  ==  'property change id context'))  or  item_correlation(self.self.items,['PROPERTY_DEFINITION_RELATIONSHIP','SHAPE_ASPECT_RELATIONSHIP','ACTION_PROPERTY']))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not (self.self.role.self.name  ==  'size id'))  or  item_correlation(self.self.items,['DIMENSIONAL_SIZE']))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (( not (self.self.role.self.name  ==  'model change id'))  or  item_correlation(self.self.items,['PROPERTY_DEFINITION','ACTION_PROPERTY']))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (( not (self.self.role.self.name  ==  'alias'))  or  item_correlation(self.self.items,['APPLICATION_CONTEXT','APPROVAL_STATUS','ASSEMBLY_COMPONENT_USAGE','CLASS','CLASS_SYSTEM','DOCUMENT_TYPE','DRAUGHTING_MODEL','GENERAL_PROPERTY','MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION','ORGANIZATION','PRODUCT','PRODUCT_CONCEPT','PRODUCT_CONCEPT_FEATURE','PRODUCT_CONCEPT_FEATURE_CATEGORY','PRODUCT_DEFINITION','PRODUCT_DEFINITION_FORMATION','PROPERTY_DEFINITION','SECURITY_CLASSIFICATION_LEVEL','SHAPE_REPRESENTATION']))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY contract #
####################
class contract(BaseEntityClass):
	'''Entity contract definition.

	:param name
	:type name:label

	:param purpose
	:type purpose:text

	:param kind
	:type kind:contract_type
	'''
	def __init__( self , name,purpose,kind, ):
		self.name = name
		self.purpose = purpose
		self.kind = kind

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument purpose is mantatory and can not be set to None')
			if not check_type(value,text):
				self._purpose = text(value)
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def kind():
		def fget( self ):
			return self._kind
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument kind is mantatory and can not be set to None')
			if not check_type(value,contract_type):
				self._kind = contract_type(value)
			else:
				self._kind = value
		return property(**locals())

####################
 # ENTITY direction_shape_representation #
####################
class direction_shape_representation(shape_representation):
	'''Entity direction_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY attribute_value_assignment #
####################
class attribute_value_assignment(BaseEntityClass):
	'''Entity attribute_value_assignment definition.

	:param attribute_name
	:type attribute_name:label

	:param attribute_value
	:type attribute_value:attribute_type

	:param role
	:type role:attribute_value_role
	'''
	def __init__( self , attribute_name,attribute_value,role, ):
		self.attribute_name = attribute_name
		self.attribute_value = attribute_value
		self.role = role

	@apply
	def attribute_name():
		def fget( self ):
			return self._attribute_name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._attribute_name = label(value)
			else:
				self._attribute_name = value
		return property(**locals())

	@apply
	def attribute_value():
		def fget( self ):
			return self._attribute_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_value is mantatory and can not be set to None')
			if not check_type(value,attribute_type):
				self._attribute_value = attribute_type(value)
			else:
				self._attribute_value = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,attribute_value_role):
				self._role = attribute_value_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY datum_feature #
####################
class datum_feature(shape_aspect):
	'''Entity datum_feature definition.

	:param feature_basis_relationship
	:type feature_basis_relationship:shape_aspect_relationship
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )

	@apply
	def feature_basis_relationship():
		def fget( self ):
			return self._feature_basis_relationship
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument feature_basis_relationship is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.shape_aspect.self.product_definitional  ==  TRUE)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY dimensional_exponents #
####################
class dimensional_exponents(BaseEntityClass):
	'''Entity dimensional_exponents definition.

	:param length_exponent
	:type length_exponent:REAL

	:param mass_exponent
	:type mass_exponent:REAL

	:param time_exponent
	:type time_exponent:REAL

	:param electric_current_exponent
	:type electric_current_exponent:REAL

	:param thermodynamic_temperature_exponent
	:type thermodynamic_temperature_exponent:REAL

	:param amount_of_substance_exponent
	:type amount_of_substance_exponent:REAL

	:param luminous_intensity_exponent
	:type luminous_intensity_exponent:REAL
	'''
	def __init__( self , length_exponent,mass_exponent,time_exponent,electric_current_exponent,thermodynamic_temperature_exponent,amount_of_substance_exponent,luminous_intensity_exponent, ):
		self.length_exponent = length_exponent
		self.mass_exponent = mass_exponent
		self.time_exponent = time_exponent
		self.electric_current_exponent = electric_current_exponent
		self.thermodynamic_temperature_exponent = thermodynamic_temperature_exponent
		self.amount_of_substance_exponent = amount_of_substance_exponent
		self.luminous_intensity_exponent = luminous_intensity_exponent

	@apply
	def length_exponent():
		def fget( self ):
			return self._length_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument length_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._length_exponent = REAL(value)
			else:
				self._length_exponent = value
		return property(**locals())

	@apply
	def mass_exponent():
		def fget( self ):
			return self._mass_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mass_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._mass_exponent = REAL(value)
			else:
				self._mass_exponent = value
		return property(**locals())

	@apply
	def time_exponent():
		def fget( self ):
			return self._time_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument time_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._time_exponent = REAL(value)
			else:
				self._time_exponent = value
		return property(**locals())

	@apply
	def electric_current_exponent():
		def fget( self ):
			return self._electric_current_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument electric_current_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._electric_current_exponent = REAL(value)
			else:
				self._electric_current_exponent = value
		return property(**locals())

	@apply
	def thermodynamic_temperature_exponent():
		def fget( self ):
			return self._thermodynamic_temperature_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thermodynamic_temperature_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._thermodynamic_temperature_exponent = REAL(value)
			else:
				self._thermodynamic_temperature_exponent = value
		return property(**locals())

	@apply
	def amount_of_substance_exponent():
		def fget( self ):
			return self._amount_of_substance_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument amount_of_substance_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._amount_of_substance_exponent = REAL(value)
			else:
				self._amount_of_substance_exponent = value
		return property(**locals())

	@apply
	def luminous_intensity_exponent():
		def fget( self ):
			return self._luminous_intensity_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument luminous_intensity_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._luminous_intensity_exponent = REAL(value)
			else:
				self._luminous_intensity_exponent = value
		return property(**locals())

####################
 # ENTITY planar_pair #
####################
class planar_pair(kinematic_pair):
	'''Entity planar_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint ,  ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )

####################
 # ENTITY pre_defined_geometrical_tolerance_symbol #
####################
class pre_defined_geometrical_tolerance_symbol(pre_defined_symbol):
	'''Entity pre_defined_geometrical_tolerance_symbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_symbol.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['angularity','basic dimension','blanked datum reference','circular runout','circularity','concentricity','cylindricity','datum target identification','diameter','filled datum reference','flatness','least material condition','maximum material condition','parallelism','perpendicularity','position','profile of a line','profile of a surface','projected tolerance zone','regardless of feature size','straightness','symmetry','total runout'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY symmetric_shape_aspect #
####################
class symmetric_shape_aspect(shape_aspect):
	'''Entity symmetric_shape_aspect definition.

	:param basis_relationships
	:type basis_relationships:SET(1,None,'shape_aspect_relationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )

	@apply
	def basis_relationships():
		def fget( self ):
			return self._basis_relationships
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument basis_relationships is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY directed_angle #
####################
class directed_angle(shape_aspect):
	'''Entity directed_angle definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (self.self.description  ==  ['punch direction','profile normal','surface normal'])
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY parallelism_tolerance #
####################
class parallelism_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity parallelism_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY externally_defined_character_glyph #
####################
class externally_defined_character_glyph(externally_defined_item):
	'''Entity externally_defined_character_glyph definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )

####################
 # ENTITY sliding_curve_pair #
####################
class sliding_curve_pair(planar_curve_pair):
	'''Entity sliding_curve_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , inherited5__curve_1 , inherited6__curve_2 , inherited7__orientation ,  ):
		planar_curve_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , inherited5__curve_1 , inherited6__curve_2 , inherited7__orientation , )

####################
 # ENTITY characterized_class #
####################
class characterized_class(characterized_object,class_):
	'''Entity characterized_class definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__name , inherited3__description ,  ):
		characterized_object.__init__(self , inherited0__name , inherited1__description , )
		class.__init__(self , inherited2__name , inherited3__description , )

####################
 # ENTITY externally_defined_tile_style #
####################
class externally_defined_tile_style(externally_defined_item,geometric_representation_item):
	'''Entity externally_defined_tile_style definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source , inherited2__name ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )
		geometric_representation_item.__init__(self , inherited2__name , )

####################
 # ENTITY pre_defined_terminator_symbol #
####################
class pre_defined_terminator_symbol(pre_defined_symbol):
	'''Entity pre_defined_terminator_symbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_symbol.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['blanked arrow','blanked box','blanked dot','dimension origin','filled arrow','filled box','filled dot','integral symbol','open arrow','slash','unfilled arrow'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY vector_style #
####################
class vector_style(pre_defined_terminator_symbol,curve_style):
	'''Entity vector_style definition.
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__curve_font , inherited3__curve_width , inherited4__curve_colour ,  ):
		pre_defined_terminator_symbol.__init__(self , inherited0__name , )
		curve_style.__init__(self , inherited1__name , inherited2__curve_font , inherited3__curve_width , inherited4__curve_colour , )

####################
 # ENTITY time_interval_assignment #
####################
class time_interval_assignment(BaseEntityClass):
	'''Entity time_interval_assignment definition.

	:param assigned_time_interval
	:type assigned_time_interval:time_interval

	:param role
	:type role:time_interval_role
	'''
	def __init__( self , assigned_time_interval,role, ):
		self.assigned_time_interval = assigned_time_interval
		self.role = role

	@apply
	def assigned_time_interval():
		def fget( self ):
			return self._assigned_time_interval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_time_interval is mantatory and can not be set to None')
			if not check_type(value,time_interval):
				self._assigned_time_interval = time_interval(value)
			else:
				self._assigned_time_interval = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,time_interval_role):
				self._role = time_interval_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_time_interval_assignment #
####################
class applied_time_interval_assignment(time_interval_assignment):
	'''Entity applied_time_interval_assignment definition.

	:param items
	:type items:SET(1,None,'time_interval_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_time_interval , inherited1__role , items, ):
		time_interval_assignment.__init__(self , inherited0__assigned_time_interval , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'time_interval_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY organizational_project_relationship #
####################
class organizational_project_relationship(BaseEntityClass):
	'''Entity organizational_project_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_organizational_project
	:type relating_organizational_project:organizational_project

	:param related_organizational_project
	:type related_organizational_project:organizational_project
	'''
	def __init__( self , name,description,relating_organizational_project,related_organizational_project, ):
		self.name = name
		self.description = description
		self.relating_organizational_project = relating_organizational_project
		self.related_organizational_project = related_organizational_project

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_organizational_project():
		def fget( self ):
			return self._relating_organizational_project
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_organizational_project is mantatory and can not be set to None')
			if not check_type(value,organizational_project):
				self._relating_organizational_project = organizational_project(value)
			else:
				self._relating_organizational_project = value
		return property(**locals())

	@apply
	def related_organizational_project():
		def fget( self ):
			return self._related_organizational_project
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_organizational_project is mantatory and can not be set to None')
			if not check_type(value,organizational_project):
				self._related_organizational_project = organizational_project(value)
			else:
				self._related_organizational_project = value
		return property(**locals())

####################
 # ENTITY context_dependent_shape_representation #
####################
class context_dependent_shape_representation(BaseEntityClass):
	'''Entity context_dependent_shape_representation definition.

	:param representation_relation
	:type representation_relation:shape_representation_relationship

	:param represented_product_relation
	:type represented_product_relation:product_definition_shape

	:param description
	:type description:text

	:param name
	:type name:label
	'''
	def __init__( self , representation_relation,represented_product_relation, ):
		self.representation_relation = representation_relation
		self.represented_product_relation = represented_product_relation

	@apply
	def representation_relation():
		def fget( self ):
			return self._representation_relation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relation is mantatory and can not be set to None')
			if not check_type(value,shape_representation_relationship):
				self._representation_relation = shape_representation_relationship(value)
			else:
				self._representation_relation = value
		return property(**locals())

	@apply
	def represented_product_relation():
		def fget( self ):
			return self._represented_product_relation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument represented_product_relation is mantatory and can not be set to None')
			if not check_type(value,product_definition_shape):
				self._represented_product_relation = product_definition_shape(value)
			else:
				self._represented_product_relation = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP'  ==  TYPEOF(self.self.represented_product_relation.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY degenerate_toroidal_surface #
####################
class degenerate_toroidal_surface(toroidal_surface):
	'''Entity degenerate_toroidal_surface definition.

	:param select_outer
	:type select_outer:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__position , inherited2__major_radius , inherited3__minor_radius , select_outer, ):
		toroidal_surface.__init__(self , inherited0__name , inherited1__position , inherited2__major_radius , inherited3__minor_radius , )
		self.select_outer = select_outer

	@apply
	def select_outer():
		def fget( self ):
			return self._select_outer
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument select_outer is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._select_outer = BOOLEAN(value)
			else:
				self._select_outer = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.major_radius  <  self.minor_radius)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY exp_function #
####################
class exp_function(unary_function_call):
	'''Entity exp_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY person_and_organization_assignment #
####################
class person_and_organization_assignment(BaseEntityClass):
	'''Entity person_and_organization_assignment definition.

	:param assigned_person_and_organization
	:type assigned_person_and_organization:person_and_organization

	:param role
	:type role:person_and_organization_role
	'''
	def __init__( self , assigned_person_and_organization,role, ):
		self.assigned_person_and_organization = assigned_person_and_organization
		self.role = role

	@apply
	def assigned_person_and_organization():
		def fget( self ):
			return self._assigned_person_and_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_person_and_organization is mantatory and can not be set to None')
			if not check_type(value,person_and_organization):
				self._assigned_person_and_organization = person_and_organization(value)
			else:
				self._assigned_person_and_organization = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,person_and_organization_role):
				self._role = person_and_organization_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY shape_aspect_associativity #
####################
class shape_aspect_associativity(shape_aspect_relationship):
	'''Entity shape_aspect_associativity definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		shape_aspect_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = self.self.relating_shape_aspect.self.product_definitional
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not self.self.related_shape_aspect.self.product_definitional)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY conditional_concept_feature #
####################
class conditional_concept_feature(product_concept_feature):
	'''Entity conditional_concept_feature definition.

	:param condition
	:type condition:concept_feature_relationship_with_condition
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , condition, ):
		product_concept_feature.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
		self.condition = condition

	@apply
	def condition():
		def fget( self ):
			return self._condition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument condition is mantatory and can not be set to None')
			if not check_type(value,concept_feature_relationship_with_condition):
				self._condition = concept_feature_relationship_with_condition(value)
			else:
				self._condition = value
		return property(**locals())

####################
 # ENTITY locator #
####################
class locator(feature_definition):
	'''Entity locator definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  <=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  <=  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY presentation_style_assignment #
####################
class presentation_style_assignment(founded_item):
	'''Entity presentation_style_assignment definition.

	:param styles
	:type styles:SET(1,None,'presentation_style_select', scope = schema_scope)
	'''
	def __init__( self , styles, ):
		founded_item.__init__(self , )
		self.styles = styles

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'presentation_style_select', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  <=  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY rib #
####################
class rib(feature_definition):
	'''Entity rib definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  <=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  <=  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  <=  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY sql_mappable_defined_function #
####################
class sql_mappable_defined_function(defined_function):
	'''Entity sql_mappable_defined_function definition.
	'''
	def __init__( self ,  ):
		defined_function.__init__(self , )

####################
 # ENTITY face_outer_bound #
####################
class face_outer_bound(face_bound):
	'''Entity face_outer_bound definition.
	'''
	def __init__( self , inherited0__name , inherited1__bound , inherited2__orientation ,  ):
		face_bound.__init__(self , inherited0__name , inherited1__bound , inherited2__orientation , )

####################
 # ENTITY geometric_item_specific_usage #
####################
class geometric_item_specific_usage(item_identified_representation_usage):
	'''Entity geometric_item_specific_usage definition.

	:param item_identified_representation_usage_definition
	:type item_identified_representation_usage_definition:shape_aspect

	:param item_identified_representation_usage_used_representation
	:type item_identified_representation_usage_used_representation:shape_representation

	:param item_identified_representation_usage_identified_item
	:type item_identified_representation_usage_identified_item:geometric_representation_item
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition , inherited3__used_representation , inherited4__identified_item , item_identified_representation_usage_definition,item_identified_representation_usage_used_representation,item_identified_representation_usage_identified_item, ):
		item_identified_representation_usage.__init__(self , inherited0__name , inherited1__description , inherited2__definition , inherited3__used_representation , inherited4__identified_item , )
		self.item_identified_representation_usage_definition = item_identified_representation_usage_definition
		self.item_identified_representation_usage_used_representation = item_identified_representation_usage_used_representation
		self.item_identified_representation_usage_identified_item = item_identified_representation_usage_identified_item

	@apply
	def item_identified_representation_usage_definition():
		def fget( self ):
			return self._item_identified_representation_usage_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_definition is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._item_identified_representation_usage_definition = shape_aspect(value)
			else:
				self._item_identified_representation_usage_definition = value
		return property(**locals())

	@apply
	def item_identified_representation_usage_used_representation():
		def fget( self ):
			return self._item_identified_representation_usage_used_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_used_representation is mantatory and can not be set to None')
			if not check_type(value,shape_representation):
				self._item_identified_representation_usage_used_representation = shape_representation(value)
			else:
				self._item_identified_representation_usage_used_representation = value
		return property(**locals())

	@apply
	def item_identified_representation_usage_identified_item():
		def fget( self ):
			return self._item_identified_representation_usage_identified_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_identified_item is mantatory and can not be set to None')
			if not check_type(value,geometric_representation_item):
				self._item_identified_representation_usage_identified_item = geometric_representation_item(value)
			else:
				self._item_identified_representation_usage_identified_item = value
		return property(**locals())

####################
 # ENTITY mass_measure_with_unit #
####################
class mass_measure_with_unit(measure_with_unit):
	'''Entity mass_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.MASS_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY square_root_function #
####################
class square_root_function(unary_function_call):
	'''Entity square_root_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY surface_texture_representation #
####################
class surface_texture_representation(representation):
	'''Entity surface_texture_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  >  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.REPRESENTATION_RELATIONSHIP.REP_1'))  <=  1)  and  (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.REPRESENTATION_RELATIONSHIP.REP_2'))  ==  0))  and  (SIZEOF(None)  ==  SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.REPRESENTATION_RELATIONSHIP.REP_1'))))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY and_expression #
####################
class and_expression(multiple_arity_boolean_expression):
	'''Entity and_expression definition.
	'''
	def __init__( self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands ,  ):
		multiple_arity_boolean_expression.__init__(self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands , )

####################
 # ENTITY brep_with_voids #
####################
class brep_with_voids(manifold_solid_brep):
	'''Entity brep_with_voids definition.

	:param voids
	:type voids:SET(1,None,'oriented_closed_shell', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__outer , voids, ):
		manifold_solid_brep.__init__(self , inherited0__name , inherited1__outer , )
		self.voids = voids

	@apply
	def voids():
		def fget( self ):
			return self._voids
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument voids is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'oriented_closed_shell', scope = schema_scope)):
				self._voids = SET(value)
			else:
				self._voids = value
		return property(**locals())

####################
 # ENTITY datum_target #
####################
class datum_target(shape_aspect):
	'''Entity datum_target definition.

	:param target_id
	:type target_id:identifier

	:param target_basis_relationship
	:type target_basis_relationship:shape_aspect_relationship
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , target_id, ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		self.target_id = target_id

	@apply
	def target_id():
		def fget( self ):
			return self._target_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument target_id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._target_id = identifier(value)
			else:
				self._target_id = value
		return property(**locals())

	@apply
	def target_basis_relationship():
		def fget( self ):
			return self._target_basis_relationship
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument target_basis_relationship is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.shape_aspect.self.product_definitional  ==  TRUE)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY surface_style_usage #
####################
class surface_style_usage(founded_item):
	'''Entity surface_style_usage definition.

	:param side
	:type side:surface_side

	:param style
	:type style:surface_side_style_select
	'''
	def __init__( self , side,style, ):
		founded_item.__init__(self , )
		self.side = side
		self.style = style

	@apply
	def side():
		def fget( self ):
			return self._side
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument side is mantatory and can not be set to None')
			if not check_type(value,surface_side):
				self._side = surface_side(value)
			else:
				self._side = value
		return property(**locals())

	@apply
	def style():
		def fget( self ):
			return self._style
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style is mantatory and can not be set to None')
			if not check_type(value,surface_side_style_select):
				self._style = surface_side_style_select(value)
			else:
				self._style = value
		return property(**locals())

####################
 # ENTITY thermodynamic_temperature_unit #
####################
class thermodynamic_temperature_unit(named_unit):
	'''Entity thermodynamic_temperature_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  1))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_ineffectivity_assignment #
####################
class applied_ineffectivity_assignment(effectivity_assignment):
	'''Entity applied_ineffectivity_assignment definition.

	:param items
	:type items:SET(1,None,'effectivity_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_effectivity , items, ):
		effectivity_assignment.__init__(self , inherited0__assigned_effectivity , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'effectivity_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'LOT_EFFECTIVITY','AUTOMOTIVE_DESIGN.'  +  'SERIAL_NUMBERED_EFFECTIVITY','AUTOMOTIVE_DESIGN.'  +  'PRODUCT_DEFINITION_EFFECTIVITY']  *  TYPEOF(self.self.assigned_effectivity))  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY composite_text_with_blanking_box #
####################
class composite_text_with_blanking_box(composite_text):
	'''Entity composite_text_with_blanking_box definition.

	:param blanking
	:type blanking:planar_box
	'''
	def __init__( self , inherited0__name , inherited1__collected_text , blanking, ):
		composite_text.__init__(self , inherited0__name , inherited1__collected_text , )
		self.blanking = blanking

	@apply
	def blanking():
		def fget( self ):
			return self._blanking
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument blanking is mantatory and can not be set to None')
			if not check_type(value,planar_box):
				self._blanking = planar_box(value)
			else:
				self._blanking = value
		return property(**locals())

####################
 # ENTITY datum_feature_callout #
####################
class datum_feature_callout(draughting_callout):
	'''Entity datum_feature_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY organization_role #
####################
class organization_role(BaseEntityClass):
	'''Entity organization_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY point_on_curve #
####################
class point_on_curve(point):
	'''Entity point_on_curve definition.

	:param basis_curve
	:type basis_curve:curve

	:param point_parameter
	:type point_parameter:parameter_value
	'''
	def __init__( self , inherited0__name , basis_curve,point_parameter, ):
		point.__init__(self , inherited0__name , )
		self.basis_curve = basis_curve
		self.point_parameter = point_parameter

	@apply
	def basis_curve():
		def fget( self ):
			return self._basis_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._basis_curve = curve(value)
			else:
				self._basis_curve = value
		return property(**locals())

	@apply
	def point_parameter():
		def fget( self ):
			return self._point_parameter
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument point_parameter is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._point_parameter = parameter_value(value)
			else:
				self._point_parameter = value
		return property(**locals())

####################
 # ENTITY surface_style_rendering_with_properties #
####################
class surface_style_rendering_with_properties(surface_style_rendering):
	'''Entity surface_style_rendering_with_properties definition.

	:param properties
	:type properties:SET(1,2,'rendering_properties_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__rendering_method , inherited1__surface_colour , properties, ):
		surface_style_rendering.__init__(self , inherited0__rendering_method , inherited1__surface_colour , )
		self.properties = properties

	@apply
	def properties():
		def fget( self ):
			return self._properties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument properties is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'rendering_properties_select', scope = schema_scope)):
				self._properties = SET(value)
			else:
				self._properties = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.self.properties)  ==  1) XOR (TYPEOF(self.self.properties[1])  !=  TYPEOF(self.self.properties[2])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY default_tolerance_table_cell #
####################
class default_tolerance_table_cell(compound_representation_item):
	'''Entity default_tolerance_table_cell definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = default_tolerance_table_cell_wr2(self.self.compound_representation_item.self.item_element)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = default_tolerance_table_cell_wr3(self.self.compound_representation_item.self.item_element)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = default_tolerance_table_cell_wr4(self.self.compound_representation_item.self.item_element)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = default_tolerance_table_cell_wr5(self.self.compound_representation_item.self.item_element)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY dimension_curve_directed_callout #
####################
class dimension_curve_directed_callout(draughting_callout):
	'''Entity dimension_curve_directed_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.draughting_callout.self.contents)  >=  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY diameter_dimension #
####################
class diameter_dimension(dimension_curve_directed_callout):
	'''Entity diameter_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		dimension_curve_directed_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY rolling_surface_pair #
####################
class rolling_surface_pair(surface_pair):
	'''Entity rolling_surface_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , inherited5__surface_1 , inherited6__surface_2 , inherited7__orientation ,  ):
		surface_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , inherited5__surface_1 , inherited6__surface_2 , inherited7__orientation , )

####################
 # ENTITY total_runout_tolerance #
####################
class total_runout_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity total_runout_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition_context_role #
####################
class product_definition_context_role(BaseEntityClass):
	'''Entity product_definition_context_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY revolute_pair #
####################
class revolute_pair(kinematic_pair):
	'''Entity revolute_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint ,  ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )

####################
 # ENTITY screw_pair_value #
####################
class screw_pair_value(pair_value):
	'''Entity screw_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:screw_pair

	:param actual_rotation
	:type actual_rotation:plane_angle_measure

	:param actual_translation
	:type actual_translation:length_measure
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_rotation, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_rotation = actual_rotation

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,screw_pair):
				self._pair_value_applies_to_pair = screw_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_rotation():
		def fget( self ):
			return self._actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_rotation is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._actual_rotation = plane_angle_measure(value)
			else:
				self._actual_rotation = value
		return property(**locals())

	@apply
	def actual_translation():
		def fget( self ):
			attribute_eval = (((self.self.pair_value.self.applies_to_pair.self.screw_pair.self.pitch  *  plane_angle_for_pair_in_radian(self.self.pair_value.self.applies_to_pair,self.actual_rotation)) / 2)  *   PI )
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument actual_translation is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY text_literal_with_associated_curves #
####################
class text_literal_with_associated_curves(text_literal):
	'''Entity text_literal_with_associated_curves definition.

	:param associated_curves
	:type associated_curves:SET(1,None,'curve', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , associated_curves, ):
		text_literal.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , )
		self.associated_curves = associated_curves

	@apply
	def associated_curves():
		def fget( self ):
			return self._associated_curves
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument associated_curves is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'curve', scope = schema_scope)):
				self._associated_curves = SET(value)
			else:
				self._associated_curves = value
		return property(**locals())

####################
 # ENTITY face_surface #
####################
class face_surface(face,geometric_representation_item):
	'''Entity face_surface definition.

	:param face_geometry
	:type face_geometry:surface

	:param same_sense
	:type same_sense:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__bounds , inherited2__name , face_geometry,same_sense, ):
		face.__init__(self , inherited0__name , inherited1__bounds , )
		geometric_representation_item.__init__(self , inherited2__name , )
		self.face_geometry = face_geometry
		self.same_sense = same_sense

	@apply
	def face_geometry():
		def fget( self ):
			return self._face_geometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument face_geometry is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._face_geometry = surface(value)
			else:
				self._face_geometry = value
		return property(**locals())

	@apply
	def same_sense():
		def fget( self ):
			return self._same_sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument same_sense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._same_sense = BOOLEAN(value)
			else:
				self._same_sense = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AUTOMOTIVE_DESIGN.ORIENTED_SURFACE'  ==  TYPEOF(self.face_geometry)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY material_property #
####################
class material_property(property_definition):
	'''Entity material_property definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition ,  ):
		property_definition.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.CHARACTERIZED_OBJECT'  ==  TYPEOF(self.self.property_definition.self.definition))  or  (SIZEOF(bag_to_set(USEDIN(self,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) - None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY oriented_face #
####################
class oriented_face(face):
	'''Entity oriented_face definition.

	:param face_element
	:type face_element:face

	:param orientation
	:type orientation:BOOLEAN

	:param face_bounds
	:type face_bounds:SET(1,None,'face_bound', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__bounds , face_element,orientation, ):
		face.__init__(self , inherited0__name , inherited1__bounds , )
		self.face_element = face_element
		self.orientation = orientation

	@apply
	def face_element():
		def fget( self ):
			return self._face_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument face_element is mantatory and can not be set to None')
			if not check_type(value,face):
				self._face_element = face(value)
			else:
				self._face_element = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def face_bounds():
		def fget( self ):
			attribute_eval = conditional_reverse(self.self.orientation,self.self.face_element.self.bounds)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument face_bounds is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AUTOMOTIVE_DESIGN.ORIENTED_FACE'  ==  TYPEOF(self.self.face_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_of_revolution #
####################
class surface_of_revolution(swept_surface):
	'''Entity surface_of_revolution definition.

	:param axis_position
	:type axis_position:axis1_placement

	:param axis_line
	:type axis_line:line
	'''
	def __init__( self , inherited0__name , inherited1__swept_curve , axis_position, ):
		swept_surface.__init__(self , inherited0__name , inherited1__swept_curve , )
		self.axis_position = axis_position

	@apply
	def axis_position():
		def fget( self ):
			return self._axis_position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axis_position is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._axis_position = axis1_placement(value)
			else:
				self._axis_position = value
		return property(**locals())

	@apply
	def axis_line():
		def fget( self ):
			attribute_eval = (((representation_item('')  ==  geometric_representation_item())  ==  curve())  ==  line(self.axis_position.self.location,(representation_item('')  ==  geometric_representation_item())  ==  vector(self.axis_position.self.z,1)))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument axis_line is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY angular_size #
####################
class angular_size(dimensional_size):
	'''Entity angular_size definition.

	:param angle_selection
	:type angle_selection:angle_relator
	'''
	def __init__( self , inherited0__applies_to , inherited1__name , angle_selection, ):
		dimensional_size.__init__(self , inherited0__applies_to , inherited1__name , )
		self.angle_selection = angle_selection

	@apply
	def angle_selection():
		def fget( self ):
			return self._angle_selection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle_selection is mantatory and can not be set to None')
			if not check_type(value,angle_relator):
				self._angle_selection = angle_relator(value)
			else:
				self._angle_selection = value
		return property(**locals())

####################
 # ENTITY organizational_project_assignment #
####################
class organizational_project_assignment(BaseEntityClass):
	'''Entity organizational_project_assignment definition.

	:param assigned_organizational_project
	:type assigned_organizational_project:organizational_project

	:param role
	:type role:organizational_project_role
	'''
	def __init__( self , assigned_organizational_project,role, ):
		self.assigned_organizational_project = assigned_organizational_project
		self.role = role

	@apply
	def assigned_organizational_project():
		def fget( self ):
			return self._assigned_organizational_project
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_organizational_project is mantatory and can not be set to None')
			if not check_type(value,organizational_project):
				self._assigned_organizational_project = organizational_project(value)
			else:
				self._assigned_organizational_project = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,organizational_project_role):
				self._role = organizational_project_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_organizational_project_assignment #
####################
class applied_organizational_project_assignment(organizational_project_assignment):
	'''Entity applied_organizational_project_assignment definition.

	:param items
	:type items:SET(1,None,'organizational_project_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_organizational_project , inherited1__role , items, ):
		organizational_project_assignment.__init__(self , inherited0__assigned_organizational_project , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'organizational_project_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY product_identification #
####################
class product_identification(configuration_item,characterized_object):
	'''Entity product_identification definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , inherited5__name , inherited6__description ,  ):
		configuration_item.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , )
		characterized_object.__init__(self , inherited5__name , inherited6__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('AUTOMOTIVE_DESIGN.'  +  'PRODUCT_CLASS')  ==  TYPEOF(self.self.item_concept))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'CONFIGURABLE_ITEM')  ==  TYPEOF(self)))  or  (('AUTOMOTIVE_DESIGN.'  +  'PRODUCT_SPECIFICATION')  ==  TYPEOF(self)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY product_specification #
####################
class product_specification(product_identification,configurable_item):
	'''Entity product_specification definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , inherited5__name , inherited6__description , inherited7__id , inherited8__name , inherited9__description , inherited10__item_concept , inherited11__purpose , inherited12__item_concept_feature ,  ):
		product_identification.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , inherited5__name , inherited6__description , )
		configurable_item.__init__(self , inherited7__id , inherited8__name , inherited9__description , inherited10__item_concept , inherited11__purpose , inherited12__item_concept_feature , )

####################
 # ENTITY advanced_brep_shape_representation #
####################
class advanced_brep_shape_representation(shape_representation):
	'''Entity advanced_brep_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY cylindrical_pair_value #
####################
class cylindrical_pair_value(pair_value):
	'''Entity cylindrical_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:cylindrical_pair

	:param actual_translation
	:type actual_translation:length_measure

	:param actual_rotation
	:type actual_rotation:plane_angle_measure
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_translation,actual_rotation, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_translation = actual_translation
		self.actual_rotation = actual_rotation

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,cylindrical_pair):
				self._pair_value_applies_to_pair = cylindrical_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_translation():
		def fget( self ):
			return self._actual_translation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_translation is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._actual_translation = length_measure(value)
			else:
				self._actual_translation = value
		return property(**locals())

	@apply
	def actual_rotation():
		def fget( self ):
			return self._actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_rotation is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._actual_rotation = plane_angle_measure(value)
			else:
				self._actual_rotation = value
		return property(**locals())

####################
 # ENTITY comparison_not_equal #
####################
class comparison_not_equal(comparison_expression):
	'''Entity comparison_not_equal definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		comparison_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY property_definition_relationship #
####################
class property_definition_relationship(BaseEntityClass):
	'''Entity property_definition_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_property_definition
	:type relating_property_definition:property_definition

	:param related_property_definition
	:type related_property_definition:property_definition
	'''
	def __init__( self , name,description,relating_property_definition,related_property_definition, ):
		self.name = name
		self.description = description
		self.relating_property_definition = relating_property_definition
		self.related_property_definition = related_property_definition

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_property_definition():
		def fget( self ):
			return self._relating_property_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_property_definition is mantatory and can not be set to None')
			if not check_type(value,property_definition):
				self._relating_property_definition = property_definition(value)
			else:
				self._relating_property_definition = value
		return property(**locals())

	@apply
	def related_property_definition():
		def fget( self ):
			return self._related_property_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_property_definition is mantatory and can not be set to None')
			if not check_type(value,property_definition):
				self._related_property_definition = property_definition(value)
			else:
				self._related_property_definition = value
		return property(**locals())

####################
 # ENTITY edge_curve #
####################
class edge_curve(edge,geometric_representation_item):
	'''Entity edge_curve definition.

	:param edge_geometry
	:type edge_geometry:curve

	:param same_sense
	:type same_sense:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__edge_start , inherited2__edge_end , inherited3__name , edge_geometry,same_sense, ):
		edge.__init__(self , inherited0__name , inherited1__edge_start , inherited2__edge_end , )
		geometric_representation_item.__init__(self , inherited3__name , )
		self.edge_geometry = edge_geometry
		self.same_sense = same_sense

	@apply
	def edge_geometry():
		def fget( self ):
			return self._edge_geometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edge_geometry is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._edge_geometry = curve(value)
			else:
				self._edge_geometry = value
		return property(**locals())

	@apply
	def same_sense():
		def fget( self ):
			return self._same_sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument same_sense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._same_sense = BOOLEAN(value)
			else:
				self._same_sense = value
		return property(**locals())

####################
 # ENTITY kinematic_property_definition #
####################
class kinematic_property_definition(property_definition):
	'''Entity kinematic_property_definition definition.

	:param ground_definition
	:type ground_definition:characterized_definition
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition , ground_definition, ):
		property_definition.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )
		self.ground_definition = ground_definition

	@apply
	def ground_definition():
		def fget( self ):
			return self._ground_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ground_definition is mantatory and can not be set to None')
			if not check_type(value,characterized_definition):
				self._ground_definition = characterized_definition(value)
			else:
				self._ground_definition = value
		return property(**locals())

####################
 # ENTITY radius_dimension #
####################
class radius_dimension(dimension_curve_directed_callout):
	'''Entity radius_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		dimension_curve_directed_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY sliding_surface_pair_value #
####################
class sliding_surface_pair_value(pair_value):
	'''Entity sliding_surface_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:sliding_surface_pair

	:param actual_point_on_surface_1
	:type actual_point_on_surface_1:point_on_surface

	:param actual_point_on_surface_2
	:type actual_point_on_surface_2:point_on_surface

	:param actual_rotation
	:type actual_rotation:plane_angle_measure
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_point_on_surface_1,actual_point_on_surface_2,actual_rotation, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_point_on_surface_1 = actual_point_on_surface_1
		self.actual_point_on_surface_2 = actual_point_on_surface_2
		self.actual_rotation = actual_rotation

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,sliding_surface_pair):
				self._pair_value_applies_to_pair = sliding_surface_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_point_on_surface_1():
		def fget( self ):
			return self._actual_point_on_surface_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_point_on_surface_1 is mantatory and can not be set to None')
			if not check_type(value,point_on_surface):
				self._actual_point_on_surface_1 = point_on_surface(value)
			else:
				self._actual_point_on_surface_1 = value
		return property(**locals())

	@apply
	def actual_point_on_surface_2():
		def fget( self ):
			return self._actual_point_on_surface_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_point_on_surface_2 is mantatory and can not be set to None')
			if not check_type(value,point_on_surface):
				self._actual_point_on_surface_2 = point_on_surface(value)
			else:
				self._actual_point_on_surface_2 = value
		return property(**locals())

	@apply
	def actual_rotation():
		def fget( self ):
			return self._actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_rotation is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._actual_rotation = plane_angle_measure(value)
			else:
				self._actual_rotation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.pair_value.self.applies_to_pair.self.surface_pair.self.surface_1  ==  self.actual_point_on_surface_1.self.basis_surface)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.pair_value.self.applies_to_pair.self.surface_pair.self.surface_2  ==  self.actual_point_on_surface_2.self.basis_surface)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY action_property #
####################
class action_property(BaseEntityClass):
	'''Entity action_property definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param definition
	:type definition:characterized_action_definition
	'''
	def __init__( self , name,description,definition, ):
		self.name = name
		self.description = description
		self.definition = definition

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,characterized_action_definition):
				self._definition = characterized_action_definition(value)
			else:
				self._definition = value
		return property(**locals())

####################
 # ENTITY electric_current_measure_with_unit #
####################
class electric_current_measure_with_unit(measure_with_unit):
	'''Entity electric_current_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.ELECTRIC_CURRENT_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY gear_pair_range #
####################
class gear_pair_range(simple_pair_range):
	'''Entity gear_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:gear_pair

	:param lower_limit_actual_rotation_1
	:type lower_limit_actual_rotation_1:rotational_range_measure

	:param upper_limit_actual_rotation_1
	:type upper_limit_actual_rotation_1:rotational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,lower_limit_actual_rotation_1,upper_limit_actual_rotation_1, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.lower_limit_actual_rotation_1 = lower_limit_actual_rotation_1
		self.upper_limit_actual_rotation_1 = upper_limit_actual_rotation_1

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,gear_pair):
				self._simple_pair_range_applies_to_pair = gear_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def lower_limit_actual_rotation_1():
		def fget( self ):
			return self._lower_limit_actual_rotation_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_actual_rotation_1 is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_actual_rotation_1 = rotational_range_measure(value)
			else:
				self._lower_limit_actual_rotation_1 = value
		return property(**locals())

	@apply
	def upper_limit_actual_rotation_1():
		def fget( self ):
			return self._upper_limit_actual_rotation_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_actual_rotation_1 is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_actual_rotation_1 = rotational_range_measure(value)
			else:
				self._upper_limit_actual_rotation_1 = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_actual_rotation_1))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_actual_rotation_1))) XOR (self.lower_limit_actual_rotation_1  <  self.upper_limit_actual_rotation_1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY boxed_half_space #
####################
class boxed_half_space(half_space_solid):
	'''Entity boxed_half_space definition.

	:param enclosure
	:type enclosure:box_domain
	'''
	def __init__( self , inherited0__name , inherited1__base_surface , inherited2__agreement_flag , enclosure, ):
		half_space_solid.__init__(self , inherited0__name , inherited1__base_surface , inherited2__agreement_flag , )
		self.enclosure = enclosure

	@apply
	def enclosure():
		def fget( self ):
			return self._enclosure
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument enclosure is mantatory and can not be set to None')
			if not check_type(value,box_domain):
				self._enclosure = box_domain(value)
			else:
				self._enclosure = value
		return property(**locals())

####################
 # ENTITY product_definition_process #
####################
class product_definition_process(action):
	'''Entity product_definition_process definition.

	:param identification
	:type identification:identifier

	:param product_definitions
	:type product_definitions:SET(1,None,'process_product_association', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method , identification, ):
		action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )
		self.identification = identification

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument identification is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._identification = identifier(value)
			else:
				self._identification = value
		return property(**locals())

	@apply
	def product_definitions():
		def fget( self ):
			return self._product_definitions
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument product_definitions is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY product_process_plan #
####################
class product_process_plan(product_definition_process):
	'''Entity product_process_plan definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method , inherited3__identification ,  ):
		product_definition_process.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , inherited3__identification , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ACTION_RELATIONSHIP.RELATING_ACTION')))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY document_product_association #
####################
class document_product_association(BaseEntityClass):
	'''Entity document_product_association definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_document
	:type relating_document:document

	:param related_product
	:type related_product:product_or_formation_or_definition
	'''
	def __init__( self , name,description,relating_document,related_product, ):
		self.name = name
		self.description = description
		self.relating_document = relating_document
		self.related_product = related_product

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_document():
		def fget( self ):
			return self._relating_document
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_document is mantatory and can not be set to None')
			if not check_type(value,document):
				self._relating_document = document(value)
			else:
				self._relating_document = value
		return property(**locals())

	@apply
	def related_product():
		def fget( self ):
			return self._related_product
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_product is mantatory and can not be set to None')
			if not check_type(value,product_or_formation_or_definition):
				self._related_product = product_or_formation_or_definition(value)
			else:
				self._related_product = value
		return property(**locals())

####################
 # ENTITY document_product_equivalence #
####################
class document_product_equivalence(document_product_association):
	'''Entity document_product_equivalence definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_document , inherited3__related_product ,  ):
		document_product_association.__init__(self , inherited0__name , inherited1__description , inherited2__relating_document , inherited3__related_product , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  'equivalence')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'PRODUCT')  ==  TYPEOF(self.self.related_product)))  or  ((self.self.relating_document.self.kind.self.product_data_type  ==  'configuration controlled document')  and  (SIZEOF(None)  ==  1)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'PRODUCT_DEFINITION_FORMATION')  ==  TYPEOF(self.self.related_product)))  or  ((self.self.relating_document.self.kind.self.product_data_type  ==  'configuration controlled document version')  and  (SIZEOF(None)  ==  1)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'PRODUCT_DEFINITION')  ==  TYPEOF(self.self.related_product)))  or  ((self.self.relating_document.self.kind.self.product_data_type  ==  'configuration controlled document definition')  and  (SIZEOF(None)  ==  1)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY point_replica #
####################
class point_replica(point):
	'''Entity point_replica definition.

	:param parent_pt
	:type parent_pt:point

	:param transformation
	:type transformation:cartesian_transformation_operator
	'''
	def __init__( self , inherited0__name , parent_pt,transformation, ):
		point.__init__(self , inherited0__name , )
		self.parent_pt = parent_pt
		self.transformation = transformation

	@apply
	def parent_pt():
		def fget( self ):
			return self._parent_pt
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_pt is mantatory and can not be set to None')
			if not check_type(value,point):
				self._parent_pt = point(value)
			else:
				self._parent_pt = value
		return property(**locals())

	@apply
	def transformation():
		def fget( self ):
			return self._transformation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transformation is mantatory and can not be set to None')
			if not check_type(value,cartesian_transformation_operator):
				self._transformation = cartesian_transformation_operator(value)
			else:
				self._transformation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.transformation.self.dim  ==  self.parent_pt.self.dim)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = acyclic_point_replica(self,self.parent_pt)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY product #
####################
class product(BaseEntityClass):
	'''Entity product definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param frame_of_reference
	:type frame_of_reference:SET(1,None,'product_context', scope = schema_scope)
	'''
	def __init__( self , id,name,description,frame_of_reference, ):
		self.id = id
		self.name = name
		self.description = description
		self.frame_of_reference = frame_of_reference

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def frame_of_reference():
		def fget( self ):
			return self._frame_of_reference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument frame_of_reference is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'product_context', scope = schema_scope)):
				self._frame_of_reference = SET(value)
			else:
				self._frame_of_reference = value
		return property(**locals())

####################
 # ENTITY product_definition_context_association #
####################
class product_definition_context_association(BaseEntityClass):
	'''Entity product_definition_context_association definition.

	:param definition
	:type definition:product_definition

	:param frame_of_reference
	:type frame_of_reference:product_definition_context

	:param role
	:type role:product_definition_context_role
	'''
	def __init__( self , definition,frame_of_reference,role, ):
		self.definition = definition
		self.frame_of_reference = frame_of_reference
		self.role = role

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,product_definition):
				self._definition = product_definition(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def frame_of_reference():
		def fget( self ):
			return self._frame_of_reference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument frame_of_reference is mantatory and can not be set to None')
			if not check_type(value,product_definition_context):
				self._frame_of_reference = product_definition_context(value)
			else:
				self._frame_of_reference = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,product_definition_context_role):
				self._role = product_definition_context_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY datum_reference #
####################
class datum_reference(BaseEntityClass):
	'''Entity datum_reference definition.

	:param precedence
	:type precedence:INTEGER

	:param referenced_datum
	:type referenced_datum:datum
	'''
	def __init__( self , precedence,referenced_datum, ):
		self.precedence = precedence
		self.referenced_datum = referenced_datum

	@apply
	def precedence():
		def fget( self ):
			return self._precedence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument precedence is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._precedence = INTEGER(value)
			else:
				self._precedence = value
		return property(**locals())

	@apply
	def referenced_datum():
		def fget( self ):
			return self._referenced_datum
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument referenced_datum is mantatory and can not be set to None')
			if not check_type(value,datum):
				self._referenced_datum = datum(value)
			else:
				self._referenced_datum = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.precedence  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rectangular_trimmed_surface #
####################
class rectangular_trimmed_surface(bounded_surface):
	'''Entity rectangular_trimmed_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param u1
	:type u1:parameter_value

	:param u2
	:type u2:parameter_value

	:param v1
	:type v1:parameter_value

	:param v2
	:type v2:parameter_value

	:param usense
	:type usense:BOOLEAN

	:param vsense
	:type vsense:BOOLEAN
	'''
	def __init__( self , inherited0__name , basis_surface,u1,u2,v1,v2,usense,vsense, ):
		bounded_surface.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.u1 = u1
		self.u2 = u2
		self.v1 = v1
		self.v2 = v2
		self.usense = usense
		self.vsense = vsense

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def u1():
		def fget( self ):
			return self._u1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u1 is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._u1 = parameter_value(value)
			else:
				self._u1 = value
		return property(**locals())

	@apply
	def u2():
		def fget( self ):
			return self._u2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u2 is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._u2 = parameter_value(value)
			else:
				self._u2 = value
		return property(**locals())

	@apply
	def v1():
		def fget( self ):
			return self._v1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v1 is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._v1 = parameter_value(value)
			else:
				self._v1 = value
		return property(**locals())

	@apply
	def v2():
		def fget( self ):
			return self._v2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v2 is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._v2 = parameter_value(value)
			else:
				self._v2 = value
		return property(**locals())

	@apply
	def usense():
		def fget( self ):
			return self._usense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument usense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._usense = BOOLEAN(value)
			else:
				self._usense = value
		return property(**locals())

	@apply
	def vsense():
		def fget( self ):
			return self._vsense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vsense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._vsense = BOOLEAN(value)
			else:
				self._vsense = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.u1  !=  self.u2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.v1  !=  self.v2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (((('AUTOMOTIVE_DESIGN.ELEMENTARY_SURFACE'  ==  TYPEOF(self.basis_surface))  and  ( not ('AUTOMOTIVE_DESIGN.PLANE'  ==  TYPEOF(self.basis_surface))))  or  ('AUTOMOTIVE_DESIGN.SURFACE_OF_REVOLUTION'  ==  TYPEOF(self.basis_surface)))  or  (self.usense  ==  (self.u2  >  self.u1)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((('AUTOMOTIVE_DESIGN.SPHERICAL_SURFACE'  ==  TYPEOF(self.basis_surface))  or  ('AUTOMOTIVE_DESIGN.TOROIDAL_SURFACE'  ==  TYPEOF(self.basis_surface)))  or  (self.vsense  ==  (self.v2  >  self.v1)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY simple_string_expression #
####################
class simple_string_expression(string_expression,simple_generic_expression):
	'''Entity simple_string_expression definition.
	'''
	def __init__( self ,  ):
		string_expression.__init__(self , )
		simple_generic_expression.__init__(self , )

####################
 # ENTITY string_variable #
####################
class string_variable(simple_string_expression,variable):
	'''Entity string_variable definition.
	'''
	def __init__( self ,  ):
		simple_string_expression.__init__(self , )
		variable.__init__(self , )

####################
 # ENTITY id_attribute #
####################
class id_attribute(BaseEntityClass):
	'''Entity id_attribute definition.

	:param attribute_value
	:type attribute_value:identifier

	:param identified_item
	:type identified_item:id_attribute_select
	'''
	def __init__( self , attribute_value,identified_item, ):
		self.attribute_value = attribute_value
		self.identified_item = identified_item

	@apply
	def attribute_value():
		def fget( self ):
			return self._attribute_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_value is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._attribute_value = identifier(value)
			else:
				self._attribute_value = value
		return property(**locals())

	@apply
	def identified_item():
		def fget( self ):
			return self._identified_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument identified_item is mantatory and can not be set to None')
			if not check_type(value,id_attribute_select):
				self._identified_item = id_attribute_select(value)
			else:
				self._identified_item = value
		return property(**locals())

####################
 # ENTITY language #
####################
class language(group):
	'''Entity language definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY plane #
####################
class plane(elementary_surface):
	'''Entity plane definition.
	'''
	def __init__( self , inherited0__name , inherited1__position ,  ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )

####################
 # ENTITY pocket_bottom #
####################
class pocket_bottom(shape_aspect):
	'''Entity pocket_bottom definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.description  ==  ['planar','complex','through'])
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not (self.self.description  ==  ['planar','complex']))  or  ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not (self.self.description  ==  ['planar','complex']))  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'complex')  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1)))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.description  !=  'planar')  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1)))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = ((self.self.description  !=  'planar')  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1)))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = ((self.self.description  !=  'through')  or  (SIZEOF(None)  ==  0))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr


####################
 # ENTITY annotation_plane #
####################
class annotation_plane(annotation_occurrence,geometric_representation_item):
	'''Entity annotation_plane definition.

	:param elements
	:type elements:SET(1,None,'annotation_plane_element', scope = schema_scope)

	:param styled_item_item
	:type styled_item_item:plane_or_planar_box
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__name , elements,styled_item_item, ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		geometric_representation_item.__init__(self , inherited3__name , )
		self.elements = elements
		self.styled_item_item = styled_item_item

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'annotation_plane_element', scope = schema_scope)):
					self._elements = SET(value)
				else:
					self._elements = value
			else:
				self._elements = value
		return property(**locals())

	@apply
	def styled_item_item():
		def fget( self ):
			return self._styled_item_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_item_item is mantatory and can not be set to None')
			if not check_type(value,plane_or_planar_box):
				self._styled_item_item = plane_or_planar_box(value)
			else:
				self._styled_item_item = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'PLANAR_BOX')  ==  TYPEOF(self.self.styled_item.self.item)))  or  (('AUTOMOTIVE_DESIGN.'  +  'AXIS2_PLACEMENT_3D')  ==  TYPEOF(self.self.styled_item.self.item.self.planar_box.self.placement)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (((('AUTOMOTIVE_DESIGN.'  +  'PLANAR_BOX')  ==  TYPEOF(self.self.styled_item.self.item))  and  (('AUTOMOTIVE_DESIGN.'  +  'CURVE_STYLE')  ==  TYPEOF(self.self.styled_item.self.styles[1].self.presentation_style_assignment.self.styles[1])))  or  ((('AUTOMOTIVE_DESIGN.'  +  'PLANE')  ==  TYPEOF(self.self.styled_item.self.item))  and  (('AUTOMOTIVE_DESIGN.'  +  'FILL_AREA_STYLE')  ==  TYPEOF(self.self.styled_item.self.styles[1].self.presentation_style_assignment.self.styles[1]))))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((SIZEOF(self.self.styled_item.self.styles)  ==  1)  and  (SIZEOF(self.self.styled_item.self.styles[1].self.presentation_style_assignment.self.styles)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY circle #
####################
class circle(conic):
	'''Entity circle definition.

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY classification_role #
####################
class classification_role(BaseEntityClass):
	'''Entity classification_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY line #
####################
class line(curve):
	'''Entity line definition.

	:param pnt
	:type pnt:cartesian_point

	:param dir
	:type dir:vector
	'''
	def __init__( self , inherited0__name , pnt,dir, ):
		curve.__init__(self , inherited0__name , )
		self.pnt = pnt
		self.dir = dir

	@apply
	def pnt():
		def fget( self ):
			return self._pnt
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pnt is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._pnt = cartesian_point(value)
			else:
				self._pnt = value
		return property(**locals())

	@apply
	def dir():
		def fget( self ):
			return self._dir
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dir is mantatory and can not be set to None')
			if not check_type(value,vector):
				self._dir = vector(value)
			else:
				self._dir = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.dir.self.dim  ==  self.pnt.self.dim)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY revolute_pair_value #
####################
class revolute_pair_value(pair_value):
	'''Entity revolute_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:revolute_pair

	:param actual_rotation
	:type actual_rotation:plane_angle_measure
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_rotation, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_rotation = actual_rotation

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,revolute_pair):
				self._pair_value_applies_to_pair = revolute_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_rotation():
		def fget( self ):
			return self._actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_rotation is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._actual_rotation = plane_angle_measure(value)
			else:
				self._actual_rotation = value
		return property(**locals())

####################
 # ENTITY approximation_tolerance_deviation #
####################
class approximation_tolerance_deviation(founded_item):
	'''Entity approximation_tolerance_deviation definition.

	:param tessellation_type
	:type tessellation_type:approximation_method

	:param tolerances
	:type tolerances:SET(1,2,'tolerance_deviation_select', scope = schema_scope)

	:param definition_space
	:type definition_space:product_or_presentation_space
	'''
	def __init__( self , tessellation_type,tolerances,definition_space, ):
		founded_item.__init__(self , )
		self.tessellation_type = tessellation_type
		self.tolerances = tolerances
		self.definition_space = definition_space

	@apply
	def tessellation_type():
		def fget( self ):
			return self._tessellation_type
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tessellation_type is mantatory and can not be set to None')
			if not check_type(value,approximation_method):
				self._tessellation_type = approximation_method(value)
			else:
				self._tessellation_type = value
		return property(**locals())

	@apply
	def tolerances():
		def fget( self ):
			return self._tolerances
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tolerances is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'tolerance_deviation_select', scope = schema_scope)):
				self._tolerances = SET(value)
			else:
				self._tolerances = value
		return property(**locals())

	@apply
	def definition_space():
		def fget( self ):
			return self._definition_space
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition_space is mantatory and can not be set to None')
			if not check_type(value,product_or_presentation_space):
				self._definition_space = product_or_presentation_space(value)
			else:
				self._definition_space = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.self.tolerances)  ==  1) XOR (TYPEOF(self.self.tolerances[1])  !=  TYPEOF(self.self.tolerances[2])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY general_property_association #
####################
class general_property_association(BaseEntityClass):
	'''Entity general_property_association definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param base_definition
	:type base_definition:general_property

	:param derived_definition
	:type derived_definition:derived_property_select
	'''
	def __init__( self , name,description,base_definition,derived_definition, ):
		self.name = name
		self.description = description
		self.base_definition = base_definition
		self.derived_definition = derived_definition

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def base_definition():
		def fget( self ):
			return self._base_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base_definition is mantatory and can not be set to None')
			if not check_type(value,general_property):
				self._base_definition = general_property(value)
			else:
				self._base_definition = value
		return property(**locals())

	@apply
	def derived_definition():
		def fget( self ):
			return self._derived_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument derived_definition is mantatory and can not be set to None')
			if not check_type(value,derived_property_select):
				self._derived_definition = derived_property_select(value)
			else:
				self._derived_definition = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self.derived_definition,'AUTOMOTIVE_DESIGN.GENERAL_PROPERTY_ASSOCIATION.DERIVED_DEFINITION'))  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.derived_definition.self.name  ==  self.base_definition.self.name)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY screw_pair_range #
####################
class screw_pair_range(simple_pair_range):
	'''Entity screw_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:screw_pair

	:param lower_limit_actual_rotation
	:type lower_limit_actual_rotation:rotational_range_measure

	:param upper_limit_actual_rotation
	:type upper_limit_actual_rotation:rotational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,lower_limit_actual_rotation,upper_limit_actual_rotation, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.lower_limit_actual_rotation = lower_limit_actual_rotation
		self.upper_limit_actual_rotation = upper_limit_actual_rotation

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,screw_pair):
				self._simple_pair_range_applies_to_pair = screw_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def lower_limit_actual_rotation():
		def fget( self ):
			return self._lower_limit_actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_actual_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_actual_rotation = rotational_range_measure(value)
			else:
				self._lower_limit_actual_rotation = value
		return property(**locals())

	@apply
	def upper_limit_actual_rotation():
		def fget( self ):
			return self._upper_limit_actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_actual_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_actual_rotation = rotational_range_measure(value)
			else:
				self._upper_limit_actual_rotation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_actual_rotation))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_actual_rotation))) XOR (self.lower_limit_actual_rotation  <  self.upper_limit_actual_rotation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY event_occurrence_context_assignment #
####################
class event_occurrence_context_assignment(BaseEntityClass):
	'''Entity event_occurrence_context_assignment definition.

	:param assigned_event_occurrence_assignment
	:type assigned_event_occurrence_assignment:event_occurrence_assignment

	:param role
	:type role:event_occurrence_context_role
	'''
	def __init__( self , assigned_event_occurrence_assignment,role, ):
		self.assigned_event_occurrence_assignment = assigned_event_occurrence_assignment
		self.role = role

	@apply
	def assigned_event_occurrence_assignment():
		def fget( self ):
			return self._assigned_event_occurrence_assignment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_event_occurrence_assignment is mantatory and can not be set to None')
			if not check_type(value,event_occurrence_assignment):
				self._assigned_event_occurrence_assignment = event_occurrence_assignment(value)
			else:
				self._assigned_event_occurrence_assignment = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,event_occurrence_context_role):
				self._role = event_occurrence_context_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY property_definition_representation #
####################
class property_definition_representation(BaseEntityClass):
	'''Entity property_definition_representation definition.

	:param definition
	:type definition:represented_definition

	:param used_representation
	:type used_representation:representation

	:param description
	:type description:text

	:param name
	:type name:label
	'''
	def __init__( self , definition,used_representation, ):
		self.definition = definition
		self.used_representation = used_representation

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,represented_definition):
				self._definition = represented_definition(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def used_representation():
		def fget( self ):
			return self._used_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument used_representation is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._used_representation = representation(value)
			else:
				self._used_representation = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY surface_style_segmentation_curve #
####################
class surface_style_segmentation_curve(founded_item):
	'''Entity surface_style_segmentation_curve definition.

	:param style_of_segmentation_curve
	:type style_of_segmentation_curve:curve_or_render
	'''
	def __init__( self , style_of_segmentation_curve, ):
		founded_item.__init__(self , )
		self.style_of_segmentation_curve = style_of_segmentation_curve

	@apply
	def style_of_segmentation_curve():
		def fget( self ):
			return self._style_of_segmentation_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_segmentation_curve is mantatory and can not be set to None')
			if not check_type(value,curve_or_render):
				self._style_of_segmentation_curve = curve_or_render(value)
			else:
				self._style_of_segmentation_curve = value
		return property(**locals())

####################
 # ENTITY view_volume #
####################
class view_volume(founded_item):
	'''Entity view_volume definition.

	:param projection_type
	:type projection_type:central_or_parallel

	:param projection_point
	:type projection_point:cartesian_point

	:param view_plane_distance
	:type view_plane_distance:length_measure

	:param front_plane_distance
	:type front_plane_distance:length_measure

	:param front_plane_clipping
	:type front_plane_clipping:BOOLEAN

	:param back_plane_distance
	:type back_plane_distance:length_measure

	:param back_plane_clipping
	:type back_plane_clipping:BOOLEAN

	:param view_volume_sides_clipping
	:type view_volume_sides_clipping:BOOLEAN

	:param view_window
	:type view_window:planar_box
	'''
	def __init__( self , projection_type,projection_point,view_plane_distance,front_plane_distance,front_plane_clipping,back_plane_distance,back_plane_clipping,view_volume_sides_clipping,view_window, ):
		founded_item.__init__(self , )
		self.projection_type = projection_type
		self.projection_point = projection_point
		self.view_plane_distance = view_plane_distance
		self.front_plane_distance = front_plane_distance
		self.front_plane_clipping = front_plane_clipping
		self.back_plane_distance = back_plane_distance
		self.back_plane_clipping = back_plane_clipping
		self.view_volume_sides_clipping = view_volume_sides_clipping
		self.view_window = view_window

	@apply
	def projection_type():
		def fget( self ):
			return self._projection_type
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument projection_type is mantatory and can not be set to None')
			if not check_type(value,central_or_parallel):
				self._projection_type = central_or_parallel(value)
			else:
				self._projection_type = value
		return property(**locals())

	@apply
	def projection_point():
		def fget( self ):
			return self._projection_point
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument projection_point is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._projection_point = cartesian_point(value)
			else:
				self._projection_point = value
		return property(**locals())

	@apply
	def view_plane_distance():
		def fget( self ):
			return self._view_plane_distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument view_plane_distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._view_plane_distance = length_measure(value)
			else:
				self._view_plane_distance = value
		return property(**locals())

	@apply
	def front_plane_distance():
		def fget( self ):
			return self._front_plane_distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument front_plane_distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._front_plane_distance = length_measure(value)
			else:
				self._front_plane_distance = value
		return property(**locals())

	@apply
	def front_plane_clipping():
		def fget( self ):
			return self._front_plane_clipping
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument front_plane_clipping is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._front_plane_clipping = BOOLEAN(value)
			else:
				self._front_plane_clipping = value
		return property(**locals())

	@apply
	def back_plane_distance():
		def fget( self ):
			return self._back_plane_distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument back_plane_distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._back_plane_distance = length_measure(value)
			else:
				self._back_plane_distance = value
		return property(**locals())

	@apply
	def back_plane_clipping():
		def fget( self ):
			return self._back_plane_clipping
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument back_plane_clipping is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._back_plane_clipping = BOOLEAN(value)
			else:
				self._back_plane_clipping = value
		return property(**locals())

	@apply
	def view_volume_sides_clipping():
		def fget( self ):
			return self._view_volume_sides_clipping
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument view_volume_sides_clipping is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._view_volume_sides_clipping = BOOLEAN(value)
			else:
				self._view_volume_sides_clipping = value
		return property(**locals())

	@apply
	def view_window():
		def fget( self ):
			return self._view_window
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument view_window is mantatory and can not be set to None')
			if not check_type(value,planar_box):
				self._view_window = planar_box(value)
			else:
				self._view_window = value
		return property(**locals())

####################
 # ENTITY curve_swept_solid_shape_representation #
####################
class curve_swept_solid_shape_representation(shape_representation):
	'''Entity curve_swept_solid_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY material_property_representation #
####################
class material_property_representation(property_definition_representation):
	'''Entity material_property_representation definition.

	:param dependent_environment
	:type dependent_environment:data_environment
	'''
	def __init__( self , inherited0__definition , inherited1__used_representation , dependent_environment, ):
		property_definition_representation.__init__(self , inherited0__definition , inherited1__used_representation , )
		self.dependent_environment = dependent_environment

	@apply
	def dependent_environment():
		def fget( self ):
			return self._dependent_environment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dependent_environment is mantatory and can not be set to None')
			if not check_type(value,data_environment):
				self._dependent_environment = data_environment(value)
			else:
				self._dependent_environment = value
		return property(**locals())

####################
 # ENTITY geometrical_tolerance_callout #
####################
class geometrical_tolerance_callout(draughting_callout):
	'''Entity geometrical_tolerance_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY comparison_equal #
####################
class comparison_equal(comparison_expression):
	'''Entity comparison_equal definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		comparison_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY geometric_set #
####################
class geometric_set(geometric_representation_item):
	'''Entity geometric_set definition.

	:param elements
	:type elements:SET(1,None,'geometric_set_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , elements, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.elements = elements

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument elements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'geometric_set_select', scope = schema_scope)):
				self._elements = SET(value)
			else:
				self._elements = value
		return property(**locals())

####################
 # ENTITY geometric_curve_set #
####################
class geometric_curve_set(geometric_set):
	'''Entity geometric_curve_set definition.
	'''
	def __init__( self , inherited0__name , inherited1__elements ,  ):
		geometric_set.__init__(self , inherited0__name , inherited1__elements , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY prismatic_pair #
####################
class prismatic_pair(kinematic_pair):
	'''Entity prismatic_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint ,  ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )

####################
 # ENTITY vee_profile #
####################
class vee_profile(shape_aspect):
	'''Entity vee_profile definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr


####################
 # ENTITY minus_function #
####################
class minus_function(unary_function_call):
	'''Entity minus_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY personal_address #
####################
class personal_address(address):
	'''Entity personal_address definition.

	:param people
	:type people:SET(1,None,'person', scope = schema_scope)

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , people,description, ):
		address.__init__(self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , )
		self.people = people
		self.description = description

	@apply
	def people():
		def fget( self ):
			return self._people
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument people is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'person', scope = schema_scope)):
				self._people = SET(value)
			else:
				self._people = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY document_relationship #
####################
class document_relationship(BaseEntityClass):
	'''Entity document_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_document
	:type relating_document:document

	:param related_document
	:type related_document:document
	'''
	def __init__( self , name,description,relating_document,related_document, ):
		self.name = name
		self.description = description
		self.relating_document = relating_document
		self.related_document = related_document

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_document():
		def fget( self ):
			return self._relating_document
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_document is mantatory and can not be set to None')
			if not check_type(value,document):
				self._relating_document = document(value)
			else:
				self._relating_document = value
		return property(**locals())

	@apply
	def related_document():
		def fget( self ):
			return self._related_document
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_document is mantatory and can not be set to None')
			if not check_type(value,document):
				self._related_document = document(value)
			else:
				self._related_document = value
		return property(**locals())

####################
 # ENTITY make_from_usage_option #
####################
class make_from_usage_option(product_definition_usage):
	'''Entity make_from_usage_option definition.

	:param ranking
	:type ranking:INTEGER

	:param ranking_rationale
	:type ranking_rationale:text

	:param quantity
	:type quantity:measure_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , ranking,ranking_rationale,quantity, ):
		product_definition_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )
		self.ranking = ranking
		self.ranking_rationale = ranking_rationale
		self.quantity = quantity

	@apply
	def ranking():
		def fget( self ):
			return self._ranking
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ranking is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._ranking = INTEGER(value)
			else:
				self._ranking = value
		return property(**locals())

	@apply
	def ranking_rationale():
		def fget( self ):
			return self._ranking_rationale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ranking_rationale is mantatory and can not be set to None')
			if not check_type(value,text):
				self._ranking_rationale = text(value)
			else:
				self._ranking_rationale = value
		return property(**locals())

	@apply
	def quantity():
		def fget( self ):
			return self._quantity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument quantity is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._quantity = measure_with_unit(value)
			else:
				self._quantity = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not ('NUMBER'  ==  TYPEOF(self.quantity.self.value_component)))  or  (self.quantity.self.value_component  >  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY outer_boundary_curve #
####################
class outer_boundary_curve(boundary_curve):
	'''Entity outer_boundary_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__segments , inherited2__self_intersect ,  ):
		boundary_curve.__init__(self , inherited0__name , inherited1__segments , inherited2__self_intersect , )

####################
 # ENTITY shape_representation_relationship #
####################
class shape_representation_relationship(representation_relationship):
	'''Entity shape_representation_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 ,  ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.SHAPE_REPRESENTATION'  ==  (TYPEOF(self.self.representation_relationship.self.rep_1)  +  TYPEOF(self.self.representation_relationship.self.rep_2)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY type_qualifier #
####################
class type_qualifier(BaseEntityClass):
	'''Entity type_qualifier definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY annotation_fill_area #
####################
class annotation_fill_area(geometric_representation_item):
	'''Entity annotation_fill_area definition.

	:param boundaries
	:type boundaries:SET(1,None,'curve', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , boundaries, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.boundaries = boundaries

	@apply
	def boundaries():
		def fget( self ):
			return self._boundaries
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument boundaries is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'curve', scope = schema_scope)):
				self._boundaries = SET(value)
			else:
				self._boundaries = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.self.geometric_representation_item.self.dim  ==  3)  or  (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_approval_assignment #
####################
class applied_approval_assignment(approval_assignment):
	'''Entity applied_approval_assignment definition.

	:param items
	:type items:SET(1,None,'approval_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_approval , items, ):
		approval_assignment.__init__(self , inherited0__assigned_approval , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'approval_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY assembly_component_usage_substitute #
####################
class assembly_component_usage_substitute(BaseEntityClass):
	'''Entity assembly_component_usage_substitute definition.

	:param name
	:type name:label

	:param definition
	:type definition:text

	:param base
	:type base:assembly_component_usage

	:param substitute
	:type substitute:assembly_component_usage
	'''
	def __init__( self , name,definition,base,substitute, ):
		self.name = name
		self.definition = definition
		self.base = base
		self.substitute = substitute

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._definition = text(value)
				else:
					self._definition = value
			else:
				self._definition = value
		return property(**locals())

	@apply
	def base():
		def fget( self ):
			return self._base
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base is mantatory and can not be set to None')
			if not check_type(value,assembly_component_usage):
				self._base = assembly_component_usage(value)
			else:
				self._base = value
		return property(**locals())

	@apply
	def substitute():
		def fget( self ):
			return self._substitute
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument substitute is mantatory and can not be set to None')
			if not check_type(value,assembly_component_usage):
				self._substitute = assembly_component_usage(value)
			else:
				self._substitute = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.base.self.relating_product_definition  ==  self.substitute.self.relating_product_definition)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.base  !=  self.substitute)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY drawing_definition #
####################
class drawing_definition(BaseEntityClass):
	'''Entity drawing_definition definition.

	:param drawing_number
	:type drawing_number:identifier

	:param drawing_type
	:type drawing_type:label
	'''
	def __init__( self , drawing_number,drawing_type, ):
		self.drawing_number = drawing_number
		self.drawing_type = drawing_type

	@apply
	def drawing_number():
		def fget( self ):
			return self._drawing_number
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument drawing_number is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._drawing_number = identifier(value)
			else:
				self._drawing_number = value
		return property(**locals())

	@apply
	def drawing_type():
		def fget( self ):
			return self._drawing_type
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._drawing_type = label(value)
				else:
					self._drawing_type = value
			else:
				self._drawing_type = value
		return property(**locals())

####################
 # ENTITY degenerate_pcurve #
####################
class degenerate_pcurve(point):
	'''Entity degenerate_pcurve definition.

	:param basis_surface
	:type basis_surface:surface

	:param reference_to_curve
	:type reference_to_curve:definitional_representation
	'''
	def __init__( self , inherited0__name , basis_surface,reference_to_curve, ):
		point.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.reference_to_curve = reference_to_curve

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def reference_to_curve():
		def fget( self ):
			return self._reference_to_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reference_to_curve is mantatory and can not be set to None')
			if not check_type(value,definitional_representation):
				self._reference_to_curve = definitional_representation(value)
			else:
				self._reference_to_curve = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.reference_to_curve.self.representation.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AUTOMOTIVE_DESIGN.CURVE'  ==  TYPEOF(self.reference_to_curve.self.representation.self.items[1]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.reference_to_curve.self.representation.self.items[1].self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY evaluated_degenerate_pcurve #
####################
class evaluated_degenerate_pcurve(degenerate_pcurve):
	'''Entity evaluated_degenerate_pcurve definition.

	:param equivalent_point
	:type equivalent_point:cartesian_point
	'''
	def __init__( self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , equivalent_point, ):
		degenerate_pcurve.__init__(self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , )
		self.equivalent_point = equivalent_point

	@apply
	def equivalent_point():
		def fget( self ):
			return self._equivalent_point
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument equivalent_point is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._equivalent_point = cartesian_point(value)
			else:
				self._equivalent_point = value
		return property(**locals())

####################
 # ENTITY open_path_profile #
####################
class open_path_profile(shape_aspect):
	'''Entity open_path_profile definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  ==  SIZEOF(None)))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY solid_angle_measure_with_unit #
####################
class solid_angle_measure_with_unit(measure_with_unit):
	'''Entity solid_angle_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.SOLID_ANGLE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY resource_requirement_type #
####################
class resource_requirement_type(BaseEntityClass):
	'''Entity resource_requirement_type definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY replicate_feature #
####################
class replicate_feature(feature_definition):
	'''Entity replicate_feature definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY circular_pattern #
####################
class circular_pattern(replicate_feature):
	'''Entity circular_pattern definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		replicate_feature.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  <=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY connected_edge_set #
####################
class connected_edge_set(topological_representation_item):
	'''Entity connected_edge_set definition.

	:param ces_edges
	:type ces_edges:SET(1,None,'edge', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , ces_edges, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.ces_edges = ces_edges

	@apply
	def ces_edges():
		def fget( self ):
			return self._ces_edges
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ces_edges is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'edge', scope = schema_scope)):
				self._ces_edges = SET(value)
			else:
				self._ces_edges = value
		return property(**locals())

####################
 # ENTITY externally_defined_feature_definition #
####################
class externally_defined_feature_definition(feature_definition,externally_defined_item):
	'''Entity externally_defined_feature_definition definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__item_id , inherited3__source ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
		externally_defined_item.__init__(self , inherited2__item_id , inherited3__source , )
	def wr1(self):
		eval_wr1_wr = ((self.self.externally_defined_item.self.item_id  ==  'external thread')  and  (self.self.externally_defined_item.self.source.self.source_id  ==  'external feature specification'))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS'))  ==  1)  or  ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.APPLIED_DOCUMENT_REFERENCE.ITEMS'))  +  SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT.ITEMS')))  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  1)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  <=  1)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY homokinetic_pair #
####################
class homokinetic_pair(universal_pair):
	'''Entity homokinetic_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , inherited5__input_skew_angle ,  ):
		universal_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , inherited5__input_skew_angle , )
	def wr1(self):
		eval_wr1_wr = ( not EXISTS(self.self.input_skew_angle))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY executed_action #
####################
class executed_action(action):
	'''Entity executed_action definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method ,  ):
		action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )

####################
 # ENTITY directed_action #
####################
class directed_action(executed_action):
	'''Entity directed_action definition.

	:param directive
	:type directive:action_directive
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method , directive, ):
		executed_action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )
		self.directive = directive

	@apply
	def directive():
		def fget( self ):
			return self._directive
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directive is mantatory and can not be set to None')
			if not check_type(value,action_directive):
				self._directive = action_directive(value)
			else:
				self._directive = value
		return property(**locals())

####################
 # ENTITY pre_defined_curve_font #
####################
class pre_defined_curve_font(pre_defined_item):
	'''Entity pre_defined_curve_font definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )

####################
 # ENTITY draughting_pre_defined_curve_font #
####################
class draughting_pre_defined_curve_font(pre_defined_curve_font):
	'''Entity draughting_pre_defined_curve_font definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_curve_font.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['continuous','chain','chain double dash','dashed','dotted'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY draughting_specification_reference #
####################
class draughting_specification_reference(document_reference):
	'''Entity draughting_specification_reference definition.

	:param specified_items
	:type specified_items:SET(1,None,'specified_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_document , inherited1__source , specified_items, ):
		document_reference.__init__(self , inherited0__assigned_document , inherited1__source , )
		self.specified_items = specified_items

	@apply
	def specified_items():
		def fget( self ):
			return self._specified_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument specified_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'specified_item', scope = schema_scope)):
				self._specified_items = SET(value)
			else:
				self._specified_items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.assigned_document.self.kind.self.product_data_type  ==  'draughting specification')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY instanced_feature #
####################
class instanced_feature(shape_aspect,feature_definition):
	'''Entity instanced_feature definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , inherited4__name , inherited5__description ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		feature_definition.__init__(self , inherited4__name , inherited5__description , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'PRODUCT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = self.self.product_definitional
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY organizational_project #
####################
class organizational_project(BaseEntityClass):
	'''Entity organizational_project definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param responsible_organizations
	:type responsible_organizations:SET(1,None,'organization', scope = schema_scope)

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description,responsible_organizations, ):
		self.name = name
		self.description = description
		self.responsible_organizations = responsible_organizations

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def responsible_organizations():
		def fget( self ):
			return self._responsible_organizations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument responsible_organizations is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'organization', scope = schema_scope)):
				self._responsible_organizations = SET(value)
			else:
				self._responsible_organizations = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY date_time_role #
####################
class date_time_role(BaseEntityClass):
	'''Entity date_time_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ratio_unit #
####################
class ratio_unit(named_unit):
	'''Entity ratio_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_style_reflectance_ambient_diffuse_specular #
####################
class surface_style_reflectance_ambient_diffuse_specular(surface_style_reflectance_ambient_diffuse):
	'''Entity surface_style_reflectance_ambient_diffuse_specular definition.

	:param specular_reflectance
	:type specular_reflectance:REAL

	:param specular_exponent
	:type specular_exponent:REAL

	:param specular_colour
	:type specular_colour:colour
	'''
	def __init__( self , inherited0__ambient_reflectance , inherited1__diffuse_reflectance , specular_reflectance,specular_exponent,specular_colour, ):
		surface_style_reflectance_ambient_diffuse.__init__(self , inherited0__ambient_reflectance , inherited1__diffuse_reflectance , )
		self.specular_reflectance = specular_reflectance
		self.specular_exponent = specular_exponent
		self.specular_colour = specular_colour

	@apply
	def specular_reflectance():
		def fget( self ):
			return self._specular_reflectance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument specular_reflectance is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._specular_reflectance = REAL(value)
			else:
				self._specular_reflectance = value
		return property(**locals())

	@apply
	def specular_exponent():
		def fget( self ):
			return self._specular_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument specular_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._specular_exponent = REAL(value)
			else:
				self._specular_exponent = value
		return property(**locals())

	@apply
	def specular_colour():
		def fget( self ):
			return self._specular_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument specular_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._specular_colour = colour(value)
			else:
				self._specular_colour = value
		return property(**locals())

####################
 # ENTITY xor_expression #
####################
class xor_expression(binary_boolean_expression):
	'''Entity xor_expression definition.

	:param binary_generic_expression_operands
	:type binary_generic_expression_operands:LIST(2,2,'boolean_expression', scope = schema_scope)
	'''
	def __init__( self , inherited0__operands , binary_generic_expression_operands, ):
		binary_boolean_expression.__init__(self , inherited0__operands , )
		self.binary_generic_expression_operands = binary_generic_expression_operands

	@apply
	def binary_generic_expression_operands():
		def fget( self ):
			return self._binary_generic_expression_operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument binary_generic_expression_operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'boolean_expression', scope = schema_scope)):
				self._binary_generic_expression_operands = LIST(value)
			else:
				self._binary_generic_expression_operands = value
		return property(**locals())

####################
 # ENTITY action_relationship #
####################
class action_relationship(BaseEntityClass):
	'''Entity action_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_action
	:type relating_action:action

	:param related_action
	:type related_action:action
	'''
	def __init__( self , name,description,relating_action,related_action, ):
		self.name = name
		self.description = description
		self.relating_action = relating_action
		self.related_action = related_action

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_action():
		def fget( self ):
			return self._relating_action
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_action is mantatory and can not be set to None')
			if not check_type(value,action):
				self._relating_action = action(value)
			else:
				self._relating_action = value
		return property(**locals())

	@apply
	def related_action():
		def fget( self ):
			return self._related_action
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_action is mantatory and can not be set to None')
			if not check_type(value,action):
				self._related_action = action(value)
			else:
				self._related_action = value
		return property(**locals())

####################
 # ENTITY applied_document_reference #
####################
class applied_document_reference(document_reference):
	'''Entity applied_document_reference definition.

	:param items
	:type items:SET(1,None,'document_reference_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_document , inherited1__source , items, ):
		document_reference.__init__(self , inherited0__assigned_document , inherited1__source , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'document_reference_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (self.self.role.self.name  ==  'general tolerance definition'))  or  item_correlation(self.self.items,['REPRESENTATION']))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((self.self.role.self.name  ==  'general tolerance definition')  or  item_correlation(self.self.items,['ACTION','ACTION_DIRECTIVE','ACTION_METHOD','ACTION_RELATIONSHIP','APPLIED_ACTION_ASSIGNMENT','APPROVAL','CERTIFICATION','CLASS','CLASS_SYSTEM','CONFIGURATION_DESIGN','CONFIGURATION_ITEM','CONTRACT','FEATURE_DEFINITION','GENERAL_PROPERTY','MATERIAL_DESIGNATION','ORGANIZATION','ORGANIZATIONAL_PROJECT','PERSON','PRODUCT_CONCEPT','PRODUCT_CONCEPT_FEATURE','PRODUCT_CONCEPT_FEATURE_CATEGORY','PRODUCT_DEFINITION','PRODUCT_DEFINITION_FORMATION','PRODUCT_DEFINITION_FORMATION_RELATIONSHIP','PRODUCT_DEFINITION_RELATIONSHIP','PRODUCT_DEFINITION_SUBSTITUTE','PRODUCT_RELATED_PRODUCT_CATEGORY','PROPERTY_DEFINITION','REPRESENTATION','RESOURCE_REQUIREMENT_TYPE','SECURITY_CLASSIFICATION','SHAPE_ASPECT','SHAPE_ASPECT_RELATIONSHIP','VERSIONED_ACTION_REQUEST']))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY area_in_set #
####################
class area_in_set(BaseEntityClass):
	'''Entity area_in_set definition.

	:param area
	:type area:presentation_area

	:param in_set
	:type in_set:presentation_set
	'''
	def __init__( self , area,in_set, ):
		self.area = area
		self.in_set = in_set

	@apply
	def area():
		def fget( self ):
			return self._area
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument area is mantatory and can not be set to None')
			if not check_type(value,presentation_area):
				self._area = presentation_area(value)
			else:
				self._area = value
		return property(**locals())

	@apply
	def in_set():
		def fget( self ):
			return self._in_set
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument in_set is mantatory and can not be set to None')
			if not check_type(value,presentation_set):
				self._in_set = presentation_set(value)
			else:
				self._in_set = value
		return property(**locals())

####################
 # ENTITY extruded_area_solid #
####################
class extruded_area_solid(swept_area_solid):
	'''Entity extruded_area_solid definition.

	:param extruded_direction
	:type extruded_direction:direction

	:param depth
	:type depth:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__swept_area , extruded_direction,depth, ):
		swept_area_solid.__init__(self , inherited0__name , inherited1__swept_area , )
		self.extruded_direction = extruded_direction
		self.depth = depth

	@apply
	def extruded_direction():
		def fget( self ):
			return self._extruded_direction
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extruded_direction is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._extruded_direction = direction(value)
			else:
				self._extruded_direction = value
		return property(**locals())

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._depth = positive_length_measure(value)
			else:
				self._depth = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (dot_product(self.self.swept_area_solid.self.swept_area.self.basis_surface.self.elementary_surface.self.position.self.p[3],self.extruded_direction)  !=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY kinematic_ground_representation #
####################
class kinematic_ground_representation(representation):
	'''Entity kinematic_ground_representation definition.

	:param property
	:type property:kinematic_property_representation_relation
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )

	@apply
	def property():
		def fget( self ):
			return self._property
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument property is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT'  ==  TYPEOF(self.self.representation.self.context_of_items))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY kinematic_joint #
####################
class kinematic_joint(BaseEntityClass):
	'''Entity kinematic_joint definition.

	:param first_link
	:type first_link:kinematic_link

	:param second_link
	:type second_link:kinematic_link

	:param structure
	:type structure:kinematic_structure
	'''
	def __init__( self , first_link,second_link, ):
		self.first_link = first_link
		self.second_link = second_link

	@apply
	def first_link():
		def fget( self ):
			return self._first_link
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument first_link is mantatory and can not be set to None')
			if not check_type(value,kinematic_link):
				self._first_link = kinematic_link(value)
			else:
				self._first_link = value
		return property(**locals())

	@apply
	def second_link():
		def fget( self ):
			return self._second_link
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument second_link is mantatory and can not be set to None')
			if not check_type(value,kinematic_link):
				self._second_link = kinematic_link(value)
			else:
				self._second_link = value
		return property(**locals())

	@apply
	def structure():
		def fget( self ):
			return self._structure
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument structure is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.first_link  !=  self.second_link)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY power_expression #
####################
class power_expression(binary_numeric_expression):
	'''Entity power_expression definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		binary_numeric_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY external_source #
####################
class external_source(BaseEntityClass):
	'''Entity external_source definition.

	:param source_id
	:type source_id:source_item

	:param description
	:type description:text
	'''
	def __init__( self , source_id, ):
		self.source_id = source_id

	@apply
	def source_id():
		def fget( self ):
			return self._source_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source_id is mantatory and can not be set to None')
			if not check_type(value,source_item):
				self._source_id = source_item(value)
			else:
				self._source_id = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY known_source #
####################
class known_source(external_source,pre_defined_item):
	'''Entity known_source definition.
	'''
	def __init__( self , inherited0__source_id , inherited1__name ,  ):
		external_source.__init__(self , inherited0__source_id , )
		pre_defined_item.__init__(self , inherited1__name , )

####################
 # ENTITY extension #
####################
class extension(derived_shape_aspect):
	'''Entity extension definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY colour_specification #
####################
class colour_specification(colour):
	'''Entity colour_specification definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		colour.__init__(self , )
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY curve_bounded_surface #
####################
class curve_bounded_surface(bounded_surface):
	'''Entity curve_bounded_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param boundaries
	:type boundaries:SET(1,None,'boundary_curve', scope = schema_scope)

	:param implicit_outer
	:type implicit_outer:BOOLEAN
	'''
	def __init__( self , inherited0__name , basis_surface,boundaries,implicit_outer, ):
		bounded_surface.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.boundaries = boundaries
		self.implicit_outer = implicit_outer

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def boundaries():
		def fget( self ):
			return self._boundaries
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument boundaries is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'boundary_curve', scope = schema_scope)):
				self._boundaries = SET(value)
			else:
				self._boundaries = value
		return property(**locals())

	@apply
	def implicit_outer():
		def fget( self ):
			return self._implicit_outer
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument implicit_outer is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._implicit_outer = BOOLEAN(value)
			else:
				self._implicit_outer = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not self.implicit_outer)  or  (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not self.implicit_outer)  or  ('AUTOMOTIVE_DESIGN.BOUNDED_SURFACE'  ==  TYPEOF(self.basis_surface)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  <=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY feature_pattern #
####################
class feature_pattern(replicate_feature):
	'''Entity feature_pattern definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		replicate_feature.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY leader_curve #
####################
class leader_curve(annotation_curve_occurrence):
	'''Entity leader_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item ,  ):
		annotation_curve_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY material_designation #
####################
class material_designation(BaseEntityClass):
	'''Entity material_designation definition.

	:param name
	:type name:label

	:param definitions
	:type definitions:SET(1,None,'characterized_definition', scope = schema_scope)
	'''
	def __init__( self , name,definitions, ):
		self.name = name
		self.definitions = definitions

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def definitions():
		def fget( self ):
			return self._definitions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definitions is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'characterized_definition', scope = schema_scope)):
				self._definitions = SET(value)
			else:
				self._definitions = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY background_colour #
####################
class background_colour(colour):
	'''Entity background_colour definition.

	:param presentation
	:type presentation:area_or_view
	'''
	def __init__( self , presentation, ):
		colour.__init__(self , )
		self.presentation = presentation

	@apply
	def presentation():
		def fget( self ):
			return self._presentation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument presentation is mantatory and can not be set to None')
			if not check_type(value,area_or_view):
				self._presentation = area_or_view(value)
			else:
				self._presentation = value
		return property(**locals())

####################
 # ENTITY closed_shell #
####################
class closed_shell(connected_face_set):
	'''Entity closed_shell definition.
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces ,  ):
		connected_face_set.__init__(self , inherited0__name , inherited1__cfs_faces , )

####################
 # ENTITY comparison_less_equal #
####################
class comparison_less_equal(comparison_expression):
	'''Entity comparison_less_equal definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		comparison_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY round_hole #
####################
class round_hole(feature_definition):
	'''Entity round_hole definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  <=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY externally_defined_general_property #
####################
class externally_defined_general_property(general_property,externally_defined_item):
	'''Entity externally_defined_general_property definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_id , inherited4__source ,  ):
		general_property.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
		externally_defined_item.__init__(self , inherited3__item_id , inherited4__source , )

####################
 # ENTITY name_assignment #
####################
class name_assignment(BaseEntityClass):
	'''Entity name_assignment definition.

	:param assigned_name
	:type assigned_name:label

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_name, ):
		self.assigned_name = assigned_name

	@apply
	def assigned_name():
		def fget( self ):
			return self._assigned_name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._assigned_name = label(value)
			else:
				self._assigned_name = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_name_assignment #
####################
class applied_name_assignment(name_assignment):
	'''Entity applied_name_assignment definition.

	:param items
	:type items:SET(1,None,'name_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_name , items, ):
		name_assignment.__init__(self , inherited0__assigned_name , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'name_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (self.self.role.self.name  ==  'kinematic element name'))  or  item_correlation(self.self.items,['KINEMATIC_STRUCTURE','KINEMATIC_JOINT','KINEMATIC_LINK']))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY draughting_subfigure_representation #
####################
class draughting_subfigure_representation(symbol_representation):
	'''Entity draughting_subfigure_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		symbol_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  >  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ( not acyclic_mapped_item_usage(self))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(self.self.context_of_items.self.representations_in_context)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY draughting_text_literal_with_delineation #
####################
class draughting_text_literal_with_delineation(text_literal_with_delineation):
	'''Entity draughting_text_literal_with_delineation definition.
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , inherited6__delineation ,  ):
		text_literal_with_delineation.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , inherited6__delineation , )
	def wr1(self):
		eval_wr1_wr = (self.self.delineation  ==  ['underline','overline'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY qualified_representation_item #
####################
class qualified_representation_item(representation_item):
	'''Entity qualified_representation_item definition.

	:param qualifiers
	:type qualifiers:SET(1,None,'value_qualifier', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , qualifiers, ):
		representation_item.__init__(self , inherited0__name , )
		self.qualifiers = qualifiers

	@apply
	def qualifiers():
		def fget( self ):
			return self._qualifiers
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument qualifiers is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'value_qualifier', scope = schema_scope)):
				self._qualifiers = SET(value)
			else:
				self._qualifiers = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY time_interval_role #
####################
class time_interval_role(BaseEntityClass):
	'''Entity time_interval_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY effectivity_context_assignment #
####################
class effectivity_context_assignment(BaseEntityClass):
	'''Entity effectivity_context_assignment definition.

	:param assigned_effectivity_assignment
	:type assigned_effectivity_assignment:effectivity_assignment

	:param role
	:type role:effectivity_context_role
	'''
	def __init__( self , assigned_effectivity_assignment,role, ):
		self.assigned_effectivity_assignment = assigned_effectivity_assignment
		self.role = role

	@apply
	def assigned_effectivity_assignment():
		def fget( self ):
			return self._assigned_effectivity_assignment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_effectivity_assignment is mantatory and can not be set to None')
			if not check_type(value,effectivity_assignment):
				self._assigned_effectivity_assignment = effectivity_assignment(value)
			else:
				self._assigned_effectivity_assignment = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,effectivity_context_role):
				self._role = effectivity_context_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY configured_effectivity_context_assignment #
####################
class configured_effectivity_context_assignment(effectivity_context_assignment):
	'''Entity configured_effectivity_context_assignment definition.

	:param items
	:type items:SET(1,None,'configured_effectivity_context_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_effectivity_assignment , inherited1__role , items, ):
		effectivity_context_assignment.__init__(self , inherited0__assigned_effectivity_assignment , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'configured_effectivity_context_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'CONFIGURED_EFFECTIVITY_ASSIGNMENT')  ==  TYPEOF(self.self.assigned_effectivity_assignment))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.items)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY drawing_revision #
####################
class drawing_revision(presentation_set):
	'''Entity drawing_revision definition.

	:param revision_identifier
	:type revision_identifier:identifier

	:param drawing_identifier
	:type drawing_identifier:drawing_definition

	:param intended_scale
	:type intended_scale:text
	'''
	def __init__( self , revision_identifier,drawing_identifier,intended_scale, ):
		presentation_set.__init__(self , )
		self.revision_identifier = revision_identifier
		self.drawing_identifier = drawing_identifier
		self.intended_scale = intended_scale

	@apply
	def revision_identifier():
		def fget( self ):
			return self._revision_identifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument revision_identifier is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._revision_identifier = identifier(value)
			else:
				self._revision_identifier = value
		return property(**locals())

	@apply
	def drawing_identifier():
		def fget( self ):
			return self._drawing_identifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument drawing_identifier is mantatory and can not be set to None')
			if not check_type(value,drawing_definition):
				self._drawing_identifier = drawing_definition(value)
			else:
				self._drawing_identifier = value
		return property(**locals())

	@apply
	def intended_scale():
		def fget( self ):
			return self._intended_scale
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._intended_scale = text(value)
				else:
					self._intended_scale = value
			else:
				self._intended_scale = value
		return property(**locals())

####################
 # ENTITY non_manifold_surface_shape_representation #
####################
class non_manifold_surface_shape_representation(shape_representation):
	'''Entity non_manifold_surface_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(None)  ==  0)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = (SIZEOF(None)  ==  0)
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr


####################
 # ENTITY angularity_tolerance #
####################
class angularity_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity angularity_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY mod_expression #
####################
class mod_expression(binary_numeric_expression):
	'''Entity mod_expression definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		binary_numeric_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY placed_datum_target_feature #
####################
class placed_datum_target_feature(datum_target):
	'''Entity placed_datum_target_feature definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , inherited4__target_id ,  ):
		datum_target.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , inherited4__target_id , )
	def wr1(self):
		eval_wr1_wr = (self.self.description  ==  ['point','line','rectangle','circle'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.description  !=  'point')  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'circle')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.description  !=  'rectangle')  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = ((self.self.description  !=  'circle')  or  (SIZEOF(None)  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = ((self.self.description  !=  'line')  or  (SIZEOF(None)  ==  1))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = ((self.self.description  !=  'rectangle')  or  (SIZEOF(None)  ==  1))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = ((self.self.description  !=  'rectangle')  or  (SIZEOF(None)  ==  1))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr


####################
 # ENTITY product_concept_feature_category_usage #
####################
class product_concept_feature_category_usage(group_assignment):
	'''Entity product_concept_feature_category_usage definition.

	:param items
	:type items:SET(1,None,'category_usage_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_group , items, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'category_usage_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'PRODUCT_CONCEPT_FEATURE_CATEGORY')  ==  TYPEOF(self.self.assigned_group))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.role.self.name  ==  ['mandatory category usage','optional category usage'])
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY box_domain #
####################
class box_domain(founded_item):
	'''Entity box_domain definition.

	:param corner
	:type corner:cartesian_point

	:param xlength
	:type xlength:positive_length_measure

	:param ylength
	:type ylength:positive_length_measure

	:param zlength
	:type zlength:positive_length_measure
	'''
	def __init__( self , corner,xlength,ylength,zlength, ):
		founded_item.__init__(self , )
		self.corner = corner
		self.xlength = xlength
		self.ylength = ylength
		self.zlength = zlength

	@apply
	def corner():
		def fget( self ):
			return self._corner
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument corner is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._corner = cartesian_point(value)
			else:
				self._corner = value
		return property(**locals())

	@apply
	def xlength():
		def fget( self ):
			return self._xlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument xlength is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._xlength = positive_length_measure(value)
			else:
				self._xlength = value
		return property(**locals())

	@apply
	def ylength():
		def fget( self ):
			return self._ylength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ylength is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._ylength = positive_length_measure(value)
			else:
				self._ylength = value
		return property(**locals())

	@apply
	def zlength():
		def fget( self ):
			return self._zlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zlength is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._zlength = positive_length_measure(value)
			else:
				self._zlength = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY definitional_representation #
####################
class definitional_representation(representation):
	'''Entity definitional_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT'  ==  TYPEOF(self.self.representation.self.context_of_items))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY precision_qualifier #
####################
class precision_qualifier(BaseEntityClass):
	'''Entity precision_qualifier definition.

	:param precision_value
	:type precision_value:INTEGER
	'''
	def __init__( self , precision_value, ):
		self.precision_value = precision_value

	@apply
	def precision_value():
		def fget( self ):
			return self._precision_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument precision_value is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._precision_value = INTEGER(value)
			else:
				self._precision_value = value
		return property(**locals())

####################
 # ENTITY action_method_relationship #
####################
class action_method_relationship(BaseEntityClass):
	'''Entity action_method_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_method
	:type relating_method:action_method

	:param related_method
	:type related_method:action_method
	'''
	def __init__( self , name,description,relating_method,related_method, ):
		self.name = name
		self.description = description
		self.relating_method = relating_method
		self.related_method = related_method

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_method():
		def fget( self ):
			return self._relating_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_method is mantatory and can not be set to None')
			if not check_type(value,action_method):
				self._relating_method = action_method(value)
			else:
				self._relating_method = value
		return property(**locals())

	@apply
	def related_method():
		def fget( self ):
			return self._related_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_method is mantatory and can not be set to None')
			if not check_type(value,action_method):
				self._related_method = action_method(value)
			else:
				self._related_method = value
		return property(**locals())

####################
 # ENTITY date_role #
####################
class date_role(BaseEntityClass):
	'''Entity date_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY int_numeric_variable #
####################
class int_numeric_variable(numeric_variable):
	'''Entity int_numeric_variable definition.
	'''
	def __init__( self ,  ):
		numeric_variable.__init__(self , )

####################
 # ENTITY dimension_callout_component_relationship #
####################
class dimension_callout_component_relationship(draughting_callout_relationship):
	'''Entity dimension_callout_component_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout ,  ):
		draughting_callout_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['prefix','suffix'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AUTOMOTIVE_DESIGN.STRUCTURED_DIMENSION_CALLOUT'  ==  TYPEOF(self.self.relating_draughting_callout))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(TYPEOF(self.self.related_draughting_callout)  *  ['AUTOMOTIVE_DESIGN.LEADER_DIRECTED_CALLOUT','AUTOMOTIVE_DESIGN.PROJECTION_DIRECTED_CALLOUT','AUTOMOTIVE_DESIGN.DIMENSION_CURVE_DIRECTED_CALLOUT','AUTOMOTIVE_DESIGN.STRUCTURED_DIMENSION_CALLOUT'])  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.related_draughting_callout.self.contents  *  self.self.relating_draughting_callout.self.contents)  ==  self.self.related_draughting_callout.self.contents)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.name  ==  'prefix')  and  (SIZEOF(None)  ==  0))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.name  ==  'suffix')  and  (SIZEOF(None)  ==  0))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY light_source_directional #
####################
class light_source_directional(light_source):
	'''Entity light_source_directional definition.

	:param orientation
	:type orientation:direction
	'''
	def __init__( self , inherited0__name , inherited1__light_colour , orientation, ):
		light_source.__init__(self , inherited0__name , inherited1__light_colour , )
		self.orientation = orientation

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._orientation = direction(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY si_unit #
####################
class si_unit(named_unit):
	'''Entity si_unit definition.

	:param prefix
	:type prefix:si_prefix

	:param name
	:type name:si_unit_name

	:param named_unit_dimensions
	:type named_unit_dimensions:dimensional_exponents
	'''
	def __init__( self , inherited0__dimensions , prefix,name, ):
		named_unit.__init__(self , inherited0__dimensions , )
		self.prefix = prefix
		self.name = name

	@apply
	def prefix():
		def fget( self ):
			return self._prefix
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,si_prefix):
					self._prefix = si_prefix(value)
				else:
					self._prefix = value
			else:
				self._prefix = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,si_unit_name):
				self._name = si_unit_name(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def named_unit_dimensions():
		def fget( self ):
			attribute_eval = dimensions_for_si_unit(self.name)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument named_unit_dimensions is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (('AUTOMOTIVE_DESIGN.MASS_UNIT'  ==  TYPEOF(self))  and  (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DERIVED_UNIT_ELEMENT.UNIT'))  >  0)))  or  (self.prefix  ==  si_prefix.self.kilo))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY attribute_value_role #
####################
class attribute_value_role(BaseEntityClass):
	'''Entity attribute_value_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY document_usage_constraint_assignment #
####################
class document_usage_constraint_assignment(BaseEntityClass):
	'''Entity document_usage_constraint_assignment definition.

	:param assigned_document_usage
	:type assigned_document_usage:document_usage_constraint

	:param role
	:type role:document_usage_role
	'''
	def __init__( self , assigned_document_usage,role, ):
		self.assigned_document_usage = assigned_document_usage
		self.role = role

	@apply
	def assigned_document_usage():
		def fget( self ):
			return self._assigned_document_usage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_document_usage is mantatory and can not be set to None')
			if not check_type(value,document_usage_constraint):
				self._assigned_document_usage = document_usage_constraint(value)
			else:
				self._assigned_document_usage = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,document_usage_role):
				self._role = document_usage_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY bezier_surface #
####################
class bezier_surface(b_spline_surface):
	'''Entity bezier_surface definition.
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect ,  ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )

####################
 # ENTITY csg_solid #
####################
class csg_solid(solid_model):
	'''Entity csg_solid definition.

	:param tree_root_expression
	:type tree_root_expression:csg_select
	'''
	def __init__( self , inherited0__name , tree_root_expression, ):
		solid_model.__init__(self , inherited0__name , )
		self.tree_root_expression = tree_root_expression

	@apply
	def tree_root_expression():
		def fget( self ):
			return self._tree_root_expression
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tree_root_expression is mantatory and can not be set to None')
			if not check_type(value,csg_select):
				self._tree_root_expression = csg_select(value)
			else:
				self._tree_root_expression = value
		return property(**locals())

####################
 # ENTITY parallel_offset #
####################
class parallel_offset(derived_shape_aspect):
	'''Entity parallel_offset definition.

	:param offset
	:type offset:measure_with_unit
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , offset, ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		self.offset = offset

	@apply
	def offset():
		def fget( self ):
			return self._offset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offset is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._offset = measure_with_unit(value)
			else:
				self._offset = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY camera_model_d3_with_hlhsr #
####################
class camera_model_d3_with_hlhsr(camera_model_d3):
	'''Entity camera_model_d3_with_hlhsr definition.

	:param hidden_line_surface_removal
	:type hidden_line_surface_removal:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__view_reference_system , inherited2__perspective_of_volume , hidden_line_surface_removal, ):
		camera_model_d3.__init__(self , inherited0__name , inherited1__view_reference_system , inherited2__perspective_of_volume , )
		self.hidden_line_surface_removal = hidden_line_surface_removal

	@apply
	def hidden_line_surface_removal():
		def fget( self ):
			return self._hidden_line_surface_removal
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hidden_line_surface_removal is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._hidden_line_surface_removal = BOOLEAN(value)
			else:
				self._hidden_line_surface_removal = value
		return property(**locals())

####################
 # ENTITY person_and_organization_address #
####################
class person_and_organization_address(organizational_address,personal_address):
	'''Entity person_and_organization_address definition.
	'''
	def __init__( self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , inherited12__organizations , inherited13__description , inherited14__internal_location , inherited15__street_number , inherited16__street , inherited17__postal_box , inherited18__town , inherited19__region , inherited20__postal_code , inherited21__country , inherited22__facsimile_number , inherited23__telephone_number , inherited24__electronic_mail_address , inherited25__telex_number , inherited26__people , inherited27__description ,  ):
		organizational_address.__init__(self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , inherited12__organizations , inherited13__description , )
		personal_address.__init__(self , inherited14__internal_location , inherited15__street_number , inherited16__street , inherited17__postal_box , inherited18__town , inherited19__region , inherited20__postal_code , inherited21__country , inherited22__facsimile_number , inherited23__telephone_number , inherited24__electronic_mail_address , inherited25__telex_number , inherited26__people , inherited27__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.personal_address.self.people)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.organizational_address.self.organizations)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY fill_area_style_colour #
####################
class fill_area_style_colour(BaseEntityClass):
	'''Entity fill_area_style_colour definition.

	:param name
	:type name:label

	:param fill_colour
	:type fill_colour:colour
	'''
	def __init__( self , name,fill_colour, ):
		self.name = name
		self.fill_colour = fill_colour

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def fill_colour():
		def fget( self ):
			return self._fill_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fill_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._fill_colour = colour(value)
			else:
				self._fill_colour = value
		return property(**locals())

####################
 # ENTITY product_definition_with_associated_documents #
####################
class product_definition_with_associated_documents(product_definition):
	'''Entity product_definition_with_associated_documents definition.

	:param documentation_ids
	:type documentation_ids:SET(1,None,'document', scope = schema_scope)
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , documentation_ids, ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )
		self.documentation_ids = documentation_ids

	@apply
	def documentation_ids():
		def fget( self ):
			return self._documentation_ids
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument documentation_ids is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'document', scope = schema_scope)):
				self._documentation_ids = SET(value)
			else:
				self._documentation_ids = value
		return property(**locals())

####################
 # ENTITY physically_modelled_product_definition #
####################
class physically_modelled_product_definition(product_definition_with_associated_documents):
	'''Entity physically_modelled_product_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , inherited4__documentation_ids ,  ):
		product_definition_with_associated_documents.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , inherited4__documentation_ids , )
	def wr1(self):
		eval_wr1_wr = (self.self.frame_of_reference.self.application_context_element.self.name  ==  'physical model occurrence')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(self.documentation_ids)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY slash_expression #
####################
class slash_expression(binary_numeric_expression):
	'''Entity slash_expression definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		binary_numeric_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY spherical_pair #
####################
class spherical_pair(kinematic_pair):
	'''Entity spherical_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint ,  ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )

####################
 # ENTITY surface_profile_tolerance #
####################
class surface_profile_tolerance(geometric_tolerance):
	'''Entity surface_profile_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))  or  (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY not_expression #
####################
class not_expression(unary_boolean_expression):
	'''Entity not_expression definition.

	:param unary_generic_expression_operand
	:type unary_generic_expression_operand:boolean_expression
	'''
	def __init__( self , inherited0__operand , unary_generic_expression_operand, ):
		unary_boolean_expression.__init__(self , inherited0__operand , )
		self.unary_generic_expression_operand = unary_generic_expression_operand

	@apply
	def unary_generic_expression_operand():
		def fget( self ):
			return self._unary_generic_expression_operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unary_generic_expression_operand is mantatory and can not be set to None')
			if not check_type(value,boolean_expression):
				self._unary_generic_expression_operand = boolean_expression(value)
			else:
				self._unary_generic_expression_operand = value
		return property(**locals())

####################
 # ENTITY contract_type #
####################
class contract_type(BaseEntityClass):
	'''Entity contract_type definition.

	:param description
	:type description:label
	'''
	def __init__( self , description, ):
		self.description = description

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,label):
				self._description = label(value)
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY planar_shape_representation #
####################
class planar_shape_representation(shape_representation):
	'''Entity planar_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.name  ==  ['profile limit','maximum feature limit'])
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.name  !=  'maximum feature limit')  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.name  !=  'profile limit')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY surface_pair_range #
####################
class surface_pair_range(simple_pair_range):
	'''Entity surface_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:surface_pair

	:param range_on_surface_1
	:type range_on_surface_1:rectangular_trimmed_surface

	:param range_on_surface_2
	:type range_on_surface_2:rectangular_trimmed_surface

	:param lower_limit_actual_rotation
	:type lower_limit_actual_rotation:rotational_range_measure

	:param upper_limit_actual_rotation
	:type upper_limit_actual_rotation:rotational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,range_on_surface_1,range_on_surface_2,lower_limit_actual_rotation,upper_limit_actual_rotation, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.range_on_surface_1 = range_on_surface_1
		self.range_on_surface_2 = range_on_surface_2
		self.lower_limit_actual_rotation = lower_limit_actual_rotation
		self.upper_limit_actual_rotation = upper_limit_actual_rotation

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,surface_pair):
				self._simple_pair_range_applies_to_pair = surface_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def range_on_surface_1():
		def fget( self ):
			return self._range_on_surface_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument range_on_surface_1 is mantatory and can not be set to None')
			if not check_type(value,rectangular_trimmed_surface):
				self._range_on_surface_1 = rectangular_trimmed_surface(value)
			else:
				self._range_on_surface_1 = value
		return property(**locals())

	@apply
	def range_on_surface_2():
		def fget( self ):
			return self._range_on_surface_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument range_on_surface_2 is mantatory and can not be set to None')
			if not check_type(value,rectangular_trimmed_surface):
				self._range_on_surface_2 = rectangular_trimmed_surface(value)
			else:
				self._range_on_surface_2 = value
		return property(**locals())

	@apply
	def lower_limit_actual_rotation():
		def fget( self ):
			return self._lower_limit_actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_actual_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_actual_rotation = rotational_range_measure(value)
			else:
				self._lower_limit_actual_rotation = value
		return property(**locals())

	@apply
	def upper_limit_actual_rotation():
		def fget( self ):
			return self._upper_limit_actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_actual_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_actual_rotation = rotational_range_measure(value)
			else:
				self._upper_limit_actual_rotation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.simple_pair_range.self.applies_to_pair.self.surface_pair.self.surface_1  ==  self.range_on_surface_1.self.basis_surface)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.simple_pair_range.self.applies_to_pair.self.surface_pair.self.surface_2  ==  self.range_on_surface_2.self.basis_surface)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_actual_rotation))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_actual_rotation))) XOR (self.lower_limit_actual_rotation  <  self.upper_limit_actual_rotation))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY b_spline_curve_with_knots #
####################
class b_spline_curve_with_knots(b_spline_curve):
	'''Entity b_spline_curve_with_knots definition.

	:param knot_multiplicities
	:type knot_multiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param knots
	:type knots:LIST(2,None,'REAL', scope = schema_scope)

	:param knot_spec
	:type knot_spec:knot_type

	:param upper_index_on_knots
	:type upper_index_on_knots:INTEGER
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , knot_multiplicities,knots,knot_spec, ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )
		self.knot_multiplicities = knot_multiplicities
		self.knots = knots
		self.knot_spec = knot_spec

	@apply
	def knot_multiplicities():
		def fget( self ):
			return self._knot_multiplicities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knot_multiplicities is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
				self._knot_multiplicities = LIST(value)
			else:
				self._knot_multiplicities = value
		return property(**locals())

	@apply
	def knots():
		def fget( self ):
			return self._knots
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knots is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._knots = LIST(value)
			else:
				self._knots = value
		return property(**locals())

	@apply
	def knot_spec():
		def fget( self ):
			return self._knot_spec
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knot_spec is mantatory and can not be set to None')
			if not check_type(value,knot_type):
				self._knot_spec = knot_type(value)
			else:
				self._knot_spec = value
		return property(**locals())

	@apply
	def upper_index_on_knots():
		def fget( self ):
			attribute_eval = SIZEOF(self.knots)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument upper_index_on_knots is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = constraints_param_b_spline(self.degree,self.upper_index_on_knots,self.upper_index_on_control_points,self.knot_multiplicities,self.knots)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.knot_multiplicities)  ==  self.upper_index_on_knots)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY document_usage_role #
####################
class document_usage_role(BaseEntityClass):
	'''Entity document_usage_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY fill_area_style_hatching #
####################
class fill_area_style_hatching(geometric_representation_item):
	'''Entity fill_area_style_hatching definition.

	:param hatch_line_appearance
	:type hatch_line_appearance:curve_style

	:param start_of_next_hatch_line
	:type start_of_next_hatch_line:one_direction_repeat_factor

	:param point_of_reference_hatch_line
	:type point_of_reference_hatch_line:cartesian_point

	:param pattern_start
	:type pattern_start:cartesian_point

	:param hatch_line_angle
	:type hatch_line_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , hatch_line_appearance,start_of_next_hatch_line,point_of_reference_hatch_line,pattern_start,hatch_line_angle, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.hatch_line_appearance = hatch_line_appearance
		self.start_of_next_hatch_line = start_of_next_hatch_line
		self.point_of_reference_hatch_line = point_of_reference_hatch_line
		self.pattern_start = pattern_start
		self.hatch_line_angle = hatch_line_angle

	@apply
	def hatch_line_appearance():
		def fget( self ):
			return self._hatch_line_appearance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hatch_line_appearance is mantatory and can not be set to None')
			if not check_type(value,curve_style):
				self._hatch_line_appearance = curve_style(value)
			else:
				self._hatch_line_appearance = value
		return property(**locals())

	@apply
	def start_of_next_hatch_line():
		def fget( self ):
			return self._start_of_next_hatch_line
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument start_of_next_hatch_line is mantatory and can not be set to None')
			if not check_type(value,one_direction_repeat_factor):
				self._start_of_next_hatch_line = one_direction_repeat_factor(value)
			else:
				self._start_of_next_hatch_line = value
		return property(**locals())

	@apply
	def point_of_reference_hatch_line():
		def fget( self ):
			return self._point_of_reference_hatch_line
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument point_of_reference_hatch_line is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._point_of_reference_hatch_line = cartesian_point(value)
			else:
				self._point_of_reference_hatch_line = value
		return property(**locals())

	@apply
	def pattern_start():
		def fget( self ):
			return self._pattern_start
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pattern_start is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._pattern_start = cartesian_point(value)
			else:
				self._pattern_start = value
		return property(**locals())

	@apply
	def hatch_line_angle():
		def fget( self ):
			return self._hatch_line_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hatch_line_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._hatch_line_angle = plane_angle_measure(value)
			else:
				self._hatch_line_angle = value
		return property(**locals())

####################
 # ENTITY initial_state #
####################
class initial_state(BaseEntityClass):
	'''Entity initial_state definition.

	:param applies_to_mechanism
	:type applies_to_mechanism:mechanism

	:param pair_values
	:type pair_values:SET(1,None,'pair_value', scope = schema_scope)
	'''
	def __init__( self , applies_to_mechanism,pair_values, ):
		self.applies_to_mechanism = applies_to_mechanism
		self.pair_values = pair_values

	@apply
	def applies_to_mechanism():
		def fget( self ):
			return self._applies_to_mechanism
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applies_to_mechanism is mantatory and can not be set to None')
			if not check_type(value,mechanism):
				self._applies_to_mechanism = mechanism(value)
			else:
				self._applies_to_mechanism = value
		return property(**locals())

	@apply
	def pair_values():
		def fget( self ):
			return self._pair_values
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_values is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'pair_value', scope = schema_scope)):
				self._pair_values = SET(value)
			else:
				self._pair_values = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY tangent #
####################
class tangent(derived_shape_aspect):
	'''Entity tangent definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ruled_surface_swept_area_solid #
####################
class ruled_surface_swept_area_solid(surface_curve_swept_area_solid):
	'''Entity ruled_surface_swept_area_solid definition.
	'''
	def __init__( self , inherited0__name , inherited1__swept_area , inherited2__directrix , inherited3__start_param , inherited4__end_param , inherited5__reference_surface ,  ):
		surface_curve_swept_area_solid.__init__(self , inherited0__name , inherited1__swept_area , inherited2__directrix , inherited3__start_param , inherited4__end_param , inherited5__reference_surface , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.B_SPLINE_SURFACE'  ==  TYPEOF(self.self.reference_surface))  and  (self.self.reference_surface.self.b_spline_surface.self.u_degree  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(self.self.directrix))  or  (('AUTOMOTIVE_DESIGN.B_SPLINE_CURVE'  ==  TYPEOF(self.self.directrix.self.surface_curve.self.curve_3d))  and  (self.self.directrix.self.surface_curve.self.curve_3d.self.b_spline_curve.self.degree  ==  self.self.reference_surface.self.b_spline_surface.self.v_degree)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY spherical_pair_value #
####################
class spherical_pair_value(pair_value):
	'''Entity spherical_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:spherical_pair

	:param input_orientation
	:type input_orientation:spatial_rotation

	:param actual_orientation
	:type actual_orientation:ARRAY(ypr_index(yaw),ypr_index(roll),'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,input_orientation, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.input_orientation = input_orientation

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,spherical_pair):
				self._pair_value_applies_to_pair = spherical_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def input_orientation():
		def fget( self ):
			return self._input_orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument input_orientation is mantatory and can not be set to None')
			if not check_type(value,spatial_rotation):
				self._input_orientation = spatial_rotation(value)
			else:
				self._input_orientation = value
		return property(**locals())

	@apply
	def actual_orientation():
		def fget( self ):
			attribute_eval = convert_spatial_to_ypr_rotation(self.self.pair_value.self.applies_to_pair,self.input_orientation)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument actual_orientation is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY attribute_language_assignment #
####################
class attribute_language_assignment(attribute_classification_assignment):
	'''Entity attribute_language_assignment definition.

	:param items
	:type items:SET(1,None,'attribute_language_item', scope = schema_scope)

	:param language
	:type language:label
	'''
	def __init__( self , inherited0__assigned_class , inherited1__attribute_name , inherited2__role , items, ):
		attribute_classification_assignment.__init__(self , inherited0__assigned_class , inherited1__attribute_name , inherited2__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'attribute_language_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def language():
		def fget( self ):
			attribute_eval = self.self.attribute_classification_assignment.self.assigned_class.self.name
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument language is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.attribute_classification_assignment.self.role.self.name  ==  ['primary','translated'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('AUTOMOTIVE_DESIGN.'  +  'LANGUAGE')  ==  TYPEOF(self.self.attribute_classification_assignment.self.assigned_class))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY element_delivery #
####################
class element_delivery(action):
	'''Entity element_delivery definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method ,  ):
		action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ACTION_PROPERTY.DEFINITION'))  ==  1)  and  (SIZEOF(None)  ==  1))  and  (SIZEOF(None)  ==  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ACTION_RELATIONSHIP.RELATING_ACTION'))  +  SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ACTION_RELATIONSHIP.RELATED_ACTION')))  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY edge_based_wireframe_shape_representation #
####################
class edge_based_wireframe_shape_representation(shape_representation):
	'''Entity edge_based_wireframe_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  3)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr


####################
 # ENTITY derived_unit_element #
####################
class derived_unit_element(BaseEntityClass):
	'''Entity derived_unit_element definition.

	:param unit
	:type unit:named_unit

	:param exponent
	:type exponent:REAL
	'''
	def __init__( self , unit,exponent, ):
		self.unit = unit
		self.exponent = exponent

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unit is mantatory and can not be set to None')
			if not check_type(value,named_unit):
				self._unit = named_unit(value)
			else:
				self._unit = value
		return property(**locals())

	@apply
	def exponent():
		def fget( self ):
			return self._exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._exponent = REAL(value)
			else:
				self._exponent = value
		return property(**locals())

####################
 # ENTITY geometrically_bounded_wireframe_shape_representation #
####################
class geometrically_bounded_wireframe_shape_representation(shape_representation):
	'''Entity geometrically_bounded_wireframe_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY sliding_curve_pair_value #
####################
class sliding_curve_pair_value(pair_value):
	'''Entity sliding_curve_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:sliding_curve_pair

	:param actual_point_on_curve_1
	:type actual_point_on_curve_1:point_on_curve

	:param actual_point_on_curve_2
	:type actual_point_on_curve_2:point_on_curve
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_point_on_curve_1,actual_point_on_curve_2, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_point_on_curve_1 = actual_point_on_curve_1
		self.actual_point_on_curve_2 = actual_point_on_curve_2

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,sliding_curve_pair):
				self._pair_value_applies_to_pair = sliding_curve_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_point_on_curve_1():
		def fget( self ):
			return self._actual_point_on_curve_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_point_on_curve_1 is mantatory and can not be set to None')
			if not check_type(value,point_on_curve):
				self._actual_point_on_curve_1 = point_on_curve(value)
			else:
				self._actual_point_on_curve_1 = value
		return property(**locals())

	@apply
	def actual_point_on_curve_2():
		def fget( self ):
			return self._actual_point_on_curve_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_point_on_curve_2 is mantatory and can not be set to None')
			if not check_type(value,point_on_curve):
				self._actual_point_on_curve_2 = point_on_curve(value)
			else:
				self._actual_point_on_curve_2 = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.pair_value.self.applies_to_pair.self.planar_curve_pair.self.curve_1  ==  self.actual_point_on_curve_1.self.basis_curve)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.pair_value.self.applies_to_pair.self.planar_curve_pair.self.curve_2  ==  self.actual_point_on_curve_2.self.basis_curve)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY linear_dimension #
####################
class linear_dimension(dimension_curve_directed_callout):
	'''Entity linear_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		dimension_curve_directed_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY resource_property #
####################
class resource_property(BaseEntityClass):
	'''Entity resource_property definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param resource
	:type resource:characterized_resource_definition
	'''
	def __init__( self , name,description,resource, ):
		self.name = name
		self.description = description
		self.resource = resource

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def resource():
		def fget( self ):
			return self._resource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument resource is mantatory and can not be set to None')
			if not check_type(value,characterized_resource_definition):
				self._resource = characterized_resource_definition(value)
			else:
				self._resource = value
		return property(**locals())

####################
 # ENTITY roundness_tolerance #
####################
class roundness_tolerance(geometric_tolerance):
	'''Entity roundness_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ( not (('AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY seam_curve #
####################
class seam_curve(surface_curve):
	'''Entity seam_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation ,  ):
		surface_curve.__init__(self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.surface_curve.self.associated_geometry)  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (associated_surface(self.self.surface_curve.self.associated_geometry[1])  ==  associated_surface(self.self.surface_curve.self.associated_geometry[2]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(self.self.surface_curve.self.associated_geometry[1]))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(self.self.surface_curve.self.associated_geometry[2]))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY datum_target_callout #
####################
class datum_target_callout(draughting_callout):
	'''Entity datum_target_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY length_function #
####################
class length_function(numeric_expression,unary_generic_expression):
	'''Entity length_function definition.

	:param unary_generic_expression_operand
	:type unary_generic_expression_operand:string_expression
	'''
	def __init__( self , inherited0__operand , unary_generic_expression_operand, ):
		numeric_expression.__init__(self , )
		unary_generic_expression.__init__(self , inherited0__operand , )
		self.unary_generic_expression_operand = unary_generic_expression_operand

	@apply
	def unary_generic_expression_operand():
		def fget( self ):
			return self._unary_generic_expression_operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unary_generic_expression_operand is mantatory and can not be set to None')
			if not check_type(value,string_expression):
				self._unary_generic_expression_operand = string_expression(value)
			else:
				self._unary_generic_expression_operand = value
		return property(**locals())

####################
 # ENTITY axis2_placement_3d #
####################
class axis2_placement_3d(placement):
	'''Entity axis2_placement_3d definition.

	:param axis
	:type axis:direction

	:param ref_direction
	:type ref_direction:direction

	:param p
	:type p:LIST(3,3,'direction', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__location , axis,ref_direction, ):
		placement.__init__(self , inherited0__name , inherited1__location , )
		self.axis = axis
		self.ref_direction = ref_direction

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._axis = direction(value)
				else:
					self._axis = value
			else:
				self._axis = value
		return property(**locals())

	@apply
	def ref_direction():
		def fget( self ):
			return self._ref_direction
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._ref_direction = direction(value)
				else:
					self._ref_direction = value
			else:
				self._ref_direction = value
		return property(**locals())

	@apply
	def p():
		def fget( self ):
			attribute_eval = build_axes(self.axis,self.ref_direction)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.placement.self.location.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.axis))  or  (self.axis.self.dim  ==  3))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not EXISTS(self.ref_direction))  or  (self.ref_direction.self.dim  ==  3))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((( not EXISTS(self.axis))  or  ( not EXISTS(self.ref_direction)))  or  (cross_product(self.axis,self.ref_direction).self.magnitude  >  0))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY datum #
####################
class datum(shape_aspect):
	'''Entity datum definition.

	:param identification
	:type identification:identifier

	:param established_by_relationships
	:type established_by_relationships:SET(1,None,'shape_aspect_relationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , identification, ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		self.identification = identification

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument identification is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._identification = identifier(value)
			else:
				self._identification = value
		return property(**locals())

	@apply
	def established_by_relationships():
		def fget( self ):
			return self._established_by_relationships
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument established_by_relationships is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY interpolated_configuration_sequence #
####################
class interpolated_configuration_sequence(BaseEntityClass):
	'''Entity interpolated_configuration_sequence definition.

	:param interpolation
	:type interpolation:SET(1,None,'configuration_interpolation', scope = schema_scope)
	'''
	def __init__( self , interpolation, ):
		self.interpolation = interpolation

	@apply
	def interpolation():
		def fget( self ):
			return self._interpolation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument interpolation is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'configuration_interpolation', scope = schema_scope)):
				self._interpolation = SET(value)
			else:
				self._interpolation = value
		return property(**locals())

####################
 # ENTITY rational_b_spline_surface #
####################
class rational_b_spline_surface(b_spline_surface):
	'''Entity rational_b_spline_surface definition.

	:param weights_data
	:type weights_data:LIST(2,None,LIST(2,None,'REAL', scope = schema_scope))

	:param weights
	:type weights:ARRAY(0,u_upper,ARRAY(0,v_upper,'REAL', scope = schema_scope))
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , weights_data, ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )
		self.weights_data = weights_data

	@apply
	def weights_data():
		def fget( self ):
			return self._weights_data
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument weights_data is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,LIST(2,None,'REAL', scope = schema_scope))):
				self._weights_data = LIST(value)
			else:
				self._weights_data = value
		return property(**locals())

	@apply
	def weights():
		def fget( self ):
			attribute_eval = make_array_of_array(self.weights_data,0,self.u_upper,0,self.v_upper)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument weights is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.weights_data)  ==  SIZEOF(self.self.b_spline_surface.self.control_points_list))  and  (SIZEOF(self.weights_data[1])  ==  SIZEOF(self.self.b_spline_surface.self.control_points_list[1])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = surface_weights_positive(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY configuration_design #
####################
class configuration_design(BaseEntityClass):
	'''Entity configuration_design definition.

	:param configuration
	:type configuration:configuration_item

	:param design
	:type design:configuration_design_item

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , configuration,design, ):
		self.configuration = configuration
		self.design = design

	@apply
	def configuration():
		def fget( self ):
			return self._configuration
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument configuration is mantatory and can not be set to None')
			if not check_type(value,configuration_item):
				self._configuration = configuration_item(value)
			else:
				self._configuration = value
		return property(**locals())

	@apply
	def design():
		def fget( self ):
			return self._design
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument design is mantatory and can not be set to None')
			if not check_type(value,configuration_design_item):
				self._design = configuration_design_item(value)
			else:
				self._design = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY defined_character_glyph #
####################
class defined_character_glyph(geometric_representation_item):
	'''Entity defined_character_glyph definition.

	:param definition
	:type definition:defined_glyph_select

	:param placement
	:type placement:axis2_placement
	'''
	def __init__( self , inherited0__name , definition,placement, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.definition = definition
		self.placement = placement

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,defined_glyph_select):
				self._definition = defined_glyph_select(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def placement():
		def fget( self ):
			return self._placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placement is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._placement = axis2_placement(value)
			else:
				self._placement = value
		return property(**locals())

####################
 # ENTITY drawing_sheet_revision #
####################
class drawing_sheet_revision(presentation_area):
	'''Entity drawing_sheet_revision definition.

	:param revision_identifier
	:type revision_identifier:identifier
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , revision_identifier, ):
		presentation_area.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , )
		self.revision_identifier = revision_identifier

	@apply
	def revision_identifier():
		def fget( self ):
			return self._revision_identifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument revision_identifier is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._revision_identifier = identifier(value)
			else:
				self._revision_identifier = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY torus #
####################
class torus(geometric_representation_item):
	'''Entity torus definition.

	:param position
	:type position:axis1_placement

	:param major_radius
	:type major_radius:positive_length_measure

	:param minor_radius
	:type minor_radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , position,major_radius,minor_radius, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.position = position
		self.major_radius = major_radius
		self.minor_radius = minor_radius

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._position = axis1_placement(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def major_radius():
		def fget( self ):
			return self._major_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument major_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._major_radius = positive_length_measure(value)
			else:
				self._major_radius = value
		return property(**locals())

	@apply
	def minor_radius():
		def fget( self ):
			return self._minor_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument minor_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._minor_radius = positive_length_measure(value)
			else:
				self._minor_radius = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.major_radius  >  self.minor_radius)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY bead #
####################
class bead(feature_definition):
	'''Entity bead definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY process_product_association #
####################
class process_product_association(BaseEntityClass):
	'''Entity process_product_association definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param defined_product
	:type defined_product:characterized_product_definition

	:param process
	:type process:product_definition_process
	'''
	def __init__( self , name,description,defined_product,process, ):
		self.name = name
		self.description = description
		self.defined_product = defined_product
		self.process = process

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def defined_product():
		def fget( self ):
			return self._defined_product
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument defined_product is mantatory and can not be set to None')
			if not check_type(value,characterized_product_definition):
				self._defined_product = characterized_product_definition(value)
			else:
				self._defined_product = value
		return property(**locals())

	@apply
	def process():
		def fget( self ):
			return self._process
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument process is mantatory and can not be set to None')
			if not check_type(value,product_definition_process):
				self._process = product_definition_process(value)
			else:
				self._process = value
		return property(**locals())

####################
 # ENTITY product_concept_relationship #
####################
class product_concept_relationship(BaseEntityClass):
	'''Entity product_concept_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_product_concept
	:type relating_product_concept:product_concept

	:param related_product_concept
	:type related_product_concept:product_concept
	'''
	def __init__( self , name,description,relating_product_concept,related_product_concept, ):
		self.name = name
		self.description = description
		self.relating_product_concept = relating_product_concept
		self.related_product_concept = related_product_concept

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_product_concept():
		def fget( self ):
			return self._relating_product_concept
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_product_concept is mantatory and can not be set to None')
			if not check_type(value,product_concept):
				self._relating_product_concept = product_concept(value)
			else:
				self._relating_product_concept = value
		return property(**locals())

	@apply
	def related_product_concept():
		def fget( self ):
			return self._related_product_concept
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_product_concept is mantatory and can not be set to None')
			if not check_type(value,product_concept):
				self._related_product_concept = product_concept(value)
			else:
				self._related_product_concept = value
		return property(**locals())

####################
 # ENTITY gear_pair_value #
####################
class gear_pair_value(pair_value):
	'''Entity gear_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:gear_pair

	:param actual_rotation_1
	:type actual_rotation_1:plane_angle_measure

	:param actual_rotation_2
	:type actual_rotation_2:plane_angle_measure
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_rotation_1, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_rotation_1 = actual_rotation_1

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,gear_pair):
				self._pair_value_applies_to_pair = gear_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_rotation_1():
		def fget( self ):
			return self._actual_rotation_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_rotation_1 is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._actual_rotation_1 = plane_angle_measure(value)
			else:
				self._actual_rotation_1 = value
		return property(**locals())

	@apply
	def actual_rotation_2():
		def fget( self ):
			attribute_eval = ((-self.actual_rotation_1)  *  self.self.pair_value.self.applies_to_pair.self.gear_pair.self.gear_ratio)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument actual_rotation_2 is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY annotation_text_occurrence #
####################
class annotation_text_occurrence(annotation_occurrence):
	'''Entity annotation_text_occurrence definition.

	:param styled_item_item
	:type styled_item_item:annotation_text_occurrence_item
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , styled_item_item, ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		self.styled_item_item = styled_item_item

	@apply
	def styled_item_item():
		def fget( self ):
			return self._styled_item_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_item_item is mantatory and can not be set to None')
			if not check_type(value,annotation_text_occurrence_item):
				self._styled_item_item = annotation_text_occurrence_item(value)
			else:
				self._styled_item_item = value
		return property(**locals())

####################
 # ENTITY common_datum #
####################
class common_datum(composite_shape_aspect,datum):
	'''Entity common_datum definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , inherited4__name , inherited5__description , inherited6__of_shape , inherited7__product_definitional , inherited8__identification ,  ):
		composite_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		datum.__init__(self , inherited4__name , inherited5__description , inherited6__of_shape , inherited7__product_definitional , inherited8__identification , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.component_relationships)  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY dimension_curve #
####################
class dimension_curve(annotation_curve_occurrence):
	'''Entity dimension_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item ,  ):
		annotation_curve_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY luminous_intensity_unit #
####################
class luminous_intensity_unit(named_unit):
	'''Entity luminous_intensity_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY cylindrical_pair #
####################
class cylindrical_pair(kinematic_pair):
	'''Entity cylindrical_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint ,  ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )

####################
 # ENTITY organization #
####################
class organization(BaseEntityClass):
	'''Entity organization definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,identifier):
					self._id = identifier(value)
				else:
					self._id = value
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY rack_and_pinion_pair_range #
####################
class rack_and_pinion_pair_range(simple_pair_range):
	'''Entity rack_and_pinion_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:rack_and_pinion_pair

	:param lower_limit_rack_displacement
	:type lower_limit_rack_displacement:translational_range_measure

	:param upper_limit_rack_displacement
	:type upper_limit_rack_displacement:translational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,lower_limit_rack_displacement,upper_limit_rack_displacement, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.lower_limit_rack_displacement = lower_limit_rack_displacement
		self.upper_limit_rack_displacement = upper_limit_rack_displacement

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,rack_and_pinion_pair):
				self._simple_pair_range_applies_to_pair = rack_and_pinion_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def lower_limit_rack_displacement():
		def fget( self ):
			return self._lower_limit_rack_displacement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_rack_displacement is mantatory and can not be set to None')
			if not check_type(value,translational_range_measure):
				self._lower_limit_rack_displacement = translational_range_measure(value)
			else:
				self._lower_limit_rack_displacement = value
		return property(**locals())

	@apply
	def upper_limit_rack_displacement():
		def fget( self ):
			return self._upper_limit_rack_displacement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_rack_displacement is mantatory and can not be set to None')
			if not check_type(value,translational_range_measure):
				self._upper_limit_rack_displacement = translational_range_measure(value)
			else:
				self._upper_limit_rack_displacement = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_rack_displacement))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_rack_displacement))) XOR (self.lower_limit_rack_displacement  <  self.upper_limit_rack_displacement))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY dimension_callout #
####################
class dimension_callout(draughting_callout):
	'''Entity dimension_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.LEADER_DIRECTED_CALLOUT'  ==  TYPEOF(self)) XOR (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('AUTOMOTIVE_DESIGN.PROJECTION_DIRECTED_CALLOUT'  ==  TYPEOF(self)) XOR (SIZEOF(None)  ==  0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (('AUTOMOTIVE_DESIGN.DIMENSION_CURVE_DIRECTED_CALLOUT'  ==  TYPEOF(self)) XOR (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY location_shape_representation #
####################
class location_shape_representation(shape_representation):
	'''Entity location_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY multi_language_attribute_assignment #
####################
class multi_language_attribute_assignment(attribute_value_assignment):
	'''Entity multi_language_attribute_assignment definition.

	:param items
	:type items:SET(1,None,'multi_language_attribute_item', scope = schema_scope)

	:param language
	:type language:label
	'''
	def __init__( self , inherited0__attribute_name , inherited1__attribute_value , inherited2__role , items, ):
		attribute_value_assignment.__init__(self , inherited0__attribute_name , inherited1__attribute_value , inherited2__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'multi_language_attribute_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def language():
		def fget( self ):
			attribute_eval = get_multi_language(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument language is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.attribute_value_assignment.self.role.self.name  ==  'alternate language')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY rep_item_group #
####################
class rep_item_group(group,representation_item):
	'''Entity rep_item_group definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__name ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )
		representation_item.__init__(self , inherited2__name , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.PRESENTATION_LAYER_ASSIGNMENT.ASSIGNED_ITEMS'))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_REPRESENTATION_ITEM','AUTOMOTIVE_DESIGN.'  +  'TOPOLOGICAL_REPRESENTATION_ITEM','AUTOMOTIVE_DESIGN.'  +  'MAPPED_ITEM','AUTOMOTIVE_DESIGN.'  +  'STYLED_ITEM']  *  TYPEOF(self))  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY colour_rgb #
####################
class colour_rgb(colour_specification):
	'''Entity colour_rgb definition.

	:param red
	:type red:REAL

	:param green
	:type green:REAL

	:param blue
	:type blue:REAL
	'''
	def __init__( self , inherited0__name , red,green,blue, ):
		colour_specification.__init__(self , inherited0__name , )
		self.red = red
		self.green = green
		self.blue = blue

	@apply
	def red():
		def fget( self ):
			return self._red
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument red is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._red = REAL(value)
			else:
				self._red = value
		return property(**locals())

	@apply
	def green():
		def fget( self ):
			return self._green
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument green is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._green = REAL(value)
			else:
				self._green = value
		return property(**locals())

	@apply
	def blue():
		def fget( self ):
			return self._blue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument blue is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._blue = REAL(value)
			else:
				self._blue = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((0  <=  self.red)  and  (self.red  <=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((0  <=  self.green)  and  (self.green  <=  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((0  <=  self.blue)  and  (self.blue  <=  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY real_defined_function #
####################
class real_defined_function(numeric_defined_function):
	'''Entity real_defined_function definition.
	'''
	def __init__( self ,  ):
		numeric_defined_function.__init__(self , )

####################
 # ENTITY referenced_modified_datum #
####################
class referenced_modified_datum(datum_reference):
	'''Entity referenced_modified_datum definition.

	:param modifier
	:type modifier:limit_condition
	'''
	def __init__( self , inherited0__precedence , inherited1__referenced_datum , modifier, ):
		datum_reference.__init__(self , inherited0__precedence , inherited1__referenced_datum , )
		self.modifier = modifier

	@apply
	def modifier():
		def fget( self ):
			return self._modifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument modifier is mantatory and can not be set to None')
			if not check_type(value,limit_condition):
				self._modifier = limit_condition(value)
			else:
				self._modifier = value
		return property(**locals())

####################
 # ENTITY mult_expression #
####################
class mult_expression(multiple_arity_numeric_expression):
	'''Entity mult_expression definition.
	'''
	def __init__( self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands ,  ):
		multiple_arity_numeric_expression.__init__(self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands , )

####################
 # ENTITY approximation_tolerance_parameter #
####################
class approximation_tolerance_parameter(founded_item):
	'''Entity approximation_tolerance_parameter definition.

	:param tolerances
	:type tolerances:SET(1,2,'tolerance_parameter_select', scope = schema_scope)
	'''
	def __init__( self , tolerances, ):
		founded_item.__init__(self , )
		self.tolerances = tolerances

	@apply
	def tolerances():
		def fget( self ):
			return self._tolerances
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tolerances is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'tolerance_parameter_select', scope = schema_scope)):
				self._tolerances = SET(value)
			else:
				self._tolerances = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.self.tolerances)  ==  1) XOR (TYPEOF(self.self.tolerances[1])  !=  TYPEOF(self.self.tolerances[2])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY b_spline_surface_with_knots #
####################
class b_spline_surface_with_knots(b_spline_surface):
	'''Entity b_spline_surface_with_knots definition.

	:param u_multiplicities
	:type u_multiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param v_multiplicities
	:type v_multiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param u_knots
	:type u_knots:LIST(2,None,'REAL', scope = schema_scope)

	:param v_knots
	:type v_knots:LIST(2,None,'REAL', scope = schema_scope)

	:param knot_spec
	:type knot_spec:knot_type

	:param knot_u_upper
	:type knot_u_upper:INTEGER

	:param knot_v_upper
	:type knot_v_upper:INTEGER
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , u_multiplicities,v_multiplicities,u_knots,v_knots,knot_spec, ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )
		self.u_multiplicities = u_multiplicities
		self.v_multiplicities = v_multiplicities
		self.u_knots = u_knots
		self.v_knots = v_knots
		self.knot_spec = knot_spec

	@apply
	def u_multiplicities():
		def fget( self ):
			return self._u_multiplicities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_multiplicities is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
				self._u_multiplicities = LIST(value)
			else:
				self._u_multiplicities = value
		return property(**locals())

	@apply
	def v_multiplicities():
		def fget( self ):
			return self._v_multiplicities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_multiplicities is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
				self._v_multiplicities = LIST(value)
			else:
				self._v_multiplicities = value
		return property(**locals())

	@apply
	def u_knots():
		def fget( self ):
			return self._u_knots
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_knots is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._u_knots = LIST(value)
			else:
				self._u_knots = value
		return property(**locals())

	@apply
	def v_knots():
		def fget( self ):
			return self._v_knots
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_knots is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._v_knots = LIST(value)
			else:
				self._v_knots = value
		return property(**locals())

	@apply
	def knot_spec():
		def fget( self ):
			return self._knot_spec
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knot_spec is mantatory and can not be set to None')
			if not check_type(value,knot_type):
				self._knot_spec = knot_type(value)
			else:
				self._knot_spec = value
		return property(**locals())

	@apply
	def knot_u_upper():
		def fget( self ):
			attribute_eval = SIZEOF(self.u_knots)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument knot_u_upper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def knot_v_upper():
		def fget( self ):
			attribute_eval = SIZEOF(self.v_knots)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument knot_v_upper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = constraints_param_b_spline(self.self.b_spline_surface.self.u_degree,self.knot_u_upper,self.self.b_spline_surface.self.u_upper,self.u_multiplicities,self.u_knots)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = constraints_param_b_spline(self.self.b_spline_surface.self.v_degree,self.knot_v_upper,self.self.b_spline_surface.self.v_upper,self.v_multiplicities,self.v_knots)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(self.u_multiplicities)  ==  self.knot_u_upper)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(self.v_multiplicities)  ==  self.knot_v_upper)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY int_value_function #
####################
class int_value_function(value_function):
	'''Entity int_value_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		value_function.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY kinematic_path #
####################
class kinematic_path(representation_item):
	'''Entity kinematic_path definition.
	'''
	def __init__( self , inherited0__name ,  ):
		representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY class_usage_effectivity_context_assignment #
####################
class class_usage_effectivity_context_assignment(effectivity_context_assignment):
	'''Entity class_usage_effectivity_context_assignment definition.

	:param items
	:type items:SET(1,None,'class_usage_effectivity_context_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_effectivity_assignment , inherited1__role , items, ):
		effectivity_context_assignment.__init__(self , inherited0__assigned_effectivity_assignment , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'class_usage_effectivity_context_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.role.self.name  ==  'class usage influence')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((((('AUTOMOTIVE_DESIGN.'  +  'APPLIED_EFFECTIVITY_ASSIGNMENT')  ==  TYPEOF(self.self.assigned_effectivity_assignment))  and  (SIZEOF(TYPEOF(self.self.assigned_effectivity_assignment.self.assigned_effectivity))  ==  1))  and  (self.self.assigned_effectivity_assignment.self.assigned_effectivity.self.id  ==  'class usage'))  and  (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY resulting_path #
####################
class resulting_path(motion_link_relationship):
	'''Entity resulting_path definition.

	:param controlling_joints
	:type controlling_joints:SET(1,None,'kinematic_joint', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , inherited4__representation_relationship_rep_1 , inherited5__representation_relationship_rep_2 , inherited6__related_frame , controlling_joints, ):
		motion_link_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , inherited4__representation_relationship_rep_1 , inherited5__representation_relationship_rep_2 , inherited6__related_frame , )
		self.controlling_joints = controlling_joints

	@apply
	def controlling_joints():
		def fget( self ):
			return self._controlling_joints
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument controlling_joints is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'kinematic_joint', scope = schema_scope)):
				self._controlling_joints = SET(value)
			else:
				self._controlling_joints = value
		return property(**locals())

####################
 # ENTITY effectivity_context_role #
####################
class effectivity_context_role(BaseEntityClass):
	'''Entity effectivity_context_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY face_shape_representation #
####################
class face_shape_representation(shape_representation):
	'''Entity face_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY modified_geometric_tolerance #
####################
class modified_geometric_tolerance(geometric_tolerance):
	'''Entity modified_geometric_tolerance definition.

	:param modifier
	:type modifier:limit_condition
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , modifier, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
		self.modifier = modifier

	@apply
	def modifier():
		def fget( self ):
			return self._modifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument modifier is mantatory and can not be set to None')
			if not check_type(value,limit_condition):
				self._modifier = limit_condition(value)
			else:
				self._modifier = value
		return property(**locals())

####################
 # ENTITY certification_type #
####################
class certification_type(BaseEntityClass):
	'''Entity certification_type definition.

	:param description
	:type description:label
	'''
	def __init__( self , description, ):
		self.description = description

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,label):
				self._description = label(value)
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY draughting_elements #
####################
class draughting_elements(draughting_callout):
	'''Entity draughting_elements definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not ('AUTOMOTIVE_DESIGN.DIMENSION_CURVE_DIRECTED_CALLOUT'  ==  TYPEOF(self)))  or  (SIZEOF(None)  <=  2))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  <=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  <=  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY modified_pattern #
####################
class modified_pattern(replicate_feature):
	'''Entity modified_pattern definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		replicate_feature.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY point_on_surface_pair_range #
####################
class point_on_surface_pair_range(simple_pair_range):
	'''Entity point_on_surface_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:point_on_surface_pair

	:param range_on_pair_surface
	:type range_on_pair_surface:rectangular_trimmed_surface

	:param lower_limit_yaw
	:type lower_limit_yaw:rotational_range_measure

	:param upper_limit_yaw
	:type upper_limit_yaw:rotational_range_measure

	:param lower_limit_pitch
	:type lower_limit_pitch:rotational_range_measure

	:param upper_limit_pitch
	:type upper_limit_pitch:rotational_range_measure

	:param lower_limit_roll
	:type lower_limit_roll:rotational_range_measure

	:param upper_limit_roll
	:type upper_limit_roll:rotational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,range_on_pair_surface,lower_limit_yaw,upper_limit_yaw,lower_limit_pitch,upper_limit_pitch,lower_limit_roll,upper_limit_roll, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.range_on_pair_surface = range_on_pair_surface
		self.lower_limit_yaw = lower_limit_yaw
		self.upper_limit_yaw = upper_limit_yaw
		self.lower_limit_pitch = lower_limit_pitch
		self.upper_limit_pitch = upper_limit_pitch
		self.lower_limit_roll = lower_limit_roll
		self.upper_limit_roll = upper_limit_roll

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,point_on_surface_pair):
				self._simple_pair_range_applies_to_pair = point_on_surface_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def range_on_pair_surface():
		def fget( self ):
			return self._range_on_pair_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument range_on_pair_surface is mantatory and can not be set to None')
			if not check_type(value,rectangular_trimmed_surface):
				self._range_on_pair_surface = rectangular_trimmed_surface(value)
			else:
				self._range_on_pair_surface = value
		return property(**locals())

	@apply
	def lower_limit_yaw():
		def fget( self ):
			return self._lower_limit_yaw
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_yaw is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_yaw = rotational_range_measure(value)
			else:
				self._lower_limit_yaw = value
		return property(**locals())

	@apply
	def upper_limit_yaw():
		def fget( self ):
			return self._upper_limit_yaw
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_yaw is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_yaw = rotational_range_measure(value)
			else:
				self._upper_limit_yaw = value
		return property(**locals())

	@apply
	def lower_limit_pitch():
		def fget( self ):
			return self._lower_limit_pitch
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_pitch is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_pitch = rotational_range_measure(value)
			else:
				self._lower_limit_pitch = value
		return property(**locals())

	@apply
	def upper_limit_pitch():
		def fget( self ):
			return self._upper_limit_pitch
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_pitch is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_pitch = rotational_range_measure(value)
			else:
				self._upper_limit_pitch = value
		return property(**locals())

	@apply
	def lower_limit_roll():
		def fget( self ):
			return self._lower_limit_roll
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_roll is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_roll = rotational_range_measure(value)
			else:
				self._lower_limit_roll = value
		return property(**locals())

	@apply
	def upper_limit_roll():
		def fget( self ):
			return self._upper_limit_roll
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_roll is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_roll = rotational_range_measure(value)
			else:
				self._upper_limit_roll = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.simple_pair_range.self.applies_to_pair.self.point_on_surface_pair.self.pair_surface  ==  self.range_on_pair_surface.self.basis_surface)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_yaw))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_yaw))) XOR (self.lower_limit_yaw  <  self.upper_limit_yaw))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_pitch))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_pitch))) XOR (self.lower_limit_pitch  <  self.upper_limit_pitch))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_roll))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_roll))) XOR (self.lower_limit_roll  <  self.upper_limit_roll))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY oriented_path #
####################
class oriented_path(path):
	'''Entity oriented_path definition.

	:param path_element
	:type path_element:path

	:param orientation
	:type orientation:BOOLEAN

	:param path_edge_list
	:type path_edge_list:LIST(1,None,'oriented_edge', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__edge_list , path_element,orientation, ):
		path.__init__(self , inherited0__name , inherited1__edge_list , )
		self.path_element = path_element
		self.orientation = orientation

	@apply
	def path_element():
		def fget( self ):
			return self._path_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument path_element is mantatory and can not be set to None')
			if not check_type(value,path):
				self._path_element = path(value)
			else:
				self._path_element = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def path_edge_list():
		def fget( self ):
			attribute_eval = conditional_reverse(self.self.orientation,self.self.path_element.self.edge_list)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument path_edge_list is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AUTOMOTIVE_DESIGN.ORIENTED_PATH'  ==  TYPEOF(self.self.path_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY face_based_surface_model #
####################
class face_based_surface_model(geometric_representation_item):
	'''Entity face_based_surface_model definition.

	:param fbsm_faces
	:type fbsm_faces:SET(1,None,'connected_face_set', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , fbsm_faces, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.fbsm_faces = fbsm_faces

	@apply
	def fbsm_faces():
		def fget( self ):
			return self._fbsm_faces
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fbsm_faces is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'connected_face_set', scope = schema_scope)):
				self._fbsm_faces = SET(value)
			else:
				self._fbsm_faces = value
		return property(**locals())

####################
 # ENTITY kinematic_control #
####################
class kinematic_control(BaseEntityClass):
	'''Entity kinematic_control definition.

	:param controlled_mechanism
	:type controlled_mechanism:mechanism

	:param contained_kinematic_programs
	:type contained_kinematic_programs:SET(1,None,'kinematic_analysis_definition', scope = schema_scope)
	'''
	def __init__( self , controlled_mechanism,contained_kinematic_programs, ):
		self.controlled_mechanism = controlled_mechanism
		self.contained_kinematic_programs = contained_kinematic_programs

	@apply
	def controlled_mechanism():
		def fget( self ):
			return self._controlled_mechanism
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument controlled_mechanism is mantatory and can not be set to None')
			if not check_type(value,mechanism):
				self._controlled_mechanism = mechanism(value)
			else:
				self._controlled_mechanism = value
		return property(**locals())

	@apply
	def contained_kinematic_programs():
		def fget( self ):
			return self._contained_kinematic_programs
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument contained_kinematic_programs is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'kinematic_analysis_definition', scope = schema_scope)):
				self._contained_kinematic_programs = SET(value)
			else:
				self._contained_kinematic_programs = value
		return property(**locals())

####################
 # ENTITY measure_qualification #
####################
class measure_qualification(BaseEntityClass):
	'''Entity measure_qualification definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param qualified_measure
	:type qualified_measure:measure_with_unit

	:param qualifiers
	:type qualifiers:SET(1,None,'value_qualifier', scope = schema_scope)
	'''
	def __init__( self , name,description,qualified_measure,qualifiers, ):
		self.name = name
		self.description = description
		self.qualified_measure = qualified_measure
		self.qualifiers = qualifiers

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def qualified_measure():
		def fget( self ):
			return self._qualified_measure
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument qualified_measure is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._qualified_measure = measure_with_unit(value)
			else:
				self._qualified_measure = value
		return property(**locals())

	@apply
	def qualifiers():
		def fget( self ):
			return self._qualifiers
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument qualifiers is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'value_qualifier', scope = schema_scope)):
				self._qualifiers = SET(value)
			else:
				self._qualifiers = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not ('AUTOMOTIVE_DESIGN.REPRESENTATION_ITEM'  ==  TYPEOF(self.self.measure_qualification.self.qualified_measure)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY security_classification #
####################
class security_classification(BaseEntityClass):
	'''Entity security_classification definition.

	:param name
	:type name:label

	:param purpose
	:type purpose:text

	:param security_level
	:type security_level:security_classification_level
	'''
	def __init__( self , name,purpose,security_level, ):
		self.name = name
		self.purpose = purpose
		self.security_level = security_level

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument purpose is mantatory and can not be set to None')
			if not check_type(value,text):
				self._purpose = text(value)
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def security_level():
		def fget( self ):
			return self._security_level
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument security_level is mantatory and can not be set to None')
			if not check_type(value,security_classification_level):
				self._security_level = security_classification_level(value)
			else:
				self._security_level = value
		return property(**locals())

####################
 # ENTITY standard_uncertainty #
####################
class standard_uncertainty(uncertainty_qualifier):
	'''Entity standard_uncertainty definition.

	:param uncertainty_value
	:type uncertainty_value:REAL
	'''
	def __init__( self , inherited0__measure_name , inherited1__description , uncertainty_value, ):
		uncertainty_qualifier.__init__(self , inherited0__measure_name , inherited1__description , )
		self.uncertainty_value = uncertainty_value

	@apply
	def uncertainty_value():
		def fget( self ):
			return self._uncertainty_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uncertainty_value is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._uncertainty_value = REAL(value)
			else:
				self._uncertainty_value = value
		return property(**locals())

####################
 # ENTITY vertex_loop #
####################
class vertex_loop(loop):
	'''Entity vertex_loop definition.

	:param loop_vertex
	:type loop_vertex:vertex
	'''
	def __init__( self , inherited0__name , loop_vertex, ):
		loop.__init__(self , inherited0__name , )
		self.loop_vertex = loop_vertex

	@apply
	def loop_vertex():
		def fget( self ):
			return self._loop_vertex
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument loop_vertex is mantatory and can not be set to None')
			if not check_type(value,vertex):
				self._loop_vertex = vertex(value)
			else:
				self._loop_vertex = value
		return property(**locals())

####################
 # ENTITY annotation_occurrence_relationship #
####################
class annotation_occurrence_relationship(BaseEntityClass):
	'''Entity annotation_occurrence_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_annotation_occurrence
	:type relating_annotation_occurrence:annotation_occurrence

	:param related_annotation_occurrence
	:type related_annotation_occurrence:annotation_occurrence
	'''
	def __init__( self , name,description,relating_annotation_occurrence,related_annotation_occurrence, ):
		self.name = name
		self.description = description
		self.relating_annotation_occurrence = relating_annotation_occurrence
		self.related_annotation_occurrence = related_annotation_occurrence

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_annotation_occurrence():
		def fget( self ):
			return self._relating_annotation_occurrence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_annotation_occurrence is mantatory and can not be set to None')
			if not check_type(value,annotation_occurrence):
				self._relating_annotation_occurrence = annotation_occurrence(value)
			else:
				self._relating_annotation_occurrence = value
		return property(**locals())

	@apply
	def related_annotation_occurrence():
		def fget( self ):
			return self._related_annotation_occurrence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_annotation_occurrence is mantatory and can not be set to None')
			if not check_type(value,annotation_occurrence):
				self._related_annotation_occurrence = annotation_occurrence(value)
			else:
				self._related_annotation_occurrence = value
		return property(**locals())

####################
 # ENTITY annotation_occurrence_associativity #
####################
class annotation_occurrence_associativity(annotation_occurrence_relationship):
	'''Entity annotation_occurrence_associativity definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_annotation_occurrence , inherited3__related_annotation_occurrence ,  ):
		annotation_occurrence_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_annotation_occurrence , inherited3__related_annotation_occurrence , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(TYPEOF(self.self.related_annotation_occurrence)  *  ['AUTOMOTIVE_DESIGN.ANNOTATION_FILL_AREA_OCCURRENCE','AUTOMOTIVE_DESIGN.PROJECTION_CURVE','AUTOMOTIVE_DESIGN.LEADER_CURVE'])  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY runout_zone_definition #
####################
class runout_zone_definition(tolerance_zone_definition):
	'''Entity runout_zone_definition definition.

	:param orientation
	:type orientation:runout_zone_orientation
	'''
	def __init__( self , inherited0__zone , inherited1__boundaries , orientation, ):
		tolerance_zone_definition.__init__(self , inherited0__zone , inherited1__boundaries , )
		self.orientation = orientation

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,runout_zone_orientation):
				self._orientation = runout_zone_orientation(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY applied_effectivity_assignment #
####################
class applied_effectivity_assignment(effectivity_assignment):
	'''Entity applied_effectivity_assignment definition.

	:param items
	:type items:SET(1,None,'effectivity_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_effectivity , items, ):
		effectivity_assignment.__init__(self , inherited0__assigned_effectivity , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'effectivity_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'LOT_EFFECTIVITY','AUTOMOTIVE_DESIGN.'  +  'SERIAL_NUMBERED_EFFECTIVITY','AUTOMOTIVE_DESIGN.'  +  'PRODUCT_DEFINITION_EFFECTIVITY']  *  TYPEOF(self.self.assigned_effectivity))  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY approval_status #
####################
class approval_status(BaseEntityClass):
	'''Entity approval_status definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY cartesian_point #
####################
class cartesian_point(point):
	'''Entity cartesian_point definition.

	:param coordinates
	:type coordinates:LIST(1,3,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , coordinates, ):
		point.__init__(self , inherited0__name , )
		self.coordinates = coordinates

	@apply
	def coordinates():
		def fget( self ):
			return self._coordinates
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordinates is mantatory and can not be set to None')
			if not check_type(value,LIST(1,3,'REAL', scope = schema_scope)):
				self._coordinates = LIST(value)
			else:
				self._coordinates = value
		return property(**locals())

####################
 # ENTITY curve_style_rendering #
####################
class curve_style_rendering(BaseEntityClass):
	'''Entity curve_style_rendering definition.

	:param rendering_method
	:type rendering_method:shading_curve_method

	:param rendering_properties
	:type rendering_properties:surface_rendering_properties
	'''
	def __init__( self , rendering_method,rendering_properties, ):
		self.rendering_method = rendering_method
		self.rendering_properties = rendering_properties

	@apply
	def rendering_method():
		def fget( self ):
			return self._rendering_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rendering_method is mantatory and can not be set to None')
			if not check_type(value,shading_curve_method):
				self._rendering_method = shading_curve_method(value)
			else:
				self._rendering_method = value
		return property(**locals())

	@apply
	def rendering_properties():
		def fget( self ):
			return self._rendering_properties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rendering_properties is mantatory and can not be set to None')
			if not check_type(value,surface_rendering_properties):
				self._rendering_properties = surface_rendering_properties(value)
			else:
				self._rendering_properties = value
		return property(**locals())

####################
 # ENTITY fully_constrained_pair #
####################
class fully_constrained_pair(kinematic_pair):
	'''Entity fully_constrained_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint ,  ):
		kinematic_pair.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__joint , )

####################
 # ENTITY pre_defined_marker #
####################
class pre_defined_marker(pre_defined_item):
	'''Entity pre_defined_marker definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )

####################
 # ENTITY action_assignment #
####################
class action_assignment(BaseEntityClass):
	'''Entity action_assignment definition.

	:param assigned_action
	:type assigned_action:action

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_action, ):
		self.assigned_action = assigned_action

	@apply
	def assigned_action():
		def fget( self ):
			return self._assigned_action
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_action is mantatory and can not be set to None')
			if not check_type(value,action):
				self._assigned_action = action(value)
			else:
				self._assigned_action = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY composite_text_with_associated_curves #
####################
class composite_text_with_associated_curves(composite_text):
	'''Entity composite_text_with_associated_curves definition.

	:param associated_curves
	:type associated_curves:SET(1,None,'curve', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__collected_text , associated_curves, ):
		composite_text.__init__(self , inherited0__name , inherited1__collected_text , )
		self.associated_curves = associated_curves

	@apply
	def associated_curves():
		def fget( self ):
			return self._associated_curves
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument associated_curves is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'curve', scope = schema_scope)):
				self._associated_curves = SET(value)
			else:
				self._associated_curves = value
		return property(**locals())

####################
 # ENTITY compound_shape_representation #
####################
class compound_shape_representation(shape_representation):
	'''Entity compound_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_REPRESENTATION_CONTEXT')  ==  TYPEOF(self.self.context_of_items))  and  (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  >  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY fill_area_style_tiles #
####################
class fill_area_style_tiles(geometric_representation_item):
	'''Entity fill_area_style_tiles definition.

	:param tiling_pattern
	:type tiling_pattern:two_direction_repeat_factor

	:param tiles
	:type tiles:SET(1,None,'fill_area_style_tile_shape_select', scope = schema_scope)

	:param tiling_scale
	:type tiling_scale:positive_ratio_measure
	'''
	def __init__( self , inherited0__name , tiling_pattern,tiles,tiling_scale, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.tiling_pattern = tiling_pattern
		self.tiles = tiles
		self.tiling_scale = tiling_scale

	@apply
	def tiling_pattern():
		def fget( self ):
			return self._tiling_pattern
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tiling_pattern is mantatory and can not be set to None')
			if not check_type(value,two_direction_repeat_factor):
				self._tiling_pattern = two_direction_repeat_factor(value)
			else:
				self._tiling_pattern = value
		return property(**locals())

	@apply
	def tiles():
		def fget( self ):
			return self._tiles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tiles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'fill_area_style_tile_shape_select', scope = schema_scope)):
				self._tiles = SET(value)
			else:
				self._tiles = value
		return property(**locals())

	@apply
	def tiling_scale():
		def fget( self ):
			return self._tiling_scale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tiling_scale is mantatory and can not be set to None')
			if not check_type(value,positive_ratio_measure):
				self._tiling_scale = positive_ratio_measure(value)
			else:
				self._tiling_scale = value
		return property(**locals())

####################
 # ENTITY cos_function #
####################
class cos_function(unary_function_call):
	'''Entity cos_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY drawing_sheet_revision_usage #
####################
class drawing_sheet_revision_usage(area_in_set):
	'''Entity drawing_sheet_revision_usage definition.

	:param sheet_number
	:type sheet_number:identifier
	'''
	def __init__( self , inherited0__area , inherited1__in_set , sheet_number, ):
		area_in_set.__init__(self , inherited0__area , inherited1__in_set , )
		self.sheet_number = sheet_number

	@apply
	def sheet_number():
		def fget( self ):
			return self._sheet_number
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sheet_number is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._sheet_number = identifier(value)
			else:
				self._sheet_number = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.DRAWING_SHEET_REVISION'  ==  TYPEOF(self.self.area_in_set.self.area))  and  ('AUTOMOTIVE_DESIGN.DRAWING_REVISION'  ==  TYPEOF(self.self.area_in_set.self.in_set)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY kinematic_property_representation_relation #
####################
class kinematic_property_representation_relation(property_definition_representation):
	'''Entity kinematic_property_representation_relation definition.
	'''
	def __init__( self , inherited0__definition , inherited1__used_representation ,  ):
		property_definition_representation.__init__(self , inherited0__definition , inherited1__used_representation , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.KINEMATIC_PROPERTY_DEFINITION'  ==  TYPEOF(self.self.property_definition_representation.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AUTOMOTIVE_DESIGN.KINEMATIC_GROUND_REPRESENTATION'  ==  TYPEOF(self.self.property_definition_representation.self.used_representation))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY parametric_representation_context #
####################
class parametric_representation_context(representation_context):
	'''Entity parametric_representation_context definition.
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type ,  ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )

####################
 # ENTITY limits_and_fits #
####################
class limits_and_fits(BaseEntityClass):
	'''Entity limits_and_fits definition.

	:param form_variance
	:type form_variance:label

	:param zone_variance
	:type zone_variance:label

	:param grade
	:type grade:label

	:param source
	:type source:text
	'''
	def __init__( self , form_variance,zone_variance,grade,source, ):
		self.form_variance = form_variance
		self.zone_variance = zone_variance
		self.grade = grade
		self.source = source

	@apply
	def form_variance():
		def fget( self ):
			return self._form_variance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument form_variance is mantatory and can not be set to None')
			if not check_type(value,label):
				self._form_variance = label(value)
			else:
				self._form_variance = value
		return property(**locals())

	@apply
	def zone_variance():
		def fget( self ):
			return self._zone_variance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zone_variance is mantatory and can not be set to None')
			if not check_type(value,label):
				self._zone_variance = label(value)
			else:
				self._zone_variance = value
		return property(**locals())

	@apply
	def grade():
		def fget( self ):
			return self._grade
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument grade is mantatory and can not be set to None')
			if not check_type(value,label):
				self._grade = label(value)
			else:
				self._grade = value
		return property(**locals())

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source is mantatory and can not be set to None')
			if not check_type(value,text):
				self._source = text(value)
			else:
				self._source = value
		return property(**locals())

####################
 # ENTITY prismatic_pair_range #
####################
class prismatic_pair_range(simple_pair_range):
	'''Entity prismatic_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:prismatic_pair

	:param lower_limit_actual_translation
	:type lower_limit_actual_translation:translational_range_measure

	:param upper_limit_actual_translation
	:type upper_limit_actual_translation:translational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,lower_limit_actual_translation,upper_limit_actual_translation, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.lower_limit_actual_translation = lower_limit_actual_translation
		self.upper_limit_actual_translation = upper_limit_actual_translation

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,prismatic_pair):
				self._simple_pair_range_applies_to_pair = prismatic_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def lower_limit_actual_translation():
		def fget( self ):
			return self._lower_limit_actual_translation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_actual_translation is mantatory and can not be set to None')
			if not check_type(value,translational_range_measure):
				self._lower_limit_actual_translation = translational_range_measure(value)
			else:
				self._lower_limit_actual_translation = value
		return property(**locals())

	@apply
	def upper_limit_actual_translation():
		def fget( self ):
			return self._upper_limit_actual_translation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_actual_translation is mantatory and can not be set to None')
			if not check_type(value,translational_range_measure):
				self._upper_limit_actual_translation = translational_range_measure(value)
			else:
				self._upper_limit_actual_translation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_actual_translation))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_actual_translation))) XOR (self.lower_limit_actual_translation  <  self.upper_limit_actual_translation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_concept_context #
####################
class product_concept_context(application_context_element):
	'''Entity product_concept_context definition.

	:param market_segment_type
	:type market_segment_type:label
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , market_segment_type, ):
		application_context_element.__init__(self , inherited0__name , inherited1__frame_of_reference , )
		self.market_segment_type = market_segment_type

	@apply
	def market_segment_type():
		def fget( self ):
			return self._market_segment_type
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument market_segment_type is mantatory and can not be set to None')
			if not check_type(value,label):
				self._market_segment_type = label(value)
			else:
				self._market_segment_type = value
		return property(**locals())

####################
 # ENTITY text_literal_with_extent #
####################
class text_literal_with_extent(text_literal):
	'''Entity text_literal_with_extent definition.

	:param extent
	:type extent:planar_extent
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , extent, ):
		text_literal.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , )
		self.extent = extent

	@apply
	def extent():
		def fget( self ):
			return self._extent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extent is mantatory and can not be set to None')
			if not check_type(value,planar_extent):
				self._extent = planar_extent(value)
			else:
				self._extent = value
		return property(**locals())

####################
 # ENTITY binary_function_call #
####################
class binary_function_call(binary_numeric_expression):
	'''Entity binary_function_call definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		binary_numeric_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY cartesian_transformation_operator_2d #
####################
class cartesian_transformation_operator_2d(cartesian_transformation_operator):
	'''Entity cartesian_transformation_operator_2d definition.

	:param u
	:type u:LIST(2,2,'direction', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__description , inherited3__axis1 , inherited4__axis2 , inherited5__local_origin , inherited6__scale ,  ):
		cartesian_transformation_operator.__init__(self , inherited0__name , inherited1__name , inherited2__description , inherited3__axis1 , inherited4__axis2 , inherited5__local_origin , inherited6__scale , )

	@apply
	def u():
		def fget( self ):
			attribute_eval = base_axis(2,self.self.cartesian_transformation_operator.self.axis1,self.self.cartesian_transformation_operator.self.axis2, None )
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument u is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_action_assignment #
####################
class applied_action_assignment(action_assignment):
	'''Entity applied_action_assignment definition.

	:param items
	:type items:SET(1,None,'action_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action , items, ):
		action_assignment.__init__(self , inherited0__assigned_action , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'action_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY pre_defined_presentation_style #
####################
class pre_defined_presentation_style(founded_item,pre_defined_item):
	'''Entity pre_defined_presentation_style definition.
	'''
	def __init__( self , inherited0__name ,  ):
		founded_item.__init__(self , )
		pre_defined_item.__init__(self , inherited0__name , )

####################
 # ENTITY process_plan #
####################
class process_plan(action):
	'''Entity process_plan definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method ,  ):
		action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ACTION_RELATIONSHIP.RELATING_ACTION')))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY surface_patch #
####################
class surface_patch(founded_item):
	'''Entity surface_patch definition.

	:param parent_surface
	:type parent_surface:bounded_surface

	:param u_transition
	:type u_transition:transition_code

	:param v_transition
	:type v_transition:transition_code

	:param u_sense
	:type u_sense:BOOLEAN

	:param v_sense
	:type v_sense:BOOLEAN

	:param using_surfaces
	:type using_surfaces:BAG(1,None,'rectangular_composite_surface', scope = schema_scope)
	'''
	def __init__( self , parent_surface,u_transition,v_transition,u_sense,v_sense, ):
		founded_item.__init__(self , )
		self.parent_surface = parent_surface
		self.u_transition = u_transition
		self.v_transition = v_transition
		self.u_sense = u_sense
		self.v_sense = v_sense

	@apply
	def parent_surface():
		def fget( self ):
			return self._parent_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_surface is mantatory and can not be set to None')
			if not check_type(value,bounded_surface):
				self._parent_surface = bounded_surface(value)
			else:
				self._parent_surface = value
		return property(**locals())

	@apply
	def u_transition():
		def fget( self ):
			return self._u_transition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_transition is mantatory and can not be set to None')
			if not check_type(value,transition_code):
				self._u_transition = transition_code(value)
			else:
				self._u_transition = value
		return property(**locals())

	@apply
	def v_transition():
		def fget( self ):
			return self._v_transition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_transition is mantatory and can not be set to None')
			if not check_type(value,transition_code):
				self._v_transition = transition_code(value)
			else:
				self._v_transition = value
		return property(**locals())

	@apply
	def u_sense():
		def fget( self ):
			return self._u_sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_sense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._u_sense = BOOLEAN(value)
			else:
				self._u_sense = value
		return property(**locals())

	@apply
	def v_sense():
		def fget( self ):
			return self._v_sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_sense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._v_sense = BOOLEAN(value)
			else:
				self._v_sense = value
		return property(**locals())

	@apply
	def using_surfaces():
		def fget( self ):
			return self._using_surfaces
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument using_surfaces is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AUTOMOTIVE_DESIGN.CURVE_BOUNDED_SURFACE'  ==  TYPEOF(self.parent_surface)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY unconstrained_pair_value #
####################
class unconstrained_pair_value(pair_value):
	'''Entity unconstrained_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:unconstrained_pair

	:param actual_placement
	:type actual_placement:axis2_placement_3d
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_placement, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_placement = actual_placement

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,unconstrained_pair):
				self._pair_value_applies_to_pair = unconstrained_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_placement():
		def fget( self ):
			return self._actual_placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_placement is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._actual_placement = axis2_placement_3d(value)
			else:
				self._actual_placement = value
		return property(**locals())

####################
 # ENTITY security_classification_assignment #
####################
class security_classification_assignment(BaseEntityClass):
	'''Entity security_classification_assignment definition.

	:param assigned_security_classification
	:type assigned_security_classification:security_classification

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_security_classification, ):
		self.assigned_security_classification = assigned_security_classification

	@apply
	def assigned_security_classification():
		def fget( self ):
			return self._assigned_security_classification
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_security_classification is mantatory and can not be set to None')
			if not check_type(value,security_classification):
				self._assigned_security_classification = security_classification(value)
			else:
				self._assigned_security_classification = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_security_classification_assignment #
####################
class applied_security_classification_assignment(security_classification_assignment):
	'''Entity applied_security_classification_assignment definition.

	:param items
	:type items:SET(1,None,'security_classification_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_security_classification , items, ):
		security_classification_assignment.__init__(self , inherited0__assigned_security_classification , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'security_classification_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY log2_function #
####################
class log2_function(unary_function_call):
	'''Entity log2_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY product_definition_occurrence_relationship #
####################
class product_definition_occurrence_relationship(BaseEntityClass):
	'''Entity product_definition_occurrence_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param occurrence
	:type occurrence:product_definition

	:param occurrence_usage
	:type occurrence_usage:assembly_component_usage
	'''
	def __init__( self , name,description,occurrence,occurrence_usage, ):
		self.name = name
		self.description = description
		self.occurrence = occurrence
		self.occurrence_usage = occurrence_usage

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def occurrence():
		def fget( self ):
			return self._occurrence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument occurrence is mantatory and can not be set to None')
			if not check_type(value,product_definition):
				self._occurrence = product_definition(value)
			else:
				self._occurrence = value
		return property(**locals())

	@apply
	def occurrence_usage():
		def fget( self ):
			return self._occurrence_usage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument occurrence_usage is mantatory and can not be set to None')
			if not check_type(value,assembly_component_usage):
				self._occurrence_usage = assembly_component_usage(value)
			else:
				self._occurrence_usage = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.occurrence_usage.self.relating_product_definition  !=  self.occurrence)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.occurrence_usage.self.related_product_definition  !=  self.occurrence)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.occurrence.self.formation  ==  self.occurrence_usage.self.related_product_definition.self.formation)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY concentricity_tolerance #
####################
class concentricity_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity concentricity_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY approximation_tolerance #
####################
class approximation_tolerance(founded_item):
	'''Entity approximation_tolerance definition.

	:param tolerance
	:type tolerance:tolerance_select
	'''
	def __init__( self , tolerance, ):
		founded_item.__init__(self , )
		self.tolerance = tolerance

	@apply
	def tolerance():
		def fget( self ):
			return self._tolerance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tolerance is mantatory and can not be set to None')
			if not check_type(value,tolerance_select):
				self._tolerance = tolerance_select(value)
			else:
				self._tolerance = value
		return property(**locals())

####################
 # ENTITY length_unit #
####################
class length_unit(named_unit):
	'''Entity length_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  1)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY volume_measure_with_unit #
####################
class volume_measure_with_unit(measure_with_unit):
	'''Entity volume_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.VOLUME_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY dimension_related_tolerance_zone_element #
####################
class dimension_related_tolerance_zone_element(BaseEntityClass):
	'''Entity dimension_related_tolerance_zone_element definition.

	:param related_dimension
	:type related_dimension:dimensional_location

	:param related_element
	:type related_element:tolerance_zone_definition
	'''
	def __init__( self , related_dimension,related_element, ):
		self.related_dimension = related_dimension
		self.related_element = related_element

	@apply
	def related_dimension():
		def fget( self ):
			return self._related_dimension
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_dimension is mantatory and can not be set to None')
			if not check_type(value,dimensional_location):
				self._related_dimension = dimensional_location(value)
			else:
				self._related_dimension = value
		return property(**locals())

	@apply
	def related_element():
		def fget( self ):
			return self._related_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_element is mantatory and can not be set to None')
			if not check_type(value,tolerance_zone_definition):
				self._related_element = tolerance_zone_definition(value)
			else:
				self._related_element = value
		return property(**locals())

####################
 # ENTITY externally_defined_class #
####################
class externally_defined_class(class_,externally_defined_item):
	'''Entity externally_defined_class definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__item_id , inherited3__source ,  ):
		class.__init__(self , inherited0__name , inherited1__description , )
		externally_defined_item.__init__(self , inherited2__item_id , inherited3__source , )

####################
 # ENTITY surface_style_control_grid #
####################
class surface_style_control_grid(founded_item):
	'''Entity surface_style_control_grid definition.

	:param style_of_control_grid
	:type style_of_control_grid:curve_or_render
	'''
	def __init__( self , style_of_control_grid, ):
		founded_item.__init__(self , )
		self.style_of_control_grid = style_of_control_grid

	@apply
	def style_of_control_grid():
		def fget( self ):
			return self._style_of_control_grid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_control_grid is mantatory and can not be set to None')
			if not check_type(value,curve_or_render):
				self._style_of_control_grid = curve_or_render(value)
			else:
				self._style_of_control_grid = value
		return property(**locals())

####################
 # ENTITY advanced_face #
####################
class advanced_face(face_surface):
	'''Entity advanced_face definition.
	'''
	def __init__( self , inherited0__name , inherited1__bounds , inherited2__name , inherited3__face_geometry , inherited4__same_sense ,  ):
		face_surface.__init__(self , inherited0__name , inherited1__bounds , inherited2__name , inherited3__face_geometry , inherited4__same_sense , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.ELEMENTARY_SURFACE','AUTOMOTIVE_DESIGN.B_SPLINE_SURFACE','AUTOMOTIVE_DESIGN.SWEPT_SURFACE']  *  TYPEOF(self.face_geometry))  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (( not ('AUTOMOTIVE_DESIGN.SWEPT_SURFACE'  ==  TYPEOF(self.face_geometry)))  or  (SIZEOF(['AUTOMOTIVE_DESIGN.LINE','AUTOMOTIVE_DESIGN.CONIC','AUTOMOTIVE_DESIGN.POLYLINE','AUTOMOTIVE_DESIGN.B_SPLINE_CURVE']  *  TYPEOF(self.face_geometry.self.swept_surface.self.swept_curve))  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (((( not ('AUTOMOTIVE_DESIGN.SWEPT_SURFACE'  ==  TYPEOF(self.face_geometry)))  or  ( not ('AUTOMOTIVE_DESIGN.POLYLINE'  ==  TYPEOF(self.face_geometry.self.swept_surface.self.swept_curve))))  or  (SIZEOF(self.face_geometry.self.swept_surface.self.swept_curve.self.polyline.self.points)  >=  3))  and  (SIZEOF(None)  ==  0))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr


####################
 # ENTITY measure_representation_item #
####################
class measure_representation_item(representation_item,measure_with_unit):
	'''Entity measure_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__value_component , inherited2__unit_component ,  ):
		representation_item.__init__(self , inherited0__name , )
		measure_with_unit.__init__(self , inherited1__value_component , inherited2__unit_component , )

####################
 # ENTITY object_role #
####################
class object_role(BaseEntityClass):
	'''Entity object_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY right_circular_cone #
####################
class right_circular_cone(geometric_representation_item):
	'''Entity right_circular_cone definition.

	:param position
	:type position:axis1_placement

	:param height
	:type height:positive_length_measure

	:param radius
	:type radius:length_measure

	:param semi_angle
	:type semi_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , position,height,radius,semi_angle, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.position = position
		self.height = height
		self.radius = radius
		self.semi_angle = semi_angle

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._position = axis1_placement(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._height = positive_length_measure(value)
			else:
				self._height = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._radius = length_measure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def semi_angle():
		def fget( self ):
			return self._semi_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._semi_angle = plane_angle_measure(value)
			else:
				self._semi_angle = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.radius  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rolling_curve_pair_value #
####################
class rolling_curve_pair_value(pair_value):
	'''Entity rolling_curve_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:rolling_curve_pair

	:param actual_point_on_curve_1
	:type actual_point_on_curve_1:point_on_curve
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_point_on_curve_1, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_point_on_curve_1 = actual_point_on_curve_1

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,rolling_curve_pair):
				self._pair_value_applies_to_pair = rolling_curve_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_point_on_curve_1():
		def fget( self ):
			return self._actual_point_on_curve_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_point_on_curve_1 is mantatory and can not be set to None')
			if not check_type(value,point_on_curve):
				self._actual_point_on_curve_1 = point_on_curve(value)
			else:
				self._actual_point_on_curve_1 = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.pair_value.self.applies_to_pair.self.planar_curve_pair.self.curve_1  ==  self.actual_point_on_curve_1.self.basis_curve)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY security_classification_level #
####################
class security_classification_level(BaseEntityClass):
	'''Entity security_classification_level definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY symbol_target #
####################
class symbol_target(geometric_representation_item):
	'''Entity symbol_target definition.

	:param placement
	:type placement:axis2_placement

	:param x_scale
	:type x_scale:positive_ratio_measure

	:param y_scale
	:type y_scale:positive_ratio_measure
	'''
	def __init__( self , inherited0__name , placement,x_scale,y_scale, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.placement = placement
		self.x_scale = x_scale
		self.y_scale = y_scale

	@apply
	def placement():
		def fget( self ):
			return self._placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placement is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._placement = axis2_placement(value)
			else:
				self._placement = value
		return property(**locals())

	@apply
	def x_scale():
		def fget( self ):
			return self._x_scale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument x_scale is mantatory and can not be set to None')
			if not check_type(value,positive_ratio_measure):
				self._x_scale = positive_ratio_measure(value)
			else:
				self._x_scale = value
		return property(**locals())

	@apply
	def y_scale():
		def fget( self ):
			return self._y_scale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument y_scale is mantatory and can not be set to None')
			if not check_type(value,positive_ratio_measure):
				self._y_scale = positive_ratio_measure(value)
			else:
				self._y_scale = value
		return property(**locals())

####################
 # ENTITY thermodynamic_temperature_measure_with_unit #
####################
class thermodynamic_temperature_measure_with_unit(measure_with_unit):
	'''Entity thermodynamic_temperature_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.THERMODYNAMIC_TEMPERATURE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_document_usage_constraint_assignment #
####################
class applied_document_usage_constraint_assignment(document_usage_constraint_assignment):
	'''Entity applied_document_usage_constraint_assignment definition.

	:param items
	:type items:SET(1,None,'document_reference_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_document_usage , inherited1__role , items, ):
		document_usage_constraint_assignment.__init__(self , inherited0__assigned_document_usage , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'document_reference_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY approval_relationship #
####################
class approval_relationship(BaseEntityClass):
	'''Entity approval_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_approval
	:type relating_approval:approval

	:param related_approval
	:type related_approval:approval
	'''
	def __init__( self , name,description,relating_approval,related_approval, ):
		self.name = name
		self.description = description
		self.relating_approval = relating_approval
		self.related_approval = related_approval

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_approval():
		def fget( self ):
			return self._relating_approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_approval is mantatory and can not be set to None')
			if not check_type(value,approval):
				self._relating_approval = approval(value)
			else:
				self._relating_approval = value
		return property(**locals())

	@apply
	def related_approval():
		def fget( self ):
			return self._related_approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_approval is mantatory and can not be set to None')
			if not check_type(value,approval):
				self._related_approval = approval(value)
			else:
				self._related_approval = value
		return property(**locals())

####################
 # ENTITY atan_function #
####################
class atan_function(binary_function_call):
	'''Entity atan_function definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		binary_function_call.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY kinematic_link_representation_relation #
####################
class kinematic_link_representation_relation(BaseEntityClass):
	'''Entity kinematic_link_representation_relation definition.

	:param topological_aspects
	:type topological_aspects:kinematic_link

	:param geometric_aspects
	:type geometric_aspects:kinematic_link_representation
	'''
	def __init__( self , topological_aspects,geometric_aspects, ):
		self.topological_aspects = topological_aspects
		self.geometric_aspects = geometric_aspects

	@apply
	def topological_aspects():
		def fget( self ):
			return self._topological_aspects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument topological_aspects is mantatory and can not be set to None')
			if not check_type(value,kinematic_link):
				self._topological_aspects = kinematic_link(value)
			else:
				self._topological_aspects = value
		return property(**locals())

	@apply
	def geometric_aspects():
		def fget( self ):
			return self._geometric_aspects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument geometric_aspects is mantatory and can not be set to None')
			if not check_type(value,kinematic_link_representation):
				self._geometric_aspects = kinematic_link_representation(value)
			else:
				self._geometric_aspects = value
		return property(**locals())

####################
 # ENTITY pocket #
####################
class pocket(feature_definition):
	'''Entity pocket definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (self.self.description  ==  ['open rectangular','closed rectangular','complex'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((self.self.description  !=  'complex')  or  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((self.self.description  !=  'closed rectangular')  or  (SIZEOF(None)  ==  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.description  !=  'open rectangular')  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  <=  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  <=  1)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr


####################
 # ENTITY moments_of_inertia_representation #
####################
class moments_of_inertia_representation(representation):
	'''Entity moments_of_inertia_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.self.items)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY polyline #
####################
class polyline(bounded_curve):
	'''Entity polyline definition.

	:param points
	:type points:LIST(2,None,'cartesian_point', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , points, ):
		bounded_curve.__init__(self , inherited0__name , )
		self.points = points

	@apply
	def points():
		def fget( self ):
			return self._points
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument points is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'cartesian_point', scope = schema_scope)):
				self._points = LIST(value)
			else:
				self._points = value
		return property(**locals())

####################
 # ENTITY approval_person_organization #
####################
class approval_person_organization(BaseEntityClass):
	'''Entity approval_person_organization definition.

	:param person_organization
	:type person_organization:person_organization_select

	:param authorized_approval
	:type authorized_approval:approval

	:param role
	:type role:approval_role
	'''
	def __init__( self , person_organization,authorized_approval,role, ):
		self.person_organization = person_organization
		self.authorized_approval = authorized_approval
		self.role = role

	@apply
	def person_organization():
		def fget( self ):
			return self._person_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument person_organization is mantatory and can not be set to None')
			if not check_type(value,person_organization_select):
				self._person_organization = person_organization_select(value)
			else:
				self._person_organization = value
		return property(**locals())

	@apply
	def authorized_approval():
		def fget( self ):
			return self._authorized_approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument authorized_approval is mantatory and can not be set to None')
			if not check_type(value,approval):
				self._authorized_approval = approval(value)
			else:
				self._authorized_approval = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,approval_role):
				self._role = approval_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY chamfer #
####################
class chamfer(transition_feature):
	'''Entity chamfer definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		transition_feature.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY div_expression #
####################
class div_expression(binary_numeric_expression):
	'''Entity div_expression definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		binary_numeric_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY document_representation_type #
####################
class document_representation_type(BaseEntityClass):
	'''Entity document_representation_type definition.

	:param name
	:type name:label

	:param represented_document
	:type represented_document:document
	'''
	def __init__( self , name,represented_document, ):
		self.name = name
		self.represented_document = represented_document

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def represented_document():
		def fget( self ):
			return self._represented_document
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument represented_document is mantatory and can not be set to None')
			if not check_type(value,document):
				self._represented_document = document(value)
			else:
				self._represented_document = value
		return property(**locals())

####################
 # ENTITY kinematic_link_representation_association #
####################
class kinematic_link_representation_association(representation_relationship):
	'''Entity kinematic_link_representation_association definition.

	:param representation_relationship_rep_1
	:type representation_relationship_rep_1:kinematic_link_representation
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , representation_relationship_rep_1, ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
		self.representation_relationship_rep_1 = representation_relationship_rep_1

	@apply
	def representation_relationship_rep_1():
		def fget( self ):
			return self._representation_relationship_rep_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_rep_1 is mantatory and can not be set to None')
			if not check_type(value,kinematic_link_representation):
				self._representation_relationship_rep_1 = kinematic_link_representation(value)
			else:
				self._representation_relationship_rep_1 = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.representation_relationship.self.rep_2.self.context_of_items  ==  self.self.representation_relationship.self.rep_1.self.representation.self.context_of_items)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.KINEMATIC_GROUND_REPRESENTATION','AUTOMOTIVE_DESIGN.KINEMATIC_LINK_REPRESENTATION']  *  TYPEOF(self.self.representation_relationship.self.rep_2))  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY surface_style_silhouette #
####################
class surface_style_silhouette(founded_item):
	'''Entity surface_style_silhouette definition.

	:param style_of_silhouette
	:type style_of_silhouette:curve_or_render
	'''
	def __init__( self , style_of_silhouette, ):
		founded_item.__init__(self , )
		self.style_of_silhouette = style_of_silhouette

	@apply
	def style_of_silhouette():
		def fget( self ):
			return self._style_of_silhouette
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_silhouette is mantatory and can not be set to None')
			if not check_type(value,curve_or_render):
				self._style_of_silhouette = curve_or_render(value)
			else:
				self._style_of_silhouette = value
		return property(**locals())

####################
 # ENTITY revolute_pair_range #
####################
class revolute_pair_range(simple_pair_range):
	'''Entity revolute_pair_range definition.

	:param simple_pair_range_applies_to_pair
	:type simple_pair_range_applies_to_pair:revolute_pair

	:param lower_limit_actual_rotation
	:type lower_limit_actual_rotation:rotational_range_measure

	:param upper_limit_actual_rotation
	:type upper_limit_actual_rotation:rotational_range_measure
	'''
	def __init__( self , inherited0__applies_to_pair , simple_pair_range_applies_to_pair,lower_limit_actual_rotation,upper_limit_actual_rotation, ):
		simple_pair_range.__init__(self , inherited0__applies_to_pair , )
		self.simple_pair_range_applies_to_pair = simple_pair_range_applies_to_pair
		self.lower_limit_actual_rotation = lower_limit_actual_rotation
		self.upper_limit_actual_rotation = upper_limit_actual_rotation

	@apply
	def simple_pair_range_applies_to_pair():
		def fget( self ):
			return self._simple_pair_range_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument simple_pair_range_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,revolute_pair):
				self._simple_pair_range_applies_to_pair = revolute_pair(value)
			else:
				self._simple_pair_range_applies_to_pair = value
		return property(**locals())

	@apply
	def lower_limit_actual_rotation():
		def fget( self ):
			return self._lower_limit_actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_limit_actual_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._lower_limit_actual_rotation = rotational_range_measure(value)
			else:
				self._lower_limit_actual_rotation = value
		return property(**locals())

	@apply
	def upper_limit_actual_rotation():
		def fget( self ):
			return self._upper_limit_actual_rotation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_limit_actual_rotation is mantatory and can not be set to None')
			if not check_type(value,rotational_range_measure):
				self._upper_limit_actual_rotation = rotational_range_measure(value)
			else:
				self._upper_limit_actual_rotation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.lower_limit_actual_rotation))  or  ('AUTOMOTIVE_DESIGN.UNLIMITED_RANGE'  ==  TYPEOF(self.upper_limit_actual_rotation))) XOR (self.lower_limit_actual_rotation  <  self.upper_limit_actual_rotation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY structured_dimension_callout #
####################
class structured_dimension_callout(draughting_callout):
	'''Entity structured_dimension_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(TYPEOF(self)  *  ['AUTOMOTIVE_DESIGN.DATUM_FEATURE_CALLOUT','AUTOMOTIVE_DESIGN.DATUM_TARGET_CALLOUT','AUTOMOTIVE_DESIGN.GEOMETRICAL_TOLERANCE_CALLOUT','AUTOMOTIVE_DESIGN.LEADER_DIRECTED_CALLOUT','AUTOMOTIVE_DESIGN.PROJECTION_DIRECTED_CALLOUT','AUTOMOTIVE_DESIGN.DIMENSION_CURVE_DIRECTED_CALLOUT'])  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  >=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  <=  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  <=  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (( not (SIZEOF(None)  >  0))  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (( not (SIZEOF(None)  >  0))  or  (SIZEOF(None)  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY time_interval_based_effectivity #
####################
class time_interval_based_effectivity(effectivity):
	'''Entity time_interval_based_effectivity definition.

	:param effectivity_period
	:type effectivity_period:time_interval
	'''
	def __init__( self , inherited0__id , effectivity_period, ):
		effectivity.__init__(self , inherited0__id , )
		self.effectivity_period = effectivity_period

	@apply
	def effectivity_period():
		def fget( self ):
			return self._effectivity_period
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument effectivity_period is mantatory and can not be set to None')
			if not check_type(value,time_interval):
				self._effectivity_period = time_interval(value)
			else:
				self._effectivity_period = value
		return property(**locals())

####################
 # ENTITY dimensional_size_with_path #
####################
class dimensional_size_with_path(dimensional_size):
	'''Entity dimensional_size_with_path definition.

	:param path
	:type path:shape_aspect
	'''
	def __init__( self , inherited0__applies_to , inherited1__name , path, ):
		dimensional_size.__init__(self , inherited0__applies_to , inherited1__name , )
		self.path = path

	@apply
	def path():
		def fget( self ):
			return self._path
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument path is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._path = shape_aspect(value)
			else:
				self._path = value
		return property(**locals())

####################
 # ENTITY two_direction_repeat_factor #
####################
class two_direction_repeat_factor(one_direction_repeat_factor):
	'''Entity two_direction_repeat_factor definition.

	:param second_repeat_factor
	:type second_repeat_factor:vector
	'''
	def __init__( self , inherited0__name , inherited1__repeat_factor , second_repeat_factor, ):
		one_direction_repeat_factor.__init__(self , inherited0__name , inherited1__repeat_factor , )
		self.second_repeat_factor = second_repeat_factor

	@apply
	def second_repeat_factor():
		def fget( self ):
			return self._second_repeat_factor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument second_repeat_factor is mantatory and can not be set to None')
			if not check_type(value,vector):
				self._second_repeat_factor = vector(value)
			else:
				self._second_repeat_factor = value
		return property(**locals())

####################
 # ENTITY retention #
####################
class retention(action):
	'''Entity retention definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method ,  ):
		action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))  and  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ACTION_RELATIONSHIP.RELATING_ACTION'))  +  SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.ACTION_RELATIONSHIP.RELATED_ACTION')))  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY revolved_face_solid #
####################
class revolved_face_solid(swept_face_solid):
	'''Entity revolved_face_solid definition.

	:param axis
	:type axis:axis1_placement

	:param angle
	:type angle:plane_angle_measure

	:param axis_line
	:type axis_line:line
	'''
	def __init__( self , inherited0__name , inherited1__swept_face , axis,angle, ):
		swept_face_solid.__init__(self , inherited0__name , inherited1__swept_face , )
		self.axis = axis
		self.angle = angle

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axis is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._axis = axis1_placement(value)
			else:
				self._axis = value
		return property(**locals())

	@apply
	def angle():
		def fget( self ):
			return self._angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._angle = plane_angle_measure(value)
			else:
				self._angle = value
		return property(**locals())

	@apply
	def axis_line():
		def fget( self ):
			attribute_eval = (((representation_item('')  ==  geometric_representation_item())  ==  curve())  ==  line(self.axis.self.location,(representation_item('')  ==  geometric_representation_item())  ==  vector(self.axis.self.z,1)))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument axis_line is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY invisibility #
####################
class invisibility(BaseEntityClass):
	'''Entity invisibility definition.

	:param invisible_items
	:type invisible_items:SET(1,None,'invisible_item', scope = schema_scope)
	'''
	def __init__( self , invisible_items, ):
		self.invisible_items = invisible_items

	@apply
	def invisible_items():
		def fget( self ):
			return self._invisible_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument invisible_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'invisible_item', scope = schema_scope)):
				self._invisible_items = SET(value)
			else:
				self._invisible_items = value
		return property(**locals())

####################
 # ENTITY surface_replica #
####################
class surface_replica(surface):
	'''Entity surface_replica definition.

	:param parent_surface
	:type parent_surface:surface

	:param transformation
	:type transformation:cartesian_transformation_operator_3d
	'''
	def __init__( self , inherited0__name , parent_surface,transformation, ):
		surface.__init__(self , inherited0__name , )
		self.parent_surface = parent_surface
		self.transformation = transformation

	@apply
	def parent_surface():
		def fget( self ):
			return self._parent_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._parent_surface = surface(value)
			else:
				self._parent_surface = value
		return property(**locals())

	@apply
	def transformation():
		def fget( self ):
			return self._transformation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transformation is mantatory and can not be set to None')
			if not check_type(value,cartesian_transformation_operator_3d):
				self._transformation = cartesian_transformation_operator_3d(value)
			else:
				self._transformation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = acyclic_surface_replica(self,self.parent_surface)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY text_style_with_mirror #
####################
class text_style_with_mirror(text_style):
	'''Entity text_style_with_mirror definition.

	:param mirror_placement
	:type mirror_placement:axis2_placement
	'''
	def __init__( self , inherited0__name , inherited1__character_appearance , mirror_placement, ):
		text_style.__init__(self , inherited0__name , inherited1__character_appearance , )
		self.mirror_placement = mirror_placement

	@apply
	def mirror_placement():
		def fget( self ):
			return self._mirror_placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mirror_placement is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._mirror_placement = axis2_placement(value)
			else:
				self._mirror_placement = value
		return property(**locals())

####################
 # ENTITY context_dependent_invisibility #
####################
class context_dependent_invisibility(invisibility):
	'''Entity context_dependent_invisibility definition.

	:param presentation_context
	:type presentation_context:invisibility_context
	'''
	def __init__( self , inherited0__invisible_items , presentation_context, ):
		invisibility.__init__(self , inherited0__invisible_items , )
		self.presentation_context = presentation_context

	@apply
	def presentation_context():
		def fget( self ):
			return self._presentation_context
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument presentation_context is mantatory and can not be set to None')
			if not check_type(value,invisibility_context):
				self._presentation_context = invisibility_context(value)
			else:
				self._presentation_context = value
		return property(**locals())

####################
 # ENTITY fillet #
####################
class fillet(transition_feature):
	'''Entity fillet definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		transition_feature.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = ((self.self.description  !=  'constant radius') XOR (SIZEOF(None)  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((self.self.description  !=  'constant radius')  or  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((self.self.description  !=  'constant radius')  or  (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.description  !=  'constant radius')  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'constant radius')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.description  !=  'constant radius')  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  1)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr


####################
 # ENTITY log10_function #
####################
class log10_function(unary_function_call):
	'''Entity log10_function definition.
	'''
	def __init__( self , inherited0__operand , inherited1__unary_generic_expression_operand ,  ):
		unary_function_call.__init__(self , inherited0__operand , inherited1__unary_generic_expression_operand , )

####################
 # ENTITY thread #
####################
class thread(feature_definition):
	'''Entity thread definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  <=  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  <=  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  1)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  1)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  <=  1)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr


####################
 # ENTITY faceted_brep_shape_representation #
####################
class faceted_brep_shape_representation(shape_representation):
	'''Entity faceted_brep_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY document_usage_constraint #
####################
class document_usage_constraint(BaseEntityClass):
	'''Entity document_usage_constraint definition.

	:param source
	:type source:document

	:param subject_element
	:type subject_element:label

	:param subject_element_value
	:type subject_element_value:text
	'''
	def __init__( self , source,subject_element,subject_element_value, ):
		self.source = source
		self.subject_element = subject_element
		self.subject_element_value = subject_element_value

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source is mantatory and can not be set to None')
			if not check_type(value,document):
				self._source = document(value)
			else:
				self._source = value
		return property(**locals())

	@apply
	def subject_element():
		def fget( self ):
			return self._subject_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument subject_element is mantatory and can not be set to None')
			if not check_type(value,label):
				self._subject_element = label(value)
			else:
				self._subject_element = value
		return property(**locals())

	@apply
	def subject_element_value():
		def fget( self ):
			return self._subject_element_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument subject_element_value is mantatory and can not be set to None')
			if not check_type(value,text):
				self._subject_element_value = text(value)
			else:
				self._subject_element_value = value
		return property(**locals())

####################
 # ENTITY light_source_spot #
####################
class light_source_spot(light_source):
	'''Entity light_source_spot definition.

	:param position
	:type position:cartesian_point

	:param orientation
	:type orientation:direction

	:param concentration_exponent
	:type concentration_exponent:REAL

	:param constant_attenuation
	:type constant_attenuation:REAL

	:param distance_attenuation
	:type distance_attenuation:REAL

	:param spread_angle
	:type spread_angle:positive_plane_angle_measure
	'''
	def __init__( self , inherited0__name , inherited1__light_colour , position,orientation,concentration_exponent,constant_attenuation,distance_attenuation,spread_angle, ):
		light_source.__init__(self , inherited0__name , inherited1__light_colour , )
		self.position = position
		self.orientation = orientation
		self.concentration_exponent = concentration_exponent
		self.constant_attenuation = constant_attenuation
		self.distance_attenuation = distance_attenuation
		self.spread_angle = spread_angle

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._position = cartesian_point(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._orientation = direction(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def concentration_exponent():
		def fget( self ):
			return self._concentration_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument concentration_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._concentration_exponent = REAL(value)
			else:
				self._concentration_exponent = value
		return property(**locals())

	@apply
	def constant_attenuation():
		def fget( self ):
			return self._constant_attenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constant_attenuation is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._constant_attenuation = REAL(value)
			else:
				self._constant_attenuation = value
		return property(**locals())

	@apply
	def distance_attenuation():
		def fget( self ):
			return self._distance_attenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance_attenuation is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._distance_attenuation = REAL(value)
			else:
				self._distance_attenuation = value
		return property(**locals())

	@apply
	def spread_angle():
		def fget( self ):
			return self._spread_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument spread_angle is mantatory and can not be set to None')
			if not check_type(value,positive_plane_angle_measure):
				self._spread_angle = positive_plane_angle_measure(value)
			else:
				self._spread_angle = value
		return property(**locals())

####################
 # ENTITY presentation_style_by_context #
####################
class presentation_style_by_context(presentation_style_assignment):
	'''Entity presentation_style_by_context definition.

	:param style_context
	:type style_context:style_context_select
	'''
	def __init__( self , inherited0__styles , style_context, ):
		presentation_style_assignment.__init__(self , inherited0__styles , )
		self.style_context = style_context

	@apply
	def style_context():
		def fget( self ):
			return self._style_context
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_context is mantatory and can not be set to None')
			if not check_type(value,style_context_select):
				self._style_context = style_context_select(value)
			else:
				self._style_context = value
		return property(**locals())

####################
 # ENTITY shape_dimension_representation #
####################
class shape_dimension_representation(shape_representation):
	'''Entity shape_dimension_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.representation.self.items)  <=  3)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY vertex_point #
####################
class vertex_point(vertex,geometric_representation_item):
	'''Entity vertex_point definition.

	:param vertex_geometry
	:type vertex_geometry:point
	'''
	def __init__( self , inherited0__name , inherited1__name , vertex_geometry, ):
		vertex.__init__(self , inherited0__name , )
		geometric_representation_item.__init__(self , inherited1__name , )
		self.vertex_geometry = vertex_geometry

	@apply
	def vertex_geometry():
		def fget( self ):
			return self._vertex_geometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vertex_geometry is mantatory and can not be set to None')
			if not check_type(value,point):
				self._vertex_geometry = point(value)
			else:
				self._vertex_geometry = value
		return property(**locals())

####################
 # ENTITY annotation_symbol #
####################
class annotation_symbol(mapped_item):
	'''Entity annotation_symbol definition.

	:param mapped_item_mapping_source
	:type mapped_item_mapping_source:symbol_representation_map

	:param mapped_item_mapping_target
	:type mapped_item_mapping_target:symbol_target
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , mapped_item_mapping_source,mapped_item_mapping_target, ):
		mapped_item.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , )
		self.mapped_item_mapping_source = mapped_item_mapping_source
		self.mapped_item_mapping_target = mapped_item_mapping_target

	@apply
	def mapped_item_mapping_source():
		def fget( self ):
			return self._mapped_item_mapping_source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_source is mantatory and can not be set to None')
			if not check_type(value,symbol_representation_map):
				self._mapped_item_mapping_source = symbol_representation_map(value)
			else:
				self._mapped_item_mapping_source = value
		return property(**locals())

	@apply
	def mapped_item_mapping_target():
		def fget( self ):
			return self._mapped_item_mapping_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_target is mantatory and can not be set to None')
			if not check_type(value,symbol_target):
				self._mapped_item_mapping_target = symbol_target(value)
			else:
				self._mapped_item_mapping_target = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.GEOMETRIC_REPRESENTATION_ITEM'  ==  TYPEOF(self))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY centre_of_symmetry #
####################
class centre_of_symmetry(derived_shape_aspect):
	'''Entity centre_of_symmetry definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY string_literal #
####################
class string_literal(simple_string_expression,generic_literal):
	'''Entity string_literal definition.

	:param the_value
	:type the_value:STRING
	'''
	def __init__( self , the_value, ):
		simple_string_expression.__init__(self , )
		generic_literal.__init__(self , )
		self.the_value = the_value

	@apply
	def the_value():
		def fget( self ):
			return self._the_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument the_value is mantatory and can not be set to None')
			if not check_type(value,STRING):
				self._the_value = STRING(value)
			else:
				self._the_value = value
		return property(**locals())

####################
 # ENTITY oriented_closed_shell #
####################
class oriented_closed_shell(closed_shell):
	'''Entity oriented_closed_shell definition.

	:param closed_shell_element
	:type closed_shell_element:closed_shell

	:param orientation
	:type orientation:BOOLEAN

	:param connected_face_set_cfs_faces
	:type connected_face_set_cfs_faces:SET(1,None,'face', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces , closed_shell_element,orientation, ):
		closed_shell.__init__(self , inherited0__name , inherited1__cfs_faces , )
		self.closed_shell_element = closed_shell_element
		self.orientation = orientation

	@apply
	def closed_shell_element():
		def fget( self ):
			return self._closed_shell_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument closed_shell_element is mantatory and can not be set to None')
			if not check_type(value,closed_shell):
				self._closed_shell_element = closed_shell(value)
			else:
				self._closed_shell_element = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def connected_face_set_cfs_faces():
		def fget( self ):
			attribute_eval = conditional_reverse(self.self.orientation,self.self.closed_shell_element.self.cfs_faces)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument connected_face_set_cfs_faces is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AUTOMOTIVE_DESIGN.ORIENTED_CLOSED_SHELL'  ==  TYPEOF(self.self.closed_shell_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY point_on_planar_curve_pair_value #
####################
class point_on_planar_curve_pair_value(pair_value):
	'''Entity point_on_planar_curve_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:point_on_planar_curve_pair

	:param actual_point_on_curve
	:type actual_point_on_curve:point_on_curve

	:param input_orientation
	:type input_orientation:spatial_rotation

	:param actual_orientation
	:type actual_orientation:ARRAY(ypr_index(yaw),ypr_index(roll),'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,actual_point_on_curve,input_orientation, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.actual_point_on_curve = actual_point_on_curve
		self.input_orientation = input_orientation

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,point_on_planar_curve_pair):
				self._pair_value_applies_to_pair = point_on_planar_curve_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def actual_point_on_curve():
		def fget( self ):
			return self._actual_point_on_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actual_point_on_curve is mantatory and can not be set to None')
			if not check_type(value,point_on_curve):
				self._actual_point_on_curve = point_on_curve(value)
			else:
				self._actual_point_on_curve = value
		return property(**locals())

	@apply
	def input_orientation():
		def fget( self ):
			return self._input_orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument input_orientation is mantatory and can not be set to None')
			if not check_type(value,spatial_rotation):
				self._input_orientation = spatial_rotation(value)
			else:
				self._input_orientation = value
		return property(**locals())

	@apply
	def actual_orientation():
		def fget( self ):
			attribute_eval = convert_spatial_to_ypr_rotation(self.self.pair_value.self.applies_to_pair,self.input_orientation)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument actual_orientation is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.pair_value.self.applies_to_pair.self.point_on_planar_curve_pair.self.pair_curve  ==  self.actual_point_on_curve.self.basis_curve)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rounded_u_profile #
####################
class rounded_u_profile(shape_aspect):
	'''Entity rounded_u_profile definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY boss_top #
####################
class boss_top(shape_aspect):
	'''Entity boss_top definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.description  ==  ['planar','complex'])
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((self.self.description  !=  'planar')  or  (SIZEOF(None)  ==  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.description  !=  'planar')  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.description  !=  'complex')  or  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  ==  0))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  <=  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr


####################
 # ENTITY constructive_geometry_representation_relationship #
####################
class constructive_geometry_representation_relationship(representation_relationship):
	'''Entity constructive_geometry_representation_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 ,  ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
	def wr1(self):
		eval_wr1_wr = ((self.self.rep_1.self.context_of_items  ==  self.self.rep_2.self.context_of_items)  and  (('AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_REPRESENTATION_CONTEXT')  ==  TYPEOF(self.self.rep_1.self.context_of_items)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('AUTOMOTIVE_DESIGN.'  +  'CONSTRUCTIVE_GEOMETRY_REPRESENTATION')  ==  TYPEOF(self.self.rep_2))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(['AUTOMOTIVE_DESIGN.'  +  'SHAPE_REPRESENTATION','AUTOMOTIVE_DESIGN.'  +  'CONSTRUCTIVE_GEOMETRY_REPRESENTATION']  *  TYPEOF(self.self.rep_1))  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ( not (('AUTOMOTIVE_DESIGN.'  +  'REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION')  ==  TYPEOF(self)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY hardness_representation #
####################
class hardness_representation(representation):
	'''Entity hardness_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (((2  <=  SIZEOF(self.self.items))  and  (SIZEOF(self.self.items)  <=  4))  and  ((SIZEOF(None)  +  SIZEOF(None))  ==  SIZEOF(self.self.items)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  <=  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  <=  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY joggle #
####################
class joggle(feature_definition):
	'''Entity joggle definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  <=  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  1)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  <=  1)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  <=  1)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  <=  1)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(None)  <=  1)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr


####################
 # ENTITY person_and_organization #
####################
class person_and_organization(BaseEntityClass):
	'''Entity person_and_organization definition.

	:param the_person
	:type the_person:person

	:param the_organization
	:type the_organization:organization

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , the_person,the_organization, ):
		self.the_person = the_person
		self.the_organization = the_organization

	@apply
	def the_person():
		def fget( self ):
			return self._the_person
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument the_person is mantatory and can not be set to None')
			if not check_type(value,person):
				self._the_person = person(value)
			else:
				self._the_person = value
		return property(**locals())

	@apply
	def the_organization():
		def fget( self ):
			return self._the_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument the_organization is mantatory and can not be set to None')
			if not check_type(value,organization):
				self._the_organization = organization(value)
			else:
				self._the_organization = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY curve_dimension #
####################
class curve_dimension(dimension_curve_directed_callout):
	'''Entity curve_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		dimension_curve_directed_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY inclusion_product_concept_feature #
####################
class inclusion_product_concept_feature(conditional_concept_feature):
	'''Entity inclusion_product_concept_feature definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__condition ,  ):
		conditional_concept_feature.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__condition , )
	def wr1(self):
		eval_wr1_wr = ( not (('AUTOMOTIVE_DESIGN.'  +  'PACKAGE_PRODUCT_CONCEPT_FEATURE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(None)  +  SIZEOF(None))  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.condition.self.conditional_operator.self.name  ==  'implication')
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ratio_measure_with_unit #
####################
class ratio_measure_with_unit(measure_with_unit):
	'''Entity ratio_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.RATIO_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rectangular_pattern #
####################
class rectangular_pattern(replicate_feature):
	'''Entity rectangular_pattern definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		replicate_feature.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY general_feature #
####################
class general_feature(feature_definition):
	'''Entity general_feature definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		feature_definition.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(get_property_definition_representations(self))  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  SIZEOF(None))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  SIZEOF(None))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  SIZEOF(None))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY tee_profile #
####################
class tee_profile(shape_aspect):
	'''Entity tee_profile definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  1)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  1)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  1)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  1)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(None)  ==  1)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr

	def wr15(self):
		eval_wr15_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr15_wr:
			raise AssertionError('Rule wr15 violated')
		else:
			return eval_wr15_wr


####################
 # ENTITY universal_pair_value #
####################
class universal_pair_value(pair_value):
	'''Entity universal_pair_value definition.

	:param pair_value_applies_to_pair
	:type pair_value_applies_to_pair:universal_pair

	:param first_rotation_angle
	:type first_rotation_angle:plane_angle_measure

	:param second_rotation_angle
	:type second_rotation_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__applies_to_pair , pair_value_applies_to_pair,first_rotation_angle,second_rotation_angle, ):
		pair_value.__init__(self , inherited0__applies_to_pair , )
		self.pair_value_applies_to_pair = pair_value_applies_to_pair
		self.first_rotation_angle = first_rotation_angle
		self.second_rotation_angle = second_rotation_angle

	@apply
	def pair_value_applies_to_pair():
		def fget( self ):
			return self._pair_value_applies_to_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pair_value_applies_to_pair is mantatory and can not be set to None')
			if not check_type(value,universal_pair):
				self._pair_value_applies_to_pair = universal_pair(value)
			else:
				self._pair_value_applies_to_pair = value
		return property(**locals())

	@apply
	def first_rotation_angle():
		def fget( self ):
			return self._first_rotation_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument first_rotation_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._first_rotation_angle = plane_angle_measure(value)
			else:
				self._first_rotation_angle = value
		return property(**locals())

	@apply
	def second_rotation_angle():
		def fget( self ):
			return self._second_rotation_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument second_rotation_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._second_rotation_angle = plane_angle_measure(value)
			else:
				self._second_rotation_angle = value
		return property(**locals())

####################
 # ENTITY pre_defined_point_marker_symbol #
####################
class pre_defined_point_marker_symbol(pre_defined_marker,pre_defined_symbol):
	'''Entity pre_defined_point_marker_symbol definition.
	'''
	def __init__( self , inherited0__name , inherited1__name ,  ):
		pre_defined_marker.__init__(self , inherited0__name , )
		pre_defined_symbol.__init__(self , inherited1__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['asterisk','circle','dot','plus','square','triangle','x'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY sphere #
####################
class sphere(geometric_representation_item):
	'''Entity sphere definition.

	:param radius
	:type radius:positive_length_measure

	:param centre
	:type centre:point
	'''
	def __init__( self , inherited0__name , radius,centre, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.radius = radius
		self.centre = centre

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def centre():
		def fget( self ):
			return self._centre
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument centre is mantatory and can not be set to None')
			if not check_type(value,point):
				self._centre = point(value)
			else:
				self._centre = value
		return property(**locals())

####################
 # ENTITY cylindrical_surface #
####################
class cylindrical_surface(elementary_surface):
	'''Entity cylindrical_surface definition.

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY general_property_relationship #
####################
class general_property_relationship(BaseEntityClass):
	'''Entity general_property_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_property
	:type relating_property:general_property

	:param related_property
	:type related_property:general_property
	'''
	def __init__( self , name,description,relating_property,related_property, ):
		self.name = name
		self.description = description
		self.relating_property = relating_property
		self.related_property = related_property

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_property():
		def fget( self ):
			return self._relating_property
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_property is mantatory and can not be set to None')
			if not check_type(value,general_property):
				self._relating_property = general_property(value)
			else:
				self._relating_property = value
		return property(**locals())

	@apply
	def related_property():
		def fget( self ):
			return self._related_property
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_property is mantatory and can not be set to None')
			if not check_type(value,general_property):
				self._related_property = general_property(value)
			else:
				self._related_property = value
		return property(**locals())

####################
 # ENTITY local_time #
####################
class local_time(BaseEntityClass):
	'''Entity local_time definition.

	:param hour_component
	:type hour_component:hour_in_day

	:param minute_component
	:type minute_component:minute_in_hour

	:param second_component
	:type second_component:second_in_minute

	:param zone
	:type zone:coordinated_universal_time_offset
	'''
	def __init__( self , hour_component,minute_component,second_component,zone, ):
		self.hour_component = hour_component
		self.minute_component = minute_component
		self.second_component = second_component
		self.zone = zone

	@apply
	def hour_component():
		def fget( self ):
			return self._hour_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hour_component is mantatory and can not be set to None')
			if not check_type(value,hour_in_day):
				self._hour_component = hour_in_day(value)
			else:
				self._hour_component = value
		return property(**locals())

	@apply
	def minute_component():
		def fget( self ):
			return self._minute_component
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,minute_in_hour):
					self._minute_component = minute_in_hour(value)
				else:
					self._minute_component = value
			else:
				self._minute_component = value
		return property(**locals())

	@apply
	def second_component():
		def fget( self ):
			return self._second_component
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,second_in_minute):
					self._second_component = second_in_minute(value)
				else:
					self._second_component = value
			else:
				self._second_component = value
		return property(**locals())

	@apply
	def zone():
		def fget( self ):
			return self._zone
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zone is mantatory and can not be set to None')
			if not check_type(value,coordinated_universal_time_offset):
				self._zone = coordinated_universal_time_offset(value)
			else:
				self._zone = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = valid_time(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY mass_unit #
####################
class mass_unit(named_unit):
	'''Entity mass_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  1))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY symbol_colour #
####################
class symbol_colour(BaseEntityClass):
	'''Entity symbol_colour definition.

	:param colour_of_symbol
	:type colour_of_symbol:colour
	'''
	def __init__( self , colour_of_symbol, ):
		self.colour_of_symbol = colour_of_symbol

	@apply
	def colour_of_symbol():
		def fget( self ):
			return self._colour_of_symbol
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument colour_of_symbol is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._colour_of_symbol = colour(value)
			else:
				self._colour_of_symbol = value
		return property(**locals())

####################
 # ENTITY solid_replica #
####################
class solid_replica(solid_model):
	'''Entity solid_replica definition.

	:param parent_solid
	:type parent_solid:solid_model

	:param transformation
	:type transformation:cartesian_transformation_operator_3d
	'''
	def __init__( self , inherited0__name , parent_solid,transformation, ):
		solid_model.__init__(self , inherited0__name , )
		self.parent_solid = parent_solid
		self.transformation = transformation

	@apply
	def parent_solid():
		def fget( self ):
			return self._parent_solid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_solid is mantatory and can not be set to None')
			if not check_type(value,solid_model):
				self._parent_solid = solid_model(value)
			else:
				self._parent_solid = value
		return property(**locals())

	@apply
	def transformation():
		def fget( self ):
			return self._transformation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transformation is mantatory and can not be set to None')
			if not check_type(value,cartesian_transformation_operator_3d):
				self._transformation = cartesian_transformation_operator_3d(value)
			else:
				self._transformation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = acyclic_solid_replica(self,self.parent_solid)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.parent_solid.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY material_designation_characterization #
####################
class material_designation_characterization(BaseEntityClass):
	'''Entity material_designation_characterization definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param designation
	:type designation:material_designation

	:param property
	:type property:characterized_material_property
	'''
	def __init__( self , name,description,designation,property, ):
		self.name = name
		self.description = description
		self.designation = designation
		self.property = property

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def designation():
		def fget( self ):
			return self._designation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument designation is mantatory and can not be set to None')
			if not check_type(value,material_designation):
				self._designation = material_designation(value)
			else:
				self._designation = value
		return property(**locals())

	@apply
	def property():
		def fget( self ):
			return self._property
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument property is mantatory and can not be set to None')
			if not check_type(value,characterized_material_property):
				self._property = characterized_material_property(value)
			else:
				self._property = value
		return property(**locals())

####################
 # ENTITY coaxiality_tolerance #
####################
class coaxiality_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity coaxiality_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY minimum_function #
####################
class minimum_function(multiple_arity_function_call):
	'''Entity minimum_function definition.
	'''
	def __init__( self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands ,  ):
		multiple_arity_function_call.__init__(self , inherited0__operands , inherited1__multiple_arity_generic_expression_operands , )

####################
 # ENTITY poly_loop #
####################
class poly_loop(loop,geometric_representation_item):
	'''Entity poly_loop definition.

	:param polygon
	:type polygon:LIST(3,None,'cartesian_point', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__name , polygon, ):
		loop.__init__(self , inherited0__name , )
		geometric_representation_item.__init__(self , inherited1__name , )
		self.polygon = polygon

	@apply
	def polygon():
		def fget( self ):
			return self._polygon
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument polygon is mantatory and can not be set to None')
			if not check_type(value,LIST(3,None,'cartesian_point', scope = schema_scope)):
				self._polygon = LIST(value)
			else:
				self._polygon = value
		return property(**locals())

####################
 # ENTITY surface_rendering_properties #
####################
class surface_rendering_properties(BaseEntityClass):
	'''Entity surface_rendering_properties definition.

	:param rendered_colour
	:type rendered_colour:colour
	'''
	def __init__( self , rendered_colour, ):
		self.rendered_colour = rendered_colour

	@apply
	def rendered_colour():
		def fget( self ):
			return self._rendered_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rendered_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._rendered_colour = colour(value)
			else:
				self._rendered_colour = value
		return property(**locals())

####################
 # ENTITY camera_image_2d_with_scale #
####################
class camera_image_2d_with_scale(camera_image):
	'''Entity camera_image_2d_with_scale definition.

	:param scale
	:type scale:positive_ratio_measure
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , inherited3__mapped_item_mapping_source , inherited4__mapped_item_mapping_target ,  ):
		camera_image.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , inherited3__mapped_item_mapping_source , inherited4__mapped_item_mapping_target , )

	@apply
	def scale():
		def fget( self ):
			attribute_eval = (self.self.mapped_item.self.mapping_target.self.planar_extent.self.size_in_x / self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d2.self.view_window.self.planar_extent.self.size_in_x)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scale is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'CAMERA_MODEL_D2')  ==  TYPEOF(self.self.mapped_item.self.mapping_source.self.mapping_origin))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (aspect_ratio(self.self.mapped_item.self.mapping_target)  ==  aspect_ratio(self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d2.self.view_window))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d2.self.view_window_clipping
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY draughting_model_item_association #
####################
class draughting_model_item_association(item_identified_representation_usage):
	'''Entity draughting_model_item_association definition.

	:param item_identified_representation_usage_definition
	:type item_identified_representation_usage_definition:shape_aspect

	:param item_identified_representation_usage_used_representation
	:type item_identified_representation_usage_used_representation:draughting_model

	:param item_identified_representation_usage_identified_item
	:type item_identified_representation_usage_identified_item:draughting_model_item_association_select
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition , inherited3__used_representation , inherited4__identified_item , item_identified_representation_usage_definition,item_identified_representation_usage_used_representation,item_identified_representation_usage_identified_item, ):
		item_identified_representation_usage.__init__(self , inherited0__name , inherited1__description , inherited2__definition , inherited3__used_representation , inherited4__identified_item , )
		self.item_identified_representation_usage_definition = item_identified_representation_usage_definition
		self.item_identified_representation_usage_used_representation = item_identified_representation_usage_used_representation
		self.item_identified_representation_usage_identified_item = item_identified_representation_usage_identified_item

	@apply
	def item_identified_representation_usage_definition():
		def fget( self ):
			return self._item_identified_representation_usage_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_definition is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._item_identified_representation_usage_definition = shape_aspect(value)
			else:
				self._item_identified_representation_usage_definition = value
		return property(**locals())

	@apply
	def item_identified_representation_usage_used_representation():
		def fget( self ):
			return self._item_identified_representation_usage_used_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_used_representation is mantatory and can not be set to None')
			if not check_type(value,draughting_model):
				self._item_identified_representation_usage_used_representation = draughting_model(value)
			else:
				self._item_identified_representation_usage_used_representation = value
		return property(**locals())

	@apply
	def item_identified_representation_usage_identified_item():
		def fget( self ):
			return self._item_identified_representation_usage_identified_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_identified_item is mantatory and can not be set to None')
			if not check_type(value,draughting_model_item_association_select):
				self._item_identified_representation_usage_identified_item = draughting_model_item_association_select(value)
			else:
				self._item_identified_representation_usage_identified_item = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'DATUM_FEATURE_CALLOUT')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  (('AUTOMOTIVE_DESIGN.'  +  'DATUM_FEATURE')  ==  TYPEOF(self.self.item_identified_representation_usage.self.definition)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'DATUM_TARGET_CALLOUT')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  (('AUTOMOTIVE_DESIGN.'  +  'DATUM_TARGET')  ==  TYPEOF(self.self.item_identified_representation_usage.self.definition)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'ANGULAR_DIMENSION')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  (('AUTOMOTIVE_DESIGN.'  +  'ANGULAR_SIZE')  ==  TYPEOF(self.self.item_identified_representation_usage.self.definition)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'CURVE_DIMENSION')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  ((('AUTOMOTIVE_DESIGN.'  +  'DIMENSIONAL_SIZE')  ==  TYPEOF(self.self.item_identified_representation_usage.self.definition))  and  (self.self.item_identified_representation_usage.self.definition.self.name  ==  'curve dimension')))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'DIAMETER_DIMENSION')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  ((('AUTOMOTIVE_DESIGN.'  +  'DIMENSIONAL_SIZE')  ==  TYPEOF(self.self.item_identified_representation_usage.self.definition))  and  (self.self.item_identified_representation_usage.self.definition.self.name  ==  'diameter')))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'LINEAR_DIMENSION')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  ((('AUTOMOTIVE_DESIGN.'  +  'DIMENSIONAL_SIZE')  ==  TYPEOF(self.self.item_identified_representation_usage.self.definition))  and  (((self.self.item_identified_representation_usage.self.definition.self.name  ==  'height')  or  (self.self.item_identified_representation_usage.self.definition.self.name  ==  'length'))  or  (self.self.item_identified_representation_usage.self.definition.self.name  ==  'width'))))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'RADIUS_DIMENSION')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  ((('AUTOMOTIVE_DESIGN.'  +  'DIMENSIONAL_SIZE')  ==  TYPEOF(self.self.item_identified_representation_usage.self.definition))  and  (self.self.item_identified_representation_usage.self.definition.self.name  ==  'radius')))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (( not (('AUTOMOTIVE_DESIGN.'  +  'GEOMETRICAL_TOLERANCE_CALLOUT')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  (('AUTOMOTIVE_DESIGN.'  +  'GEOMETRIC_TOLERANCE')  ==  TYPEOF(self.self.item_identified_representation_usage.self.definition)))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (((((( not (('AUTOMOTIVE_DESIGN.'  +  'DIMENSIONAL_SIZE')  ==  TYPEOF(self.self.item_identified_representation_usage.self.definition)))  or  (('AUTOMOTIVE_DESIGN.'  +  'DIMENSION_CALLOUT')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  (('AUTOMOTIVE_DESIGN.'  +  'DIMENSION_CURVE_DIRECTED_CALLOUT')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  (('AUTOMOTIVE_DESIGN.'  +  'LEADER_DIRECTED_DIMENSION')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  (('AUTOMOTIVE_DESIGN.'  +  'ORDINATE_DIMENSION')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))  or  (('AUTOMOTIVE_DESIGN.'  +  'STRUCTURED_DIMENSION_CALLOUT')  ==  TYPEOF(self.self.item_identified_representation_usage.self.identified_item)))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr


####################
 # ENTITY surface_style_boundary #
####################
class surface_style_boundary(founded_item):
	'''Entity surface_style_boundary definition.

	:param style_of_boundary
	:type style_of_boundary:curve_or_render
	'''
	def __init__( self , style_of_boundary, ):
		founded_item.__init__(self , )
		self.style_of_boundary = style_of_boundary

	@apply
	def style_of_boundary():
		def fget( self ):
			return self._style_of_boundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_boundary is mantatory and can not be set to None')
			if not check_type(value,curve_or_render):
				self._style_of_boundary = curve_or_render(value)
			else:
				self._style_of_boundary = value
		return property(**locals())

####################
 # ENTITY area_unit #
####################
class area_unit(derived_unit):
	'''Entity area_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensional_exponents(2,0,0,0,0,0,0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY offset_curve_2d #
####################
class offset_curve_2d(curve):
	'''Entity offset_curve_2d definition.

	:param basis_curve
	:type basis_curve:curve

	:param distance
	:type distance:length_measure

	:param self_intersect
	:type self_intersect:LOGICAL
	'''
	def __init__( self , inherited0__name , basis_curve,distance,self_intersect, ):
		curve.__init__(self , inherited0__name , )
		self.basis_curve = basis_curve
		self.distance = distance
		self.self_intersect = self_intersect

	@apply
	def basis_curve():
		def fget( self ):
			return self._basis_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._basis_curve = curve(value)
			else:
				self._basis_curve = value
		return property(**locals())

	@apply
	def distance():
		def fget( self ):
			return self._distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._distance = length_measure(value)
			else:
				self._distance = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.basis_curve.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY shape_definition_representation #
####################
class shape_definition_representation(property_definition_representation):
	'''Entity shape_definition_representation definition.
	'''
	def __init__( self , inherited0__definition , inherited1__used_representation ,  ):
		property_definition_representation.__init__(self , inherited0__definition , inherited1__used_representation , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.PRODUCT_DEFINITION_SHAPE'  ==  TYPEOF(self.self.definition))  or  ('AUTOMOTIVE_DESIGN.SHAPE_DEFINITION'  ==  TYPEOF(self.self.definition.self.definition)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AUTOMOTIVE_DESIGN.SHAPE_REPRESENTATION'  ==  TYPEOF(self.self.used_representation))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY symbol_style #
####################
class symbol_style(founded_item):
	'''Entity symbol_style definition.

	:param name
	:type name:label

	:param style_of_symbol
	:type style_of_symbol:symbol_style_select
	'''
	def __init__( self , name,style_of_symbol, ):
		founded_item.__init__(self , )
		self.name = name
		self.style_of_symbol = style_of_symbol

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def style_of_symbol():
		def fget( self ):
			return self._style_of_symbol
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_symbol is mantatory and can not be set to None')
			if not check_type(value,symbol_style_select):
				self._style_of_symbol = symbol_style_select(value)
			else:
				self._style_of_symbol = value
		return property(**locals())

####################
 # ENTITY tactile_appearance_representation #
####################
class tactile_appearance_representation(representation):
	'''Entity tactile_appearance_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((SIZEOF(USEDIN(self,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY volume_unit #
####################
class volume_unit(derived_unit):
	'''Entity volume_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensional_exponents(3,0,0,0,0,0,0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY conical_surface #
####################
class conical_surface(elementary_surface):
	'''Entity conical_surface definition.

	:param radius
	:type radius:length_measure

	:param semi_angle
	:type semi_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius,semi_angle, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self.radius = radius
		self.semi_angle = semi_angle

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._radius = length_measure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def semi_angle():
		def fget( self ):
			return self._semi_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._semi_angle = plane_angle_measure(value)
			else:
				self._semi_angle = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.radius  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_person_and_organization_assignment #
####################
class applied_person_and_organization_assignment(person_and_organization_assignment):
	'''Entity applied_person_and_organization_assignment definition.

	:param items
	:type items:SET(1,None,'person_and_organization_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_person_and_organization , inherited1__role , items, ):
		person_and_organization_assignment.__init__(self , inherited0__assigned_person_and_organization , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'person_and_organization_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (self.self.role.self.name  ==  'signing for contract'))  or  item_correlation(self.self.items,['APPLIED_ORGANIZATION_ASSIGNMENT']))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY block #
####################
class block(geometric_representation_item):
	'''Entity block definition.

	:param position
	:type position:axis2_placement_3d

	:param x
	:type x:positive_length_measure

	:param y
	:type y:positive_length_measure

	:param z
	:type z:positive_length_measure
	'''
	def __init__( self , inherited0__name , position,x,y,z, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.position = position
		self.x = x
		self.y = y
		self.z = z

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._position = axis2_placement_3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def x():
		def fget( self ):
			return self._x
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument x is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._x = positive_length_measure(value)
			else:
				self._x = value
		return property(**locals())

	@apply
	def y():
		def fget( self ):
			return self._y
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument y is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._y = positive_length_measure(value)
			else:
				self._y = value
		return property(**locals())

	@apply
	def z():
		def fget( self ):
			return self._z
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument z is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._z = positive_length_measure(value)
			else:
				self._z = value
		return property(**locals())

####################
 # ENTITY global_unit_assigned_context #
####################
class global_unit_assigned_context(representation_context):
	'''Entity global_unit_assigned_context definition.

	:param units
	:type units:SET(1,None,'unit', scope = schema_scope)
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type , units, ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )
		self.units = units

	@apply
	def units():
		def fget( self ):
			return self._units
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument units is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'unit', scope = schema_scope)):
				self._units = SET(value)
			else:
				self._units = value
		return property(**locals())

####################
 # ENTITY placed_feature #
####################
class placed_feature(shape_aspect):
	'''Entity placed_feature definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'PRODUCT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY surface_style_parameter_line #
####################
class surface_style_parameter_line(founded_item):
	'''Entity surface_style_parameter_line definition.

	:param style_of_parameter_lines
	:type style_of_parameter_lines:curve_or_render

	:param direction_counts
	:type direction_counts:SET(1,2,'direction_count_select', scope = schema_scope)
	'''
	def __init__( self , style_of_parameter_lines,direction_counts, ):
		founded_item.__init__(self , )
		self.style_of_parameter_lines = style_of_parameter_lines
		self.direction_counts = direction_counts

	@apply
	def style_of_parameter_lines():
		def fget( self ):
			return self._style_of_parameter_lines
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_parameter_lines is mantatory and can not be set to None')
			if not check_type(value,curve_or_render):
				self._style_of_parameter_lines = curve_or_render(value)
			else:
				self._style_of_parameter_lines = value
		return property(**locals())

	@apply
	def direction_counts():
		def fget( self ):
			return self._direction_counts
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument direction_counts is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'direction_count_select', scope = schema_scope)):
				self._direction_counts = SET(value)
			else:
				self._direction_counts = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.self.direction_counts)  ==  1) XOR (TYPEOF(self.self.direction_counts[1])  !=  TYPEOF(self.self.direction_counts[2])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_side_style #
####################
class surface_side_style(founded_item):
	'''Entity surface_side_style definition.

	:param name
	:type name:label

	:param styles
	:type styles:SET(1,7,'surface_style_element_select', scope = schema_scope)
	'''
	def __init__( self , name,styles, ):
		founded_item.__init__(self , )
		self.name = name
		self.styles = styles

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,7,'surface_style_element_select', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY time_measure_with_unit #
####################
class time_measure_with_unit(measure_with_unit):
	'''Entity time_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.TIME_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_property_representation #
####################
class action_property_representation(BaseEntityClass):
	'''Entity action_property_representation definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param property
	:type property:action_property

	:param representation
	:type representation:representation
	'''
	def __init__( self , name,description,property,representation, ):
		self.name = name
		self.description = description
		self.property = property
		self.representation = representation

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def property():
		def fget( self ):
			return self._property
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument property is mantatory and can not be set to None')
			if not check_type(value,action_property):
				self._property = action_property(value)
			else:
				self._property = value
		return property(**locals())

	@apply
	def representation():
		def fget( self ):
			return self._representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._representation = representation(value)
			else:
				self._representation = value
		return property(**locals())

####################
 # ENTITY angular_dimension #
####################
class angular_dimension(dimension_curve_directed_callout):
	'''Entity angular_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		dimension_curve_directed_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY boolean_literal #
####################
class boolean_literal(simple_boolean_expression,generic_literal):
	'''Entity boolean_literal definition.

	:param the_value
	:type the_value:BOOLEAN
	'''
	def __init__( self , the_value, ):
		simple_boolean_expression.__init__(self , )
		generic_literal.__init__(self , )
		self.the_value = the_value

	@apply
	def the_value():
		def fget( self ):
			return self._the_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument the_value is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._the_value = BOOLEAN(value)
			else:
				self._the_value = value
		return property(**locals())

####################
 # ENTITY defined_symbol #
####################
class defined_symbol(geometric_representation_item):
	'''Entity defined_symbol definition.

	:param definition
	:type definition:defined_symbol_select

	:param target
	:type target:symbol_target
	'''
	def __init__( self , inherited0__name , definition,target, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.definition = definition
		self.target = target

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,defined_symbol_select):
				self._definition = defined_symbol_select(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def target():
		def fget( self ):
			return self._target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument target is mantatory and can not be set to None')
			if not check_type(value,symbol_target):
				self._target = symbol_target(value)
			else:
				self._target = value
		return property(**locals())

####################
 # ENTITY dimension_text_associativity #
####################
class dimension_text_associativity(text_literal,mapped_item):
	'''Entity dimension_text_associativity definition.
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , inherited6__name , inherited7__mapping_source , inherited8__mapping_target ,  ):
		text_literal.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , )
		mapped_item.__init__(self , inherited6__name , inherited7__mapping_source , inherited8__mapping_target , )
	def wr1(self):
		eval_wr1_wr = ('AUTOMOTIVE_DESIGN.SHAPE_DIMENSION_REPRESENTATION'  ==  TYPEOF(self.self.mapped_item.self.mapping_source.self.mapped_representation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AUTOMOTIVE_DESIGN.DRAUGHTING_CALLOUT'  ==  TYPEOF(self.self.mapped_item.self.mapping_target))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY organizational_project_role #
####################
class organizational_project_role(BaseEntityClass):
	'''Entity organizational_project_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY pair_actuator #
####################
class pair_actuator(BaseEntityClass):
	'''Entity pair_actuator definition.

	:param actuated_pair
	:type actuated_pair:kinematic_pair

	:param name
	:type name:label
	'''
	def __init__( self , actuated_pair,name, ):
		self.actuated_pair = actuated_pair
		self.name = name

	@apply
	def actuated_pair():
		def fget( self ):
			return self._actuated_pair
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actuated_pair is mantatory and can not be set to None')
			if not check_type(value,kinematic_pair):
				self._actuated_pair = kinematic_pair(value)
			else:
				self._actuated_pair = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY partial_circular_profile #
####################
class partial_circular_profile(shape_aspect):
	'''Entity partial_circular_profile definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (('AUTOMOTIVE_DESIGN.'  +  'FEATURE_COMPONENT_DEFINITION')  ==  TYPEOF(self.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  ==  SIZEOF(None)))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr


####################
 # ENTITY point_placement_shape_representation #
####################
class point_placement_shape_representation(shape_representation):
	'''Entity point_placement_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # FUNCTION check_associative_shape_aspects #
####################
def check_associative_shape_aspects(sdr,):
	'''
	:param sdr
	:type sdr:shape_definition_representation
	'''
	if (SIZEOF(sdr.used_representation.items)  !=  2):
		return FALSE
	sr1 = using_representations(sdr.used_representation.items[1])
	sr2 = using_representations(sdr.used_representation.items[2])
	for  i in range(1,HIINDEX(sr1),1):
		dm = representations_mapped_into(sr1[i])
		for  j in range(1,HIINDEX(dm),1):
			if ('AUTOMOTIVE_DESIGN.DRAUGHTING_MODEL'  ==  TYPEOF(dm[j])):
				if (dm[j]  ==  sr2):
					return TRUE
				pv = representations_mapped_into(dm[j])
				for  k in range(1,HIINDEX(pv),1):
					if ('AUTOMOTIVE_DESIGN.PRESENTATION_VIEW'  ==  TYPEOF(pv[k])):
						if (pv[k]  ==  sr2):
							return TRUE
	for  i in range(1,HIINDEX(sr2),1):
		dm = representations_mapped_into(sr2[i])
		for  j in range(1,HIINDEX(dm),1):
			if ('AUTOMOTIVE_DESIGN.DRAUGHTING_MODEL'  ==  TYPEOF(dm[j])):
				if (dm[j]  ==  sr1):
					return TRUE
				pv = representations_mapped_into(dm[j])
				for  k in range(1,HIINDEX(pv),1):
					if ('AUTOMOTIVE_DESIGN.PRESENTATION_VIEW'  ==  TYPEOF(pv[k])):
						if (pv[k]  ==  sr1):
							return TRUE
	return FALSE

####################
 # FUNCTION build_2axes #
####################
def build_2axes(ref_direction,):
	'''
	:param ref_direction
	:type ref_direction:direction
	'''
	return [d,orthogonal_complement(d)]

####################
 # FUNCTION get_round_holes_for_composite_hole #
####################
def get_round_holes_for_composite_hole(sar_instance_set,):
	'''
	:param sar_instance_set
	:type sar_instance_set:(null)
	'''
	for  i in range(1,HIINDEX(sar_instance_set),1):
		if (SIZEOF(['AUTOMOTIVE_DESIGN.INSTANCED_FEATURE','AUTOMOTIVE_DESIGN.ROUND_HOLE']  *  TYPEOF(sar_instance_set[i].related_shape_aspect))  >=  2):
			rh_set = rh_set  +  sar_instance_set[i].related_shape_aspect.round_hole
		if ('AUTOMOTIVE_DESIGN.PLACED_FEATURE'  ==  TYPEOF(sar_instance_set[i])):
			pdr_set = get_shape_aspect_property_definition_representations(sar_instance_set[i].related_shape_aspect)
			for  j in range(1,HIINDEX(pdr_set),1):
				if ((pdr_set[j].used_representation.name  ==  'feature definition placement')  and  ('AUTOMOTIVE_DESIGN.SHAPE_REPRESENTATION'  ==  TYPEOF(pdr_set[j].used_representation))):
					ri_set = pdr_set[j].used_representation.items
					for  k in range(1,HIINDEX(ri_set),1):
						if (('AUTOMOTIVE_DESIGN.MAPPED_ITEM'  ==  TYPEOF(ri_set[k]))  and  (('AUTOMOTIVE_DESIGN.'  +  'SHAPE_REPRESENTATION_WITH_PARAMETERS')  ==  TYPEOF(ri_set[k].mapped_item.mapping_source.mapped_representation))):
							pdr_set1 = bag_to_set(USEDIN(ri_set[k].mapped_item.mapping_source.mapped_representation,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
							for  l in range(1,HIINDEX(pdr_set1),1):
								if ('AUTOMOTIVE_DESIGN.ROUND_HOLE'  ==  TYPEOF(pdr_set1[l].definition.definition)):
									rh_set = rh_set  +  pdr_set1[l].definition.definition
	return rh_set

####################
 # FUNCTION item_in_context #
####################
def item_in_context(item,cntxt,):
	'''
	:param item
	:type item:representation_item
	:param cntxt
	:type cntxt:representation_context
	'''
	if (SIZEOF(USEDIN(item,'AUTOMOTIVE_DESIGN.REPRESENTATION.ITEMS')  *  cntxt.representations_in_context)  >  0):
		return TRUE
	else:
		y = None
		if (SIZEOF(y)  >  0):
			for  i in range(1,HIINDEX(y),1):
				if (item_in_context(y[i],cntxt)):
					return TRUE
	return FALSE

####################
 # FUNCTION default_tolerance_table_cell_wr3 #
####################
def default_tolerance_table_cell_wr3(agg,):
	'''
	:param agg
	:type agg:(null)
	'''
	if ((SIZEOF(None)  ==  1)  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION default_tolerance_table_cell_wr2 #
####################
def default_tolerance_table_cell_wr2(agg,):
	'''
	:param agg
	:type agg:(null)
	'''
	if (SIZEOF(agg)  <=  5):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION gbsf_check_point #
####################
def gbsf_check_point(pnt,):
	'''
	:param pnt
	:type pnt:point
	'''
	if ('AUTOMOTIVE_DESIGN.CARTESIAN_POINT'  ==  TYPEOF(pnt)):
		return TRUE
	else:
		if ('AUTOMOTIVE_DESIGN.POINT_ON_CURVE'  ==  TYPEOF(pnt)):
			return gbsf_check_curve(pnt.point_on_curve.basis_curve)
		else:
			if ('AUTOMOTIVE_DESIGN.POINT_ON_SURFACE'  ==  TYPEOF(pnt)):
				return gbsf_check_surface(pnt.point_on_surface.basis_surface)
			else:
				if ('AUTOMOTIVE_DESIGN.DEGENERATE_PCURVE'  ==  TYPEOF(pnt)):
					return gbsf_check_curve(pnt.degenerate_pcurve.reference_to_curve.representation.items[1])  and  gbsf_check_surface(pnt.degenerate_pcurve.basis_surface)
	return FALSE

####################
 # FUNCTION acyclic_solid_replica #
####################
def acyclic_solid_replica(rep,parent,):
	'''
	:param rep
	:type rep:solid_replica
	:param parent
	:type parent:solid_model
	'''
	if ( not ('AUTOMOTIVE_DESIGN.SOLID_REPLICA'  ==  TYPEOF(parent))):
		return TRUE
	if (parent  ==  rep):
		return FALSE
	else:
		return acyclic_solid_replica(rep,parent.solid_replica.parent_solid)

####################
 # FUNCTION build_axes #
####################
def build_axes(axis,ref_direction,):
	'''
	:param axis
	:type axis:direction
	:param ref_direction
	:type ref_direction:direction
	'''
	d1 = NVL(normalise(axis),dummy_gri  ==  direction([0,0,1]))
	d2 = first_proj_axis(d1,ref_direction)
	return [d2,normalise(cross_product(d1,d2)).vector.orientation,d1]

####################
 # FUNCTION edge_reversed #
####################
def edge_reversed(an_edge,):
	'''
	:param an_edge
	:type an_edge:edge
	'''
	if ('AUTOMOTIVE_DESIGN.ORIENTED_EDGE'  ==  TYPEOF(an_edge)):
		the_reverse = (dummy_tri  ==  edge(an_edge.edge_end,an_edge.edge_start))  ==  oriented_edge(an_edge.oriented_edge.edge_element, not an_edge.oriented_edge.orientation)
	else:
		the_reverse = (dummy_tri  ==  edge(an_edge.edge_end,an_edge.edge_start))  ==  oriented_edge(an_edge,FALSE)
	return the_reverse

####################
 # FUNCTION default_tolerance_table_cell_wr5 #
####################
def default_tolerance_table_cell_wr5(agg,):
	'''
	:param agg
	:type agg:(null)
	'''
	if ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  ==  SIZEOF(None))):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION constraints_composite_curve_on_surface #
####################
def constraints_composite_curve_on_surface(c,):
	'''
	:param c
	:type c:composite_curve_on_surface
	'''
	for  k in range(1,n_segments,1):
		if ((( not ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(c.composite_curve.segments[k].parent_curve)))  and  ( not ('AUTOMOTIVE_DESIGN.SURFACE_CURVE'  ==  TYPEOF(c.composite_curve.segments[k].parent_curve))))  and  ( not ('AUTOMOTIVE_DESIGN.COMPOSITE_CURVE_ON_SURFACE'  ==  TYPEOF(c.composite_curve.segments[k].parent_curve)))):
			return FALSE
	return TRUE

####################
 # FUNCTION default_tolerance_table_cell_wr4 #
####################
def default_tolerance_table_cell_wr4(agg,):
	'''
	:param agg
	:type agg:(null)
	'''
	if ((SIZEOF(None)  ==  1)  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION acyclic_mapped_representation #
####################
def acyclic_mapped_representation(parent_set,children_set,):
	'''
	:param parent_set
	:type parent_set:(null)
	:param children_set
	:type children_set:(null)
	'''
	x = None
	if (SIZEOF(x)  >  0):
		for  i in range(1,HIINDEX(x),1):
			if (x[i].mapped_item.mapping_source.mapped_representation  ==  parent_set):
				return FALSE
			if ( not acyclic_mapped_representation(parent_set  +  x[i].mapped_item.mapping_source.mapped_representation,x[i].mapped_item.mapping_source.mapped_representation.items)):
				return FALSE
	x = children_set - x
	if (SIZEOF(x)  >  0):
		for  i in range(1,HIINDEX(x),1):
			y = None
			if ( not acyclic_mapped_representation(parent_set,y)):
				return FALSE
	return TRUE

####################
 # FUNCTION get_name_value #
####################
def get_name_value(obj,):
	'''
	:param obj
	:type obj:name_attribute_select
	'''
	if (SIZEOF(name_bag)  ==  1):
		return name_bag[1].attribute_value
	else:
		return  None 

####################
 # FUNCTION convert_spatial_to_ypr_rotation #
####################
def convert_spatial_to_ypr_rotation(pair,rotation,):
	'''
	:param pair
	:type pair:kinematic_pair
	:param rotation
	:type rotation:spatial_rotation
	'''
	if ('AUTOMOTIVE_DESIGN.YPR_ROTATION'  ==  TYPEOF(rotation)):
		return rotation
	axis = normalise(rotation.rotation_about_direction.direction_of_axis)
	angle = rotation.rotation_about_direction.rotation_angle
	if (angle  ==  0):
		return [0,0,0]
	dx = axis.direction_ratios[1]
	dy = axis.direction_ratios[2]
	dz = axis.direction_ratios[3]
	conv_angle = plane_angle_for_pair_in_radian(pair,angle)
	if (conv_angle  ==   None ):
		return  None 
	ucf = angle / conv_angle
	s_a = SIN(conv_angle)
	c_a = COS(conv_angle)
	if ((dy  ==  0)  and  ((dx  *  dz)  ==  0)):
		for  while conv_angle  <=  (- PI )			conv_angle = conv_angle  +  (2  *   PI )
		for  while conv_angle  >   PI 			conv_angle = conv_angle - (2  *   PI )
		ya = ucf  *  conv_angle
		if (conv_angle  !=   PI ):
			ra = -ya
		else:
			ra = ya
		if (dx  !=  0):
			if (dx  >  0):
				return [0,0,ya]
			else:
				return [0,0,ra]
		else:
			if (dz  >  0):
				return [ya,0,0]
			else:
				return [ra,0,0]
	if (((dy  !=  0)  and  (dx  ==  0))  and  (dz  ==  0)):
		if (c_a  >=  0):
			ya = 0
			ra = 0
		else:
			ya = ucf  *   PI 
			ra = ya
		pa = ucf  *  ATAN(s_a,ABS(c_a))
		if (dy  <  0):
			pa = -pa
		return [ya,pa,ra]
	cm1 = 1 - c_a
	rotmat = [[((dx  *  dx)  *  cm1)  +  c_a,((dx  *  dy)  *  cm1) - (dz  *  s_a),((dx  *  dz)  *  cm1)  +  (dy  *  s_a)],[((dx  *  dy)  *  cm1)  +  (dz  *  s_a),((dy  *  dy)  *  cm1)  +  c_a,((dy  *  dz)  *  cm1) - (dx  *  s_a)],[((dx  *  dz)  *  cm1) - (dy  *  s_a),((dy  *  dz)  *  cm1)  +  (dx  *  s_a),((dz  *  dz)  *  cm1)  +  c_a]]
	if (ABS(rotmat[1][3])  ==  1):
		if (rotmat[1][3]  ==  1):
			pa = 0.5  *   PI 
		else:
			pa = (-0.5)  *   PI 
		ra = 0
		ya = ATAN(rotmat[2][1],rotmat[2][2])
		if (rotmat[2][2]  <  0):
			if (ya  <=  0):
				ya = ya  +   PI 
			else:
				ya = ya -  PI 
	else:
		ya = ATAN(-rotmat[1][2],rotmat[1][1])
		if (rotmat[1][1]  <  0):
			if (ya  <=  0):
				ya = ya  +   PI 
			else:
				ya = ya -  PI 
		ra = ATAN(-rotmat[2][3],rotmat[3][3])
		if (rotmat[3][3]  <  0):
			if (ra  <=  0):
				ra = ra  +   PI 
			else:
				ra = ra -  PI 
		s_y = SIN(ya)
		c_y = COS(ya)
		s_r = SIN(ra)
		c_r = COS(ra)
		if (((ABS(s_y)  >  ABS(c_y))  and  (ABS(s_y)  >  ABS(s_r)))  and  (ABS(s_y)  >  ABS(c_r))):
			cm1 = (-rotmat[1][2]) / s_y
		else:
			if ((ABS(c_y)  >  ABS(s_r))  and  (ABS(c_y)  >  ABS(c_r))):
				cm1 = rotmat[1][1] / c_y
			else:
				if (ABS(s_r)  >  ABS(c_r)):
					cm1 = (-rotmat[2][3]) / s_r
				else:
					cm1 = rotmat[3][3] / c_r
		pa = ATAN(rotmat[1][3],cm1)
	ya = ya  *  ucf
	pa = pa  *  ucf
	ra = ra  *  ucf
	return [ya,pa,ra]

####################
 # FUNCTION check_text_font #
####################
def check_text_font(ct,):
	'''
	:param ct
	:type ct:composite_text
	'''
	for  i in range(1,HIINDEX(ct.collected_text),1):
		f = f  +  [ct.collected_text[i].text_literal.font]
	return SIZEOF(f)  <=  1

####################
 # FUNCTION conditional_reverse #
####################
def conditional_reverse(p,an_item,):
	'''
	:param p
	:type p:BOOLEAN
	:param an_item
	:type an_item:reversible_topology
	'''
	if (p):
		return an_item
	else:
		return topology_reversed(an_item)

####################
 # FUNCTION nmsf_curve_check #
####################
def nmsf_curve_check(cv,):
	'''
	:param cv
	:type cv:representation_item
	'''
	if (SIZEOF(['AUTOMOTIVE_DESIGN.BOUNDED_CURVE','AUTOMOTIVE_DESIGN.CONIC','AUTOMOTIVE_DESIGN.CURVE_REPLICA','AUTOMOTIVE_DESIGN.LINE','AUTOMOTIVE_DESIGN.OFFSET_CURVE_3D']  *  TYPEOF(cv))  >  1):
		return FALSE
	else:
		if ((('AUTOMOTIVE_DESIGN.B_SPLINE_CURVE'  ==  TYPEOF(cv))  and  (cv.b_spline_curve.self_intersect  ==  FALSE))  or  (cv.b_spline_curve.self_intersect  ==  UNKNOWN)):
			return TRUE
		else:
			if (SIZEOF(['AUTOMOTIVE_DESIGN.CONIC','AUTOMOTIVE_DESIGN.LINE']  *  TYPEOF(cv))  ==  1):
				return TRUE
			else:
				if ('AUTOMOTIVE_DESIGN.CURVE_REPLICA'  ==  TYPEOF(cv)):
					return nmsf_curve_check(cv.curve_replica.parent_curve)
				else:
					if ((('AUTOMOTIVE_DESIGN.OFFSET_CURVE_3D'  ==  TYPEOF(cv))  and  ((cv.offset_curve_3d.self_intersect  ==  FALSE)  or  (cv.offset_curve_3d.self_intersect  ==  UNKNOWN)))  and  ( not ('AUTOMOTIVE_DESIGN.POLYLINE'  ==  TYPEOF(cv.offset_curve_3d.basis_curve)))):
						return nmsf_curve_check(cv.offset_curve_3d.basis_curve)
					else:
						if ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(cv)):
							return nmsf_curve_check(cv.pcurve.reference_to_curve.representation.items[1])  and  nmsf_surface_check(cv.pcurve.basis_surface)
						else:
							if ('AUTOMOTIVE_DESIGN.SURFACE_CURVE'  ==  TYPEOF(cv)):
								if (nmsf_curve_check(cv.surface_curve.curve_3d)):
									for  i in range(1,SIZEOF(cv.surface_curve.associated_geometry),1):
										if ('AUTOMOTIVE_DESIGN.SURFACE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
											if ( not nmsf_surface_check(cv.surface_curve.associated_geometry[i])):
												return FALSE
										else:
											if ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
												if ( not nmsf_curve_check(cv.surface_curve.associated_geometry[i])):
													return FALSE
									return TRUE
							else:
								if ('AUTOMOTIVE_DESIGN.POLYLINE'  ==  TYPEOF(cv)):
									if (SIZEOF(cv.polyline.points)  >=  3):
										return TRUE
	return FALSE

####################
 # FUNCTION valid_measure_value #
####################
def valid_measure_value(m,):
	'''
	:param m
	:type m:measure_value
	'''
	if ('REAL'  ==  TYPEOF(m)):
		return m  >  0
	else:
		if ('INTEGER'  ==  TYPEOF(m)):
			return m  >  0
		else:
			return TRUE

####################
 # FUNCTION gbsf_check_curve #
####################
def gbsf_check_curve(cv,):
	'''
	:param cv
	:type cv:representation_item
	'''
	if (SIZEOF(['AUTOMOTIVE_DESIGN.BOUNDED_CURVE','AUTOMOTIVE_DESIGN.CONIC','AUTOMOTIVE_DESIGN.CURVE_REPLICA','AUTOMOTIVE_DESIGN.LINE','AUTOMOTIVE_DESIGN.OFFSET_CURVE_3D']  *  TYPEOF(cv))  >  1):
		return FALSE
	if (SIZEOF(['AUTOMOTIVE_DESIGN.CIRCLE','AUTOMOTIVE_DESIGN.ELLIPSE','AUTOMOTIVE_DESIGN.TRIMMED_CURVE']  *  TYPEOF(cv))  ==  1):
		return TRUE
	else:
		if ((('AUTOMOTIVE_DESIGN.B_SPLINE_CURVE'  ==  TYPEOF(cv))  and  (cv.b_spline_curve.self_intersect  ==  FALSE))  or  (cv.b_spline_curve.self_intersect  ==  UNKNOWN)):
			return TRUE
		else:
			if ((('AUTOMOTIVE_DESIGN.COMPOSITE_CURVE'  ==  TYPEOF(cv))  and  (cv.composite_curve.self_intersect  ==  FALSE))  or  (cv.composite_curve.self_intersect  ==  UNKNOWN)):
				return SIZEOF(None)  ==  0
			else:
				if ('AUTOMOTIVE_DESIGN.CURVE_REPLICA'  ==  TYPEOF(cv)):
					return gbsf_check_curve(cv.curve_replica.parent_curve)
				else:
					if ((('AUTOMOTIVE_DESIGN.OFFSET_CURVE_3D'  ==  TYPEOF(cv))  and  ((cv.offset_curve_3d.self_intersect  ==  FALSE)  or  (cv.offset_curve_3d.self_intersect  ==  UNKNOWN)))  and  ( not ('AUTOMOTIVE_DESIGN.POLYLINE'  ==  TYPEOF(cv.offset_curve_3d.basis_curve)))):
						return gbsf_check_curve(cv.offset_curve_3d.basis_curve)
					else:
						if ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(cv)):
							return gbsf_check_curve(cv.pcurve.reference_to_curve.representation.items[1])  and  gbsf_check_surface(cv.pcurve.basis_surface)
						else:
							if ('AUTOMOTIVE_DESIGN.POLYLINE'  ==  TYPEOF(cv)):
								if (SIZEOF(cv.polyline.points)  >=  3):
									return TRUE
							else:
								if ('AUTOMOTIVE_DESIGN.SURFACE_CURVE'  ==  TYPEOF(cv)):
									if (gbsf_check_curve(cv.surface_curve.curve_3d)):
										for  i in range(1,SIZEOF(cv.surface_curve.associated_geometry),1):
											if ('AUTOMOTIVE_DESIGN.SURFACE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
												if ( not gbsf_check_surface(cv.surface_curve.associated_geometry[i])):
													return FALSE
											else:
												if ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
													if ( not gbsf_check_curve(cv.surface_curve.associated_geometry[i])):
														return FALSE
										return TRUE
	return FALSE

####################
 # FUNCTION base_axis #
####################
def base_axis(dim,axis1,axis2,axis3,):
	'''
	:param dim
	:type dim:INTEGER
	:param axis1
	:type axis1:direction
	:param axis2
	:type axis2:direction
	:param axis3
	:type axis3:direction
	'''
	if (dim  ==  3):
		d1 = NVL(normalise(axis3),dummy_gri  ==  direction([0,0,1]))
		d2 = first_proj_axis(d1,axis1)
		u = [d2,second_proj_axis(d1,d2,axis2),d1]
	else:
		if (EXISTS(axis1)):
			d1 = normalise(axis1)
			u = [d1,orthogonal_complement(d1)]
			if (EXISTS(axis2)):
				factor = dot_product(axis2,u[2])
				if (factor  <  0):
					u[2].direction_ratios[1] = -u[2].direction_ratios[1]
					u[2].direction_ratios[2] = -u[2].direction_ratios[2]
		else:
			if (EXISTS(axis2)):
				d1 = normalise(axis2)
				u = [orthogonal_complement(d1),d1]
				u[1].direction_ratios[1] = -u[1].direction_ratios[1]
				u[1].direction_ratios[2] = -u[1].direction_ratios[2]
			else:
				u = [dummy_gri  ==  direction([1,0]),dummy_gri  ==  direction([0,1])]
	return u

####################
 # FUNCTION get_basis_surface #
####################
def get_basis_surface(c,):
	'''
	:param c
	:type c:curve_on_surface
	'''
	surfs = []
	if ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(c)):
		surfs = [c.pcurve.basis_surface]
	else:
		if ('AUTOMOTIVE_DESIGN.SURFACE_CURVE'  ==  TYPEOF(c)):
			n = SIZEOF(c.surface_curve.associated_geometry)
			for  i in range(1,n,1):
				surfs = surfs  +  associated_surface(c.surface_curve.associated_geometry[i])
	if ('AUTOMOTIVE_DESIGN.COMPOSITE_CURVE_ON_SURFACE'  ==  TYPEOF(c)):
		n = SIZEOF(c.composite_curve.segments)
		surfs = get_basis_surface(c.composite_curve.segments[1].parent_curve)
		if (n  >  1):
			for  i in range(2,n,1):
				surfs = surfs  *  get_basis_surface(c.composite_curve.segments[i].parent_curve)
	return surfs

####################
 # FUNCTION coordinated_pair_link_representation #
####################
def coordinated_pair_link_representation(link,pair_placement,):
	'''
	:param link
	:type link:kinematic_link
	:param pair_placement
	:type pair_placement:rigid_placement
	'''
	link_rep = representation_of_link(link)
	if (link_rep  ==   None ):
		return FALSE
	else:
		if ( not (pair_placement  ==  link_rep.representation.items)):
			return FALSE
		else:
			return TRUE

####################
 # FUNCTION list_face_loops #
####################
def list_face_loops(f,):
	'''
	:param f
	:type f:face
	'''
	for  i in range(1,SIZEOF(f.bounds),1):
		loops = loops  +  f.bounds[i].bound
	return loops

####################
 # FUNCTION get_diameter_for_round_hole #
####################
def get_diameter_for_round_hole(rh,):
	'''
	:param rh
	:type rh:round_hole
	'''
	sa_set = get_shape_aspects(rh)
	for  i in range(1,HIINDEX(sa_set),1):
		if (sa_set[i].description  ==  'diameter occurrence'):
			sar_set = bag_to_set(USEDIN(sa_set[i],'AUTOMOTIVE_DESIGN.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))
			for  j in range(1,HIINDEX(sar_set),1):
				if ((((sar_set[j].name  ==  'diameter')  and  (sar_set[j].description  ==  'profile usage'))  and  ('AUTOMOTIVE_DESIGN.SHAPE_DEFINING_RELATIONSHIP'  ==  TYPEOF(sar_set[j])))  and  ('AUTOMOTIVE_DESIGN.CIRCULAR_CLOSED_PROFILE'  ==  TYPEOF(sar_set[j].relating_shape_aspect))):
					pdr_set = get_shape_aspect_property_definition_representations(sar_set[j].relating_shape_aspect)
					for  k in range(1,HIINDEX(pdr_set),1):
						if ('AUTOMOTIVE_DESIGN.SHAPE_REPRESENTATION_WITH_PARAMETERS'  ==  TYPEOF(pdr_set[k].used_representation)):
							ri_set = pdr_set[k].used_representation.items
							for  l in range(1,HIINDEX(ri_set),1):
								if (('AUTOMOTIVE_DESIGN.MEASURE_REPRESENTATION_ITEM'  ==  TYPEOF(ri_set[l]))  and  ('AUTOMOTIVE_DESIGN.LENGTH_MEASURE_WITH_UNIT'  ==  TYPEOF(ri_set[l]))):
									return ri_set[l].measure_with_unit.value_component
	return  None 

####################
 # FUNCTION list_of_topology_reversed #
####################
def list_of_topology_reversed(a_list,):
	'''
	:param a_list
	:type a_list:list_of_reversible_topology_item
	'''
	the_reverse = []
	for  i in range(1,SIZEOF(a_list),1):
		the_reverse = topology_reversed(a_list[i])  +  the_reverse
	return the_reverse

####################
 # FUNCTION msf_curve_check #
####################
def msf_curve_check(cv,):
	'''
	:param cv
	:type cv:representation_item
	'''
	if (SIZEOF(['AUTOMOTIVE_DESIGN.BOUNDED_CURVE','AUTOMOTIVE_DESIGN.CONIC','AUTOMOTIVE_DESIGN.CURVE_REPLICA','AUTOMOTIVE_DESIGN.LINE','AUTOMOTIVE_DESIGN.OFFSET_CURVE_3D']  *  TYPEOF(cv))  >  1):
		return FALSE
	if ((('AUTOMOTIVE_DESIGN.B_SPLINE_CURVE'  ==  TYPEOF(cv))  and  (cv.b_spline_curve.self_intersect  ==  FALSE))  or  (cv.b_spline_curve.self_intersect  ==  UNKNOWN)):
		return TRUE
	else:
		if (SIZEOF(['AUTOMOTIVE_DESIGN.CONIC','AUTOMOTIVE_DESIGN.LINE']  *  TYPEOF(cv))  ==  1):
			return TRUE
		else:
			if ('AUTOMOTIVE_DESIGN.CURVE_REPLICA'  ==  TYPEOF(cv)):
				return msf_curve_check(cv.curve_replica.parent_curve)
			else:
				if ((('AUTOMOTIVE_DESIGN.OFFSET_CURVE_3D'  ==  TYPEOF(cv))  and  ((cv.offset_curve_3d.self_intersect  ==  FALSE)  or  (cv.offset_curve_3d.self_intersect  ==  UNKNOWN)))  and  ( not ('AUTOMOTIVE_DESIGN.POLYLINE'  ==  TYPEOF(cv.offset_curve_3d.basis_curve)))):
					return msf_curve_check(cv.offset_curve_3d.basis_curve)
				else:
					if ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(cv)):
						return msf_curve_check(cv.pcurve.reference_to_curve.representation.items[1])  and  msf_surface_check(cv.pcurve.basis_surface)
					else:
						if ('AUTOMOTIVE_DESIGN.SURFACE_CURVE'  ==  TYPEOF(cv)):
							if (msf_curve_check(cv.surface_curve.curve_3d)):
								for  i in range(1,SIZEOF(cv.surface_curve.associated_geometry),1):
									if ('AUTOMOTIVE_DESIGN.SURFACE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
										if ( not msf_surface_check(cv.surface_curve.associated_geometry[i])):
											return FALSE
									else:
										if ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
											if ( not msf_curve_check(cv.surface_curve.associated_geometry[i])):
												return FALSE
								return TRUE
						else:
							if ('AUTOMOTIVE_DESIGN.POLYLINE'  ==  TYPEOF(cv)):
								if (SIZEOF(cv.polyline.points)  >=  3):
									return TRUE
	return FALSE

####################
 # FUNCTION shell_reversed #
####################
def shell_reversed(a_shell,):
	'''
	:param a_shell
	:type a_shell:shell
	'''
	if ('AUTOMOTIVE_DESIGN.OPEN_SHELL'  ==  TYPEOF(a_shell)):
		return open_shell_reversed(a_shell)
	else:
		if ('AUTOMOTIVE_DESIGN.CLOSED_SHELL'  ==  TYPEOF(a_shell)):
			return closed_shell_reversed(a_shell)
		else:
			return  None 

####################
 # FUNCTION topology_reversed #
####################
def topology_reversed(an_item,):
	'''
	:param an_item
	:type an_item:reversible_topology
	'''
	if ('AUTOMOTIVE_DESIGN.EDGE'  ==  TYPEOF(an_item)):
		return edge_reversed(an_item)
	if ('AUTOMOTIVE_DESIGN.PATH'  ==  TYPEOF(an_item)):
		return path_reversed(an_item)
	if ('AUTOMOTIVE_DESIGN.FACE_BOUND'  ==  TYPEOF(an_item)):
		return face_bound_reversed(an_item)
	if ('AUTOMOTIVE_DESIGN.FACE'  ==  TYPEOF(an_item)):
		return face_reversed(an_item)
	if ('AUTOMOTIVE_DESIGN.SHELL'  ==  TYPEOF(an_item)):
		return shell_reversed(an_item)
	if ('SET'  ==  TYPEOF(an_item)):
		return set_of_topology_reversed(an_item)
	if ('LIST'  ==  TYPEOF(an_item)):
		return list_of_topology_reversed(an_item)
	return  None 

####################
 # FUNCTION first_proj_axis #
####################
def first_proj_axis(z_axis,arg,):
	'''
	:param z_axis
	:type z_axis:direction
	:param arg
	:type arg:direction
	'''
	if ( not EXISTS(z_axis)):
		return  None 
	else:
		z = normalise(z_axis)
		if ( not EXISTS(arg)):
			if ((z.direction_ratios  !=  [1,0,0])  and  (z.direction_ratios  !=  [-1,0,0])):
				v = dummy_gri  ==  direction([1,0,0])
			else:
				v = dummy_gri  ==  direction([0,1,0])
		else:
			if (arg.dim  !=  3):
				return  None 
			if (cross_product(arg,z).magnitude  ==  0):
				return  None 
			else:
				v = normalise(arg)
		x_vec = scalar_times_vector(dot_product(v,z),z)
		x_axis = vector_difference(v,x_vec).orientation
		x_axis = normalise(x_axis)
	return x_axis

####################
 # FUNCTION acyclic_composite_text #
####################
def acyclic_composite_text(start_composite,child_text,):
	'''
	:param start_composite
	:type start_composite:composite_text
	:param child_text
	:type child_text:(null)
	'''
	local_composite_text = None
	if (SIZEOF(local_composite_text)  >  0):
		for  i in range(1,HIINDEX(local_composite_text),1):
			if (start_composite  ==  local_composite_text[i]):
				return FALSE
	local_children = child_text
	if (SIZEOF(local_composite_text)  >  0):
		for  i in range(1,HIINDEX(local_composite_text),1):
			local_children = local_children  +  local_composite_text[i].collected_text
	local_annotation_text = None
	if (SIZEOF(local_annotation_text)  >  0):
		for  i in range(1,HIINDEX(local_annotation_text),1):
			local_children = local_children  +  None
	if (local_children  !=  child_text):
		return acyclic_composite_text(start_composite,local_children)
	else:
		return TRUE

####################
 # FUNCTION get_shape_aspect_property_definition_representations #
####################
def get_shape_aspect_property_definition_representations(s_a_instance,):
	'''
	:param s_a_instance
	:type s_a_instance:shape_aspect
	'''
	pd_set = bag_to_set(USEDIN(s_a_instance,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION.DEFINITION'))
	if (SIZEOF(pd_set)  <  1):
		return pdr_set
	for  i in range(1,HIINDEX(pd_set),1):
		pdr_set = pdr_set  +  None
	return pdr_set

####################
 # FUNCTION orthogonal_complement #
####################
def orthogonal_complement(vec,):
	'''
	:param vec
	:type vec:direction
	'''
	if ((vec.dim  !=  2)  or  ( not EXISTS(vec))):
		return  None 
	else:
		result = dummy_gri  ==  direction([-vec.direction_ratios[2],vec.direction_ratios[1]])
		return result

####################
 # FUNCTION get_shape_aspects #
####################
def get_shape_aspects(c_def_instance,):
	'''
	:param c_def_instance
	:type c_def_instance:characterized_definition
	'''
	pd_set = bag_to_set(None)
	if (SIZEOF(pd_set)  <  1):
		return pdr_set
	for  i in range(1,HIINDEX(pd_set),1):
		pdr_set = pdr_set  +  bag_to_set(USEDIN(pd_set[i],'AUTOMOTIVE_DESIGN.SHAPE_ASPECT.OF_SHAPE'))
	return pdr_set

####################
 # FUNCTION make_array_of_array #
####################
def make_array_of_array(lis,low1,u1,low2,u2,):
	'''
	:param lis
	:type lis:(null)
	:param low1
	:type low1:INTEGER
	:param u1
	:type u1:INTEGER
	:param low2
	:type low2:INTEGER
	:param u2
	:type u2:INTEGER
	'''
	if (((u1 - low1)  +  1)  !=  SIZEOF(lis)):
		return  None 
	if (((u2 - low2)  +  1)  !=  SIZEOF(lis[1])):
		return  None 
	res = [list_to_array(lis[1],low2,u2),(u1 - low1)  +  1]
	for  i in range(2,HIINDEX(lis),1):
		if (((u2 - low2)  +  1)  !=  SIZEOF(lis[i])):
			return  None 
		res[(low1  +  i) - 1] = list_to_array(lis[i],low2,u2)
	return res

####################
 # FUNCTION second_proj_axis #
####################
def second_proj_axis(z_axis,x_axis,arg,):
	'''
	:param z_axis
	:type z_axis:direction
	:param x_axis
	:type x_axis:direction
	:param arg
	:type arg:direction
	'''
	if ( not EXISTS(arg)):
		v = dummy_gri  ==  direction([0,1,0])
	else:
		v = arg
	temp = scalar_times_vector(dot_product(v,z_axis),z_axis)
	y_axis = vector_difference(v,temp)
	temp = scalar_times_vector(dot_product(v,x_axis),x_axis)
	y_axis = vector_difference(y_axis,temp)
	y_axis = normalise(y_axis)
	return y_axis.orientation

####################
 # FUNCTION bag_to_set #
####################
def bag_to_set(the_bag,):
	'''
	:param the_bag
	:type the_bag:(null)
	'''
	if (SIZEOF(the_bag)  >  0):
		for  i in range(1,HIINDEX(the_bag),1):
			the_set = the_set  +  the_bag[i]
	return the_set

####################
 # FUNCTION valid_wireframe_edge_curve #
####################
def valid_wireframe_edge_curve(crv,):
	'''
	:param crv
	:type crv:curve
	'''
	if (SIZEOF(['AUTOMOTIVE_DESIGN.LINE','AUTOMOTIVE_DESIGN.CONIC','AUTOMOTIVE_DESIGN.B_SPLINE_CURVE','AUTOMOTIVE_DESIGN.POLYLINE']  *  TYPEOF(crv))  ==  1):
		return TRUE
	else:
		if ('AUTOMOTIVE_DESIGN.CURVE_REPLICA'  ==  TYPEOF(crv)):
			return valid_wireframe_edge_curve(crv.curve_replica.parent_curve)
		else:
			if ('AUTOMOTIVE_DESIGN.OFFSET_CURVE_3D'  ==  TYPEOF(crv)):
				return valid_wireframe_edge_curve(crv.offset_curve_3d.basis_curve)
	return FALSE

####################
 # FUNCTION acyclic_product_category_relationship #
####################
def acyclic_product_category_relationship(relation,children,):
	'''
	:param relation
	:type relation:product_category_relationship
	:param children
	:type children:(null)
	'''
	for  i in range(1,HIINDEX(children),1):
		if (relation.category  ==  children[i]):
			return FALSE
	x = bag_to_set(USEDIN(relation.category,'AUTOMOTIVE_DESIGN.PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'))
	local_children = children  +  relation.category
	if (SIZEOF(x)  >  0):
		for  i in range(1,HIINDEX(x),1):
			if ( not acyclic_product_category_relationship(x[i],local_children)):
				return FALSE
	return TRUE

####################
 # FUNCTION surface_weights_positive #
####################
def surface_weights_positive(b,):
	'''
	:param b
	:type b:rational_b_spline_surface
	'''
	for  i in range(0,b.u_upper,1):
		for  j in range(0,b.v_upper,1):
			if (b.weights[i][j]  <=  0):
				result = FALSE
				return result
	return result

####################
 # FUNCTION vector_difference #
####################
def vector_difference(arg1,arg2,):
	'''
	:param arg1
	:type arg1:vector_or_direction
	:param arg2
	:type arg2:vector_or_direction
	'''
	if ((( not EXISTS(arg1))  or  ( not EXISTS(arg2)))  or  (arg1.dim  !=  arg2.dim)):
		return  None 
	else:
		if ('AUTOMOTIVE_DESIGN.VECTOR'  ==  TYPEOF(arg1)):
			mag1 = arg1.magnitude
			vec1 = arg1.vector.orientation
		else:
			mag1 = 1
			vec1 = arg1
		if ('AUTOMOTIVE_DESIGN.VECTOR'  ==  TYPEOF(arg2)):
			mag2 = arg2.magnitude
			vec2 = arg2.vector.orientation
		else:
			mag2 = 1
			vec2 = arg2
		vec1 = normalise(vec1)
		vec2 = normalise(vec2)
		ndim = SIZEOF(vec1.direction_ratios)
		mag = 0
		res = dummy_gri  ==  direction(vec1.direction_ratios)
		for  i in range(1,ndim,1):
			res.direction_ratios[i] = (mag1  *  vec1.direction_ratios[i]) - (mag2  *  vec2.direction_ratios[i])
			mag = mag  +  (res.direction_ratios[i]  *  res.direction_ratios[i])
		if (mag  >  0):
			result = dummy_gri  ==  vector(res,SQRT(mag))
		else:
			result = dummy_gri  ==  vector(vec1,0)
	return result

####################
 # FUNCTION advanced_face_properties #
####################
def advanced_face_properties(testface,):
	'''
	:param testface
	:type testface:face
	'''
	if ('AUTOMOTIVE_DESIGN.ADVANCED_FACE'  ==  TYPEOF(testface)):
		return TRUE
	if ('AUTOMOTIVE_DESIGN.SUBFACE'  ==  TYPEOF(testface)):
		return advanced_face_properties(testface.parent_face)
	else:
		return FALSE

####################
 # FUNCTION get_property_definition_representations #
####################
def get_property_definition_representations(c_def_instance,):
	'''
	:param c_def_instance
	:type c_def_instance:characterized_definition
	'''
	pd_set = bag_to_set(USEDIN(c_def_instance,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION.DEFINITION'))
	if (SIZEOF(pd_set)  <  1):
		return pdr_set
	for  i in range(1,HIINDEX(pd_set),1):
		pdr_set = pdr_set  +  bag_to_set(USEDIN(pd_set[i],'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))
	return pdr_set

####################
 # FUNCTION value_range_wr1 #
####################
def value_range_wr1(agg,):
	'''
	:param agg
	:type agg:(null)
	'''
	if ((SIZEOF(agg)  ==  2)  and  ((SIZEOF(None)  ==  2)  or  (SIZEOF(None)  ==  2))):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION value_range_wr3 #
####################
def value_range_wr3(agg,):
	'''
	:param agg
	:type agg:(null)
	'''
	if (SIZEOF(None)  ==  2):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION acyclic_product_definition_relationship #
####################
def acyclic_product_definition_relationship(relation,relatives,specific_relation,):
	'''
	:param relation
	:type relation:product_definition_relationship
	:param relatives
	:type relatives:(null)
	:param specific_relation
	:type specific_relation:STRING
	'''
	if (relation.relating_product_definition  ==  relatives):
		return FALSE
	x = None
	for  i in range(1,HIINDEX(x),1):
		if ( not acyclic_product_definition_relationship(x[i],relatives  +  relation.relating_product_definition,specific_relation)):
			return FALSE
	return TRUE

####################
 # FUNCTION value_range_wr2 #
####################
def value_range_wr2(agg,):
	'''
	:param agg
	:type agg:(null)
	'''
	if ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1)):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION list_to_set #
####################
def list_to_set(l,):
	'''
	:param l
	:type l:(null)
	'''
	for  i in range(1,SIZEOF(l),1):
		s = s  +  l[i]
	return s

####################
 # FUNCTION valid_calendar_date #
####################
def valid_calendar_date(date,):
	'''
	:param date
	:type date:calendar_date
	'''
	case_selector = date.month_component
	if  case_selector == 1:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 2:
		# begin/end block
		if (leap_year(date.year_component)):
			return (1  <=  date.day_component)  and  (date.day_component  <=  29)
		else:
			return (1  <=  date.day_component)  and  (date.day_component  <=  28)
	elif case_selector == 3:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 4:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 5:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 6:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 7:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 8:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 9:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 10:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 11:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 12:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	return FALSE

####################
 # FUNCTION valid_wireframe_vertex_point #
####################
def valid_wireframe_vertex_point(pnt,):
	'''
	:param pnt
	:type pnt:point
	'''
	if ('AUTOMOTIVE_DESIGN.CARTESIAN_POINT'  ==  TYPEOF(pnt)):
		return TRUE
	else:
		if ('AUTOMOTIVE_DESIGN.POINT_REPLICA'  ==  TYPEOF(pnt)):
			return valid_wireframe_vertex_point(pnt.point_replica.parent_pt)
	return FALSE

####################
 # FUNCTION list_to_array #
####################
def list_to_array(lis,low,u,):
	'''
	:param lis
	:type lis:(null)
	:param low
	:type low:INTEGER
	:param u
	:type u:INTEGER
	'''
	n = SIZEOF(lis)
	if (n  !=  ((u - low)  +  1)):
		return  None 
	else:
		res = [lis[1],n]
		for  i in range(2,n,1):
			res[(low  +  i) - 1] = lis[i]
		return res

####################
 # FUNCTION using_items #
####################
def using_items(item,checked_items,):
	'''
	:param item
	:type item:founded_item_select
	:param checked_items
	:type checked_items:(null)
	'''
	result_items = []
	new_check_items = checked_items  +  item
	next_items = None
	if (SIZEOF(next_items)  >  0):
		for  i in range(1,HIINDEX(next_items),1):
			if ( not (next_items[i]  ==  new_check_items)):
				result_items = (result_items  +  next_items[i])  +  using_items(next_items[i],new_check_items)
	return result_items

####################
 # FUNCTION valid_basis_curve_in_2d_wireframe #
####################
def valid_basis_curve_in_2d_wireframe(crv,):
	'''
	:param crv
	:type crv:curve
	'''
	if (SIZEOF(['AUTOMOTIVE_DESIGN.POLYLINE','AUTOMOTIVE_DESIGN.B_SPLINE_CURVE','AUTOMOTIVE_DESIGN.ELLIPSE','AUTOMOTIVE_DESIGN.CIRCLE']  *  TYPEOF(crv))  ==  1):
		return TRUE
	else:
		if ('AUTOMOTIVE_DESIGN.TRIMMED_CURVE'  ==  TYPEOF(crv)):
			if (SIZEOF(['AUTOMOTIVE_DESIGN.LINE','AUTOMOTIVE_DESIGN.PARABOLA','AUTOMOTIVE_DESIGN.HYPERBOLA']  *  TYPEOF(crv.trimmed_curve.basis_curve))  ==  1):
				return TRUE
			else:
				return valid_basis_curve_in_2d_wireframe(crv.trimmed_curve.basis_curve)
		else:
			if ('AUTOMOTIVE_DESIGN.OFFSET_CURVE_2D'  ==  TYPEOF(crv)):
				return valid_basis_curve_in_2d_wireframe(crv.offset_curve_2d.basis_curve)
			else:
				if ('AUTOMOTIVE_DESIGN.CURVE_REPLICA'  ==  TYPEOF(crv)):
					return valid_basis_curve_in_2d_wireframe(crv.curve_replica.parent_curve)
				else:
					if ('AUTOMOTIVE_DESIGN.COMPOSITE_CURVE'  ==  TYPEOF(crv)):
						return SIZEOF(None)  ==  0
	return FALSE

####################
 # FUNCTION constraints_geometry_shell_based_surface_model #
####################
def constraints_geometry_shell_based_surface_model(m,):
	'''
	:param m
	:type m:shell_based_surface_model
	'''
	for  j in range(1,SIZEOF(m.sbsm_boundary),1):
		if (( not ('AUTOMOTIVE_DESIGN.OPEN_SHELL'  ==  TYPEOF(m.sbsm_boundary[j])))  and  ( not ('AUTOMOTIVE_DESIGN.CLOSED_SHELL'  ==  TYPEOF(m.sbsm_boundary[j])))):
			result = FALSE
			return result
	return result

####################
 # FUNCTION face_bound_reversed #
####################
def face_bound_reversed(a_face_bound,):
	'''
	:param a_face_bound
	:type a_face_bound:face_bound
	'''
	if ('AUTOMOTIVE_DESIGN.FACE_OUTER_BOUND'  ==  TYPEOF(a_face_bound)):
		the_reverse = (dummy_tri  ==  face_bound(a_face_bound.face_bound.bound, not a_face_bound.face_bound.orientation))  ==  face_outer_bound()
	else:
		the_reverse = dummy_tri  ==  face_bound(a_face_bound.bound, not a_face_bound.orientation)
	return the_reverse

####################
 # FUNCTION acyclic #
####################
def acyclic(arg1,arg2,):
	'''
	:param arg1
	:type arg1:generic_expression
	:param arg2
	:type arg2:(null)
	'''
	if ('AUTOMOTIVE_DESIGN.SIMPLE_GENERIC_EXPRESSION'  ==  TYPEOF(arg1)):
		return TRUE
	if (arg1  ==  arg2):
		return FALSE
	if ('AUTOMOTIVE_DESIGN.UNARY_GENERIC_EXPRESSION'  ==  TYPEOF(arg1)):
		return acyclic(arg1.unary_generic_expression.operand,arg2  +  [arg1])
	if ('AUTOMOTIVE_DESIGN.BINARY_GENERIC_EXPRESSION'  ==  TYPEOF(arg1)):
		return acyclic(arg1.binary_generic_expression.operands[1],arg2  +  [arg1])  and  acyclic(arg1.binary_generic_expression.operands[2],arg2  +  [arg1])
	if ('AUTOMOTIVE_DESIGN.MULTIPLE_ARITY_GENERIC_EXPRESSION'  ==  TYPEOF(arg1)):
		result = TRUE
		for  i in range(1,SIZEOF(arg1.multiple_arity_generic_expression.operands),1):
			result = result  and  acyclic(arg1.multiple_arity_generic_expression.operands[i],arg2  +  [arg1])
		return result

####################
 # FUNCTION set_of_topology_reversed #
####################
def set_of_topology_reversed(a_set,):
	'''
	:param a_set
	:type a_set:set_of_reversible_topology_item
	'''
	the_reverse = []
	for  i in range(1,SIZEOF(a_set),1):
		the_reverse = the_reverse  +  topology_reversed(a_set[i])
	return the_reverse

####################
 # FUNCTION item_correlation #
####################
def item_correlation(items,c_items,):
	'''
	:param items
	:type items:(null)
	:param c_items
	:type c_items:(null)
	'''
	for  i in range(1,HIINDEX(c_items),1):
		c_types = c_types  +  ['AUTOMOTIVE_DESIGN.'  +  c_items[i]]
	for  i in range(1,HIINDEX(items),1):
		if (SIZEOF(c_types  *  TYPEOF(items[i]))  ==  1):
			c_hit = c_hit  +  1
	if (SIZEOF(items)  ==  c_hit):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION is_int_expr #
####################
def is_int_expr(arg,):
	'''
	:param arg
	:type arg:numeric_expression
	'''
	if ('AUTOMOTIVE_DESIGN.INT_LITERAL'  ==  TYPEOF(arg)):
		return TRUE
	if ('AUTOMOTIVE_DESIGN.REAL_LITERAL'  ==  TYPEOF(arg)):
		return FALSE
	if ('AUTOMOTIVE_DESIGN.INT_NUMERIC_VARIABLE'  ==  TYPEOF(arg)):
		return TRUE
	if ('AUTOMOTIVE_DESIGN.REAL_NUMERIC_VARIABLE'  ==  TYPEOF(arg)):
		return FALSE
	if ('AUTOMOTIVE_DESIGN.ABS_FUNCTION'  ==  TYPEOF(arg)):
		return is_int_expr(arg.unary_numeric_expression.operand)
	if ('AUTOMOTIVE_DESIGN.MINUS_FUNCTION'  ==  TYPEOF(arg)):
		return is_int_expr(arg.unary_numeric_expression.operand)
	if ((((((((((('AUTOMOTIVE_DESIGN.SIN_FUNCTION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.COS_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.TAN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.ASIN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.ACOS_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.ATAN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.EXP_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.LOG_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.LOG2_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.LOG10_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.SQUARE_ROOT_FUNCTION'  ==  TYPEOF(arg))):
		return FALSE
	if (((('AUTOMOTIVE_DESIGN.PLUS_EXPRESSION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.MULT_EXPRESSION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.MAXIMUM_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.MINIMUM_FUNCTION'  ==  TYPEOF(arg))):
		for  i in range(1,SIZEOF(arg.multiple_arity_numeric_expression.operands),1):
			if ( not is_int_expr(arg.multiple_arity_numeric_expression.operands[i])):
				return FALSE
		return TRUE
	if (('AUTOMOTIVE_DESIGN.MINUS_EXPRESSION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.POWER_EXPRESSION'  ==  TYPEOF(arg))):
		return is_int_expr(arg.binary_numeric_expression.operands[1])  and  is_int_expr(arg.binary_numeric_expression.operands[2])
	if (('AUTOMOTIVE_DESIGN.DIV_EXPRESSION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.MOD_EXPRESSION'  ==  TYPEOF(arg))):
		return TRUE
	if ('AUTOMOTIVE_DESIGN.SLASH_EXPRESSION'  ==  TYPEOF(arg)):
		return FALSE
	if ('AUTOMOTIVE_DESIGN.LENGTH_FUNCTION'  ==  TYPEOF(arg)):
		return TRUE
	if ('AUTOMOTIVE_DESIGN.VALUE_FUNCTION'  ==  TYPEOF(arg)):
		if ('AUTOMOTIVE_DESIGN.INT_VALUE_FUNCTION'  ==  TYPEOF(arg)):
			return TRUE
		else:
			return FALSE
	if ('AUTOMOTIVE_DESIGN.INTEGER_DEFINED_FUNCTION'  ==  TYPEOF(arg)):
		return TRUE
	if ('AUTOMOTIVE_DESIGN.REAL_DEFINED_FUNCTION'  ==  TYPEOF(arg)):
		return FALSE
	if ('AUTOMOTIVE_DESIGN.BOOLEAN_DEFINED_FUNCTION'  ==  TYPEOF(arg)):
		return FALSE
	if ('AUTOMOTIVE_DESIGN.STRING_DEFINED_FUNCTION'  ==  TYPEOF(arg)):
		return FALSE
	return FALSE

####################
 # FUNCTION dimension_of #
####################
def dimension_of(item,):
	'''
	:param item
	:type item:geometric_representation_item
	'''
	if ('AUTOMOTIVE_DESIGN.CARTESIAN_POINT'  ==  TYPEOF(item)):
		dim = SIZEOF(item.cartesian_point.coordinates)
		return dim
	if ('AUTOMOTIVE_DESIGN.DIRECTION'  ==  TYPEOF(item)):
		dim = SIZEOF(item.direction.direction_ratios)
		return dim
	if ('AUTOMOTIVE_DESIGN.VECTOR'  ==  TYPEOF(item)):
		dim = SIZEOF(item.vector.orientation.direction.direction_ratios)
		return dim
	x = using_representations(item)
	y = x[1].context_of_items
	dim = y.geometric_representation_context.coordinate_space_dimension
	return dim

####################
 # FUNCTION scalar_times_vector #
####################
def scalar_times_vector(scalar,vec,):
	'''
	:param scalar
	:type scalar:REAL
	:param vec
	:type vec:vector_or_direction
	'''
	if (( not EXISTS(scalar))  or  ( not EXISTS(vec))):
		return  None 
	else:
		if ('AUTOMOTIVE_DESIGN.VECTOR'  ==  TYPEOF(vec)):
			v = dummy_gri  ==  direction(vec.vector.orientation.direction_ratios)
			mag = scalar  *  vec.magnitude
		else:
			v = dummy_gri  ==  direction(vec.direction_ratios)
			mag = scalar
		if (mag  <  0):
			for  i in range(1,SIZEOF(v.direction_ratios),1):
				v.direction_ratios[i] = -v.direction_ratios[i]
			mag = -mag
		result = dummy_gri  ==  vector(normalise(v),mag)
	return result

####################
 # FUNCTION dimensions_for_si_unit #
####################
def dimensions_for_si_unit(n,):
	'''
	:param n
	:type n:si_unit_name
	'''
	case_selector = n
	if  case_selector == metre:
		return dimensional_exponents(1,0,0,0,0,0,0)
	elif case_selector == gram:
		return dimensional_exponents(0,1,0,0,0,0,0)
	elif case_selector == second:
		return dimensional_exponents(0,0,1,0,0,0,0)
	elif case_selector == ampere:
		return dimensional_exponents(0,0,0,1,0,0,0)
	elif case_selector == kelvin:
		return dimensional_exponents(0,0,0,0,1,0,0)
	elif case_selector == mole:
		return dimensional_exponents(0,0,0,0,0,1,0)
	elif case_selector == candela:
		return dimensional_exponents(0,0,0,0,0,0,1)
	elif case_selector == radian:
		return dimensional_exponents(0,0,0,0,0,0,0)
	elif case_selector == steradian:
		return dimensional_exponents(0,0,0,0,0,0,0)
	elif case_selector == hertz:
		return dimensional_exponents(0,0,-1,0,0,0,0)
	elif case_selector == newton:
		return dimensional_exponents(1,1,-2,0,0,0,0)
	elif case_selector == pascal:
		return dimensional_exponents(-1,1,-2,0,0,0,0)
	elif case_selector == joule:
		return dimensional_exponents(2,1,-2,0,0,0,0)
	elif case_selector == watt:
		return dimensional_exponents(2,1,-3,0,0,0,0)
	elif case_selector == coulomb:
		return dimensional_exponents(0,0,1,1,0,0,0)
	elif case_selector == volt:
		return dimensional_exponents(2,1,-3,-1,0,0,0)
	elif case_selector == farad:
		return dimensional_exponents(-2,-1,4,1,0,0,0)
	elif case_selector == ohm:
		return dimensional_exponents(2,1,-3,-2,0,0,0)
	elif case_selector == siemens:
		return dimensional_exponents(-2,-1,3,2,0,0,0)
	elif case_selector == weber:
		return dimensional_exponents(2,1,-2,-1,0,0,0)
	elif case_selector == tesla:
		return dimensional_exponents(0,1,-2,-1,0,0,0)
	elif case_selector == henry:
		return dimensional_exponents(2,1,-2,-2,0,0,0)
	elif case_selector == degree_celsius:
		return dimensional_exponents(0,0,0,0,1,0,0)
	elif case_selector == lumen:
		return dimensional_exponents(0,0,0,0,0,0,1)
	elif case_selector == lux:
		return dimensional_exponents(-2,0,0,0,0,0,1)
	elif case_selector == becquerel:
		return dimensional_exponents(0,0,-1,0,0,0,0)
	elif case_selector == gray:
		return dimensional_exponents(2,0,-2,0,0,0,0)
	elif case_selector == sievert:
		return dimensional_exponents(2,0,-2,0,0,0,0)
	else:
		return  None 

####################
 # FUNCTION assembly_shape_is_defined #
####################
def assembly_shape_is_defined(assy,):
	'''
	:param assy
	:type assy:next_assembly_usage_occurrence
	'''
	pd_set = bag_to_set(USEDIN(assy.related_product_definition,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION.DEFINITION'))
	pdr_set = None
	if (SIZEOF(pd_set)  >  0):
		for  i in range(1,HIINDEX(pd_set),1):
			sdr_set = sdr_set  +  None
	if (SIZEOF(pdr_set)  >  0):
		for  i in range(1,HIINDEX(pdr_set),1):
			prop_set = prop_set  +  bag_to_set(USEDIN(pdr_set[i],'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION.DEFINITION'))
		if (SIZEOF(prop_set)  >  0):
			for  i in range(1,HIINDEX(prop_set),1):
				sdr_set = sdr_set  +  None
	if (SIZEOF(sdr_set)  >  0):
		for  i in range(1,HIINDEX(sdr_set),1):
			srr_set = None
			pd_set = bag_to_set(USEDIN(assy.relating_product_definition,'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION.DEFINITION'))
			if (SIZEOF(pd_set)  >  0):
				for  i in range(1,HIINDEX(pd_set),1):
					sdr1_set = sdr1_set  +  None
			if ((SIZEOF(sdr_set)  >  0)  and  (SIZEOF(sdr1_set)  >  0)):
				if (SIZEOF(srr_set)  >  0):
					for  j in range(1,HIINDEX(srr_set),1):
						if (SIZEOF(None  *  sdr1_set)  >=  1):
							pds_set = None
							if (SIZEOF(pds_set)  ==  0):
								return FALSE
							for  k in range(1,HIINDEX(pds_set),1):
								if (SIZEOF(None)  >  0):
									return FALSE
	return TRUE

####################
 # FUNCTION surface_condition_correlation #
####################
def surface_condition_correlation(pd,rep,):
	'''
	:param pd
	:type pd:property_definition
	:param rep
	:type rep:representation
	'''
	case_selector = pd.name
	if  case_selector == 'visual appearance':
		return pd.name  ==  rep.name
	elif case_selector == 'tactile appearance':
		return pd.name  ==  rep.name
	elif case_selector == 'contact ratio':
		return pd.name  ==  rep.name
	elif case_selector == 'hardness':
		return pd.name  ==  rep.name
	elif case_selector == 'treatment result':
		return pd.name  ==  rep.name
	elif case_selector == 'surface texture':
		return pd.name  ==  rep.name
	else:
		return UNKNOWN

####################
 # FUNCTION open_shell_reversed #
####################
def open_shell_reversed(a_shell,):
	'''
	:param a_shell
	:type a_shell:open_shell
	'''
	if ('AUTOMOTIVE_DESIGN.ORIENTED_OPEN_SHELL'  ==  TYPEOF(a_shell)):
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  open_shell())  ==  oriented_open_shell(a_shell.oriented_open_shell.open_shell_element, not a_shell.oriented_open_shell.orientation)
	else:
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  open_shell())  ==  oriented_open_shell(a_shell,FALSE)
	return the_reverse

####################
 # FUNCTION acyclic_surface_replica #
####################
def acyclic_surface_replica(rep,parent,):
	'''
	:param rep
	:type rep:surface_replica
	:param parent
	:type parent:surface
	'''
	if ( not ('AUTOMOTIVE_DESIGN.SURFACE_REPLICA'  ==  TYPEOF(parent))):
		return TRUE
	if (parent  ==  rep):
		return FALSE
	else:
		return acyclic_surface_replica(rep,parent.surface_replica.parent_surface)

####################
 # FUNCTION gbsf_check_surface #
####################
def gbsf_check_surface(sf,):
	'''
	:param sf
	:type sf:surface
	'''
	if ((('AUTOMOTIVE_DESIGN.B_SPLINE_SURFACE'  ==  TYPEOF(sf))  and  (sf.b_spline_surface.self_intersect  ==  FALSE))  or  (sf.b_spline_surface.self_intersect  ==  UNKNOWN)):
		return TRUE
	else:
		if (SIZEOF(['AUTOMOTIVE_DESIGN.SPHERICAL_SURFACE','AUTOMOTIVE_DESIGN.TOROIDAL_SURFACE','AUTOMOTIVE_DESIGN.CURVE_BOUNDED_SURFACE','AUTOMOTIVE_DESIGN.RECTANGULAR_TRIMMED_SURFACE']  *  TYPEOF(sf))  ==  1):
			return TRUE
		else:
			if ((('AUTOMOTIVE_DESIGN.OFFSET_SURFACE'  ==  TYPEOF(sf))  and  (sf.offset_surface.self_intersect  ==  FALSE))  or  (sf.offset_surface.self_intersect  ==  UNKNOWN)):
				return gbsf_check_surface(sf.offset_surface.basis_surface)
			else:
				if ('AUTOMOTIVE_DESIGN.RECTANGULAR_COMPOSITE_SURFACE'  ==  TYPEOF(sf)):
					for  i in range(1,SIZEOF(sf.rectangular_composite_surface.segments),1):
						for  j in range(1,SIZEOF(sf.rectangular_composite_surface.segments[i]),1):
							if ( not gbsf_check_surface(sf.rectangular_composite_surface.segments[i][j].parent_surface)):
								return FALSE
					return TRUE
				else:
					if ('AUTOMOTIVE_DESIGN.SURFACE_REPLICA'  ==  TYPEOF(sf)):
						return gbsf_check_surface(sf.surface_replica.parent_surface)
					else:
						if ('AUTOMOTIVE_DESIGN.SURFACE_OF_REVOLUTION'  ==  TYPEOF(sf)):
							return gbsf_check_curve(sf.swept_surface.swept_curve)
	return FALSE

####################
 # FUNCTION msf_surface_check #
####################
def msf_surface_check(surf,):
	'''
	:param surf
	:type surf:surface
	'''
	if ('AUTOMOTIVE_DESIGN.ELEMENTARY_SURFACE'  ==  TYPEOF(surf)):
		return TRUE
	else:
		if ('AUTOMOTIVE_DESIGN.SWEPT_SURFACE'  ==  TYPEOF(surf)):
			return msf_curve_check(surf.swept_surface.swept_curve)
		else:
			if ((('AUTOMOTIVE_DESIGN.OFFSET_SURFACE'  ==  TYPEOF(surf))  and  (surf.offset_surface.self_intersect  ==  FALSE))  or  (surf.offset_surface.self_intersect  ==  UNKNOWN)):
				return msf_surface_check(surf.offset_surface.basis_surface)
			else:
				if ('AUTOMOTIVE_DESIGN.SURFACE_REPLICA'  ==  TYPEOF(surf)):
					return msf_surface_check(surf.surface_replica.parent_surface)
				else:
					if ((('AUTOMOTIVE_DESIGN.B_SPLINE_SURFACE'  ==  TYPEOF(surf))  and  (surf.b_spline_surface.self_intersect  ==  FALSE))  or  (surf.b_spline_surface.self_intersect  ==  UNKNOWN)):
						return TRUE
	return FALSE

####################
 # FUNCTION normalise #
####################
def normalise(arg,):
	'''
	:param arg
	:type arg:vector_or_direction
	'''
	if ( not EXISTS(arg)):
		result =  None 
	else:
		ndim = arg.dim
		if ('AUTOMOTIVE_DESIGN.VECTOR'  ==  TYPEOF(arg)):
			v = dummy_gri  ==  direction(arg.vector.orientation.direction_ratios)
			if (arg.magnitude  ==  0):
				return  None 
			else:
				vec = dummy_gri  ==  vector(v,1)
		else:
			v = dummy_gri  ==  direction(arg.direction_ratios)
		mag = 0
		for  i in range(1,ndim,1):
			mag = mag  +  (v.direction_ratios[i]  *  v.direction_ratios[i])
		if (mag  >  0):
			mag = SQRT(mag)
			for  i in range(1,ndim,1):
				v.direction_ratios[i] = v.direction_ratios[i] / mag
			if ('AUTOMOTIVE_DESIGN.VECTOR'  ==  TYPEOF(arg)):
				vec.orientation = v
				result = vec
			else:
				result = v
		else:
			return  None 
	return result

####################
 # FUNCTION msb_shells #
####################
def msb_shells(brep,):
	'''
	:param brep
	:type brep:manifold_solid_brep
	'''
	if (SIZEOF(None)  >=  1):
		return_set = return_set  +  brep.brep_with_voids.voids
	return return_set

####################
 # FUNCTION nmsf_surface_check #
####################
def nmsf_surface_check(surf,):
	'''
	:param surf
	:type surf:surface
	'''
	if ('AUTOMOTIVE_DESIGN.ELEMENTARY_SURFACE'  ==  TYPEOF(surf)):
		return TRUE
	else:
		if ('AUTOMOTIVE_DESIGN.SWEPT_SURFACE'  ==  TYPEOF(surf)):
			return nmsf_curve_check(surf.swept_surface.swept_curve)
		else:
			if ((('AUTOMOTIVE_DESIGN.OFFSET_SURFACE'  ==  TYPEOF(surf))  and  (surf.offset_surface.self_intersect  ==  FALSE))  or  (surf.offset_surface.self_intersect  ==  UNKNOWN)):
				return nmsf_surface_check(surf.offset_surface.basis_surface)
			else:
				if ('AUTOMOTIVE_DESIGN.SURFACE_REPLICA'  ==  TYPEOF(surf)):
					return nmsf_surface_check(surf.surface_replica.parent_surface)
				else:
					if ((('AUTOMOTIVE_DESIGN.B_SPLINE_SURFACE'  ==  TYPEOF(surf))  and  (surf.b_spline_surface.self_intersect  ==  FALSE))  or  (surf.b_spline_surface.self_intersect  ==  UNKNOWN)):
						return TRUE
	return FALSE

####################
 # FUNCTION mixed_loop_type_set #
####################
def mixed_loop_type_set(l,):
	'''
	:param l
	:type l:(null)
	'''
	if (SIZEOF(l)  <=  1):
		return FALSE
	poly_loop_type = 'AUTOMOTIVE_DESIGN.POLY_LOOP'  ==  TYPEOF(l[1])
	for  i in range(2,SIZEOF(l),1):
		if (('AUTOMOTIVE_DESIGN.POLY_LOOP'  ==  TYPEOF(l[i]))  !=  poly_loop_type):
			return TRUE
	return FALSE

####################
 # FUNCTION derive_dimensional_exponents #
####################
def derive_dimensional_exponents(x,):
	'''
	:param x
	:type x:unit
	'''
	if ('AUTOMOTIVE_DESIGN.DERIVED_UNIT'  ==  TYPEOF(x)):
		for  i in range(LOINDEX(x.derived_unit.elements),HIINDEX(x.derived_unit.elements),1):
			result.length_exponent = result.length_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.length_exponent)
			result.mass_exponent = result.mass_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.mass_exponent)
			result.time_exponent = result.time_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.time_exponent)
			result.electric_current_exponent = result.electric_current_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.electric_current_exponent)
			result.thermodynamic_temperature_exponent = result.thermodynamic_temperature_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.thermodynamic_temperature_exponent)
			result.amount_of_substance_exponent = result.amount_of_substance_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.amount_of_substance_exponent)
			result.luminous_intensity_exponent = result.luminous_intensity_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.luminous_intensity_exponent)
	else:
		result = x.named_unit.dimensions
	return result

####################
 # FUNCTION curve_weights_positive #
####################
def curve_weights_positive(b,):
	'''
	:param b
	:type b:rational_b_spline_curve
	'''
	for  i in range(0,b.upper_index_on_control_points,1):
		if (b.weights[i]  <=  0):
			result = FALSE
			return result
	return result

####################
 # FUNCTION type_check_function #
####################
def type_check_function(the_type,sub_names,criterion,):
	'''
	:param the_type
	:type the_type:(null)
	:param sub_names
	:type sub_names:(null)
	:param criterion
	:type criterion:INTEGER
	'''
	if ((( not EXISTS(the_type))  or  ( not ((0  <=  criterion)  and  (criterion  <=  3))))  or  (SIZEOF(sub_names)  ==  0)):
		return UNKNOWN
	else:
		case_selector = criterion
		if  case_selector == 0:
			return SIZEOF(sub_names  *  TYPEOF(the_type))  >  0
		elif case_selector == 1:
			return SIZEOF(sub_names  *  TYPEOF(the_type))  ==  0
		elif case_selector == 2:
			return SIZEOF(sub_names  *  TYPEOF(the_type))  ==  1
		elif case_selector == 3:
			return SIZEOF(sub_names  *  TYPEOF(the_type))  <=  1

####################
 # FUNCTION valid_geometrically_bounded_wf_point #
####################
def valid_geometrically_bounded_wf_point(pnt,):
	'''
	:param pnt
	:type pnt:point
	'''
	if ('AUTOMOTIVE_DESIGN.CARTESIAN_POINT'  ==  TYPEOF(pnt)):
		return TRUE
	else:
		if ('AUTOMOTIVE_DESIGN.POINT_ON_CURVE'  ==  TYPEOF(pnt)):
			return valid_geometrically_bounded_wf_curve(pnt.point_on_curve.basis_curve)
		else:
			if ('AUTOMOTIVE_DESIGN.POINT_REPLICA'  ==  TYPEOF(pnt)):
				return valid_geometrically_bounded_wf_point(pnt.point_replica.parent_pt)
	return FALSE

####################
 # FUNCTION path_head_to_tail #
####################
def path_head_to_tail(a_path,):
	'''
	:param a_path
	:type a_path:path
	'''
	n = SIZEOF(a_path.edge_list)
	for  i in range(2,n,1):
		p = p  and  (a_path.edge_list[i - 1].edge_end  ==  a_path.edge_list[i].edge_start)
	return p

####################
 # FUNCTION path_reversed #
####################
def path_reversed(a_path,):
	'''
	:param a_path
	:type a_path:path
	'''
	if ('AUTOMOTIVE_DESIGN.ORIENTED_PATH'  ==  TYPEOF(a_path)):
		the_reverse = (dummy_tri  ==  path(list_of_topology_reversed(a_path.edge_list)))  ==  oriented_path(a_path.oriented_path.path_element, not a_path.oriented_path.orientation)
	else:
		the_reverse = (dummy_tri  ==  path(list_of_topology_reversed(a_path.edge_list)))  ==  oriented_path(a_path,FALSE)
	return the_reverse

####################
 # FUNCTION get_id_value #
####################
def get_id_value(obj,):
	'''
	:param obj
	:type obj:id_attribute_select
	'''
	if (SIZEOF(id_bag)  ==  1):
		return id_bag[1].attribute_value
	else:
		return  None 

####################
 # FUNCTION aspect_ratio #
####################
def aspect_ratio(p,):
	'''
	:param p
	:type p:planar_box
	'''
	if ((p.size_in_x  >  0)  and  (p.size_in_y  >  0)):
		return p.size_in_x / p.size_in_y
	else:
		return  None 

####################
 # FUNCTION convert_plane_angle_for_pair_from_radian #
####################
def convert_plane_angle_for_pair_from_radian(pair,angle_expr,):
	'''
	:param pair
	:type pair:kinematic_pair
	:param angle_expr
	:type angle_expr:REAL
	'''
	link_cntxt = link_rep.representation.context_of_items
	if ( not ('AUTOMOTIVE_DESIGN.GLOBAL_UNIT_ASSIGNED_CONTEXT'  ==  TYPEOF(link_cntxt))):
		return  None 
	pa_units = None
	if (SIZEOF(pa_units)  !=  1):
		return  None 
	pau = pa_units[1]
	if (( not ('AUTOMOTIVE_DESIGN.SI_UNIT'  ==  TYPEOF(pau)))  and  ( not ('AUTOMOTIVE_DESIGN.CONVERSION_BASED_UNIT'  ==  TYPEOF(pau)))):
		return  None 
	for  while 'AUTOMOTIVE_DESIGN.CONVERSION_BASED_UNIT'  ==  TYPEOF(pau)		conv_factor = conv_factor  *  pau.conversion_based_unit.conversion_factor.value_component
		pau = pau.conversion_based_unit.conversion_factor.unit_component
		if ((( not ('AUTOMOTIVE_DESIGN.SI_UNIT'  ==  TYPEOF(pau)))  and  ( not ('AUTOMOTIVE_DESIGN.CONVERSION_BASED_UNIT'  ==  TYPEOF(pau))))  or  ( not ('AUTOMOTIVE_DESIGN.PLANE_ANGLE_UNIT'  ==  TYPEOF(pau)))):
			return  None 
	if (pau.si_unit.name  !=  si_unit_name.radian):
		return  None 
	case_selector = pau.si_unit.prefix
	if  case_selector == si_prefix.exa:
		conv_factor = 1e+018  *  conv_factor
	elif case_selector == si_prefix.peta:
		conv_factor = 1e+015  *  conv_factor
	elif case_selector == si_prefix.tera:
		conv_factor = 1e+012  *  conv_factor
	elif case_selector == si_prefix.giga:
		conv_factor = 1e+009  *  conv_factor
	elif case_selector == si_prefix.mega:
		conv_factor = 1e+006  *  conv_factor
	elif case_selector == si_prefix.kilo:
		conv_factor = 1000  *  conv_factor
	elif case_selector == si_prefix.hecto:
		conv_factor = 100  *  conv_factor
	elif case_selector == si_prefix.deca:
		conv_factor = 10  *  conv_factor
	elif case_selector == si_prefix.deci:
		conv_factor = 0.1  *  conv_factor
	elif case_selector == si_prefix.centi:
		conv_factor = 0.01  *  conv_factor
	elif case_selector == si_prefix.milli:
		conv_factor = 0.001  *  conv_factor
	elif case_selector == si_prefix.micro:
		conv_factor = 1e-006  *  conv_factor
	elif case_selector == si_prefix.nano:
		conv_factor = 1e-009  *  conv_factor
	elif case_selector == si_prefix.pico:
		conv_factor = 1e-012  *  conv_factor
	elif case_selector == si_prefix.femto:
		conv_factor = 1e-015  *  conv_factor
	elif case_selector == si_prefix.atto:
		conv_factor = 1e-018  *  conv_factor
	result = angle_expr / conv_factor
	return result

####################
 # FUNCTION is_acyclic #
####################
def is_acyclic(arg,):
	'''
	:param arg
	:type arg:generic_expression
	'''
	return acyclic(arg,[])

####################
 # FUNCTION check_text_alignment #
####################
def check_text_alignment(ct,):
	'''
	:param ct
	:type ct:composite_text
	'''
	for  i in range(1,HIINDEX(ct.collected_text),1):
		a = a  +  [ct.collected_text[i].text_literal.alignment]
	return SIZEOF(a)  ==  1

####################
 # FUNCTION leap_year #
####################
def leap_year(year,):
	'''
	:param year
	:type year:INTEGER
	'''
	if ((((year  %  4)  ==  0)  and  ((year  %  100)  !=  0))  or  ((year  %  400)  ==  0)):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION face_reversed #
####################
def face_reversed(a_face,):
	'''
	:param a_face
	:type a_face:face
	'''
	if ('AUTOMOTIVE_DESIGN.ORIENTED_FACE'  ==  TYPEOF(a_face)):
		the_reverse = (dummy_tri  ==  face(set_of_topology_reversed(a_face.bounds)))  ==  oriented_face(a_face.oriented_face.face_element, not a_face.oriented_face.orientation)
	else:
		the_reverse = (dummy_tri  ==  face(set_of_topology_reversed(a_face.bounds)))  ==  oriented_face(a_face,FALSE)
	return the_reverse

####################
 # FUNCTION get_description_value #
####################
def get_description_value(obj,):
	'''
	:param obj
	:type obj:description_attribute_select
	'''
	if (SIZEOF(description_bag)  ==  1):
		return description_bag[1].attribute_value
	else:
		return  None 

####################
 # FUNCTION constraints_param_b_spline #
####################
def constraints_param_b_spline(degree,up_knots,up_cp,knot_mult,knots,):
	'''
	:param degree
	:type degree:INTEGER
	:param up_knots
	:type up_knots:INTEGER
	:param up_cp
	:type up_cp:INTEGER
	:param knot_mult
	:type knot_mult:(null)
	:param knots
	:type knots:(null)
	'''
	sum = knot_mult[1]
	for  i in range(2,up_knots,1):
		sum = sum  +  knot_mult[i]
	if ((((degree  <  1)  or  (up_knots  <  2))  or  (up_cp  <  degree))  or  (sum  !=  ((degree  +  up_cp)  +  2))):
		result = FALSE
		return result
	k = knot_mult[1]
	if ((k  <  1)  or  (k  >  (degree  +  1))):
		result = FALSE
		return result
	for  i in range(2,up_knots,1):
		if ((knot_mult[i]  <  1)  or  (knots[i]  <=  knots[i - 1])):
			result = FALSE
			return result
		k = knot_mult[i]
		if ((i  <  up_knots)  and  (k  >  degree)):
			result = FALSE
			return result
		if ((i  ==  up_knots)  and  (k  >  (degree  +  1))):
			result = FALSE
			return result
	return result

####################
 # FUNCTION value_range_aggregate_rep_item #
####################
def value_range_aggregate_rep_item(agg,):
	'''
	:param agg
	:type agg:(null)
	'''
	if ((SIZEOF(agg)  ==  3)  and  (SIZEOF(None)  ==  1)):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION frame_associated_to_background #
####################
def frame_associated_to_background(frame,background,):
	'''
	:param frame
	:type frame:rigid_placement
	:param background
	:type background:kinematic_frame_background
	'''
	rep_bag = None
	if (SIZEOF(rep_bag)  ==  0):
		return FALSE
	trf_bag = USEDIN(frame,'AUTOMOTIVE_DESIGN.KINEMATIC_FRAME_BASED_TRANSFORMATION.TRANSFORMATOR')
	if (SIZEOF(trf_bag)  ==  0):
		return FALSE
	for  i in range(1,HIINDEX(rep_bag),1):
		rep = rep_bag[i]
		ass_bag = None
		if (SIZEOF(ass_bag)  >  0):
			for  j in range(1,HIINDEX(ass_bag),1):
				ass = ass_bag[j]
				trm_bag = None
				if (SIZEOF(trm_bag)  >  0):
					return TRUE
	return FALSE

####################
 # FUNCTION representation_of_link #
####################
def representation_of_link(link,):
	'''
	:param link
	:type link:kinematic_link
	'''
	link_rep_rel = USEDIN(link,'AUTOMOTIVE_DESIGN.KINEMATIC_LINK_REPRESENTATION_RELATION.TOPOLOGICAL_ASPECTS')
	if (SIZEOF(link_rep_rel)  ==  0):
		return  None 
	else:
		return link_rep_rel[1].geometric_aspects

####################
 # FUNCTION ypr_index #
####################
def ypr_index(ypr,):
	'''
	:param ypr
	:type ypr:ypr_enumeration
	'''
	case_selector = ypr
	if  case_selector == yaw:
		return 1
	elif case_selector == pitch:
		return 2
	elif case_selector == roll:
		return 3
	return  None 

####################
 # FUNCTION acyclic_mapped_item_usage #
####################
def acyclic_mapped_item_usage(rep,):
	'''
	:param rep
	:type rep:representation
	'''
	items = None
	if (SIZEOF(items)  ==  0):
		return FALSE
	else:
		for  i in range(1,HIINDEX(items),1):
			if (items[i].mapped_item.mapping_source.mapped_representation  ==  rep):
				return TRUE
			else:
				return acyclic_mapped_item_usage(items[i].mapped_item.mapping_source.mapped_representation)
		return FALSE

####################
 # FUNCTION plane_angle_for_pair_in_radian #
####################
def plane_angle_for_pair_in_radian(pair,angle,):
	'''
	:param pair
	:type pair:kinematic_pair
	:param angle
	:type angle:REAL
	'''
	link_cntxt = link_rep.representation.context_of_items
	if ( not ('AUTOMOTIVE_DESIGN.GLOBAL_UNIT_ASSIGNED_CONTEXT'  ==  TYPEOF(link_cntxt))):
		return  None 
	pa_units = None
	if (SIZEOF(pa_units)  !=  1):
		return  None 
	pau = pa_units[1]
	if (( not ('AUTOMOTIVE_DESIGN.SI_UNIT'  ==  TYPEOF(pau)))  and  ( not ('AUTOMOTIVE_DESIGN.CONVERSION_BASED_UNIT'  ==  TYPEOF(pau)))):
		return  None 
	for  while 'AUTOMOTIVE_DESIGN.CONVERSION_BASED_UNIT'  ==  TYPEOF(pau)		converted_angle = converted_angle  *  pau.conversion_based_unit.conversion_factor.value_component
		pau = pau.conversion_based_unit.conversion_factor.unit_component
		if ((( not ('AUTOMOTIVE_DESIGN.SI_UNIT'  ==  TYPEOF(pau)))  and  ( not ('AUTOMOTIVE_DESIGN.CONVERSION_BASED_UNIT'  ==  TYPEOF(pau))))  or  ( not ('AUTOMOTIVE_DESIGN.PLANE_ANGLE_UNIT'  ==  TYPEOF(pau)))):
			return  None 
	if (pau.si_unit.name  !=  si_unit_name.radian):
		return  None 
	case_selector = pau.si_unit.prefix
	if  case_selector == si_prefix.exa:
		return 1e+018  *  converted_angle
	elif case_selector == si_prefix.peta:
		return 1e+015  *  converted_angle
	elif case_selector == si_prefix.tera:
		return 1e+012  *  converted_angle
	elif case_selector == si_prefix.giga:
		return 1e+009  *  converted_angle
	elif case_selector == si_prefix.mega:
		return 1e+006  *  converted_angle
	elif case_selector == si_prefix.kilo:
		return 1000  *  converted_angle
	elif case_selector == si_prefix.hecto:
		return 100  *  converted_angle
	elif case_selector == si_prefix.deca:
		return 10  *  converted_angle
	elif case_selector == si_prefix.deci:
		return 0.1  *  converted_angle
	elif case_selector == si_prefix.centi:
		return 0.01  *  converted_angle
	elif case_selector == si_prefix.milli:
		return 0.001  *  converted_angle
	elif case_selector == si_prefix.micro:
		return 1e-006  *  converted_angle
	elif case_selector == si_prefix.nano:
		return 1e-009  *  converted_angle
	elif case_selector == si_prefix.pico:
		return 1e-012  *  converted_angle
	elif case_selector == si_prefix.femto:
		return 1e-015  *  converted_angle
	elif case_selector == si_prefix.atto:
		return 1e-018  *  converted_angle
	else:
		return converted_angle

####################
 # FUNCTION get_multi_language #
####################
def get_multi_language(x,):
	'''
	:param x
	:type x:multi_language_attribute_assignment
	'''
	if (SIZEOF(alas)  >  0):
		return alas[1].language
	return  None 

####################
 # FUNCTION unique_link_usage #
####################
def unique_link_usage(link,):
	'''
	:param link
	:type link:kinematic_link
	'''
	joints = bag_to_set(USEDIN(link,'AUTOMOTIVE_DESIGN.KINEMATIC_JOINT.FIRST_LINK')  +  USEDIN(link,'AUTOMOTIVE_DESIGN.KINEMATIC_JOINT.SECOND_LINK'))
	struct = joints[1].structure
	for  i in range(2,SIZEOF(joints),1):
		if (joints[i].structure  !=  struct):
			return FALSE
	mechs = bag_to_set(USEDIN(struct,'AUTOMOTIVE_DESIGN.MECHANISM.STRUCTURE_DEFINITION'))
	if (SIZEOF(mechs)  !=  1):
		return FALSE
	return TRUE

####################
 # FUNCTION using_representations #
####################
def using_representations(item,):
	'''
	:param item
	:type item:founded_item_select
	'''
	results = []
	result_bag = USEDIN(item,'AUTOMOTIVE_DESIGN.REPRESENTATION.ITEMS')
	if (SIZEOF(result_bag)  >  0):
		for  i in range(1,HIINDEX(result_bag),1):
			results = results  +  result_bag[i]
	intermediate_items = using_items(item,[])
	if (SIZEOF(intermediate_items)  >  0):
		for  i in range(1,HIINDEX(intermediate_items),1):
			result_bag = USEDIN(intermediate_items[i],'AUTOMOTIVE_DESIGN.REPRESENTATION.ITEMS')
			if (SIZEOF(result_bag)  >  0):
				for  j in range(1,HIINDEX(result_bag),1):
					results = results  +  result_bag[j]
	return results

####################
 # FUNCTION control_characters_free #
####################
def control_characters_free(s,):
	'''
	:param s
	:type s:STRING
	'''
	for  i in range(1,LENGTH(s),1):
		ch = s[i]
		if (((ch  ==  '\x9')  or  (ch  ==  '\xA'))  or  (ch  ==  '\xD')):
			return FALSE
	return TRUE

####################
 # FUNCTION associated_surface #
####################
def associated_surface(arg,):
	'''
	:param arg
	:type arg:pcurve_or_surface
	'''
	if ('AUTOMOTIVE_DESIGN.PCURVE'  ==  TYPEOF(arg)):
		surf = arg.pcurve.basis_surface
	else:
		surf = arg
	return surf

####################
 # FUNCTION acyclic_point_replica #
####################
def acyclic_point_replica(rep,parent,):
	'''
	:param rep
	:type rep:point_replica
	:param parent
	:type parent:point
	'''
	if ( not ('AUTOMOTIVE_DESIGN.POINT_REPLICA'  ==  TYPEOF(parent))):
		return TRUE
	if (parent  ==  rep):
		return FALSE
	else:
		return acyclic_point_replica(rep,parent.point_replica.parent_pt)

####################
 # FUNCTION cross_product #
####################
def cross_product(arg1,arg2,):
	'''
	:param arg1
	:type arg1:direction
	:param arg2
	:type arg2:direction
	'''
	if (((( not EXISTS(arg1))  or  (arg1.dim  ==  2))  or  ( not EXISTS(arg2)))  or  (arg2.dim  ==  2)):
		return  None 
	else:
		v1 = normalise(arg1).direction_ratios
		v2 = normalise(arg2).direction_ratios
		res = dummy_gri  ==  direction([(v1[2]  *  v2[3]) - (v1[3]  *  v2[2]),(v1[3]  *  v2[1]) - (v1[1]  *  v2[3]),(v1[1]  *  v2[2]) - (v1[2]  *  v2[1])])
		mag = 0
		for  i in range(1,3,1):
			mag = mag  +  (res.direction_ratios[i]  *  res.direction_ratios[i])
		if (mag  >  0):
			result = dummy_gri  ==  vector(res,SQRT(mag))
		else:
			result = dummy_gri  ==  vector(arg1,0)
		return result

####################
 # FUNCTION valid_units #
####################
def valid_units(m,):
	'''
	:param m
	:type m:measure_with_unit
	'''
	if ('AUTOMOTIVE_DESIGN.LENGTH_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,0,0,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.MASS_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,1,0,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.TIME_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,1,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.ELECTRIC_CURRENT_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,1,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,1,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.CELSIUS_TEMPERATURE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,1,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,1,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.LUMINOUS_INTENSITY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,1)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.PLANE_ANGLE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.SOLID_ANGLE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.AREA_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,0,0,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.VOLUME_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(3,0,0,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.RATIO_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.POSITIVE_LENGTH_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,0,0,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.ACCELERATION_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,0,-2,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.CAPACITANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(-2,-1,4,1,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.ELECTRIC_CHARGE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,1,1,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.CONDUCTANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(-2,-1,3,2,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.ELECTRIC_POTENTIAL_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-3,-1,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.ENERGY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-2,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.FORCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,1,-2,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.FREQUENCY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,-1,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.ILLUMINANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(-2,0,0,0,0,0,1)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.INDUCTANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-2,-2,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.LUMINOUS_FLUX_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,1)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.MAGNETIC_FLUX_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-2,-1,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.MAGNETIC_FLUX_DENSITY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,1,-2,-1,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.POWER_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-3,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.PRESSURE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(-1,1,-2,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.RESISTANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-3,-2,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.VELOCITY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,0,-1,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.RADIOACTIVITY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,-1,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.ABSORBED_DOSE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,0,-2,0,0,0,0)):
			return FALSE
	if ('AUTOMOTIVE_DESIGN.DOSE_EQUIVALENT_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,0,-2,0,0,0,0)):
			return FALSE
	return TRUE

####################
 # FUNCTION representations_mapped_into #
####################
def representations_mapped_into(rep,):
	'''
	:param rep
	:type rep:representation
	'''
	rm = bag_to_set(USEDIN(rep,'AUTOMOTIVE_DESIGN.REPRESENTATION_MAP.MAPPED_REPRESENTATION'))
	for  i in range(1,HIINDEX(rm),1):
		mi = mi  +  rm[i].map_usage
	for  j in range(1,HIINDEX(mi),1):
		results = results  +  USEDIN(mi[j],'AUTOMOTIVE_DESIGN.REPRESENTATION.ITEMS')
	return results

####################
 # FUNCTION constraints_rectangular_composite_surface #
####################
def constraints_rectangular_composite_surface(s,):
	'''
	:param s
	:type s:rectangular_composite_surface
	'''
	for  i in range(1,s.n_u,1):
		for  j in range(1,s.n_v,1):
			if ( not (('AUTOMOTIVE_DESIGN.B_SPLINE_SURFACE'  ==  TYPEOF(s.segments[i][j].parent_surface))  or  ('AUTOMOTIVE_DESIGN.RECTANGULAR_TRIMMED_SURFACE'  ==  TYPEOF(s.segments[i][j].parent_surface)))):
				return FALSE
	for  i in range(1,s.n_u - 1,1):
		for  j in range(1,s.n_v,1):
			if (s.segments[i][j].u_transition  ==  discontinuous):
				return FALSE
	for  i in range(1,s.n_u,1):
		for  j in range(1,s.n_v - 1,1):
			if (s.segments[i][j].v_transition  ==  discontinuous):
				return FALSE
	return TRUE

####################
 # FUNCTION suitably_based_mechanism #
####################
def suitably_based_mechanism(mbp,mech,):
	'''
	:param mbp
	:type mbp:mechanism_base_placement
	:param mech
	:type mech:mechanism
	'''
	kprop = mech.containing_property
	if ('AUTOMOTIVE_DESIGN.KINEMATIC_GROUND_REPRESENTATION'  ==  TYPEOF(mbp.representation_relationship.rep_1)):
		kgrep = mbp.representation_relationship.rep_1
		if (kgrep.property.property_definition_representation.definition  ==  kprop):
			return TRUE
		else:
			return FALSE
	else:
		klrep = mbp.representation_relationship.rep_1
		klnk = klrep.link_representation_relation.topological_aspects
		kjnts = USEDIN(klnk,'AUTOMOTIVE_DESIGN.KINEMATIC_JOINT.FIRST_LINK')  +  USEDIN(klnk,'AUTOMOTIVE_DESIGN.KINEMATIC_JOINT.SECOND_LINK')
		nmechs = USEDIN(kjnts[1].structure,'AUTOMOTIVE_DESIGN.MECHANISM.STRUCTURE_DEFINITION')
		if (nmechs[1]  ==  mech):
			return FALSE
		else:
			if (nmechs[1].containing_property  !=  kprop):
				return FALSE
			else:
				nmbps = USEDIN(nmechs[1],'AUTOMOTIVE_DESIGN.MECHANISM_BASE_PLACEMENT.BASE_OF_MECHANISM')
				if (SIZEOF(nmbps)  ==  0):
					return FALSE
				else:
					return suitably_based_mechanism(nmbps[1],mech)

####################
 # FUNCTION closed_shell_reversed #
####################
def closed_shell_reversed(a_shell,):
	'''
	:param a_shell
	:type a_shell:closed_shell
	'''
	if ('AUTOMOTIVE_DESIGN.ORIENTED_CLOSED_SHELL'  ==  TYPEOF(a_shell)):
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  closed_shell())  ==  oriented_closed_shell(a_shell.oriented_closed_shell.closed_shell_element, not a_shell.oriented_closed_shell.orientation)
	else:
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  closed_shell())  ==  oriented_closed_shell(a_shell,FALSE)
	return the_reverse

####################
 # FUNCTION boolean_choose #
####################
def boolean_choose(b,choice1,choice2,):
	'''
	:param b
	:type b:BOOLEAN
	:param choice1
	:type choice1:(null)
	:param choice2
	:type choice2:(null)
	'''
	if (b):
		return choice1
	else:
		return choice2

####################
 # FUNCTION valid_time #
####################
def valid_time(time,):
	'''
	:param time
	:type time:local_time
	'''
	if (EXISTS(time.second_component)):
		return EXISTS(time.minute_component)
	else:
		return TRUE

####################
 # FUNCTION is_sql_mappable #
####################
def is_sql_mappable(arg,):
	'''
	:param arg
	:type arg:expression
	'''
	if ('AUTOMOTIVE_DESIGN.SIMPLE_NUMERIC_EXPRESSION'  ==  TYPEOF(arg)):
		return TRUE
	if ('AUTOMOTIVE_DESIGN.SQL_MAPPABLE_DEFINED_FUNCTION'  ==  TYPEOF(arg)):
		return TRUE
	if ('AUTOMOTIVE_DESIGN.MINUS_FUNCTION'  ==  TYPEOF(arg)):
		return is_sql_mappable(arg.unary_numeric_expression.operand)
	if (((((((((((((('AUTOMOTIVE_DESIGN.ABS_FUNCTION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.SIN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.COS_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.TAN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.ASIN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.ACOS_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.ATAN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.EXP_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.LOG_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.LOG2_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.LOG10_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.SQUARE_ROOT_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.VALUE_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.LENGTH_FUNCTION'  ==  TYPEOF(arg))):
		return FALSE
	if (((('AUTOMOTIVE_DESIGN.PLUS_EXPRESSION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.MULT_EXPRESSION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.MAXIMUM_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.MINIMUM_FUNCTION'  ==  TYPEOF(arg))):
		for  i in range(1,SIZEOF(arg.multiple_arity_numeric_expression.operands),1):
			if ( not is_sql_mappable(arg.multiple_arity_numeric_expression.operands[i])):
				return FALSE
		return TRUE
	if (('AUTOMOTIVE_DESIGN.MINUS_EXPRESSION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.SLASH_EXPRESSION'  ==  TYPEOF(arg))):
		return is_sql_mappable(arg.binary_numeric_expression.operands[1])  and  is_sql_mappable(arg.binary_numeric_expression.operands[2])
	if ((('AUTOMOTIVE_DESIGN.DIV_EXPRESSION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.MOD_EXPRESSION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.POWER_EXPRESSION'  ==  TYPEOF(arg))):
		return FALSE
	if ('AUTOMOTIVE_DESIGN.SIMPLE_BOOLEAN_EXPRESSION'  ==  TYPEOF(arg)):
		return TRUE
	if ('AUTOMOTIVE_DESIGN.NOT_EXPRESSION'  ==  TYPEOF(arg)):
		return is_sql_mappable(arg.unary_generic_expression.operand)
	if (('AUTOMOTIVE_DESIGN.ODD_FUNCTION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.XOR_EXPRESSION'  ==  TYPEOF(arg))):
		return FALSE
	if (('AUTOMOTIVE_DESIGN.AND_EXPRESSION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.OR_EXPRESSION'  ==  TYPEOF(arg))):
		for  i in range(1,SIZEOF(arg.multiple_arity_boolean_expression.operands),1):
			if ( not is_sql_mappable(arg.multiple_arity_boolean_expression.operands[i])):
				return FALSE
		return TRUE
	if ('AUTOMOTIVE_DESIGN.EQUALS_EXPRESSION'  ==  TYPEOF(arg)):
		return is_sql_mappable(arg.binary_generic_expression.operands[1])  and  is_sql_mappable(arg.binary_generic_expression.operands[2])
	if ((((((('AUTOMOTIVE_DESIGN.COMPARISON_EQUAL'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.COMPARISON_GREATER'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.COMPARISON_GREATER_EQUAL'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.COMPARISON_LESS'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.COMPARISON_LESS_EQUAL'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.COMPARISON_NOT_EQUAL'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.LIKE_EXPRESSION'  ==  TYPEOF(arg))):
		return is_sql_mappable(arg.comparison_expression.operands[1])  and  is_sql_mappable(arg.comparison_expression.operands[2])
	if ('AUTOMOTIVE_DESIGN.INTERVAL_EXPRESSION'  ==  TYPEOF(arg)):
		return (is_sql_mappable(arg.interval_expression.interval_low)  and  is_sql_mappable(arg.interval_expression.interval_high))  and  is_sql_mappable(arg.interval_expression.interval_item)
	if ((('AUTOMOTIVE_DESIGN.NUMERIC_DEFINED_FUNCTION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.BOOLEAN_DEFINED_FUNCTION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.STRING_DEFINED_FUNCTION'  ==  TYPEOF(arg))):
		return FALSE
	if ('AUTOMOTIVE_DESIGN.SIMPLE_STRING_EXPRESSION'  ==  TYPEOF(arg)):
		return TRUE
	if (((('AUTOMOTIVE_DESIGN.INDEX_EXPRESSION'  ==  TYPEOF(arg))  or  ('AUTOMOTIVE_DESIGN.SUBSTRING_EXPRESSION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.CONCAT_EXPRESSION'  ==  TYPEOF(arg)))  or  ('AUTOMOTIVE_DESIGN.FORMAT_FUNCTION'  ==  TYPEOF(arg))):
		return FALSE
	return FALSE

####################
 # FUNCTION valid_geometrically_bounded_wf_curve #
####################
def valid_geometrically_bounded_wf_curve(crv,):
	'''
	:param crv
	:type crv:curve
	'''
	if (SIZEOF(['AUTOMOTIVE_DESIGN.POLYLINE','AUTOMOTIVE_DESIGN.B_SPLINE_CURVE','AUTOMOTIVE_DESIGN.ELLIPSE','AUTOMOTIVE_DESIGN.CIRCLE']  *  TYPEOF(crv))  ==  1):
		return TRUE
	else:
		if ('AUTOMOTIVE_DESIGN.TRIMMED_CURVE'  ==  TYPEOF(crv)):
			if (SIZEOF(['AUTOMOTIVE_DESIGN.LINE','AUTOMOTIVE_DESIGN.PARABOLA','AUTOMOTIVE_DESIGN.HYPERBOLA']  *  TYPEOF(crv.trimmed_curve.basis_curve))  ==  1):
				return TRUE
			else:
				return valid_geometrically_bounded_wf_curve(crv.trimmed_curve.basis_curve)
		else:
			if ('AUTOMOTIVE_DESIGN.OFFSET_CURVE_3D'  ==  TYPEOF(crv)):
				return valid_geometrically_bounded_wf_curve(crv.offset_curve_3d.basis_curve)
			else:
				if ('AUTOMOTIVE_DESIGN.CURVE_REPLICA'  ==  TYPEOF(crv)):
					return valid_geometrically_bounded_wf_curve(crv.curve_replica.parent_curve)
				else:
					if ('AUTOMOTIVE_DESIGN.COMPOSITE_CURVE'  ==  TYPEOF(crv)):
						return SIZEOF(None)  ==  0
	return FALSE

####################
 # FUNCTION dot_product #
####################
def dot_product(arg1,arg2,):
	'''
	:param arg1
	:type arg1:direction
	:param arg2
	:type arg2:direction
	'''
	if (( not EXISTS(arg1))  or  ( not EXISTS(arg2))):
		scalar =  None 
	else:
		if (arg1.dim  !=  arg2.dim):
			scalar =  None 
		else:
			vec1 = normalise(arg1)
			vec2 = normalise(arg2)
			ndim = arg1.dim
			scalar = 0
			for  i in range(1,ndim,1):
				scalar = scalar  +  (vec1.direction_ratios[i]  *  vec2.direction_ratios[i])
	return scalar

####################
 # FUNCTION get_role #
####################
def get_role(obj,):
	'''
	:param obj
	:type obj:role_select
	'''
	if (SIZEOF(role_bag)  ==  1):
		return role_bag[1].role
	else:
		return  None 

####################
 # FUNCTION acyclic_curve_replica #
####################
def acyclic_curve_replica(rep,parent,):
	'''
	:param rep
	:type rep:curve_replica
	:param parent
	:type parent:curve
	'''
	if ( not ('AUTOMOTIVE_DESIGN.CURVE_REPLICA'  ==  TYPEOF(parent))):
		return TRUE
	if (parent  ==  rep):
		return FALSE
	else:
		return acyclic_curve_replica(rep,parent.curve_replica.parent_curve)

####################
 # RULE restrict_multi_language_for_approval_relationship #
####################
restrict_multi_language_for_approval_relationship = Rule()

####################
 # RULE restrict_multi_language_for_action_relationship #
####################
restrict_multi_language_for_action_relationship = Rule()

####################
 # RULE subtype_exclusiveness_replicate_feature #
####################
subtype_exclusiveness_replicate_feature = Rule()

####################
 # RULE subtype_exclusiveness_shape_representation_feature_geometry #
####################
subtype_exclusiveness_shape_representation_feature_geometry = Rule()

####################
 # RULE restrict_configuration_design_for_product_class #
####################
restrict_configuration_design_for_product_class = Rule()

####################
 # RULE restrict_multi_language_for_action_method #
####################
restrict_multi_language_for_action_method = Rule()

####################
 # RULE versioned_action_request_requires_status #
####################
versioned_action_request_requires_status = Rule()

####################
 # RULE person_requires_person_and_organization #
####################
person_requires_person_and_organization = Rule()

####################
 # RULE restrict_multi_language_for_kinematic_pair #
####################
restrict_multi_language_for_kinematic_pair = Rule()

####################
 # RULE restrict_multi_language_for_product_related_product_category #
####################
restrict_multi_language_for_product_related_product_category = Rule()

####################
 # RULE dependent_instantiable_date_and_time #
####################
dependent_instantiable_date_and_time = Rule()

####################
 # RULE restrict_multi_language_for_organization_relationship #
####################
restrict_multi_language_for_organization_relationship = Rule()

####################
 # RULE dependent_instantiable_dimensional_size #
####################
dependent_instantiable_dimensional_size = Rule()

####################
 # RULE dependent_instantiable_person_and_organization_role #
####################
dependent_instantiable_person_and_organization_role = Rule()

####################
 # RULE drawing_sheet_annotation_layers #
####################
drawing_sheet_annotation_layers = Rule()

####################
 # RULE subtype_exclusiveness_pre_defined_symbol #
####################
subtype_exclusiveness_pre_defined_symbol = Rule()

####################
 # RULE subtype_mandatory_externally_defined_item #
####################
subtype_mandatory_externally_defined_item = Rule()

####################
 # RULE compatible_dimension #
####################
compatible_dimension = Rule()

####################
 # RULE dependent_instantiable_curve_style #
####################
dependent_instantiable_curve_style = Rule()

####################
 # RULE restrict_multi_language_for_geometric_tolerance #
####################
restrict_multi_language_for_geometric_tolerance = Rule()

####################
 # RULE restrict_multi_language_for_security_classification #
####################
restrict_multi_language_for_security_classification = Rule()

####################
 # RULE curve_font_usage #
####################
curve_font_usage = Rule()

####################
 # RULE restrict_camera_image_in_view #
####################
restrict_camera_image_in_view = Rule()

####################
 # RULE restrict_process_product_association #
####################
restrict_process_product_association = Rule()

####################
 # RULE subtype_mandatory_annotation_occurrence #
####################
subtype_mandatory_annotation_occurrence = Rule()

####################
 # RULE product_requires_id_owner #
####################
product_requires_id_owner = Rule()

####################
 # RULE restrict_multi_language_for_time_interval_role #
####################
restrict_multi_language_for_time_interval_role = Rule()

####################
 # RULE subtype_exclusiveness_feature_definition #
####################
subtype_exclusiveness_feature_definition = Rule()

####################
 # RULE product_requires_version #
####################
product_requires_version = Rule()

####################
 # RULE restrict_multi_language_for_identification_role #
####################
restrict_multi_language_for_identification_role = Rule()

####################
 # RULE restrict_alternative_definition #
####################
restrict_alternative_definition = Rule()

####################
 # RULE restrict_multi_language_for_representation #
####################
restrict_multi_language_for_representation = Rule()

####################
 # RULE dependent_instantiable_retention #
####################
dependent_instantiable_retention = Rule()

####################
 # RULE subtype_exclusiveness_geometric_tolerance #
####################
subtype_exclusiveness_geometric_tolerance = Rule()

####################
 # RULE restrict_multi_language_for_product_definition_formation #
####################
restrict_multi_language_for_product_definition_formation = Rule()

####################
 # RULE restrict_multi_language_for_property_definition #
####################
restrict_multi_language_for_property_definition = Rule()

####################
 # RULE restrict_multi_language_for_document_relationship #
####################
restrict_multi_language_for_document_relationship = Rule()

####################
 # RULE subtype_exclusiveness_mapped_item #
####################
subtype_exclusiveness_mapped_item = Rule()

####################
 # RULE subtype_exclusiveness_effectivity_context_assignment #
####################
subtype_exclusiveness_effectivity_context_assignment = Rule()

####################
 # RULE restrict_multi_language_for_action_property #
####################
restrict_multi_language_for_action_property = Rule()

####################
 # RULE versioned_action_request_requires_date_and_person_or_organization #
####################
versioned_action_request_requires_date_and_person_or_organization = Rule()

####################
 # RULE retention_requires_retention_assignment #
####################
retention_requires_retention_assignment = Rule()

####################
 # RULE subtype_mandatory_pre_defined_text_font #
####################
subtype_mandatory_pre_defined_text_font = Rule()

####################
 # RULE subtype_exclusiveness_group_assignment #
####################
subtype_exclusiveness_group_assignment = Rule()

####################
 # RULE restrict_zone_boundary #
####################
restrict_zone_boundary = Rule()

####################
 # RULE subtype_exclusiveness_presentation_area #
####################
subtype_exclusiveness_presentation_area = Rule()

####################
 # RULE restrict_multi_language_for_alternate_product_relationship #
####################
restrict_multi_language_for_alternate_product_relationship = Rule()

####################
 # RULE restrict_multi_language_for_effectivity #
####################
restrict_multi_language_for_effectivity = Rule()

####################
 # RULE subtype_exclusiveness_effectivity_assignment #
####################
subtype_exclusiveness_effectivity_assignment = Rule()

####################
 # RULE restrict_product_definition_for_mating_tree #
####################
restrict_product_definition_for_mating_tree = Rule()

####################
 # RULE restrict_version_assignment_for_action_directive #
####################
restrict_version_assignment_for_action_directive = Rule()

####################
 # RULE restrict_centre_of_mass_representation #
####################
restrict_centre_of_mass_representation = Rule()

####################
 # RULE restrict_version_assignment_for_document_file #
####################
restrict_version_assignment_for_document_file = Rule()

####################
 # RULE restrict_version_assignment_for_mechanical_design_geometric_presentation_representation #
####################
restrict_version_assignment_for_mechanical_design_geometric_presentation_representation = Rule()

####################
 # RULE restrict_multi_language_for_product_definition_substitute #
####################
restrict_multi_language_for_product_definition_substitute = Rule()

####################
 # RULE restrict_representation_for_document_content_property #
####################
restrict_representation_for_document_content_property = Rule()

####################
 # RULE restrict_multi_language_for_organizational_project #
####################
restrict_multi_language_for_organizational_project = Rule()

####################
 # RULE selected_instance_usage_requires_representation #
####################
selected_instance_usage_requires_representation = Rule()

####################
 # RULE subtype_exclusiveness_effectivity #
####################
subtype_exclusiveness_effectivity = Rule()

####################
 # RULE subtype_mandatory_founded_item #
####################
subtype_mandatory_founded_item = Rule()

####################
 # RULE dependent_instantiable_named_unit #
####################
dependent_instantiable_named_unit = Rule()

####################
 # RULE restrict_name_assignment_for_kinematic_link #
####################
restrict_name_assignment_for_kinematic_link = Rule()

####################
 # RULE restrict_multi_language_for_person_and_organization_role #
####################
restrict_multi_language_for_person_and_organization_role = Rule()

####################
 # RULE restrict_multi_language_for_product_definition_relationship #
####################
restrict_multi_language_for_product_definition_relationship = Rule()

####################
 # RULE application_protocol_definition_required #
####################
application_protocol_definition_required = Rule()

####################
 # RULE subtype_exclusiveness_action #
####################
subtype_exclusiveness_action = Rule()

####################
 # RULE subtype_mandatory_draughting_callout #
####################
subtype_mandatory_draughting_callout = Rule()

####################
 # RULE restrict_multi_language_for_organization_role #
####################
restrict_multi_language_for_organization_role = Rule()

####################
 # RULE restrict_multi_language_for_product_definition_formation_relationship #
####################
restrict_multi_language_for_product_definition_formation_relationship = Rule()

####################
 # RULE restrict_multi_language_for_uncertainty_measure_with_unit #
####################
restrict_multi_language_for_uncertainty_measure_with_unit = Rule()

####################
 # RULE restrict_viewing_plane_usage #
####################
restrict_viewing_plane_usage = Rule()

####################
 # RULE subtype_exclusiveness_identification_assignment #
####################
subtype_exclusiveness_identification_assignment = Rule()

####################
 # RULE subtype_mandatory_pre_defined_colour #
####################
subtype_mandatory_pre_defined_colour = Rule()

####################
 # RULE restrict_multi_language_for_configuration_item #
####################
restrict_multi_language_for_configuration_item = Rule()

####################
 # RULE restrict_class_system_assignment_for_class #
####################
restrict_class_system_assignment_for_class = Rule()

####################
 # RULE restrict_multi_language_for_pair_actuator #
####################
restrict_multi_language_for_pair_actuator = Rule()

####################
 # RULE restrict_product_definitions_for_product_definition_relationship #
####################
restrict_product_definitions_for_product_definition_relationship = Rule()

####################
 # RULE subtype_exclusiveness_symbol_representation #
####################
subtype_exclusiveness_symbol_representation = Rule()

####################
 # RULE dependent_instantiable_time_interval_role #
####################
dependent_instantiable_time_interval_role = Rule()

####################
 # RULE executed_action_requires_action_status #
####################
executed_action_requires_action_status = Rule()

####################
 # RULE consistent_uncertainty #
####################
consistent_uncertainty = Rule()

####################
 # RULE restrict_multi_language_for_application_context #
####################
restrict_multi_language_for_application_context = Rule()

####################
 # RULE restrict_multi_language_for_assembly_component_usage_substitute #
####################
restrict_multi_language_for_assembly_component_usage_substitute = Rule()

####################
 # RULE restrict_properties_of_document_representation #
####################
restrict_properties_of_document_representation = Rule()

####################
 # RULE security_classification_requires_security_classification_assignment #
####################
security_classification_requires_security_classification_assignment = Rule()

####################
 # RULE dependent_instantiable_fill_area_style_colour #
####################
dependent_instantiable_fill_area_style_colour = Rule()

####################
 # RULE dependent_instantiable_uncertainty_qualifier #
####################
dependent_instantiable_uncertainty_qualifier = Rule()

####################
 # RULE restrict_multi_language_for_certification #
####################
restrict_multi_language_for_certification = Rule()

####################
 # RULE restrict_multi_language_for_draughting_title #
####################
restrict_multi_language_for_draughting_title = Rule()

####################
 # RULE dependent_instantiable_product_definition_context_role #
####################
dependent_instantiable_product_definition_context_role = Rule()

####################
 # RULE dependent_instantiable_standard_uncertainty #
####################
dependent_instantiable_standard_uncertainty = Rule()

####################
 # RULE product_definition_replacement_requires_effectivity_assignment #
####################
product_definition_replacement_requires_effectivity_assignment = Rule()

####################
 # RULE restrict_name_assignment_for_kinematic_joint #
####################
restrict_name_assignment_for_kinematic_joint = Rule()

####################
 # RULE restrict_multi_language_for_group #
####################
restrict_multi_language_for_group = Rule()

####################
 # RULE dependent_instantiable_type_qualifier #
####################
dependent_instantiable_type_qualifier = Rule()

####################
 # RULE subtype_mandatory_configurable_item #
####################
subtype_mandatory_configurable_item = Rule()

####################
 # RULE restrict_multi_language_for_product_concept_feature #
####################
restrict_multi_language_for_product_concept_feature = Rule()

####################
 # RULE dependent_instantiable_identification_role #
####################
dependent_instantiable_identification_role = Rule()

####################
 # RULE restrict_product_categories_for_tool_part_relationship #
####################
restrict_product_categories_for_tool_part_relationship = Rule()

####################
 # RULE restrict_effectivity_usage #
####################
restrict_effectivity_usage = Rule()

####################
 # RULE restrict_multi_language_for_organizational_project_relationship #
####################
restrict_multi_language_for_organizational_project_relationship = Rule()

####################
 # RULE dependent_instantiable_date_time_role #
####################
dependent_instantiable_date_time_role = Rule()

####################
 # RULE dependent_instantiable_date_role #
####################
dependent_instantiable_date_role = Rule()

####################
 # RULE subtype_exclusiveness_colour #
####################
subtype_exclusiveness_colour = Rule()

####################
 # RULE subtype_exclusiveness_shape_representation_geometry #
####################
subtype_exclusiveness_shape_representation_geometry = Rule()

####################
 # RULE dependent_instantiable_text_style #
####################
dependent_instantiable_text_style = Rule()

####################
 # RULE dimensionality_is_two_or_three #
####################
dimensionality_is_two_or_three = Rule()

####################
 # RULE restrict_multi_language_for_product_definition #
####################
restrict_multi_language_for_product_definition = Rule()

####################
 # RULE subtype_exclusiveness_classification_assignment #
####################
subtype_exclusiveness_classification_assignment = Rule()

####################
 # RULE approval_person_organization_requires_date_time #
####################
approval_person_organization_requires_date_time = Rule()

####################
 # RULE restrict_group_relationship_for_general_classification_hierarchy #
####################
restrict_group_relationship_for_general_classification_hierarchy = Rule()

####################
 # RULE subtype_exclusiveness_shape_aspect #
####################
subtype_exclusiveness_shape_aspect = Rule()

####################
 # RULE event_occurrence_requires_event_occurrence_assignment #
####################
event_occurrence_requires_event_occurrence_assignment = Rule()

####################
 # RULE restrict_multi_language_for_topological_representation_item #
####################
restrict_multi_language_for_topological_representation_item = Rule()

####################
 # RULE subtype_exclusiveness_property_definition #
####################
subtype_exclusiveness_property_definition = Rule()

####################
 # RULE subtype_exclusiveness_pre_defined_item #
####################
subtype_exclusiveness_pre_defined_item = Rule()

####################
 # RULE restrict_multi_language_for_effectivity_relationship #
####################
restrict_multi_language_for_effectivity_relationship = Rule()

####################
 # RULE restrict_multi_language_for_action #
####################
restrict_multi_language_for_action = Rule()

####################
 # RULE restrict_multi_language_for_name_assignment #
####################
restrict_multi_language_for_name_assignment = Rule()

####################
 # RULE restrict_version_assignment_for_general_property #
####################
restrict_version_assignment_for_general_property = Rule()

####################
 # RULE restrict_multi_language_for_shape_aspect_relationship #
####################
restrict_multi_language_for_shape_aspect_relationship = Rule()

####################
 # RULE subtype_mandatory_pre_defined_item #
####################
subtype_mandatory_pre_defined_item = Rule()

####################
 # RULE restrict_applied_classification_assignment_role #
####################
restrict_applied_classification_assignment_role = Rule()

####################
 # RULE dependent_instantiable_event_occurrence_role #
####################
dependent_instantiable_event_occurrence_role = Rule()

####################
 # RULE full_model_change_completeness_for_action_property #
####################
full_model_change_completeness_for_action_property = Rule()

####################
 # RULE restrict_multi_language_for_external_source #
####################
restrict_multi_language_for_external_source = Rule()

####################
 # RULE restrict_multi_language_for_general_property_relationship #
####################
restrict_multi_language_for_general_property_relationship = Rule()

####################
 # RULE restrict_multi_language_for_general_property #
####################
restrict_multi_language_for_general_property = Rule()

####################
 # RULE restrict_multi_language_for_product #
####################
restrict_multi_language_for_product = Rule()

####################
 # RULE restrict_treatment_result #
####################
restrict_treatment_result = Rule()

####################
 # RULE dependent_instantiable_organizational_project_role #
####################
dependent_instantiable_organizational_project_role = Rule()

####################
 # RULE compound_features_of_equal_type #
####################
compound_features_of_equal_type = Rule()

####################
 # RULE restrict_product_definition_context_for_product #
####################
restrict_product_definition_context_for_product = Rule()

####################
 # RULE restrict_concept_feature_operator #
####################
restrict_concept_feature_operator = Rule()

####################
 # RULE dependent_instantiable_presentation_style_by_context #
####################
dependent_instantiable_presentation_style_by_context = Rule()

####################
 # RULE dependent_instantiable_pre_defined_symbol #
####################
dependent_instantiable_pre_defined_symbol = Rule()

####################
 # RULE restrict_version_assignment_for_action #
####################
restrict_version_assignment_for_action = Rule()

####################
 # RULE restrict_multi_language_for_resource_property #
####################
restrict_multi_language_for_resource_property = Rule()

####################
 # RULE physical_instance_requires_product_definition #
####################
physical_instance_requires_product_definition = Rule()

####################
 # RULE restrict_part_occurrence #
####################
restrict_part_occurrence = Rule()

####################
 # RULE restrict_default_settings #
####################
restrict_default_settings = Rule()

####################
 # RULE dependent_instantiable_symbol_colour #
####################
dependent_instantiable_symbol_colour = Rule()

####################
 # RULE design_constraint_requires_product_definition #
####################
design_constraint_requires_product_definition = Rule()

####################
 # RULE draughting_subfigure_representation_layers #
####################
draughting_subfigure_representation_layers = Rule()

####################
 # RULE restrict_multi_language_for_descriptive_representation_item #
####################
restrict_multi_language_for_descriptive_representation_item = Rule()

####################
 # RULE restrict_drawing #
####################
restrict_drawing = Rule()

####################
 # RULE full_model_change_completeness_for_property_definition #
####################
full_model_change_completeness_for_property_definition = Rule()

####################
 # RULE restrict_multi_language_for_process_product_association #
####################
restrict_multi_language_for_process_product_association = Rule()

####################
 # RULE dependent_instantiable_classification_role #
####################
dependent_instantiable_classification_role = Rule()

####################
 # RULE dependent_instantiable_derived_unit #
####################
dependent_instantiable_derived_unit = Rule()

####################
 # RULE subtype_exclusiveness_feature_component_relationship #
####################
subtype_exclusiveness_feature_component_relationship = Rule()

####################
 # RULE restrict_multi_language_for_resource_requirement_type #
####################
restrict_multi_language_for_resource_requirement_type = Rule()

####################
 # RULE restrict_product_definition_substitute #
####################
restrict_product_definition_substitute = Rule()

####################
 # RULE restrict_version_assignment_for_effectivity #
####################
restrict_version_assignment_for_effectivity = Rule()

####################
 # RULE dependent_instantiable_tolerance_value #
####################
dependent_instantiable_tolerance_value = Rule()

####################
 # RULE externally_defined_class_with_known_source_requirement #
####################
externally_defined_class_with_known_source_requirement = Rule()

####################
 # RULE restrict_default_thickness #
####################
restrict_default_thickness = Rule()

####################
 # RULE dependent_instantiable_action_directive #
####################
dependent_instantiable_action_directive = Rule()

####################
 # RULE subtype_exclusiveness_characterized_object #
####################
subtype_exclusiveness_characterized_object = Rule()

####################
 # RULE restrict_product_definition_context_for_external_properties #
####################
restrict_product_definition_context_for_external_properties = Rule()

####################
 # RULE drawing_sheet_layout_usage #
####################
drawing_sheet_layout_usage = Rule()

####################
 # RULE restrict_representation_for_document_properties #
####################
restrict_representation_for_document_properties = Rule()

####################
 # RULE plib_property_reference_requires_name_scope #
####################
plib_property_reference_requires_name_scope = Rule()

####################
 # RULE global_length_and_angle_units_2d_or_3d #
####################
global_length_and_angle_units_2d_or_3d = Rule()

####################
 # RULE subtype_exclusiveness_group #
####################
subtype_exclusiveness_group = Rule()

####################
 # RULE dependent_instantiable_action_resource_type #
####################
dependent_instantiable_action_resource_type = Rule()

####################
 # RULE dependent_instantiable_organization_role #
####################
dependent_instantiable_organization_role = Rule()

####################
 # RULE restrict_multi_language_for_date_role #
####################
restrict_multi_language_for_date_role = Rule()

####################
 # RULE restrict_multi_language_for_shape_aspect #
####################
restrict_multi_language_for_shape_aspect = Rule()

####################
 # RULE restrict_effectivity_assignment_for_class_category_usage #
####################
restrict_effectivity_assignment_for_class_category_usage = Rule()

####################
 # RULE dependent_instantiable_contract_type #
####################
dependent_instantiable_contract_type = Rule()

####################
 # RULE restrict_product_category_for_product #
####################
restrict_product_category_for_product = Rule()

####################
 # RULE styled_curve #
####################
styled_curve = Rule()

####################
 # RULE restrict_action_resource_requirement_for_process_operation #
####################
restrict_action_resource_requirement_for_process_operation = Rule()

####################
 # RULE subtype_exclusiveness_representation_item #
####################
subtype_exclusiveness_representation_item = Rule()

####################
 # RULE dependent_instantiable_effectivity_context_role #
####################
dependent_instantiable_effectivity_context_role = Rule()

####################
 # RULE plib_class_reference_requires_version #
####################
plib_class_reference_requires_version = Rule()

####################
 # RULE restrict_version_assignment_for_shape_representation #
####################
restrict_version_assignment_for_shape_representation = Rule()

####################
 # RULE subtype_exclusiveness_founded_item #
####################
subtype_exclusiveness_founded_item = Rule()

####################
 # RULE text_font_usage #
####################
text_font_usage = Rule()

####################
 # RULE subtype_exclusiveness_representation_map #
####################
subtype_exclusiveness_representation_map = Rule()

####################
 # RULE subtype_mandatory_pre_defined_symbol #
####################
subtype_mandatory_pre_defined_symbol = Rule()

####################
 # RULE restrict_class_system_assignment_for_security_classification_level #
####################
restrict_class_system_assignment_for_security_classification_level = Rule()

####################
 # RULE restrict_multi_language_for_action_directive #
####################
restrict_multi_language_for_action_directive = Rule()

####################
 # RULE subtype_mandatory_address #
####################
subtype_mandatory_address = Rule()

####################
 # RULE dependent_instantiable_document_usage_role #
####################
dependent_instantiable_document_usage_role = Rule()

####################
 # RULE dependent_instantiable_text_style_for_defined_font #
####################
dependent_instantiable_text_style_for_defined_font = Rule()

####################
 # RULE restrict_multi_language_for_product_concept_feature_association #
####################
restrict_multi_language_for_product_concept_feature_association = Rule()

####################
 # RULE subtype_exclusiveness_representation_relationship_with_transformation #
####################
subtype_exclusiveness_representation_relationship_with_transformation = Rule()

####################
 # RULE subtype_mandatory_colour_specification #
####################
subtype_mandatory_colour_specification = Rule()

####################
 # RULE restrict_name_assignment_for_kinematic_structure #
####################
restrict_name_assignment_for_kinematic_structure = Rule()

####################
 # RULE restrict_representation_for_document_size_property #
####################
restrict_representation_for_document_size_property = Rule()

####################
 # RULE subtype_exclusiveness_presentation_representation #
####################
subtype_exclusiveness_presentation_representation = Rule()

####################
 # RULE restrict_version_assignment_for_product_concept #
####################
restrict_version_assignment_for_product_concept = Rule()

####################
 # RULE fill_area_style_tile_symbol_constraint #
####################
fill_area_style_tile_symbol_constraint = Rule()

####################
 # RULE restrict_multi_language_for_property_definition_relationship #
####################
restrict_multi_language_for_property_definition_relationship = Rule()

####################
 # RULE subtype_exclusiveness_compound_representation_item #
####################
subtype_exclusiveness_compound_representation_item = Rule()

####################
 # RULE subtype_mandatory_pre_defined_curve_font #
####################
subtype_mandatory_pre_defined_curve_font = Rule()

####################
 # RULE dependent_instantiable_measure_with_unit #
####################
dependent_instantiable_measure_with_unit = Rule()

####################
 # RULE restrict_representation_for_document_creation_property #
####################
restrict_representation_for_document_creation_property = Rule()

####################
 # RULE dependent_instantiable_colour_rgb #
####################
dependent_instantiable_colour_rgb = Rule()

####################
 # RULE restrict_multi_language_for_mapped_item #
####################
restrict_multi_language_for_mapped_item = Rule()

####################
 # RULE restrict_multi_language_for_presentation_layer_assignment #
####################
restrict_multi_language_for_presentation_layer_assignment = Rule()

####################
 # RULE restrict_multi_language_for_product_concept_relationship #
####################
restrict_multi_language_for_product_concept_relationship = Rule()

####################
 # RULE restrict_multi_language_for_versioned_action_request #
####################
restrict_multi_language_for_versioned_action_request = Rule()

####################
 # RULE dependent_instantiable_date #
####################
dependent_instantiable_date = Rule()

####################
 # RULE restrict_version_assignment_for_configuration_item #
####################
restrict_version_assignment_for_configuration_item = Rule()

####################
 # RULE restrict_representation_item_for_hybrid_geometric_model_3d #
####################
restrict_representation_item_for_hybrid_geometric_model_3d = Rule()

####################
 # RULE restrict_multi_language_for_contract #
####################
restrict_multi_language_for_contract = Rule()

####################
 # RULE restrict_multi_language_for_configuration_design #
####################
restrict_multi_language_for_configuration_design = Rule()

####################
 # RULE subtype_exclusiveness_document_reference #
####################
subtype_exclusiveness_document_reference = Rule()

####################
 # RULE restrict_multi_language_for_versioned_action_request_relationship #
####################
restrict_multi_language_for_versioned_action_request_relationship = Rule()

####################
 # RULE restrict_version_assignment_for_draughting_model #
####################
restrict_version_assignment_for_draughting_model = Rule()

####################
 # RULE subtype_exclusiveness_shape_aspect_relationship #
####################
subtype_exclusiveness_shape_aspect_relationship = Rule()

####################
 # RULE dependent_instantiable_precision_qualifier #
####################
dependent_instantiable_precision_qualifier = Rule()

####################
 # RULE restrict_approval #
####################
restrict_approval = Rule()

####################
 # RULE subtype_mandatory_document_product_association #
####################
subtype_mandatory_document_product_association = Rule()

####################
 # RULE restrict_group_relationship_for_specification_category #
####################
restrict_group_relationship_for_specification_category = Rule()

####################
 # RULE restrict_multi_language_for_product_concept #
####################
restrict_multi_language_for_product_concept = Rule()

####################
 # RULE restrict_multi_language_for_uncertainty_qualifier #
####################
restrict_multi_language_for_uncertainty_qualifier = Rule()

####################
 # RULE restrict_externally_defined_item_relationship #
####################
restrict_externally_defined_item_relationship = Rule()

####################
 # RULE restrict_representation_for_surface_condition #
####################
restrict_representation_for_surface_condition = Rule()

####################
 # RULE subtype_mandatory_camera_model #
####################
subtype_mandatory_camera_model = Rule()

####################
 # RULE restrict_applied_action_request_assignment #
####################
restrict_applied_action_request_assignment = Rule()

####################
 # RULE restrict_version_assignment_for_product_concept_feature #
####################
restrict_version_assignment_for_product_concept_feature = Rule()

####################
 # RULE subtype_exclusiveness_property_definition_representation #
####################
subtype_exclusiveness_property_definition_representation = Rule()

####################
 # RULE subtype_exclusiveness_representation_relationship #
####################
subtype_exclusiveness_representation_relationship = Rule()

####################
 # RULE sheets_belong_to_one_drawing #
####################
sheets_belong_to_one_drawing = Rule()

####################
 # RULE restrict_multi_language_for_representation_relationship #
####################
restrict_multi_language_for_representation_relationship = Rule()

####################
 # RULE dependent_instantiable_approval_role #
####################
dependent_instantiable_approval_role = Rule()

####################
 # RULE restrict_version_assignment_for_class #
####################
restrict_version_assignment_for_class = Rule()

####################
 # RULE subtype_exclusiveness_externally_defined_item #
####################
subtype_exclusiveness_externally_defined_item = Rule()

####################
 # RULE complex_product_requires_product_definition #
####################
complex_product_requires_product_definition = Rule()

####################
 # RULE restrict_multi_language_for_styled_item #
####################
restrict_multi_language_for_styled_item = Rule()

####################
 # RULE subtype_exclusiveness_transition_feature #
####################
subtype_exclusiveness_transition_feature = Rule()

####################
 # RULE restrict_properties_of_document_file #
####################
restrict_properties_of_document_file = Rule()

####################
 # RULE restrict_class_system_assignment_for_descriptive_representation_item #
####################
restrict_class_system_assignment_for_descriptive_representation_item = Rule()

####################
 # RULE restrict_representation_for_document_format_property #
####################
restrict_representation_for_document_format_property = Rule()

####################
 # RULE dependent_instantiable_object_role #
####################
dependent_instantiable_object_role = Rule()

####################
 # RULE restrict_applied_organizational_project_assignment #
####################
restrict_applied_organizational_project_assignment = Rule()

####################
 # RULE restrict_multi_language_for_group_relationship #
####################
restrict_multi_language_for_group_relationship = Rule()

####################
 # RULE dependent_instantiable_attribute_value_role #
####################
dependent_instantiable_attribute_value_role = Rule()

####################
 # RULE drawing_view_annotation_layers #
####################
drawing_view_annotation_layers = Rule()

####################
 # RULE subtype_mandatory_geometric_tolerance #
####################
subtype_mandatory_geometric_tolerance = Rule()

####################
 # RULE product_concept_feature_requires_category #
####################
product_concept_feature_requires_category = Rule()

####################
 # RULE restrict_version_assignment_for_presentation_area #
####################
restrict_version_assignment_for_presentation_area = Rule()

####################
 # RULE terminator_symbol_constraint #
####################
terminator_symbol_constraint = Rule()

####################
 # RULE dependent_instantiable_pre_defined_colour #
####################
dependent_instantiable_pre_defined_colour = Rule()

####################
 # RULE restrict_multi_language_for_event_occurrence #
####################
restrict_multi_language_for_event_occurrence = Rule()

####################
 # RULE restrict_effectivity_for_effectivity_relationship #
####################
restrict_effectivity_for_effectivity_relationship = Rule()

####################
 # RULE restrict_applied_event_occurrence_assignment #
####################
restrict_applied_event_occurrence_assignment = Rule()

####################
 # RULE restrict_applied_action_assignment #
####################
restrict_applied_action_assignment = Rule()

####################
 # RULE presentation_view_presented_once #
####################
presentation_view_presented_once = Rule()

####################
 # RULE dependent_instantiable_resource_requirement_type #
####################
dependent_instantiable_resource_requirement_type = Rule()

####################
 # RULE restrict_multi_language_for_geometric_representation_item #
####################
restrict_multi_language_for_geometric_representation_item = Rule()

####################
 # RULE coordinated_assembly_and_shape #
####################
coordinated_assembly_and_shape = Rule()

####################
 # RULE restrict_multi_language_for_date_time_role #
####################
restrict_multi_language_for_date_time_role = Rule()

####################
 # RULE restrict_multi_language_for_requirement_for_action_resource #
####################
restrict_multi_language_for_requirement_for_action_resource = Rule()

####################
 # RULE restrict_version_assignment_for_applied_identification_assignment #
####################
restrict_version_assignment_for_applied_identification_assignment = Rule()

####################
 # RULE approval_requires_approval_assignment #
####################
approval_requires_approval_assignment = Rule()

####################
 # RULE plib_property_reference_requires_version #
####################
plib_property_reference_requires_version = Rule()

####################
 # RULE restrict_version_assignment_for_action_method #
####################
restrict_version_assignment_for_action_method = Rule()

####################
 # RULE dependent_instantiable_fill_area_style #
####################
dependent_instantiable_fill_area_style = Rule()

####################
 # RULE subtype_exclusiveness_representation #
####################
subtype_exclusiveness_representation = Rule()

####################
 # RULE product_requires_category #
####################
product_requires_category = Rule()

####################
 # RULE subtype_mandatory_camera_image #
####################
subtype_mandatory_camera_image = Rule()

####################
 # RULE presentation_layer_assignment_constraint_2d_or_3d #
####################
presentation_layer_assignment_constraint_2d_or_3d = Rule()

####################
 # RULE restrict_class_system_assignment_for_approval_status #
####################
restrict_class_system_assignment_for_approval_status = Rule()

####################
 # RULE restrict_name_for_known_source #
####################
restrict_name_for_known_source = Rule()

####################
 # RULE dependent_instantiable_externally_defined_symbol #
####################
dependent_instantiable_externally_defined_symbol = Rule()

####################
 # RULE restrict_class_system_assignment_for_document_type #
####################
restrict_class_system_assignment_for_document_type = Rule()

####################
 # RULE restrict_multi_language_for_data_environment #
####################
restrict_multi_language_for_data_environment = Rule()
