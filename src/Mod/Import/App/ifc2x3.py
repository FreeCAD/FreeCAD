# This file was generated by fedex_python.  You probably don't want to edit
# it since your modifications will be lost if fedex_plus is used to
# regenerate it.
import sys

from SCL.SCLBase import *
from SCL.SimpleDataTypes import *
from SCL.ConstructedDataTypes import *
from SCL.AggregationDataTypes import *
from SCL.TypeChecker import check_type
from SCL.Builtin import *
from SCL.Rules import *

schema_name = 'ifc2x3'

schema_scope = sys.modules[__name__]

# Defined datatype ifcstructuralsurfacetypeenum
class ifcstructuralsurfacetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcloadgrouptypeenum
class ifcloadgrouptypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmodulusoflinearsubgradereactionmeasure
class ifcmodulusoflinearsubgradereactionmeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifchatchlinedistanceselect
ifchatchlinedistanceselect = SELECT(
	'ifconedirectionrepeatfactor',
	'ifcpositivelengthmeasure',
	scope = schema_scope)
# SELECT TYPE ifcshell
ifcshell = SELECT(
	'ifcclosedshell',
	'ifcopenshell',
	scope = schema_scope)
# Defined datatype ifcprotectivedevicetypeenum
class ifcprotectivedevicetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclinearforcemeasure
class ifclinearforcemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcassemblyplaceenum
class ifcassemblyplaceenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcroleenum
class ifcroleenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcribplatedirectionenum
class ifcribplatedirectionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsoundpowermeasure
class ifcsoundpowermeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsiunitname
class ifcsiunitname(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcairtoairheatrecoverytypeenum
class ifcairtoairheatrecoverytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcanalysistheorytypeenum
class ifcanalysistheorytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcchangeactionenum
class ifcchangeactionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdoorpaneloperationenum
class ifcdoorpaneloperationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwindowpaneloperationenum
class ifcwindowpaneloperationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcslabtypeenum
class ifcslabtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricconductancemeasure
class ifcelectricconductancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifckinematicviscositymeasure
class ifckinematicviscositymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclinearvelocitymeasure
class ifclinearvelocitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctimemeasure
class ifctimemeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcfillstyleselect
ifcfillstyleselect = SELECT(
	'ifcfillareastylehatching',
	'ifcfillareastyletiles',
	'ifccolour',
	'ifcexternallydefinedhatchstyle',
	scope = schema_scope)
# SELECT TYPE ifcstructuralactivityassignmentselect
ifcstructuralactivityassignmentselect = SELECT(
	'ifcstructuralitem',
	'ifcelement',
	scope = schema_scope)
# Defined datatype ifcreflectancemethodenum
class ifcreflectancemethodenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctransformertypeenum
class ifctransformertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccsgselect
ifccsgselect = SELECT(
	'ifcbooleanresult',
	'ifccsgprimitive3d',
	scope = schema_scope)
# SELECT TYPE ifcmaterialselect
ifcmaterialselect = SELECT(
	'ifcmaterial',
	'ifcmateriallist',
	'ifcmateriallayersetusage',
	'ifcmateriallayerset',
	'ifcmateriallayer',
	scope = schema_scope)
# SELECT TYPE ifcdraughtingcalloutelement
ifcdraughtingcalloutelement = SELECT(
	'ifcannotationcurveoccurrence',
	'ifcannotationtextoccurrence',
	'ifcannotationsymboloccurrence',
	scope = schema_scope)
# Defined datatype ifcelectriccapacitancemeasure
class ifcelectriccapacitancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfrequencymeasure
class ifcfrequencymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcidentifier
class ifcidentifier(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdirectionsenseenum
class ifcdirectionsenseenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcvalue
ifcvalue = SELECT(
	'ifcmeasurevalue',
	'ifcsimplevalue',
	'ifcderivedmeasurevalue',
	scope = schema_scope)
# Defined datatype ifcductsilencertypeenum
class ifcductsilencertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclabel
class ifclabel(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcactionsourcetypeenum
class ifcactionsourcetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctendontypeenum
class ifctendontypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpressuremeasure
class ifcpressuremeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctransitioncode
class ifctransitioncode(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcenvironmentalimpactcategoryenum
class ifcenvironmentalimpactcategoryenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctextalignment
class ifctextalignment(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['left','right','center','justify'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcthermalresistancemeasure
class ifcthermalresistancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricmotortypeenum
class ifcelectricmotortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctanktypeenum
class ifctanktypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcforcemeasure
class ifcforcemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcheatexchangertypeenum
class ifcheatexchangertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccoiltypeenum
class ifccoiltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcrotationalmassmeasure
class ifcrotationalmassmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectriccurrentenum
class ifcelectriccurrentenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctimeseriesscheduletypeenum
class ifctimeseriesscheduletypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsectionalareaintegralmeasure
class ifcsectionalareaintegralmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclengthmeasure
class ifclengthmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwindowpanelpositionenum
class ifcwindowpanelpositionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcluminousintensitydistributionmeasure
class ifcluminousintensitydistributionmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcrotationalstiffnessmeasure
class ifcrotationalstiffnessmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcanalysismodeltypeenum
class ifcanalysismodeltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsoundpressuremeasure
class ifcsoundpressuremeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccolour
ifccolour = SELECT(
	'ifccolourspecification',
	'ifcpredefinedcolour',
	scope = schema_scope)
# Defined datatype ifcspecularroughness
class ifcspecularroughness(REAL):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE ifcappliedvalueselect
ifcappliedvalueselect = SELECT(
	'ifcratiomeasure',
	'ifcmeasurewithunit',
	'ifcmonetarymeasure',
	scope = schema_scope)
# SELECT TYPE ifcclassificationnotationselect
ifcclassificationnotationselect = SELECT(
	'ifcclassificationnotation',
	'ifcclassificationreference',
	scope = schema_scope)
# Defined datatype ifcproceduretypeenum
class ifcproceduretypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcheatingvaluemeasure
class ifcheatingvaluemeasure(REAL):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcinductancemeasure
class ifcinductancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccurtainwalltypeenum
class ifccurtainwalltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmassperlengthmeasure
class ifcmassperlengthmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcthermalloadsourceenum
class ifcthermalloadsourceenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifctextstyleselect
ifctextstyleselect = SELECT(
	'ifctextstylewithboxcharacteristics',
	'ifctextstyletextmodel',
	scope = schema_scope)
# Defined datatype ifctexttransformation
class ifctexttransformation(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['capitalize','uppercase','lowercase','none'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcactuatortypeenum
class ifcactuatortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifchumidifiertypeenum
class ifchumidifiertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcconnectiontypeenum
class ifcconnectiontypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccontrollertypeenum
class ifccontrollertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricgeneratortypeenum
class ifcelectricgeneratortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwasteterminaltypeenum
class ifcwasteterminaltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcshearmodulusmeasure
class ifcshearmodulusmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclamptypeenum
class ifclamptypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcpresentationstyleselect
ifcpresentationstyleselect = SELECT(
	'ifcnullstyle',
	'ifccurvestyle',
	'ifcsymbolstyle',
	'ifcfillareastyle',
	'ifctextstyle',
	'ifcsurfacestyle',
	scope = schema_scope)
# Defined datatype ifcintegercountratemeasure
class ifcintegercountratemeasure(INTEGER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcaddresstypeenum
class ifcaddresstypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcbenchmarkenum
class ifcbenchmarkenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcoccupanttypeenum
class ifcoccupanttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmassdensitymeasure
class ifcmassdensitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccablecarriersegmenttypeenum
class ifccablecarriersegmenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifclightdistributiondatasourceselect
ifclightdistributiondatasourceselect = SELECT(
	'ifcexternalreference',
	'ifclightintensitydistribution',
	scope = schema_scope)
# SELECT TYPE ifcunit
ifcunit = SELECT(
	'ifcderivedunit',
	'ifcnamedunit',
	'ifcmonetaryunit',
	scope = schema_scope)
# Defined datatype ifcmodulusofelasticitymeasure
class ifcmodulusofelasticitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcairterminaltypeenum
class ifcairterminaltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcpointorvertexpoint
ifcpointorvertexpoint = SELECT(
	'ifcpoint',
	'ifcvertexpoint',
	scope = schema_scope)
# Defined datatype ifctransportelementtypeenum
class ifctransportelementtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelementassemblytypeenum
class ifcelementassemblytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdocumentstatusenum
class ifcdocumentstatusenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccurvefontorscaledcurvefontselect
ifccurvefontorscaledcurvefontselect = SELECT(
	'ifccurvestylefontselect',
	'ifccurvestylefontandscaling',
	scope = schema_scope)
# Defined datatype ifcspecularexponent
class ifcspecularexponent(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifctextfontselect
ifctextfontselect = SELECT(
	'ifcpredefinedtextfont',
	'ifcexternallydefinedtextfont',
	scope = schema_scope)
# Defined datatype ifcactiontypeenum
class ifcactiontypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdynamicviscositymeasure
class ifcdynamicviscositymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclightemissionsourceenum
class ifclightemissionsourceenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcvolumemeasure
class ifcvolumemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcnullstyle
class ifcnullstyle(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcluminousintensitymeasure
class ifcluminousintensitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmodulusofrotationalsubgradereactionmeasure
class ifcmodulusofrotationalsubgradereactionmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcspaceheatertypeenum
class ifcspaceheatertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpiletypeenum
class ifcpiletypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcstackterminaltypeenum
class ifcstackterminaltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfiltertypeenum
class ifcfiltertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcprojectorderrecordtypeenum
class ifcprojectorderrecordtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcabsorbeddosemeasure
class ifcabsorbeddosemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclightdistributioncurveenum
class ifclightdistributioncurveenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcmetricvalueselect
ifcmetricvalueselect = SELECT(
	'ifcdatetimeselect',
	'ifcmeasurewithunit',
	'ifctable',
	'ifctext',
	'ifctimeseries',
	'ifccostvalue',
	scope = schema_scope)
# Defined datatype ifcobjecttypeenum
class ifcobjecttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfantypeenum
class ifcfantypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcgeometricprojectionenum
class ifcgeometricprojectionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctrimmingpreference
class ifctrimmingpreference(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcinternalorexternalenum
class ifcinternalorexternalenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcthermodynamictemperaturemeasure
class ifcthermodynamictemperaturemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsurfaceside
class ifcsurfaceside(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricvoltagemeasure
class ifcelectricvoltagemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwindowstyleconstructionenum
class ifcwindowstyleconstructionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcductfittingtypeenum
class ifcductfittingtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctubebundletypeenum
class ifctubebundletypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccountmeasure
class ifccountmeasure(NUMBER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcrailingtypeenum
class ifcrailingtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcswitchingdevicetypeenum
class ifcswitchingdevicetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcaccelerationmeasure
class ifcaccelerationmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccurvaturemeasure
class ifccurvaturemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcplaneanglemeasure
class ifcplaneanglemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricheatertypeenum
class ifcelectricheatertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcsurfaceorfacesurface
ifcsurfaceorfacesurface = SELECT(
	'ifcsurface',
	'ifcfacesurface',
	'ifcfacebasedsurfacemodel',
	scope = schema_scope)
# Defined datatype ifclogicaloperatorenum
class ifclogicaloperatorenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcmeasurevalue
ifcmeasurevalue = SELECT(
	'ifcvolumemeasure',
	'ifctimemeasure',
	'ifcthermodynamictemperaturemeasure',
	'ifcsolidanglemeasure',
	'ifcpositiveratiomeasure',
	'ifcratiomeasure',
	'ifcpositiveplaneanglemeasure',
	'ifcplaneanglemeasure',
	'ifcparametervalue',
	'ifcnumericmeasure',
	'ifcmassmeasure',
	'ifcpositivelengthmeasure',
	'ifclengthmeasure',
	'ifcelectriccurrentmeasure',
	'ifcdescriptivemeasure',
	'ifccountmeasure',
	'ifccontextdependentmeasure',
	'ifcareameasure',
	'ifcamountofsubstancemeasure',
	'ifcluminousintensitymeasure',
	'ifcnormalisedratiomeasure',
	'ifccomplexnumber',
	scope = schema_scope)
# SELECT TYPE ifclibraryselect
ifclibraryselect = SELECT(
	'ifclibraryreference',
	'ifclibraryinformation',
	scope = schema_scope)
# Defined datatype ifcparametervalue
class ifcparametervalue(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcthermalconductivitymeasure
class ifcthermalconductivitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcgasterminaltypeenum
class ifcgasterminaltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsectiontypeenum
class ifcsectiontypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcplanarforcemeasure
class ifcplanarforcemeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcgeometricsetselect
ifcgeometricsetselect = SELECT(
	'ifcpoint',
	'ifccurve',
	'ifcsurface',
	scope = schema_scope)
# Defined datatype ifcareameasure
class ifcareameasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccontextdependentmeasure
class ifccontextdependentmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctextfontname
class ifctextfontname(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclogical
class ifclogical(LOGICAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcorientationselect
ifcorientationselect = SELECT(
	'ifcplaneanglemeasure',
	'ifcdirection',
	scope = schema_scope)
# Defined datatype ifcthermaladmittancemeasure
class ifcthermaladmittancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcspacetypeenum
class ifcspacetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdoseequivalentmeasure
class ifcdoseequivalentmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmolecularweightmeasure
class ifcmolecularweightmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcenergysequenceenum
class ifcenergysequenceenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcobjectreferenceselect
ifcobjectreferenceselect = SELECT(
	'ifcmaterial',
	'ifcperson',
	'ifcdateandtime',
	'ifcmateriallist',
	'ifcorganization',
	'ifccalendardate',
	'ifclocaltime',
	'ifcpersonandorganization',
	'ifcmateriallayer',
	'ifcexternalreference',
	'ifctimeseries',
	'ifcaddress',
	'ifcappliedvalue',
	scope = schema_scope)
# Defined datatype ifcpowermeasure
class ifcpowermeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccurveoredgecurve
ifccurveoredgecurve = SELECT(
	'ifcboundedcurve',
	'ifcedgecurve',
	scope = schema_scope)
# Defined datatype ifccoveringtypeenum
class ifccoveringtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcunitaryequipmenttypeenum
class ifcunitaryequipmenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcaxis2placement
ifcaxis2placement = SELECT(
	'ifcaxis2placement2d',
	'ifcaxis2placement3d',
	scope = schema_scope)
# Defined datatype ifcbooleanoperator
class ifcbooleanoperator(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccostscheduletypeenum
class ifccostscheduletypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpileconstructionenum
class ifcpileconstructionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcderivedunitenum
class ifcderivedunitenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricflowstoragedevicetypeenum
class ifcelectricflowstoragedevicetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclightfixturetypeenum
class ifclightfixturetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfontstyle
class ifcfontstyle(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['normal','italic','oblique'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE ifctrimmingselect
ifctrimmingselect = SELECT(
	'ifccartesianpoint',
	'ifcparametervalue',
	scope = schema_scope)
# Defined datatype ifcamountofsubstancemeasure
class ifcamountofsubstancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcsizeselect
ifcsizeselect = SELECT(
	'ifcratiomeasure',
	'ifclengthmeasure',
	'ifcdescriptivemeasure',
	'ifcpositivelengthmeasure',
	'ifcnormalisedratiomeasure',
	'ifcpositiveratiomeasure',
	scope = schema_scope)
# Defined datatype ifcbeamtypeenum
class ifcbeamtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccharacterstyleselect
ifccharacterstyleselect = SELECT(
	'ifctextstylefordefinedfont',
	scope = schema_scope)
# Defined datatype ifcpropertysourceenum
class ifcpropertysourceenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsoundscaleenum
class ifcsoundscaleenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpumptypeenum
class ifcpumptypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcboxalignment
class ifcboxalignment(ifclabel):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['top-left','top-middle','top-right','middle-left','center','middle-right','bottom-left','bottom-middle','bottom-right'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcelectricchargemeasure
class ifcelectricchargemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcminuteinhour
class ifcminuteinhour(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <=  59))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcinventorytypeenum
class ifcinventorytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwarpingmomentmeasure
class ifcwarpingmomentmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcresourceconsumptionenum
class ifcresourceconsumptionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctext
class ifctext(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcairterminalboxtypeenum
class ifcairterminalboxtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcderivedmeasurevalue
ifcderivedmeasurevalue = SELECT(
	'ifcvolumetricflowratemeasure',
	'ifctimestamp',
	'ifcthermaltransmittancemeasure',
	'ifcthermalresistancemeasure',
	'ifcthermaladmittancemeasure',
	'ifcpressuremeasure',
	'ifcpowermeasure',
	'ifcmassflowratemeasure',
	'ifcmassdensitymeasure',
	'ifclinearvelocitymeasure',
	'ifckinematicviscositymeasure',
	'ifcintegercountratemeasure',
	'ifcheatfluxdensitymeasure',
	'ifcfrequencymeasure',
	'ifcenergymeasure',
	'ifcelectricvoltagemeasure',
	'ifcdynamicviscositymeasure',
	'ifccompoundplaneanglemeasure',
	'ifcangularvelocitymeasure',
	'ifcthermalconductivitymeasure',
	'ifcmolecularweightmeasure',
	'ifcvaporpermeabilitymeasure',
	'ifcmoisturediffusivitymeasure',
	'ifcisothermalmoisturecapacitymeasure',
	'ifcspecificheatcapacitymeasure',
	'ifcmonetarymeasure',
	'ifcmagneticfluxdensitymeasure',
	'ifcmagneticfluxmeasure',
	'ifcluminousfluxmeasure',
	'ifcforcemeasure',
	'ifcinductancemeasure',
	'ifcilluminancemeasure',
	'ifcelectricresistancemeasure',
	'ifcelectricconductancemeasure',
	'ifcelectricchargemeasure',
	'ifcdoseequivalentmeasure',
	'ifcelectriccapacitancemeasure',
	'ifcabsorbeddosemeasure',
	'ifcradioactivitymeasure',
	'ifcrotationalfrequencymeasure',
	'ifctorquemeasure',
	'ifcaccelerationmeasure',
	'ifclinearforcemeasure',
	'ifclinearstiffnessmeasure',
	'ifcmodulusofsubgradereactionmeasure',
	'ifcmodulusofelasticitymeasure',
	'ifcmomentofinertiameasure',
	'ifcplanarforcemeasure',
	'ifcrotationalstiffnessmeasure',
	'ifcshearmodulusmeasure',
	'ifclinearmomentmeasure',
	'ifcluminousintensitydistributionmeasure',
	'ifccurvaturemeasure',
	'ifcmassperlengthmeasure',
	'ifcmodulusoflinearsubgradereactionmeasure',
	'ifcmodulusofrotationalsubgradereactionmeasure',
	'ifcrotationalmassmeasure',
	'ifcsectionalareaintegralmeasure',
	'ifcsectionmodulusmeasure',
	'ifctemperaturegradientmeasure',
	'ifcthermalexpansioncoefficientmeasure',
	'ifcwarpingconstantmeasure',
	'ifcwarpingmomentmeasure',
	'ifcsoundpowermeasure',
	'ifcsoundpressuremeasure',
	'ifcheatingvaluemeasure',
	'ifcphmeasure',
	'ifcionconcentrationmeasure',
	scope = schema_scope)
# Defined datatype ifcreinforcingbarroleenum
class ifcreinforcingbarroleenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclinearstiffnessmeasure
class ifclinearstiffnessmeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccolourorfactor
ifccolourorfactor = SELECT(
	'ifccolourrgb',
	'ifcnormalisedratiomeasure',
	scope = schema_scope)
# SELECT TYPE ifcvectorordirection
ifcvectorordirection = SELECT(
	'ifcdirection',
	'ifcvector',
	scope = schema_scope)
# Defined datatype ifcisothermalmoisturecapacitymeasure
class ifcisothermalmoisturecapacitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricappliancetypeenum
class ifcelectricappliancetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcratiomeasure
class ifcratiomeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfootingtypeenum
class ifcfootingtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcplatetypeenum
class ifcplatetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcsimplevalue
ifcsimplevalue = SELECT(
	'ifcinteger',
	'ifcreal',
	'ifcboolean',
	'ifcidentifier',
	'ifctext',
	'ifclabel',
	'ifclogical',
	scope = schema_scope)
# Defined datatype ifcinteger
class ifcinteger(INTEGER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcthermalexpansioncoefficientmeasure
class ifcthermalexpansioncoefficientmeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcdefinedsymbolselect
ifcdefinedsymbolselect = SELECT(
	'ifcpredefinedsymbol',
	'ifcexternallydefinedsymbol',
	scope = schema_scope)
# Defined datatype ifcpositiveplaneanglemeasure
class ifcpositiveplaneanglemeasure(ifcplaneanglemeasure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifccooledbeamtypeenum
class ifccooledbeamtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcdatetimeselect
ifcdatetimeselect = SELECT(
	'ifccalendardate',
	'ifclocaltime',
	'ifcdateandtime',
	scope = schema_scope)
# Defined datatype ifcdimensioncount
class ifcdimensioncount(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <  self)  and  (self  <=  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcmassmeasure
class ifcmassmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdataoriginenum
class ifcdataoriginenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcphysicalorvirtualenum
class ifcphysicalorvirtualenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpermeablecoveringoperationenum
class ifcpermeablecoveringoperationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcstairflighttypeenum
class ifcstairflighttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcjunctionboxtypeenum
class ifcjunctionboxtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctorquemeasure
class ifctorquemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcglobalorlocalenum
class ifcglobalorlocalenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmoisturediffusivitymeasure
class ifcmoisturediffusivitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdistributionchamberelementtypeenum
class ifcdistributionchamberelementtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctextpath
class ifctextpath(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcunitenum
class ifcunitenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricdistributionpointfunctionenum
class ifcelectricdistributionpointfunctionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcvalvetypeenum
class ifcvalvetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpresentabletext
class ifcpresentabletext(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccompressortypeenum
class ifccompressortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctimeseriesdatatypeenum
class ifctimeseriesdatatypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcspecularhighlightselect
ifcspecularhighlightselect = SELECT(
	'ifcspecularexponent',
	'ifcspecularroughness',
	scope = schema_scope)
# Defined datatype ifcdayinmonthnumber
class ifcdayinmonthnumber(INTEGER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcspecificheatcapacitymeasure
class ifcspecificheatcapacitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcenergymeasure
class ifcenergymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdimensionextentusage
class ifcdimensionextentusage(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectriccurrentmeasure
class ifcelectriccurrentmeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifclayereditem
ifclayereditem = SELECT(
	'ifcrepresentationitem',
	'ifcrepresentation',
	scope = schema_scope)
# Defined datatype ifcluminousfluxmeasure
class ifcluminousfluxmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsensortypeenum
class ifcsensortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsequenceenum
class ifcsequenceenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdescriptivemeasure
class ifcdescriptivemeasure(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelementcompositionenum
class ifcelementcompositionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcthermaltransmittancemeasure
class ifcthermaltransmittancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcreal
class ifcreal(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcconstraintenum
class ifcconstraintenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdoorpanelpositionenum
class ifcdoorpanelpositionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcflowdirectionenum
class ifcflowdirectionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsiprefix
class ifcsiprefix(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcboilertypeenum
class ifcboilertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccurrencyenum
class ifccurrencyenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmagneticfluxdensitymeasure
class ifcmagneticfluxdensitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcservicelifefactortypeenum
class ifcservicelifefactortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccoolingtowertypeenum
class ifccoolingtowertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcboolean
class ifcboolean(BOOLEAN):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdaylightsavinghour
class ifcdaylightsavinghour(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <=  2))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcbuildingelementproxytypeenum
class ifcbuildingelementproxytypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcstructuralcurvetypeenum
class ifcstructuralcurvetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcangularvelocitymeasure
class ifcangularvelocitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmonetarymeasure
class ifcmonetarymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmonthinyearnumber
class ifcmonthinyearnumber(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((1  <=  self)  and  (self  <=  12))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcsectionmodulusmeasure
class ifcsectionmodulusmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdoorstyleconstructionenum
class ifcdoorstyleconstructionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcrooftypeenum
class ifcrooftypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsanitaryterminaltypeenum
class ifcsanitaryterminaltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcdocumentconfidentialityenum
class ifcdocumentconfidentialityenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfiresuppressionterminaltypeenum
class ifcfiresuppressionterminaltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcradioactivitymeasure
class ifcradioactivitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsurfacetextureenum
class ifcsurfacetextureenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmomentofinertiameasure
class ifcmomentofinertiameasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwarpingconstantmeasure
class ifcwarpingconstantmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcheatfluxdensitymeasure
class ifcheatfluxdensitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcvaporpermeabilitymeasure
class ifcvaporpermeabilitymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsecondinminute
class ifcsecondinminute(REAL):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <  60))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcvibrationisolatortypeenum
class ifcvibrationisolatortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcbooleanoperand
ifcbooleanoperand = SELECT(
	'ifcsolidmodel',
	'ifchalfspacesolid',
	'ifcbooleanresult',
	'ifccsgprimitive3d',
	scope = schema_scope)
# Defined datatype ifcflowinstrumenttypeenum
class ifcflowinstrumenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfontvariant
class ifcfontvariant(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['normal','small-caps'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcprofiletypeenum
class ifcprofiletypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcactorselect
ifcactorselect = SELECT(
	'ifcorganization',
	'ifcperson',
	'ifcpersonandorganization',
	scope = schema_scope)
# Defined datatype ifcmagneticfluxmeasure
class ifcmagneticfluxmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcyearnumber
class ifcyearnumber(INTEGER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcgloballyuniqueid
class ifcgloballyuniqueid(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcevaporativecoolertypeenum
class ifcevaporativecoolertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcaheadorbehind
class ifcaheadorbehind(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcfontweight
class ifcfontweight(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['normal','small-caps','100','200','300','400','500','600','700','800','900'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcchillertypeenum
class ifcchillertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcalarmtypeenum
class ifcalarmtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccablecarrierfittingtypeenum
class ifccablecarrierfittingtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcthermalloadtypeenum
class ifcthermalloadtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccolumntypeenum
class ifccolumntypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcprojectordertypeenum
class ifcprojectordertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcramptypeenum
class ifcramptypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcstateenum
class ifcstateenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpipesegmenttypeenum
class ifcpipesegmenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifchourinday
class ifchourinday(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <  24))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcnormalisedratiomeasure
class ifcnormalisedratiomeasure(ifcratiomeasure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcreinforcingbarsurfaceenum
class ifcreinforcingbarsurfaceenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpositivelengthmeasure
class ifcpositivelengthmeasure(ifclengthmeasure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcdampertypeenum
class ifcdampertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclayersetdirectionenum
class ifclayersetdirectionenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpipefittingtypeenum
class ifcpipefittingtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifccurvestylefontselect
ifccurvestylefontselect = SELECT(
	'ifcpredefinedcurvefont',
	'ifccurvestylefont',
	scope = schema_scope)
# Defined datatype ifcstairtypeenum
class ifcstairtypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

ifccomplexnumber = ARRAY(1,2,'REAL', scope = schema_scope)
ifccompoundplaneanglemeasure = LIST(3,4,'INTEGER', scope = schema_scope)
# Defined datatype ifcevaporatortypeenum
class ifcevaporatortypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmembertypeenum
class ifcmembertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcflowmetertypeenum
class ifcflowmetertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcprojectedortruelengthenum
class ifcprojectedortruelengthenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcpositiveratiomeasure
class ifcpositiveratiomeasure(ifcratiomeasure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifcobjectiveenum
class ifcobjectiveenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcconditioncriterionselect
ifcconditioncriterionselect = SELECT(
	'ifclabel',
	'ifcmeasurewithunit',
	scope = schema_scope)
# Defined datatype ifcrotationalfrequencymeasure
class ifcrotationalfrequencymeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcvolumetricflowratemeasure
class ifcvolumetricflowratemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwindowstyleoperationenum
class ifcwindowstyleoperationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcworkcontroltypeenum
class ifcworkcontroltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifclinearmomentmeasure
class ifclinearmomentmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcphmeasure
class ifcphmeasure(REAL):
	def __init__(self,*kargs):
		pass
		self.wr21()

	def wr21(self):
		eval_wr21_wr = ((0  <=  self)  and  (self  <=  14))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

# Defined datatype ifccondensertypeenum
class ifccondensertypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmotorconnectiontypeenum
class ifcmotorconnectiontypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcsymbolstyleselect
ifcsymbolstyleselect = SELECT(
	'ifccolour',
	scope = schema_scope)
# SELECT TYPE ifcfillareastyletileshapeselect
ifcfillareastyletileshapeselect = SELECT(
	'ifcfillareastyletilesymbolwithstyle',
	scope = schema_scope)
# Defined datatype ifcmodulusofsubgradereactionmeasure
class ifcmodulusofsubgradereactionmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcsolidanglemeasure
class ifcsolidanglemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcwalltypeenum
class ifcwalltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcdocumentselect
ifcdocumentselect = SELECT(
	'ifcdocumentreference',
	'ifcdocumentinformation',
	scope = schema_scope)
# Defined datatype ifcdoorstyleoperationenum
class ifcdoorstyleoperationenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcductsegmenttypeenum
class ifcductsegmenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcionconcentrationmeasure
class ifcionconcentrationmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcnumericmeasure
class ifcnumericmeasure(NUMBER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcmassflowratemeasure
class ifcmassflowratemeasure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE ifcsurfacestyleelementselect
ifcsurfacestyleelementselect = SELECT(
	'ifcsurfacestyleshading',
	'ifcsurfacestylelighting',
	'ifcsurfacestylewithtextures',
	'ifcexternallydefinedsurfacestyle',
	'ifcsurfacestylerefraction',
	scope = schema_scope)
# Defined datatype ifcoutlettypeenum
class ifcoutlettypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctemperaturegradientmeasure
class ifctemperaturegradientmeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifctextdecoration
class ifctextdecoration(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  ==  ['none','underline','overline','line-through','blink'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype ifctimestamp
class ifctimestamp(INTEGER):
	def __init__(self,*kargs):
		pass

# Defined datatype ifccablesegmenttypeenum
class ifccablesegmenttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcservicelifetypeenum
class ifcservicelifetypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcarithmeticoperatorenum
class ifcarithmeticoperatorenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectricresistancemeasure
class ifcelectricresistancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcilluminancemeasure
class ifcilluminancemeasure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcrampflighttypeenum
class ifcrampflighttypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcbsplinecurveform
class ifcbsplinecurveform(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype ifcelectrictimecontroltypeenum
class ifcelectrictimecontroltypeenum(ENUMERATION):
	def __init__(self,*kargs):
		pass


####################
 # ENTITY ifcroot #
####################
class ifcroot(BaseEntityClass):
	'''Entity ifcroot definition.

	:param globalid
	:type globalid:ifcgloballyuniqueid

	:param ownerhistory
	:type ownerhistory:ifcownerhistory

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext
	'''
	def __init__( self , globalid,ownerhistory,name,description, ):
		self.globalid = globalid
		self.ownerhistory = ownerhistory
		self.name = name
		self.description = description

	@apply
	def globalid():
		def fget( self ):
			return self._globalid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument globalid is mantatory and can not be set to None')
			if not check_type(value,ifcgloballyuniqueid):
				self._globalid = ifcgloballyuniqueid(value)
			else:
				self._globalid = value
		return property(**locals())

	@apply
	def ownerhistory():
		def fget( self ):
			return self._ownerhistory
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ownerhistory is mantatory and can not be set to None')
			if not check_type(value,ifcownerhistory):
				self._ownerhistory = ifcownerhistory(value)
			else:
				self._ownerhistory = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY ifcrelationship #
####################
class ifcrelationship(ifcroot):
	'''Entity ifcrelationship definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcroot.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

####################
 # ENTITY ifcrelconnects #
####################
class ifcrelconnects(ifcrelationship):
	'''Entity ifcrelconnects definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcrelationship.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

####################
 # ENTITY ifcrelinteractionrequirements #
####################
class ifcrelinteractionrequirements(ifcrelconnects):
	'''Entity ifcrelinteractionrequirements definition.

	:param dailyinteraction
	:type dailyinteraction:ifccountmeasure

	:param importancerating
	:type importancerating:ifcnormalisedratiomeasure

	:param locationofinteraction
	:type locationofinteraction:ifcspatialstructureelement

	:param relatedspaceprogram
	:type relatedspaceprogram:ifcspaceprogram

	:param relatingspaceprogram
	:type relatingspaceprogram:ifcspaceprogram
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , dailyinteraction,importancerating,locationofinteraction,relatedspaceprogram,relatingspaceprogram, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.dailyinteraction = dailyinteraction
		self.importancerating = importancerating
		self.locationofinteraction = locationofinteraction
		self.relatedspaceprogram = relatedspaceprogram
		self.relatingspaceprogram = relatingspaceprogram

	@apply
	def dailyinteraction():
		def fget( self ):
			return self._dailyinteraction
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccountmeasure):
					self._dailyinteraction = ifccountmeasure(value)
				else:
					self._dailyinteraction = value
			else:
				self._dailyinteraction = value
		return property(**locals())

	@apply
	def importancerating():
		def fget( self ):
			return self._importancerating
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._importancerating = ifcnormalisedratiomeasure(value)
				else:
					self._importancerating = value
			else:
				self._importancerating = value
		return property(**locals())

	@apply
	def locationofinteraction():
		def fget( self ):
			return self._locationofinteraction
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcspatialstructureelement):
					self._locationofinteraction = ifcspatialstructureelement(value)
				else:
					self._locationofinteraction = value
			else:
				self._locationofinteraction = value
		return property(**locals())

	@apply
	def relatedspaceprogram():
		def fget( self ):
			return self._relatedspaceprogram
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedspaceprogram is mantatory and can not be set to None')
			if not check_type(value,ifcspaceprogram):
				self._relatedspaceprogram = ifcspaceprogram(value)
			else:
				self._relatedspaceprogram = value
		return property(**locals())

	@apply
	def relatingspaceprogram():
		def fget( self ):
			return self._relatingspaceprogram
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingspaceprogram is mantatory and can not be set to None')
			if not check_type(value,ifcspaceprogram):
				self._relatingspaceprogram = ifcspaceprogram(value)
			else:
				self._relatingspaceprogram = value
		return property(**locals())

####################
 # ENTITY ifcobjectdefinition #
####################
class ifcobjectdefinition(ifcroot):
	'''Entity ifcobjectdefinition definition.

	:param hasassignments
	:type hasassignments:SET(0,None,'ifcrelassigns', scope = schema_scope)

	:param isdecomposedby
	:type isdecomposedby:SET(0,None,'ifcreldecomposes', scope = schema_scope)

	:param decomposes
	:type decomposes:SET(0,1,'ifcreldecomposes', scope = schema_scope)

	:param hasassociations
	:type hasassociations:SET(0,None,'ifcrelassociates', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcroot.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

	@apply
	def hasassignments():
		def fget( self ):
			return self._hasassignments
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasassignments is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isdecomposedby():
		def fget( self ):
			return self._isdecomposedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isdecomposedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def decomposes():
		def fget( self ):
			return self._decomposes
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument decomposes is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasassociations():
		def fget( self ):
			return self._hasassociations
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasassociations is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcobject #
####################
class ifcobject(ifcobjectdefinition):
	'''Entity ifcobject definition.

	:param objecttype
	:type objecttype:ifclabel

	:param isdefinedby
	:type isdefinedby:SET(0,None,'ifcreldefines', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , objecttype, ):
		ifcobjectdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.objecttype = objecttype

	@apply
	def objecttype():
		def fget( self ):
			return self._objecttype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._objecttype = ifclabel(value)
				else:
					self._objecttype = value
			else:
				self._objecttype = value
		return property(**locals())

	@apply
	def isdefinedby():
		def fget( self ):
			return self._isdefinedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isdefinedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcproduct #
####################
class ifcproduct(ifcobject):
	'''Entity ifcproduct definition.

	:param objectplacement
	:type objectplacement:ifcobjectplacement

	:param representation
	:type representation:ifcproductrepresentation

	:param referencedby
	:type referencedby:SET(0,None,'ifcrelassignstoproduct', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , objectplacement,representation, ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.objectplacement = objectplacement
		self.representation = representation

	@apply
	def objectplacement():
		def fget( self ):
			return self._objectplacement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcobjectplacement):
					self._objectplacement = ifcobjectplacement(value)
				else:
					self._objectplacement = value
			else:
				self._objectplacement = value
		return property(**locals())

	@apply
	def representation():
		def fget( self ):
			return self._representation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcproductrepresentation):
					self._representation = ifcproductrepresentation(value)
				else:
					self._representation = value
			else:
				self._representation = value
		return property(**locals())

	@apply
	def referencedby():
		def fget( self ):
			return self._referencedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referencedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((EXISTS(self.representation)  and  EXISTS(self.objectplacement))  or  (EXISTS(self.representation)  and  ( not ('IFC2X3.IFCPRODUCTDEFINITIONSHAPE'  ==  TYPEOF(self.representation)))))  or  ( not EXISTS(self.representation)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcelement #
####################
class ifcelement(ifcproduct):
	'''Entity ifcelement definition.

	:param tag
	:type tag:ifcidentifier

	:param hasstructuralmember
	:type hasstructuralmember:SET(0,None,'ifcrelconnectsstructuralelement', scope = schema_scope)

	:param fillsvoids
	:type fillsvoids:SET(0,1,'ifcrelfillselement', scope = schema_scope)

	:param connectedto
	:type connectedto:SET(0,None,'ifcrelconnectselements', scope = schema_scope)

	:param hascoverings
	:type hascoverings:SET(0,None,'ifcrelcoversbldgelements', scope = schema_scope)

	:param hasprojections
	:type hasprojections:SET(0,None,'ifcrelprojectselement', scope = schema_scope)

	:param referencedinstructures
	:type referencedinstructures:SET(0,None,'ifcrelreferencedinspatialstructure', scope = schema_scope)

	:param hasports
	:type hasports:SET(0,None,'ifcrelconnectsporttoelement', scope = schema_scope)

	:param hasopenings
	:type hasopenings:SET(0,None,'ifcrelvoidselement', scope = schema_scope)

	:param isconnectionrealization
	:type isconnectionrealization:SET(0,None,'ifcrelconnectswithrealizingelements', scope = schema_scope)

	:param providesboundaries
	:type providesboundaries:SET(0,None,'ifcrelspaceboundary', scope = schema_scope)

	:param connectedfrom
	:type connectedfrom:SET(0,None,'ifcrelconnectselements', scope = schema_scope)

	:param containedinstructure
	:type containedinstructure:SET(0,1,'ifcrelcontainedinspatialstructure', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , tag, ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.tag = tag

	@apply
	def tag():
		def fget( self ):
			return self._tag
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._tag = ifcidentifier(value)
				else:
					self._tag = value
			else:
				self._tag = value
		return property(**locals())

	@apply
	def hasstructuralmember():
		def fget( self ):
			return self._hasstructuralmember
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasstructuralmember is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def fillsvoids():
		def fget( self ):
			return self._fillsvoids
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument fillsvoids is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def connectedto():
		def fget( self ):
			return self._connectedto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectedto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hascoverings():
		def fget( self ):
			return self._hascoverings
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hascoverings is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasprojections():
		def fget( self ):
			return self._hasprojections
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasprojections is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def referencedinstructures():
		def fget( self ):
			return self._referencedinstructures
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referencedinstructures is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasports():
		def fget( self ):
			return self._hasports
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasports is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasopenings():
		def fget( self ):
			return self._hasopenings
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasopenings is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isconnectionrealization():
		def fget( self ):
			return self._isconnectionrealization
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isconnectionrealization is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def providesboundaries():
		def fget( self ):
			return self._providesboundaries
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument providesboundaries is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def connectedfrom():
		def fget( self ):
			return self._connectedfrom
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectedfrom is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def containedinstructure():
		def fget( self ):
			return self._containedinstructure
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument containedinstructure is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcvirtualelement #
####################
class ifcvirtualelement(ifcelement):
	'''Entity ifcvirtualelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifccurvestylefontpattern #
####################
class ifccurvestylefontpattern(BaseEntityClass):
	'''Entity ifccurvestylefontpattern definition.

	:param visiblesegmentlength
	:type visiblesegmentlength:ifclengthmeasure

	:param invisiblesegmentlength
	:type invisiblesegmentlength:ifcpositivelengthmeasure
	'''
	def __init__( self , visiblesegmentlength,invisiblesegmentlength, ):
		self.visiblesegmentlength = visiblesegmentlength
		self.invisiblesegmentlength = invisiblesegmentlength

	@apply
	def visiblesegmentlength():
		def fget( self ):
			return self._visiblesegmentlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument visiblesegmentlength is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._visiblesegmentlength = ifclengthmeasure(value)
			else:
				self._visiblesegmentlength = value
		return property(**locals())

	@apply
	def invisiblesegmentlength():
		def fget( self ):
			return self._invisiblesegmentlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument invisiblesegmentlength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._invisiblesegmentlength = ifcpositivelengthmeasure(value)
			else:
				self._invisiblesegmentlength = value
		return property(**locals())
	def wr01(self):
		eval_wr01_wr = (self.visiblesegmentlength  >=  0)
		if not eval_wr01_wr:
			raise AssertionError('Rule wr01 violated')
		else:
			return eval_wr01_wr


####################
 # ENTITY ifcrelconnectsstructuralactivity #
####################
class ifcrelconnectsstructuralactivity(ifcrelconnects):
	'''Entity ifcrelconnectsstructuralactivity definition.

	:param relatingelement
	:type relatingelement:ifcstructuralactivityassignmentselect

	:param relatedstructuralactivity
	:type relatedstructuralactivity:ifcstructuralactivity
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingelement,relatedstructuralactivity, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingelement = relatingelement
		self.relatedstructuralactivity = relatedstructuralactivity

	@apply
	def relatingelement():
		def fget( self ):
			return self._relatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralactivityassignmentselect):
				self._relatingelement = ifcstructuralactivityassignmentselect(value)
			else:
				self._relatingelement = value
		return property(**locals())

	@apply
	def relatedstructuralactivity():
		def fget( self ):
			return self._relatedstructuralactivity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedstructuralactivity is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralactivity):
				self._relatedstructuralactivity = ifcstructuralactivity(value)
			else:
				self._relatedstructuralactivity = value
		return property(**locals())

####################
 # ENTITY ifcmaterialproperties #
####################
class ifcmaterialproperties(BaseEntityClass):
	'''Entity ifcmaterialproperties definition.

	:param material
	:type material:ifcmaterial
	'''
	def __init__( self , material, ):
		self.material = material

	@apply
	def material():
		def fget( self ):
			return self._material
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument material is mantatory and can not be set to None')
			if not check_type(value,ifcmaterial):
				self._material = ifcmaterial(value)
			else:
				self._material = value
		return property(**locals())

####################
 # ENTITY ifchygroscopicmaterialproperties #
####################
class ifchygroscopicmaterialproperties(ifcmaterialproperties):
	'''Entity ifchygroscopicmaterialproperties definition.

	:param uppervaporresistancefactor
	:type uppervaporresistancefactor:ifcpositiveratiomeasure

	:param lowervaporresistancefactor
	:type lowervaporresistancefactor:ifcpositiveratiomeasure

	:param isothermalmoisturecapacity
	:type isothermalmoisturecapacity:ifcisothermalmoisturecapacitymeasure

	:param vaporpermeability
	:type vaporpermeability:ifcvaporpermeabilitymeasure

	:param moisturediffusivity
	:type moisturediffusivity:ifcmoisturediffusivitymeasure
	'''
	def __init__( self , inherited0__material , uppervaporresistancefactor,lowervaporresistancefactor,isothermalmoisturecapacity,vaporpermeability,moisturediffusivity, ):
		ifcmaterialproperties.__init__(self , inherited0__material , )
		self.uppervaporresistancefactor = uppervaporresistancefactor
		self.lowervaporresistancefactor = lowervaporresistancefactor
		self.isothermalmoisturecapacity = isothermalmoisturecapacity
		self.vaporpermeability = vaporpermeability
		self.moisturediffusivity = moisturediffusivity

	@apply
	def uppervaporresistancefactor():
		def fget( self ):
			return self._uppervaporresistancefactor
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._uppervaporresistancefactor = ifcpositiveratiomeasure(value)
				else:
					self._uppervaporresistancefactor = value
			else:
				self._uppervaporresistancefactor = value
		return property(**locals())

	@apply
	def lowervaporresistancefactor():
		def fget( self ):
			return self._lowervaporresistancefactor
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._lowervaporresistancefactor = ifcpositiveratiomeasure(value)
				else:
					self._lowervaporresistancefactor = value
			else:
				self._lowervaporresistancefactor = value
		return property(**locals())

	@apply
	def isothermalmoisturecapacity():
		def fget( self ):
			return self._isothermalmoisturecapacity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcisothermalmoisturecapacitymeasure):
					self._isothermalmoisturecapacity = ifcisothermalmoisturecapacitymeasure(value)
				else:
					self._isothermalmoisturecapacity = value
			else:
				self._isothermalmoisturecapacity = value
		return property(**locals())

	@apply
	def vaporpermeability():
		def fget( self ):
			return self._vaporpermeability
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvaporpermeabilitymeasure):
					self._vaporpermeability = ifcvaporpermeabilitymeasure(value)
				else:
					self._vaporpermeability = value
			else:
				self._vaporpermeability = value
		return property(**locals())

	@apply
	def moisturediffusivity():
		def fget( self ):
			return self._moisturediffusivity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmoisturediffusivitymeasure):
					self._moisturediffusivity = ifcmoisturediffusivitymeasure(value)
				else:
					self._moisturediffusivity = value
			else:
				self._moisturediffusivity = value
		return property(**locals())

####################
 # ENTITY ifcrelassigns #
####################
class ifcrelassigns(ifcrelationship):
	'''Entity ifcrelassigns definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobjectdefinition', scope = schema_scope)

	:param relatedobjectstype
	:type relatedobjectstype:ifcobjecttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedobjects,relatedobjectstype, ):
		ifcrelationship.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedobjects = relatedobjects
		self.relatedobjectstype = relatedobjectstype

	@apply
	def relatedobjects():
		def fget( self ):
			return self._relatedobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcobjectdefinition', scope = schema_scope)):
				self._relatedobjects = SET(value)
			else:
				self._relatedobjects = value
		return property(**locals())

	@apply
	def relatedobjectstype():
		def fget( self ):
			return self._relatedobjectstype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcobjecttypeenum):
					self._relatedobjectstype = ifcobjecttypeenum(value)
				else:
					self._relatedobjectstype = value
			else:
				self._relatedobjectstype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ifccorrectobjectassignment(self.relatedobjectstype,self.relatedobjects)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcrelassignstocontrol #
####################
class ifcrelassignstocontrol(ifcrelassigns):
	'''Entity ifcrelassignstocontrol definition.

	:param relatingcontrol
	:type relatingcontrol:ifccontrol
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatingcontrol, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatingcontrol = relatingcontrol

	@apply
	def relatingcontrol():
		def fget( self ):
			return self._relatingcontrol
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingcontrol is mantatory and can not be set to None')
			if not check_type(value,ifccontrol):
				self._relatingcontrol = ifccontrol(value)
			else:
				self._relatingcontrol = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcrelschedulescostitems #
####################
class ifcrelschedulescostitems(ifcrelassignstocontrol):
	'''Entity ifcrelschedulescostitems definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , inherited6__relatingcontrol ,  ):
		ifcrelassignstocontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , inherited6__relatingcontrol , )
	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = ('IFC2X3.IFCCOSTSCHEDULE'  ==  TYPEOF(self.self.ifcrelassignstocontrol.self.relatingcontrol))
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr


####################
 # ENTITY ifcproperty #
####################
class ifcproperty(BaseEntityClass):
	'''Entity ifcproperty definition.

	:param name
	:type name:ifcidentifier

	:param description
	:type description:ifctext

	:param propertyfordependance
	:type propertyfordependance:SET(0,None,'ifcpropertydependencyrelationship', scope = schema_scope)

	:param propertydependson
	:type propertydependson:SET(0,None,'ifcpropertydependencyrelationship', scope = schema_scope)

	:param partofcomplex
	:type partofcomplex:SET(0,1,'ifccomplexproperty', scope = schema_scope)
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._name = ifcidentifier(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def propertyfordependance():
		def fget( self ):
			return self._propertyfordependance
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument propertyfordependance is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def propertydependson():
		def fget( self ):
			return self._propertydependson
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument propertydependson is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def partofcomplex():
		def fget( self ):
			return self._partofcomplex
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofcomplex is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcsimpleproperty #
####################
class ifcsimpleproperty(ifcproperty):
	'''Entity ifcsimpleproperty definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		ifcproperty.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY ifcpropertyenumeratedvalue #
####################
class ifcpropertyenumeratedvalue(ifcsimpleproperty):
	'''Entity ifcpropertyenumeratedvalue definition.

	:param enumerationvalues
	:type enumerationvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param enumerationreference
	:type enumerationreference:ifcpropertyenumeration
	'''
	def __init__( self , inherited0__name , inherited1__description , enumerationvalues,enumerationreference, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.enumerationvalues = enumerationvalues
		self.enumerationreference = enumerationreference

	@apply
	def enumerationvalues():
		def fget( self ):
			return self._enumerationvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument enumerationvalues is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
				self._enumerationvalues = LIST(value)
			else:
				self._enumerationvalues = value
		return property(**locals())

	@apply
	def enumerationreference():
		def fget( self ):
			return self._enumerationreference
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpropertyenumeration):
					self._enumerationreference = ifcpropertyenumeration(value)
				else:
					self._enumerationreference = value
			else:
				self._enumerationreference = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not EXISTS(self.enumerationreference))  or  (SIZEOF(None)  ==  SIZEOF(self.enumerationvalues)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcreinforcementbarproperties #
####################
class ifcreinforcementbarproperties(BaseEntityClass):
	'''Entity ifcreinforcementbarproperties definition.

	:param totalcrosssectionarea
	:type totalcrosssectionarea:ifcareameasure

	:param steelgrade
	:type steelgrade:ifclabel

	:param barsurface
	:type barsurface:ifcreinforcingbarsurfaceenum

	:param effectivedepth
	:type effectivedepth:ifclengthmeasure

	:param nominalbardiameter
	:type nominalbardiameter:ifcpositivelengthmeasure

	:param barcount
	:type barcount:ifccountmeasure
	'''
	def __init__( self , totalcrosssectionarea,steelgrade,barsurface,effectivedepth,nominalbardiameter,barcount, ):
		self.totalcrosssectionarea = totalcrosssectionarea
		self.steelgrade = steelgrade
		self.barsurface = barsurface
		self.effectivedepth = effectivedepth
		self.nominalbardiameter = nominalbardiameter
		self.barcount = barcount

	@apply
	def totalcrosssectionarea():
		def fget( self ):
			return self._totalcrosssectionarea
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument totalcrosssectionarea is mantatory and can not be set to None')
			if not check_type(value,ifcareameasure):
				self._totalcrosssectionarea = ifcareameasure(value)
			else:
				self._totalcrosssectionarea = value
		return property(**locals())

	@apply
	def steelgrade():
		def fget( self ):
			return self._steelgrade
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument steelgrade is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._steelgrade = ifclabel(value)
			else:
				self._steelgrade = value
		return property(**locals())

	@apply
	def barsurface():
		def fget( self ):
			return self._barsurface
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreinforcingbarsurfaceenum):
					self._barsurface = ifcreinforcingbarsurfaceenum(value)
				else:
					self._barsurface = value
			else:
				self._barsurface = value
		return property(**locals())

	@apply
	def effectivedepth():
		def fget( self ):
			return self._effectivedepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._effectivedepth = ifclengthmeasure(value)
				else:
					self._effectivedepth = value
			else:
				self._effectivedepth = value
		return property(**locals())

	@apply
	def nominalbardiameter():
		def fget( self ):
			return self._nominalbardiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominalbardiameter = ifcpositivelengthmeasure(value)
				else:
					self._nominalbardiameter = value
			else:
				self._nominalbardiameter = value
		return property(**locals())

	@apply
	def barcount():
		def fget( self ):
			return self._barcount
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccountmeasure):
					self._barcount = ifccountmeasure(value)
				else:
					self._barcount = value
			else:
				self._barcount = value
		return property(**locals())

####################
 # ENTITY ifcrepresentationitem #
####################
class ifcrepresentationitem(BaseEntityClass):
	'''Entity ifcrepresentationitem definition.

	:param layerassignments
	:type layerassignments:SET(0,None,'ifcpresentationlayerassignment', scope = schema_scope)

	:param styledbyitem
	:type styledbyitem:SET(0,1,'ifcstyleditem', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def layerassignments():
		def fget( self ):
			return self._layerassignments
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument layerassignments is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def styledbyitem():
		def fget( self ):
			return self._styledbyitem
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument styledbyitem is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcgeometricrepresentationitem #
####################
class ifcgeometricrepresentationitem(ifcrepresentationitem):
	'''Entity ifcgeometricrepresentationitem definition.
	'''
	def __init__( self ,  ):
		ifcrepresentationitem.__init__(self , )

####################
 # ENTITY ifcsurface #
####################
class ifcsurface(ifcgeometricrepresentationitem):
	'''Entity ifcsurface definition.
	'''
	def __init__( self ,  ):
		ifcgeometricrepresentationitem.__init__(self , )

####################
 # ENTITY ifcsweptsurface #
####################
class ifcsweptsurface(ifcsurface):
	'''Entity ifcsweptsurface definition.

	:param sweptcurve
	:type sweptcurve:ifcprofiledef

	:param position
	:type position:ifcaxis2placement3d

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , sweptcurve,position, ):
		ifcsurface.__init__(self , )
		self.sweptcurve = sweptcurve
		self.position = position

	@apply
	def sweptcurve():
		def fget( self ):
			return self._sweptcurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sweptcurve is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._sweptcurve = ifcprofiledef(value)
			else:
				self._sweptcurve = value
		return property(**locals())

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement3d):
				self._position = ifcaxis2placement3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.position.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('IFC2X3.IFCDERIVEDPROFILEDEF'  ==  TYPEOF(self.sweptcurve)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.sweptcurve.self.profiletype  ==  ifcprofiletypeenum.self.curve)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcsurfaceofrevolution #
####################
class ifcsurfaceofrevolution(ifcsweptsurface):
	'''Entity ifcsurfaceofrevolution definition.

	:param axisposition
	:type axisposition:ifcaxis1placement

	:param axisline
	:type axisline:ifcline
	'''
	def __init__( self , inherited0__sweptcurve , inherited1__position , axisposition, ):
		ifcsweptsurface.__init__(self , inherited0__sweptcurve , inherited1__position , )
		self.axisposition = axisposition

	@apply
	def axisposition():
		def fget( self ):
			return self._axisposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axisposition is mantatory and can not be set to None')
			if not check_type(value,ifcaxis1placement):
				self._axisposition = ifcaxis1placement(value)
			else:
				self._axisposition = value
		return property(**locals())

	@apply
	def axisline():
		def fget( self ):
			attribute_eval = (((ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifccurve())  ==  ifcline(self.axisposition.self.location,(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(self.axisposition.self.z,1)))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument axisline is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcprofiledef #
####################
class ifcprofiledef(BaseEntityClass):
	'''Entity ifcprofiledef definition.

	:param profiletype
	:type profiletype:ifcprofiletypeenum

	:param profilename
	:type profilename:ifclabel
	'''
	def __init__( self , profiletype,profilename, ):
		self.profiletype = profiletype
		self.profilename = profilename

	@apply
	def profiletype():
		def fget( self ):
			return self._profiletype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument profiletype is mantatory and can not be set to None')
			if not check_type(value,ifcprofiletypeenum):
				self._profiletype = ifcprofiletypeenum(value)
			else:
				self._profiletype = value
		return property(**locals())

	@apply
	def profilename():
		def fget( self ):
			return self._profilename
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._profilename = ifclabel(value)
				else:
					self._profilename = value
			else:
				self._profilename = value
		return property(**locals())

####################
 # ENTITY ifcparameterizedprofiledef #
####################
class ifcparameterizedprofiledef(ifcprofiledef):
	'''Entity ifcparameterizedprofiledef definition.

	:param position
	:type position:ifcaxis2placement2d
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , position, ):
		ifcprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement2d):
				self._position = ifcaxis2placement2d(value)
			else:
				self._position = value
		return property(**locals())

####################
 # ENTITY ifccranerailashapeprofiledef #
####################
class ifccranerailashapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifccranerailashapeprofiledef definition.

	:param overallheight
	:type overallheight:ifcpositivelengthmeasure

	:param basewidth2
	:type basewidth2:ifcpositivelengthmeasure

	:param radius
	:type radius:ifcpositivelengthmeasure

	:param headwidth
	:type headwidth:ifcpositivelengthmeasure

	:param headdepth2
	:type headdepth2:ifcpositivelengthmeasure

	:param headdepth3
	:type headdepth3:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param basewidth4
	:type basewidth4:ifcpositivelengthmeasure

	:param basedepth1
	:type basedepth1:ifcpositivelengthmeasure

	:param basedepth2
	:type basedepth2:ifcpositivelengthmeasure

	:param basedepth3
	:type basedepth3:ifcpositivelengthmeasure

	:param centreofgravityiny
	:type centreofgravityiny:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , overallheight,basewidth2,radius,headwidth,headdepth2,headdepth3,webthickness,basewidth4,basedepth1,basedepth2,basedepth3,centreofgravityiny, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.overallheight = overallheight
		self.basewidth2 = basewidth2
		self.radius = radius
		self.headwidth = headwidth
		self.headdepth2 = headdepth2
		self.headdepth3 = headdepth3
		self.webthickness = webthickness
		self.basewidth4 = basewidth4
		self.basedepth1 = basedepth1
		self.basedepth2 = basedepth2
		self.basedepth3 = basedepth3
		self.centreofgravityiny = centreofgravityiny

	@apply
	def overallheight():
		def fget( self ):
			return self._overallheight
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument overallheight is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._overallheight = ifcpositivelengthmeasure(value)
			else:
				self._overallheight = value
		return property(**locals())

	@apply
	def basewidth2():
		def fget( self ):
			return self._basewidth2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basewidth2 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._basewidth2 = ifcpositivelengthmeasure(value)
			else:
				self._basewidth2 = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._radius = ifcpositivelengthmeasure(value)
				else:
					self._radius = value
			else:
				self._radius = value
		return property(**locals())

	@apply
	def headwidth():
		def fget( self ):
			return self._headwidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument headwidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._headwidth = ifcpositivelengthmeasure(value)
			else:
				self._headwidth = value
		return property(**locals())

	@apply
	def headdepth2():
		def fget( self ):
			return self._headdepth2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument headdepth2 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._headdepth2 = ifcpositivelengthmeasure(value)
			else:
				self._headdepth2 = value
		return property(**locals())

	@apply
	def headdepth3():
		def fget( self ):
			return self._headdepth3
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument headdepth3 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._headdepth3 = ifcpositivelengthmeasure(value)
			else:
				self._headdepth3 = value
		return property(**locals())

	@apply
	def webthickness():
		def fget( self ):
			return self._webthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument webthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._webthickness = ifcpositivelengthmeasure(value)
			else:
				self._webthickness = value
		return property(**locals())

	@apply
	def basewidth4():
		def fget( self ):
			return self._basewidth4
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basewidth4 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._basewidth4 = ifcpositivelengthmeasure(value)
			else:
				self._basewidth4 = value
		return property(**locals())

	@apply
	def basedepth1():
		def fget( self ):
			return self._basedepth1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basedepth1 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._basedepth1 = ifcpositivelengthmeasure(value)
			else:
				self._basedepth1 = value
		return property(**locals())

	@apply
	def basedepth2():
		def fget( self ):
			return self._basedepth2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basedepth2 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._basedepth2 = ifcpositivelengthmeasure(value)
			else:
				self._basedepth2 = value
		return property(**locals())

	@apply
	def basedepth3():
		def fget( self ):
			return self._basedepth3
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basedepth3 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._basedepth3 = ifcpositivelengthmeasure(value)
			else:
				self._basedepth3 = value
		return property(**locals())

	@apply
	def centreofgravityiny():
		def fget( self ):
			return self._centreofgravityiny
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._centreofgravityiny = ifcpositivelengthmeasure(value)
				else:
					self._centreofgravityiny = value
			else:
				self._centreofgravityiny = value
		return property(**locals())

####################
 # ENTITY ifctypeobject #
####################
class ifctypeobject(ifcobjectdefinition):
	'''Entity ifctypeobject definition.

	:param applicableoccurrence
	:type applicableoccurrence:ifclabel

	:param haspropertysets
	:type haspropertysets:SET(1,None,'ifcpropertysetdefinition', scope = schema_scope)

	:param objecttypeof
	:type objecttypeof:SET(0,1,'ifcreldefinesbytype', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , applicableoccurrence,haspropertysets, ):
		ifcobjectdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.applicableoccurrence = applicableoccurrence
		self.haspropertysets = haspropertysets

	@apply
	def applicableoccurrence():
		def fget( self ):
			return self._applicableoccurrence
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._applicableoccurrence = ifclabel(value)
				else:
					self._applicableoccurrence = value
			else:
				self._applicableoccurrence = value
		return property(**locals())

	@apply
	def haspropertysets():
		def fget( self ):
			return self._haspropertysets
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcpropertysetdefinition', scope = schema_scope)):
					self._haspropertysets = SET(value)
				else:
					self._haspropertysets = value
			else:
				self._haspropertysets = value
		return property(**locals())

	@apply
	def objecttypeof():
		def fget( self ):
			return self._objecttypeof
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument objecttypeof is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifctypeproduct #
####################
class ifctypeproduct(ifctypeobject):
	'''Entity ifctypeproduct definition.

	:param representationmaps
	:type representationmaps:LIST(1,None,'ifcrepresentationmap', scope = schema_scope)

	:param tag
	:type tag:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , representationmaps,tag, ):
		ifctypeobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , )
		self.representationmaps = representationmaps
		self.tag = tag

	@apply
	def representationmaps():
		def fget( self ):
			return self._representationmaps
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcrepresentationmap', scope = schema_scope)):
					self._representationmaps = LIST(value)
				else:
					self._representationmaps = value
			else:
				self._representationmaps = value
		return property(**locals())

	@apply
	def tag():
		def fget( self ):
			return self._tag
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._tag = ifclabel(value)
				else:
					self._tag = value
			else:
				self._tag = value
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = (( not EXISTS(self.self.ifctypeobject.self.objecttypeof[1]))  or  (SIZEOF(None)  ==  0))
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr


####################
 # ENTITY ifcelementtype #
####################
class ifcelementtype(ifctypeproduct):
	'''Entity ifcelementtype definition.

	:param elementtype
	:type elementtype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , elementtype, ):
		ifctypeproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , )
		self.elementtype = elementtype

	@apply
	def elementtype():
		def fget( self ):
			return self._elementtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._elementtype = ifclabel(value)
				else:
					self._elementtype = value
			else:
				self._elementtype = value
		return property(**locals())

####################
 # ENTITY ifcdistributionelementtype #
####################
class ifcdistributionelementtype(ifcelementtype):
	'''Entity ifcdistributionelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcdistributionflowelementtype #
####################
class ifcdistributionflowelementtype(ifcdistributionelementtype):
	'''Entity ifcdistributionflowelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcflowsegmenttype #
####################
class ifcflowsegmenttype(ifcdistributionflowelementtype):
	'''Entity ifcflowsegmenttype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifccablesegmenttype #
####################
class ifccablesegmenttype(ifcflowsegmenttype):
	'''Entity ifccablesegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifccablesegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowsegmenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccablesegmenttypeenum):
				self._predefinedtype = ifccablesegmenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcpropertydefinition #
####################
class ifcpropertydefinition(ifcroot):
	'''Entity ifcpropertydefinition definition.

	:param hasassociations
	:type hasassociations:SET(0,None,'ifcrelassociates', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcroot.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

	@apply
	def hasassociations():
		def fget( self ):
			return self._hasassociations
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasassociations is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcpropertysetdefinition #
####################
class ifcpropertysetdefinition(ifcpropertydefinition):
	'''Entity ifcpropertysetdefinition definition.

	:param propertydefinitionof
	:type propertydefinitionof:SET(0,1,'ifcreldefinesbyproperties', scope = schema_scope)

	:param definestype
	:type definestype:SET(0,1,'ifctypeobject', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description ,  ):
		ifcpropertydefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )

	@apply
	def propertydefinitionof():
		def fget( self ):
			return self._propertydefinitionof
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument propertydefinitionof is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def definestype():
		def fget( self ):
			return self._definestype
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument definestype is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcelementquantity #
####################
class ifcelementquantity(ifcpropertysetdefinition):
	'''Entity ifcelementquantity definition.

	:param methodofmeasurement
	:type methodofmeasurement:ifclabel

	:param quantities
	:type quantities:SET(1,None,'ifcphysicalquantity', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , methodofmeasurement,quantities, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.methodofmeasurement = methodofmeasurement
		self.quantities = quantities

	@apply
	def methodofmeasurement():
		def fget( self ):
			return self._methodofmeasurement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._methodofmeasurement = ifclabel(value)
				else:
					self._methodofmeasurement = value
			else:
				self._methodofmeasurement = value
		return property(**locals())

	@apply
	def quantities():
		def fget( self ):
			return self._quantities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument quantities is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcphysicalquantity', scope = schema_scope)):
				self._quantities = SET(value)
			else:
				self._quantities = value
		return property(**locals())

####################
 # ENTITY ifcenergyconversiondevicetype #
####################
class ifcenergyconversiondevicetype(ifcdistributionflowelementtype):
	'''Entity ifcenergyconversiondevicetype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifchumidifiertype #
####################
class ifchumidifiertype(ifcenergyconversiondevicetype):
	'''Entity ifchumidifiertype definition.

	:param predefinedtype
	:type predefinedtype:ifchumidifiertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifchumidifiertypeenum):
				self._predefinedtype = ifchumidifiertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifchumidifiertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifchumidifiertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcstructuralitem #
####################
class ifcstructuralitem(ifcproduct):
	'''Entity ifcstructuralitem definition.

	:param assignedstructuralactivity
	:type assignedstructuralactivity:SET(0,None,'ifcrelconnectsstructuralactivity', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation ,  ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )

	@apply
	def assignedstructuralactivity():
		def fget( self ):
			return self._assignedstructuralactivity
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument assignedstructuralactivity is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstructuralload #
####################
class ifcstructuralload(BaseEntityClass):
	'''Entity ifcstructuralload definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifcstructuralloadstatic #
####################
class ifcstructuralloadstatic(ifcstructuralload):
	'''Entity ifcstructuralloadstatic definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcstructuralload.__init__(self , inherited0__name , )

####################
 # ENTITY ifcstructuralloadsingledisplacement #
####################
class ifcstructuralloadsingledisplacement(ifcstructuralloadstatic):
	'''Entity ifcstructuralloadsingledisplacement definition.

	:param displacementx
	:type displacementx:ifclengthmeasure

	:param displacementy
	:type displacementy:ifclengthmeasure

	:param displacementz
	:type displacementz:ifclengthmeasure

	:param rotationaldisplacementrx
	:type rotationaldisplacementrx:ifcplaneanglemeasure

	:param rotationaldisplacementry
	:type rotationaldisplacementry:ifcplaneanglemeasure

	:param rotationaldisplacementrz
	:type rotationaldisplacementrz:ifcplaneanglemeasure
	'''
	def __init__( self , inherited0__name , displacementx,displacementy,displacementz,rotationaldisplacementrx,rotationaldisplacementry,rotationaldisplacementrz, ):
		ifcstructuralloadstatic.__init__(self , inherited0__name , )
		self.displacementx = displacementx
		self.displacementy = displacementy
		self.displacementz = displacementz
		self.rotationaldisplacementrx = rotationaldisplacementrx
		self.rotationaldisplacementry = rotationaldisplacementry
		self.rotationaldisplacementrz = rotationaldisplacementrz

	@apply
	def displacementx():
		def fget( self ):
			return self._displacementx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._displacementx = ifclengthmeasure(value)
				else:
					self._displacementx = value
			else:
				self._displacementx = value
		return property(**locals())

	@apply
	def displacementy():
		def fget( self ):
			return self._displacementy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._displacementy = ifclengthmeasure(value)
				else:
					self._displacementy = value
			else:
				self._displacementy = value
		return property(**locals())

	@apply
	def displacementz():
		def fget( self ):
			return self._displacementz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._displacementz = ifclengthmeasure(value)
				else:
					self._displacementz = value
			else:
				self._displacementz = value
		return property(**locals())

	@apply
	def rotationaldisplacementrx():
		def fget( self ):
			return self._rotationaldisplacementrx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._rotationaldisplacementrx = ifcplaneanglemeasure(value)
				else:
					self._rotationaldisplacementrx = value
			else:
				self._rotationaldisplacementrx = value
		return property(**locals())

	@apply
	def rotationaldisplacementry():
		def fget( self ):
			return self._rotationaldisplacementry
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._rotationaldisplacementry = ifcplaneanglemeasure(value)
				else:
					self._rotationaldisplacementry = value
			else:
				self._rotationaldisplacementry = value
		return property(**locals())

	@apply
	def rotationaldisplacementrz():
		def fget( self ):
			return self._rotationaldisplacementrz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._rotationaldisplacementrz = ifcplaneanglemeasure(value)
				else:
					self._rotationaldisplacementrz = value
			else:
				self._rotationaldisplacementrz = value
		return property(**locals())

####################
 # ENTITY ifctransportelementtype #
####################
class ifctransportelementtype(ifcelementtype):
	'''Entity ifctransportelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifctransportelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctransportelementtypeenum):
				self._predefinedtype = ifctransportelementtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifctrapeziumprofiledef #
####################
class ifctrapeziumprofiledef(ifcparameterizedprofiledef):
	'''Entity ifctrapeziumprofiledef definition.

	:param bottomxdim
	:type bottomxdim:ifcpositivelengthmeasure

	:param topxdim
	:type topxdim:ifcpositivelengthmeasure

	:param ydim
	:type ydim:ifcpositivelengthmeasure

	:param topxoffset
	:type topxoffset:ifclengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , bottomxdim,topxdim,ydim,topxoffset, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.bottomxdim = bottomxdim
		self.topxdim = topxdim
		self.ydim = ydim
		self.topxoffset = topxoffset

	@apply
	def bottomxdim():
		def fget( self ):
			return self._bottomxdim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bottomxdim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._bottomxdim = ifcpositivelengthmeasure(value)
			else:
				self._bottomxdim = value
		return property(**locals())

	@apply
	def topxdim():
		def fget( self ):
			return self._topxdim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument topxdim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._topxdim = ifcpositivelengthmeasure(value)
			else:
				self._topxdim = value
		return property(**locals())

	@apply
	def ydim():
		def fget( self ):
			return self._ydim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ydim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._ydim = ifcpositivelengthmeasure(value)
			else:
				self._ydim = value
		return property(**locals())

	@apply
	def topxoffset():
		def fget( self ):
			return self._topxoffset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument topxoffset is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._topxoffset = ifclengthmeasure(value)
			else:
				self._topxoffset = value
		return property(**locals())

####################
 # ENTITY ifczshapeprofiledef #
####################
class ifczshapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifczshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param flangewidth
	:type flangewidth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcpositivelengthmeasure

	:param edgeradius
	:type edgeradius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , depth,flangewidth,webthickness,flangethickness,filletradius,edgeradius, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.depth = depth
		self.flangewidth = flangewidth
		self.webthickness = webthickness
		self.flangethickness = flangethickness
		self.filletradius = filletradius
		self.edgeradius = edgeradius

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def flangewidth():
		def fget( self ):
			return self._flangewidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangewidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangewidth = ifcpositivelengthmeasure(value)
			else:
				self._flangewidth = value
		return property(**locals())

	@apply
	def webthickness():
		def fget( self ):
			return self._webthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument webthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._webthickness = ifcpositivelengthmeasure(value)
			else:
				self._webthickness = value
		return property(**locals())

	@apply
	def flangethickness():
		def fget( self ):
			return self._flangethickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangethickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangethickness = ifcpositivelengthmeasure(value)
			else:
				self._flangethickness = value
		return property(**locals())

	@apply
	def filletradius():
		def fget( self ):
			return self._filletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._filletradius = ifcpositivelengthmeasure(value)
				else:
					self._filletradius = value
			else:
				self._filletradius = value
		return property(**locals())

	@apply
	def edgeradius():
		def fget( self ):
			return self._edgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._edgeradius = ifcpositivelengthmeasure(value)
				else:
					self._edgeradius = value
			else:
				self._edgeradius = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (self.flangethickness  <  (self.depth / 2))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcstyleditem #
####################
class ifcstyleditem(ifcrepresentationitem):
	'''Entity ifcstyleditem definition.

	:param item
	:type item:ifcrepresentationitem

	:param styles
	:type styles:SET(1,None,'ifcpresentationstyleassignment', scope = schema_scope)

	:param name
	:type name:ifclabel
	'''
	def __init__( self , item,styles,name, ):
		ifcrepresentationitem.__init__(self , )
		self.item = item
		self.styles = styles
		self.name = name

	@apply
	def item():
		def fget( self ):
			return self._item
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrepresentationitem):
					self._item = ifcrepresentationitem(value)
				else:
					self._item = value
			else:
				self._item = value
		return property(**locals())

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcpresentationstyleassignment', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (SIZEOF(self.styles)  ==  1)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = ( not ('IFC2X3.IFCSTYLEDITEM'  ==  TYPEOF(self.item)))
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr


####################
 # ENTITY ifcannotationoccurrence #
####################
class ifcannotationoccurrence(ifcstyleditem):
	'''Entity ifcannotationoccurrence definition.
	'''
	def __init__( self , inherited0__item , inherited1__styles , inherited2__name ,  ):
		ifcstyleditem.__init__(self , inherited0__item , inherited1__styles , inherited2__name , )

####################
 # ENTITY ifcannotationtextoccurrence #
####################
class ifcannotationtextoccurrence(ifcannotationoccurrence):
	'''Entity ifcannotationtextoccurrence definition.
	'''
	def __init__( self , inherited0__item , inherited1__styles , inherited2__name ,  ):
		ifcannotationoccurrence.__init__(self , inherited0__item , inherited1__styles , inherited2__name , )
	def wr31(self):
		eval_wr31_wr = (( not EXISTS(self.self.ifcstyleditem.self.item))  or  ('IFC2X3.IFCTEXTLITERAL'  ==  TYPEOF(self.self.ifcstyleditem.self.item)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifccontrol #
####################
class ifccontrol(ifcobject):
	'''Entity ifccontrol definition.

	:param controls
	:type controls:SET(0,None,'ifcrelassignstocontrol', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

	@apply
	def controls():
		def fget( self ):
			return self._controls
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument controls is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifccostitem #
####################
class ifccostitem(ifccontrol):
	'''Entity ifccostitem definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

####################
 # ENTITY ifclightsource #
####################
class ifclightsource(ifcgeometricrepresentationitem):
	'''Entity ifclightsource definition.

	:param name
	:type name:ifclabel

	:param lightcolour
	:type lightcolour:ifccolourrgb

	:param ambientintensity
	:type ambientintensity:ifcnormalisedratiomeasure

	:param intensity
	:type intensity:ifcnormalisedratiomeasure
	'''
	def __init__( self , name,lightcolour,ambientintensity,intensity, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.name = name
		self.lightcolour = lightcolour
		self.ambientintensity = ambientintensity
		self.intensity = intensity

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def lightcolour():
		def fget( self ):
			return self._lightcolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lightcolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._lightcolour = ifccolourrgb(value)
			else:
				self._lightcolour = value
		return property(**locals())

	@apply
	def ambientintensity():
		def fget( self ):
			return self._ambientintensity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._ambientintensity = ifcnormalisedratiomeasure(value)
				else:
					self._ambientintensity = value
			else:
				self._ambientintensity = value
		return property(**locals())

	@apply
	def intensity():
		def fget( self ):
			return self._intensity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._intensity = ifcnormalisedratiomeasure(value)
				else:
					self._intensity = value
			else:
				self._intensity = value
		return property(**locals())

####################
 # ENTITY ifcfeatureelement #
####################
class ifcfeatureelement(ifcelement):
	'''Entity ifcfeatureelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcfeatureelementaddition #
####################
class ifcfeatureelementaddition(ifcfeatureelement):
	'''Entity ifcfeatureelementaddition definition.

	:param projectselements
	:type projectselements:ifcrelprojectselement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcfeatureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

	@apply
	def projectselements():
		def fget( self ):
			return self._projectselements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument projectselements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstructuralconnectioncondition #
####################
class ifcstructuralconnectioncondition(BaseEntityClass):
	'''Entity ifcstructuralconnectioncondition definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifcpoint #
####################
class ifcpoint(ifcgeometricrepresentationitem):
	'''Entity ifcpoint definition.
	'''
	def __init__( self ,  ):
		ifcgeometricrepresentationitem.__init__(self , )

####################
 # ENTITY ifccartesianpoint #
####################
class ifccartesianpoint(ifcpoint):
	'''Entity ifccartesianpoint definition.

	:param coordinates
	:type coordinates:LIST(1,3,'REAL', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , coordinates, ):
		ifcpoint.__init__(self , )
		self.coordinates = coordinates

	@apply
	def coordinates():
		def fget( self ):
			return self._coordinates
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordinates is mantatory and can not be set to None')
			if not check_type(value,LIST(1,3,'REAL', scope = schema_scope)):
				self._coordinates = LIST(value)
			else:
				self._coordinates = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = HIINDEX(self.coordinates)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (HIINDEX(self.coordinates)  >=  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcexternalreference #
####################
class ifcexternalreference(BaseEntityClass):
	'''Entity ifcexternalreference definition.

	:param location
	:type location:ifclabel

	:param itemreference
	:type itemreference:ifcidentifier

	:param name
	:type name:ifclabel
	'''
	def __init__( self , location,itemreference,name, ):
		self.location = location
		self.itemreference = itemreference
		self.name = name

	@apply
	def location():
		def fget( self ):
			return self._location
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._location = ifclabel(value)
				else:
					self._location = value
			else:
				self._location = value
		return property(**locals())

	@apply
	def itemreference():
		def fget( self ):
			return self._itemreference
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._itemreference = ifcidentifier(value)
				else:
					self._itemreference = value
			else:
				self._itemreference = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((EXISTS(self.itemreference)  or  EXISTS(self.location))  or  EXISTS(self.name))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcclassificationreference #
####################
class ifcclassificationreference(ifcexternalreference):
	'''Entity ifcclassificationreference definition.

	:param referencedsource
	:type referencedsource:ifcclassification
	'''
	def __init__( self , inherited0__location , inherited1__itemreference , inherited2__name , referencedsource, ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__itemreference , inherited2__name , )
		self.referencedsource = referencedsource

	@apply
	def referencedsource():
		def fget( self ):
			return self._referencedsource
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcclassification):
					self._referencedsource = ifcclassification(value)
				else:
					self._referencedsource = value
			else:
				self._referencedsource = value
		return property(**locals())

####################
 # ENTITY ifcderivedunitelement #
####################
class ifcderivedunitelement(BaseEntityClass):
	'''Entity ifcderivedunitelement definition.

	:param unit
	:type unit:ifcnamedunit

	:param exponent
	:type exponent:INTEGER
	'''
	def __init__( self , unit,exponent, ):
		self.unit = unit
		self.exponent = exponent

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unit is mantatory and can not be set to None')
			if not check_type(value,ifcnamedunit):
				self._unit = ifcnamedunit(value)
			else:
				self._unit = value
		return property(**locals())

	@apply
	def exponent():
		def fget( self ):
			return self._exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument exponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._exponent = INTEGER(value)
			else:
				self._exponent = value
		return property(**locals())

####################
 # ENTITY ifcbuildingelement #
####################
class ifcbuildingelement(ifcelement):
	'''Entity ifcbuildingelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcrailing #
####################
class ifcrailing(ifcbuildingelement):
	'''Entity ifcrailing definition.

	:param predefinedtype
	:type predefinedtype:ifcrailingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrailingtypeenum):
					self._predefinedtype = ifcrailingtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr61(self):
		eval_wr61_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcrailingtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcrailingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_wr61_wr:
			raise AssertionError('Rule wr61 violated')
		else:
			return eval_wr61_wr


####################
 # ENTITY ifccurrencyrelationship #
####################
class ifccurrencyrelationship(BaseEntityClass):
	'''Entity ifccurrencyrelationship definition.

	:param relatingmonetaryunit
	:type relatingmonetaryunit:ifcmonetaryunit

	:param relatedmonetaryunit
	:type relatedmonetaryunit:ifcmonetaryunit

	:param exchangerate
	:type exchangerate:ifcpositiveratiomeasure

	:param ratedatetime
	:type ratedatetime:ifcdateandtime

	:param ratesource
	:type ratesource:ifclibraryinformation
	'''
	def __init__( self , relatingmonetaryunit,relatedmonetaryunit,exchangerate,ratedatetime,ratesource, ):
		self.relatingmonetaryunit = relatingmonetaryunit
		self.relatedmonetaryunit = relatedmonetaryunit
		self.exchangerate = exchangerate
		self.ratedatetime = ratedatetime
		self.ratesource = ratesource

	@apply
	def relatingmonetaryunit():
		def fget( self ):
			return self._relatingmonetaryunit
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingmonetaryunit is mantatory and can not be set to None')
			if not check_type(value,ifcmonetaryunit):
				self._relatingmonetaryunit = ifcmonetaryunit(value)
			else:
				self._relatingmonetaryunit = value
		return property(**locals())

	@apply
	def relatedmonetaryunit():
		def fget( self ):
			return self._relatedmonetaryunit
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedmonetaryunit is mantatory and can not be set to None')
			if not check_type(value,ifcmonetaryunit):
				self._relatedmonetaryunit = ifcmonetaryunit(value)
			else:
				self._relatedmonetaryunit = value
		return property(**locals())

	@apply
	def exchangerate():
		def fget( self ):
			return self._exchangerate
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument exchangerate is mantatory and can not be set to None')
			if not check_type(value,ifcpositiveratiomeasure):
				self._exchangerate = ifcpositiveratiomeasure(value)
			else:
				self._exchangerate = value
		return property(**locals())

	@apply
	def ratedatetime():
		def fget( self ):
			return self._ratedatetime
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ratedatetime is mantatory and can not be set to None')
			if not check_type(value,ifcdateandtime):
				self._ratedatetime = ifcdateandtime(value)
			else:
				self._ratedatetime = value
		return property(**locals())

	@apply
	def ratesource():
		def fget( self ):
			return self._ratesource
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclibraryinformation):
					self._ratesource = ifclibraryinformation(value)
				else:
					self._ratesource = value
			else:
				self._ratesource = value
		return property(**locals())

####################
 # ENTITY ifcmaterial #
####################
class ifcmaterial(BaseEntityClass):
	'''Entity ifcmaterial definition.

	:param name
	:type name:ifclabel

	:param hasrepresentation
	:type hasrepresentation:SET(0,1,'ifcmaterialdefinitionrepresentation', scope = schema_scope)

	:param classifiedas
	:type classifiedas:SET(0,1,'ifcmaterialclassificationrelationship', scope = schema_scope)
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def hasrepresentation():
		def fget( self ):
			return self._hasrepresentation
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasrepresentation is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def classifiedas():
		def fget( self ):
			return self._classifiedas
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument classifiedas is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcmember #
####################
class ifcmember(ifcbuildingelement):
	'''Entity ifcmember definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcprofileproperties #
####################
class ifcprofileproperties(BaseEntityClass):
	'''Entity ifcprofileproperties definition.

	:param profilename
	:type profilename:ifclabel

	:param profiledefinition
	:type profiledefinition:ifcprofiledef
	'''
	def __init__( self , profilename,profiledefinition, ):
		self.profilename = profilename
		self.profiledefinition = profiledefinition

	@apply
	def profilename():
		def fget( self ):
			return self._profilename
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._profilename = ifclabel(value)
				else:
					self._profilename = value
			else:
				self._profilename = value
		return property(**locals())

	@apply
	def profiledefinition():
		def fget( self ):
			return self._profiledefinition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcprofiledef):
					self._profiledefinition = ifcprofiledef(value)
				else:
					self._profiledefinition = value
			else:
				self._profiledefinition = value
		return property(**locals())

####################
 # ENTITY ifcgeneralprofileproperties #
####################
class ifcgeneralprofileproperties(ifcprofileproperties):
	'''Entity ifcgeneralprofileproperties definition.

	:param physicalweight
	:type physicalweight:ifcmassperlengthmeasure

	:param perimeter
	:type perimeter:ifcpositivelengthmeasure

	:param minimumplatethickness
	:type minimumplatethickness:ifcpositivelengthmeasure

	:param maximumplatethickness
	:type maximumplatethickness:ifcpositivelengthmeasure

	:param crosssectionarea
	:type crosssectionarea:ifcareameasure
	'''
	def __init__( self , inherited0__profilename , inherited1__profiledefinition , physicalweight,perimeter,minimumplatethickness,maximumplatethickness,crosssectionarea, ):
		ifcprofileproperties.__init__(self , inherited0__profilename , inherited1__profiledefinition , )
		self.physicalweight = physicalweight
		self.perimeter = perimeter
		self.minimumplatethickness = minimumplatethickness
		self.maximumplatethickness = maximumplatethickness
		self.crosssectionarea = crosssectionarea

	@apply
	def physicalweight():
		def fget( self ):
			return self._physicalweight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmassperlengthmeasure):
					self._physicalweight = ifcmassperlengthmeasure(value)
				else:
					self._physicalweight = value
			else:
				self._physicalweight = value
		return property(**locals())

	@apply
	def perimeter():
		def fget( self ):
			return self._perimeter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._perimeter = ifcpositivelengthmeasure(value)
				else:
					self._perimeter = value
			else:
				self._perimeter = value
		return property(**locals())

	@apply
	def minimumplatethickness():
		def fget( self ):
			return self._minimumplatethickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._minimumplatethickness = ifcpositivelengthmeasure(value)
				else:
					self._minimumplatethickness = value
			else:
				self._minimumplatethickness = value
		return property(**locals())

	@apply
	def maximumplatethickness():
		def fget( self ):
			return self._maximumplatethickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._maximumplatethickness = ifcpositivelengthmeasure(value)
				else:
					self._maximumplatethickness = value
			else:
				self._maximumplatethickness = value
		return property(**locals())

	@apply
	def crosssectionarea():
		def fget( self ):
			return self._crosssectionarea
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._crosssectionarea = ifcareameasure(value)
				else:
					self._crosssectionarea = value
			else:
				self._crosssectionarea = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not EXISTS(self.crosssectionarea))  or  (self.crosssectionarea  >  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcstructuralprofileproperties #
####################
class ifcstructuralprofileproperties(ifcgeneralprofileproperties):
	'''Entity ifcstructuralprofileproperties definition.

	:param torsionalconstantx
	:type torsionalconstantx:ifcmomentofinertiameasure

	:param momentofinertiayz
	:type momentofinertiayz:ifcmomentofinertiameasure

	:param momentofinertiay
	:type momentofinertiay:ifcmomentofinertiameasure

	:param momentofinertiaz
	:type momentofinertiaz:ifcmomentofinertiameasure

	:param warpingconstant
	:type warpingconstant:ifcwarpingconstantmeasure

	:param shearcentrez
	:type shearcentrez:ifclengthmeasure

	:param shearcentrey
	:type shearcentrey:ifclengthmeasure

	:param sheardeformationareaz
	:type sheardeformationareaz:ifcareameasure

	:param sheardeformationareay
	:type sheardeformationareay:ifcareameasure

	:param maximumsectionmodulusy
	:type maximumsectionmodulusy:ifcsectionmodulusmeasure

	:param minimumsectionmodulusy
	:type minimumsectionmodulusy:ifcsectionmodulusmeasure

	:param maximumsectionmodulusz
	:type maximumsectionmodulusz:ifcsectionmodulusmeasure

	:param minimumsectionmodulusz
	:type minimumsectionmodulusz:ifcsectionmodulusmeasure

	:param torsionalsectionmodulus
	:type torsionalsectionmodulus:ifcsectionmodulusmeasure

	:param centreofgravityinx
	:type centreofgravityinx:ifclengthmeasure

	:param centreofgravityiny
	:type centreofgravityiny:ifclengthmeasure
	'''
	def __init__( self , inherited0__profilename , inherited1__profiledefinition , inherited2__physicalweight , inherited3__perimeter , inherited4__minimumplatethickness , inherited5__maximumplatethickness , inherited6__crosssectionarea , torsionalconstantx,momentofinertiayz,momentofinertiay,momentofinertiaz,warpingconstant,shearcentrez,shearcentrey,sheardeformationareaz,sheardeformationareay,maximumsectionmodulusy,minimumsectionmodulusy,maximumsectionmodulusz,minimumsectionmodulusz,torsionalsectionmodulus,centreofgravityinx,centreofgravityiny, ):
		ifcgeneralprofileproperties.__init__(self , inherited0__profilename , inherited1__profiledefinition , inherited2__physicalweight , inherited3__perimeter , inherited4__minimumplatethickness , inherited5__maximumplatethickness , inherited6__crosssectionarea , )
		self.torsionalconstantx = torsionalconstantx
		self.momentofinertiayz = momentofinertiayz
		self.momentofinertiay = momentofinertiay
		self.momentofinertiaz = momentofinertiaz
		self.warpingconstant = warpingconstant
		self.shearcentrez = shearcentrez
		self.shearcentrey = shearcentrey
		self.sheardeformationareaz = sheardeformationareaz
		self.sheardeformationareay = sheardeformationareay
		self.maximumsectionmodulusy = maximumsectionmodulusy
		self.minimumsectionmodulusy = minimumsectionmodulusy
		self.maximumsectionmodulusz = maximumsectionmodulusz
		self.minimumsectionmodulusz = minimumsectionmodulusz
		self.torsionalsectionmodulus = torsionalsectionmodulus
		self.centreofgravityinx = centreofgravityinx
		self.centreofgravityiny = centreofgravityiny

	@apply
	def torsionalconstantx():
		def fget( self ):
			return self._torsionalconstantx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmomentofinertiameasure):
					self._torsionalconstantx = ifcmomentofinertiameasure(value)
				else:
					self._torsionalconstantx = value
			else:
				self._torsionalconstantx = value
		return property(**locals())

	@apply
	def momentofinertiayz():
		def fget( self ):
			return self._momentofinertiayz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmomentofinertiameasure):
					self._momentofinertiayz = ifcmomentofinertiameasure(value)
				else:
					self._momentofinertiayz = value
			else:
				self._momentofinertiayz = value
		return property(**locals())

	@apply
	def momentofinertiay():
		def fget( self ):
			return self._momentofinertiay
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmomentofinertiameasure):
					self._momentofinertiay = ifcmomentofinertiameasure(value)
				else:
					self._momentofinertiay = value
			else:
				self._momentofinertiay = value
		return property(**locals())

	@apply
	def momentofinertiaz():
		def fget( self ):
			return self._momentofinertiaz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmomentofinertiameasure):
					self._momentofinertiaz = ifcmomentofinertiameasure(value)
				else:
					self._momentofinertiaz = value
			else:
				self._momentofinertiaz = value
		return property(**locals())

	@apply
	def warpingconstant():
		def fget( self ):
			return self._warpingconstant
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcwarpingconstantmeasure):
					self._warpingconstant = ifcwarpingconstantmeasure(value)
				else:
					self._warpingconstant = value
			else:
				self._warpingconstant = value
		return property(**locals())

	@apply
	def shearcentrez():
		def fget( self ):
			return self._shearcentrez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._shearcentrez = ifclengthmeasure(value)
				else:
					self._shearcentrez = value
			else:
				self._shearcentrez = value
		return property(**locals())

	@apply
	def shearcentrey():
		def fget( self ):
			return self._shearcentrey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._shearcentrey = ifclengthmeasure(value)
				else:
					self._shearcentrey = value
			else:
				self._shearcentrey = value
		return property(**locals())

	@apply
	def sheardeformationareaz():
		def fget( self ):
			return self._sheardeformationareaz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._sheardeformationareaz = ifcareameasure(value)
				else:
					self._sheardeformationareaz = value
			else:
				self._sheardeformationareaz = value
		return property(**locals())

	@apply
	def sheardeformationareay():
		def fget( self ):
			return self._sheardeformationareay
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._sheardeformationareay = ifcareameasure(value)
				else:
					self._sheardeformationareay = value
			else:
				self._sheardeformationareay = value
		return property(**locals())

	@apply
	def maximumsectionmodulusy():
		def fget( self ):
			return self._maximumsectionmodulusy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsectionmodulusmeasure):
					self._maximumsectionmodulusy = ifcsectionmodulusmeasure(value)
				else:
					self._maximumsectionmodulusy = value
			else:
				self._maximumsectionmodulusy = value
		return property(**locals())

	@apply
	def minimumsectionmodulusy():
		def fget( self ):
			return self._minimumsectionmodulusy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsectionmodulusmeasure):
					self._minimumsectionmodulusy = ifcsectionmodulusmeasure(value)
				else:
					self._minimumsectionmodulusy = value
			else:
				self._minimumsectionmodulusy = value
		return property(**locals())

	@apply
	def maximumsectionmodulusz():
		def fget( self ):
			return self._maximumsectionmodulusz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsectionmodulusmeasure):
					self._maximumsectionmodulusz = ifcsectionmodulusmeasure(value)
				else:
					self._maximumsectionmodulusz = value
			else:
				self._maximumsectionmodulusz = value
		return property(**locals())

	@apply
	def minimumsectionmodulusz():
		def fget( self ):
			return self._minimumsectionmodulusz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsectionmodulusmeasure):
					self._minimumsectionmodulusz = ifcsectionmodulusmeasure(value)
				else:
					self._minimumsectionmodulusz = value
			else:
				self._minimumsectionmodulusz = value
		return property(**locals())

	@apply
	def torsionalsectionmodulus():
		def fget( self ):
			return self._torsionalsectionmodulus
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsectionmodulusmeasure):
					self._torsionalsectionmodulus = ifcsectionmodulusmeasure(value)
				else:
					self._torsionalsectionmodulus = value
			else:
				self._torsionalsectionmodulus = value
		return property(**locals())

	@apply
	def centreofgravityinx():
		def fget( self ):
			return self._centreofgravityinx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._centreofgravityinx = ifclengthmeasure(value)
				else:
					self._centreofgravityinx = value
			else:
				self._centreofgravityinx = value
		return property(**locals())

	@apply
	def centreofgravityiny():
		def fget( self ):
			return self._centreofgravityiny
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._centreofgravityiny = ifclengthmeasure(value)
				else:
					self._centreofgravityiny = value
			else:
				self._centreofgravityiny = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.sheardeformationareay))  or  (self.sheardeformationareay  >=  0))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (( not EXISTS(self.sheardeformationareaz))  or  (self.sheardeformationareaz  >=  0))
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcpropertyconstraintrelationship #
####################
class ifcpropertyconstraintrelationship(BaseEntityClass):
	'''Entity ifcpropertyconstraintrelationship definition.

	:param relatingconstraint
	:type relatingconstraint:ifcconstraint

	:param relatedproperties
	:type relatedproperties:SET(1,None,'ifcproperty', scope = schema_scope)

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext
	'''
	def __init__( self , relatingconstraint,relatedproperties,name,description, ):
		self.relatingconstraint = relatingconstraint
		self.relatedproperties = relatedproperties
		self.name = name
		self.description = description

	@apply
	def relatingconstraint():
		def fget( self ):
			return self._relatingconstraint
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingconstraint is mantatory and can not be set to None')
			if not check_type(value,ifcconstraint):
				self._relatingconstraint = ifcconstraint(value)
			else:
				self._relatingconstraint = value
		return property(**locals())

	@apply
	def relatedproperties():
		def fget( self ):
			return self._relatedproperties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedproperties is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproperty', scope = schema_scope)):
				self._relatedproperties = SET(value)
			else:
				self._relatedproperties = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY ifccurve #
####################
class ifccurve(ifcgeometricrepresentationitem):
	'''Entity ifccurve definition.

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self ,  ):
		ifcgeometricrepresentationitem.__init__(self , )

	@apply
	def dim():
		def fget( self ):
			attribute_eval = ifccurvedim(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcboundedcurve #
####################
class ifcboundedcurve(ifccurve):
	'''Entity ifcboundedcurve definition.
	'''
	def __init__( self ,  ):
		ifccurve.__init__(self , )

####################
 # ENTITY ifcbsplinecurve #
####################
class ifcbsplinecurve(ifcboundedcurve):
	'''Entity ifcbsplinecurve definition.

	:param degree
	:type degree:INTEGER

	:param controlpointslist
	:type controlpointslist:LIST(2,None,'ifccartesianpoint', scope = schema_scope)

	:param curveform
	:type curveform:ifcbsplinecurveform

	:param closedcurve
	:type closedcurve:LOGICAL

	:param selfintersect
	:type selfintersect:LOGICAL

	:param controlpoints
	:type controlpoints:ARRAY(0,255,'ifccartesianpoint', scope = schema_scope)

	:param upperindexoncontrolpoints
	:type upperindexoncontrolpoints:INTEGER
	'''
	def __init__( self , degree,controlpointslist,curveform,closedcurve,selfintersect, ):
		ifcboundedcurve.__init__(self , )
		self.degree = degree
		self.controlpointslist = controlpointslist
		self.curveform = curveform
		self.closedcurve = closedcurve
		self.selfintersect = selfintersect

	@apply
	def degree():
		def fget( self ):
			return self._degree
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument degree is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._degree = INTEGER(value)
			else:
				self._degree = value
		return property(**locals())

	@apply
	def controlpointslist():
		def fget( self ):
			return self._controlpointslist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument controlpointslist is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'ifccartesianpoint', scope = schema_scope)):
				self._controlpointslist = LIST(value)
			else:
				self._controlpointslist = value
		return property(**locals())

	@apply
	def curveform():
		def fget( self ):
			return self._curveform
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curveform is mantatory and can not be set to None')
			if not check_type(value,ifcbsplinecurveform):
				self._curveform = ifcbsplinecurveform(value)
			else:
				self._curveform = value
		return property(**locals())

	@apply
	def closedcurve():
		def fget( self ):
			return self._closedcurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument closedcurve is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._closedcurve = LOGICAL(value)
			else:
				self._closedcurve = value
		return property(**locals())

	@apply
	def selfintersect():
		def fget( self ):
			return self._selfintersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument selfintersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._selfintersect = LOGICAL(value)
			else:
				self._selfintersect = value
		return property(**locals())

	@apply
	def controlpoints():
		def fget( self ):
			attribute_eval = ifclisttoarray(self.controlpointslist,0,self.upperindexoncontrolpoints)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument controlpoints is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def upperindexoncontrolpoints():
		def fget( self ):
			attribute_eval = (SIZEOF(self.controlpointslist) - 1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument upperindexoncontrolpoints is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = (SIZEOF(None)  ==  0)
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr


####################
 # ENTITY ifcbeziercurve #
####################
class ifcbeziercurve(ifcbsplinecurve):
	'''Entity ifcbeziercurve definition.
	'''
	def __init__( self , inherited0__degree , inherited1__controlpointslist , inherited2__curveform , inherited3__closedcurve , inherited4__selfintersect ,  ):
		ifcbsplinecurve.__init__(self , inherited0__degree , inherited1__controlpointslist , inherited2__curveform , inherited3__closedcurve , inherited4__selfintersect , )

####################
 # ENTITY ifcrationalbeziercurve #
####################
class ifcrationalbeziercurve(ifcbeziercurve):
	'''Entity ifcrationalbeziercurve definition.

	:param weightsdata
	:type weightsdata:LIST(2,None,'REAL', scope = schema_scope)

	:param weights
	:type weights:ARRAY(0,255,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__degree , inherited1__controlpointslist , inherited2__curveform , inherited3__closedcurve , inherited4__selfintersect , weightsdata, ):
		ifcbeziercurve.__init__(self , inherited0__degree , inherited1__controlpointslist , inherited2__curveform , inherited3__closedcurve , inherited4__selfintersect , )
		self.weightsdata = weightsdata

	@apply
	def weightsdata():
		def fget( self ):
			return self._weightsdata
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument weightsdata is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._weightsdata = LIST(value)
			else:
				self._weightsdata = value
		return property(**locals())

	@apply
	def weights():
		def fget( self ):
			attribute_eval = ifclisttoarray(self.weightsdata,0,self.self.ifcbsplinecurve.self.upperindexoncontrolpoints)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument weights is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.weightsdata)  ==  SIZEOF(self.self.ifcbsplinecurve.self.controlpointslist))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ifccurveweightspositive(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcgroup #
####################
class ifcgroup(ifcobject):
	'''Entity ifcgroup definition.

	:param isgroupedby
	:type isgroupedby:ifcrelassignstogroup
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

	@apply
	def isgroupedby():
		def fget( self ):
			return self._isgroupedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isgroupedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcsystem #
####################
class ifcsystem(ifcgroup):
	'''Entity ifcsystem definition.

	:param servicesbuildings
	:type servicesbuildings:SET(0,1,'ifcrelservicesbuildings', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

	@apply
	def servicesbuildings():
		def fget( self ):
			return self._servicesbuildings
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument servicesbuildings is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcannotationfillarea #
####################
class ifcannotationfillarea(ifcgeometricrepresentationitem):
	'''Entity ifcannotationfillarea definition.

	:param outerboundary
	:type outerboundary:ifccurve

	:param innerboundaries
	:type innerboundaries:SET(1,None,'ifccurve', scope = schema_scope)
	'''
	def __init__( self , outerboundary,innerboundaries, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.outerboundary = outerboundary
		self.innerboundaries = innerboundaries

	@apply
	def outerboundary():
		def fget( self ):
			return self._outerboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outerboundary is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._outerboundary = ifccurve(value)
			else:
				self._outerboundary = value
		return property(**locals())

	@apply
	def innerboundaries():
		def fget( self ):
			return self._innerboundaries
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifccurve', scope = schema_scope)):
					self._innerboundaries = SET(value)
				else:
					self._innerboundaries = value
			else:
				self._innerboundaries = value
		return property(**locals())

####################
 # ENTITY ifcelectricalcircuit #
####################
class ifcelectricalcircuit(ifcsystem):
	'''Entity ifcelectricalcircuit definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifcsystem.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

####################
 # ENTITY ifcdoorpanelproperties #
####################
class ifcdoorpanelproperties(ifcpropertysetdefinition):
	'''Entity ifcdoorpanelproperties definition.

	:param paneldepth
	:type paneldepth:ifcpositivelengthmeasure

	:param paneloperation
	:type paneloperation:ifcdoorpaneloperationenum

	:param panelwidth
	:type panelwidth:ifcnormalisedratiomeasure

	:param panelposition
	:type panelposition:ifcdoorpanelpositionenum

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , paneldepth,paneloperation,panelwidth,panelposition,shapeaspectstyle, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.paneldepth = paneldepth
		self.paneloperation = paneloperation
		self.panelwidth = panelwidth
		self.panelposition = panelposition
		self.shapeaspectstyle = shapeaspectstyle

	@apply
	def paneldepth():
		def fget( self ):
			return self._paneldepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._paneldepth = ifcpositivelengthmeasure(value)
				else:
					self._paneldepth = value
			else:
				self._paneldepth = value
		return property(**locals())

	@apply
	def paneloperation():
		def fget( self ):
			return self._paneloperation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument paneloperation is mantatory and can not be set to None')
			if not check_type(value,ifcdoorpaneloperationenum):
				self._paneloperation = ifcdoorpaneloperationenum(value)
			else:
				self._paneloperation = value
		return property(**locals())

	@apply
	def panelwidth():
		def fget( self ):
			return self._panelwidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._panelwidth = ifcnormalisedratiomeasure(value)
				else:
					self._panelwidth = value
			else:
				self._panelwidth = value
		return property(**locals())

	@apply
	def panelposition():
		def fget( self ):
			return self._panelposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument panelposition is mantatory and can not be set to None')
			if not check_type(value,ifcdoorpanelpositionenum):
				self._panelposition = ifcdoorpanelpositionenum(value)
			else:
				self._panelposition = value
		return property(**locals())

	@apply
	def shapeaspectstyle():
		def fget( self ):
			return self._shapeaspectstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshapeaspect):
					self._shapeaspectstyle = ifcshapeaspect(value)
				else:
					self._shapeaspectstyle = value
			else:
				self._shapeaspectstyle = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (EXISTS(self.self.ifcpropertysetdefinition.self.definestype[1])  and  ('IFC2X3.IFCDOORSTYLE'  ==  TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1])))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcpermeablecoveringproperties #
####################
class ifcpermeablecoveringproperties(ifcpropertysetdefinition):
	'''Entity ifcpermeablecoveringproperties definition.

	:param operationtype
	:type operationtype:ifcpermeablecoveringoperationenum

	:param panelposition
	:type panelposition:ifcwindowpanelpositionenum

	:param framedepth
	:type framedepth:ifcpositivelengthmeasure

	:param framethickness
	:type framethickness:ifcpositivelengthmeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , operationtype,panelposition,framedepth,framethickness,shapeaspectstyle, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.operationtype = operationtype
		self.panelposition = panelposition
		self.framedepth = framedepth
		self.framethickness = framethickness
		self.shapeaspectstyle = shapeaspectstyle

	@apply
	def operationtype():
		def fget( self ):
			return self._operationtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operationtype is mantatory and can not be set to None')
			if not check_type(value,ifcpermeablecoveringoperationenum):
				self._operationtype = ifcpermeablecoveringoperationenum(value)
			else:
				self._operationtype = value
		return property(**locals())

	@apply
	def panelposition():
		def fget( self ):
			return self._panelposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument panelposition is mantatory and can not be set to None')
			if not check_type(value,ifcwindowpanelpositionenum):
				self._panelposition = ifcwindowpanelpositionenum(value)
			else:
				self._panelposition = value
		return property(**locals())

	@apply
	def framedepth():
		def fget( self ):
			return self._framedepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._framedepth = ifcpositivelengthmeasure(value)
				else:
					self._framedepth = value
			else:
				self._framedepth = value
		return property(**locals())

	@apply
	def framethickness():
		def fget( self ):
			return self._framethickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._framethickness = ifcpositivelengthmeasure(value)
				else:
					self._framethickness = value
			else:
				self._framethickness = value
		return property(**locals())

	@apply
	def shapeaspectstyle():
		def fget( self ):
			return self._shapeaspectstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshapeaspect):
					self._shapeaspectstyle = ifcshapeaspect(value)
				else:
					self._shapeaspectstyle = value
			else:
				self._shapeaspectstyle = value
		return property(**locals())

####################
 # ENTITY ifcservicelifefactor #
####################
class ifcservicelifefactor(ifcpropertysetdefinition):
	'''Entity ifcservicelifefactor definition.

	:param predefinedtype
	:type predefinedtype:ifcservicelifefactortypeenum

	:param uppervalue
	:type uppervalue:ifcmeasurevalue

	:param mostusedvalue
	:type mostusedvalue:ifcmeasurevalue

	:param lowervalue
	:type lowervalue:ifcmeasurevalue
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , predefinedtype,uppervalue,mostusedvalue,lowervalue, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.predefinedtype = predefinedtype
		self.uppervalue = uppervalue
		self.mostusedvalue = mostusedvalue
		self.lowervalue = lowervalue

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcservicelifefactortypeenum):
				self._predefinedtype = ifcservicelifefactortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def uppervalue():
		def fget( self ):
			return self._uppervalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmeasurevalue):
					self._uppervalue = ifcmeasurevalue(value)
				else:
					self._uppervalue = value
			else:
				self._uppervalue = value
		return property(**locals())

	@apply
	def mostusedvalue():
		def fget( self ):
			return self._mostusedvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mostusedvalue is mantatory and can not be set to None')
			if not check_type(value,ifcmeasurevalue):
				self._mostusedvalue = ifcmeasurevalue(value)
			else:
				self._mostusedvalue = value
		return property(**locals())

	@apply
	def lowervalue():
		def fget( self ):
			return self._lowervalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmeasurevalue):
					self._lowervalue = ifcmeasurevalue(value)
				else:
					self._lowervalue = value
			else:
				self._lowervalue = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (( not (self.predefinedtype  ==  ifcservicelifefactortypeenum.self.userdefined))  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcflowcontrollertype #
####################
class ifcflowcontrollertype(ifcdistributionflowelementtype):
	'''Entity ifcflowcontrollertype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcvalvetype #
####################
class ifcvalvetype(ifcflowcontrollertype):
	'''Entity ifcvalvetype definition.

	:param predefinedtype
	:type predefinedtype:ifcvalvetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcvalvetypeenum):
				self._predefinedtype = ifcvalvetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcvalvetypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcvalvetypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcsolidmodel #
####################
class ifcsolidmodel(ifcgeometricrepresentationitem):
	'''Entity ifcsolidmodel definition.

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self ,  ):
		ifcgeometricrepresentationitem.__init__(self , )

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcsweptareasolid #
####################
class ifcsweptareasolid(ifcsolidmodel):
	'''Entity ifcsweptareasolid definition.

	:param sweptarea
	:type sweptarea:ifcprofiledef

	:param position
	:type position:ifcaxis2placement3d
	'''
	def __init__( self , sweptarea,position, ):
		ifcsolidmodel.__init__(self , )
		self.sweptarea = sweptarea
		self.position = position

	@apply
	def sweptarea():
		def fget( self ):
			return self._sweptarea
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sweptarea is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._sweptarea = ifcprofiledef(value)
			else:
				self._sweptarea = value
		return property(**locals())

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement3d):
				self._position = ifcaxis2placement3d(value)
			else:
				self._position = value
		return property(**locals())
	def wr22(self):
		eval_wr22_wr = (self.sweptarea.self.profiletype  ==  ifcprofiletypeenum.self.area)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcrevolvedareasolid #
####################
class ifcrevolvedareasolid(ifcsweptareasolid):
	'''Entity ifcrevolvedareasolid definition.

	:param axis
	:type axis:ifcaxis1placement

	:param angle
	:type angle:ifcplaneanglemeasure

	:param axisline
	:type axisline:ifcline
	'''
	def __init__( self , inherited0__sweptarea , inherited1__position , axis,angle, ):
		ifcsweptareasolid.__init__(self , inherited0__sweptarea , inherited1__position , )
		self.axis = axis
		self.angle = angle

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axis is mantatory and can not be set to None')
			if not check_type(value,ifcaxis1placement):
				self._axis = ifcaxis1placement(value)
			else:
				self._axis = value
		return property(**locals())

	@apply
	def angle():
		def fget( self ):
			return self._angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle is mantatory and can not be set to None')
			if not check_type(value,ifcplaneanglemeasure):
				self._angle = ifcplaneanglemeasure(value)
			else:
				self._angle = value
		return property(**locals())

	@apply
	def axisline():
		def fget( self ):
			attribute_eval = (((ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifccurve())  ==  ifcline(self.axis.self.location,(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(self.axis.self.z,1)))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument axisline is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (self.axis.self.location.self.coordinates[3]  ==  0)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = (self.axis.self.z.self.directionratios[3]  ==  0)
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr


####################
 # ENTITY ifctexturecoordinate #
####################
class ifctexturecoordinate(BaseEntityClass):
	'''Entity ifctexturecoordinate definition.

	:param annotatedsurface
	:type annotatedsurface:SET(1,1,'ifcannotationsurface', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def annotatedsurface():
		def fget( self ):
			return self._annotatedsurface
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument annotatedsurface is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifctexturemap #
####################
class ifctexturemap(ifctexturecoordinate):
	'''Entity ifctexturemap definition.

	:param texturemaps
	:type texturemaps:SET(1,None,'ifcvertexbasedtexturemap', scope = schema_scope)
	'''
	def __init__( self , texturemaps, ):
		ifctexturecoordinate.__init__(self , )
		self.texturemaps = texturemaps

	@apply
	def texturemaps():
		def fget( self ):
			return self._texturemaps
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument texturemaps is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcvertexbasedtexturemap', scope = schema_scope)):
				self._texturemaps = SET(value)
			else:
				self._texturemaps = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (SIZEOF(['IFC2X3.IFCSHELLBASEDSURFACEMODEL','IFC2X3.IFCFACEBASEDSURFACEMODEL','IFC2X3.IFCFACETEDBREP','IFC2X3.IFCFACETEDBREPWITHVOIDS']  *  TYPEOF(self.self.ifctexturecoordinate.self.annotatedsurface[1].self.item))  >=  1)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcairterminalboxtype #
####################
class ifcairterminalboxtype(ifcflowcontrollertype):
	'''Entity ifcairterminalboxtype definition.

	:param predefinedtype
	:type predefinedtype:ifcairterminalboxtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcairterminalboxtypeenum):
				self._predefinedtype = ifcairterminalboxtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcairterminalboxtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcairterminalboxtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcboundarycondition #
####################
class ifcboundarycondition(BaseEntityClass):
	'''Entity ifcboundarycondition definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifcbuildingelementtype #
####################
class ifcbuildingelementtype(ifcelementtype):
	'''Entity ifcbuildingelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcbuildingelementproxytype #
####################
class ifcbuildingelementproxytype(ifcbuildingelementtype):
	'''Entity ifcbuildingelementproxytype definition.

	:param predefinedtype
	:type predefinedtype:ifcbuildingelementproxytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcbuildingelementproxytypeenum):
				self._predefinedtype = ifcbuildingelementproxytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcpresentationstyle #
####################
class ifcpresentationstyle(BaseEntityClass):
	'''Entity ifcpresentationstyle definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifcfillareastyle #
####################
class ifcfillareastyle(ifcpresentationstyle):
	'''Entity ifcfillareastyle definition.

	:param fillstyles
	:type fillstyles:SET(1,None,'ifcfillstyleselect', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , fillstyles, ):
		ifcpresentationstyle.__init__(self , inherited0__name , )
		self.fillstyles = fillstyles

	@apply
	def fillstyles():
		def fget( self ):
			return self._fillstyles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fillstyles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcfillstyleselect', scope = schema_scope)):
				self._fillstyles = SET(value)
			else:
				self._fillstyles = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  <=  1)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  <=  1)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = ifccorrectfillareastyle(self.self.fillstyles)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr


####################
 # ENTITY ifccsgsolid #
####################
class ifccsgsolid(ifcsolidmodel):
	'''Entity ifccsgsolid definition.

	:param treerootexpression
	:type treerootexpression:ifccsgselect
	'''
	def __init__( self , treerootexpression, ):
		ifcsolidmodel.__init__(self , )
		self.treerootexpression = treerootexpression

	@apply
	def treerootexpression():
		def fget( self ):
			return self._treerootexpression
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument treerootexpression is mantatory and can not be set to None')
			if not check_type(value,ifccsgselect):
				self._treerootexpression = ifccsgselect(value)
			else:
				self._treerootexpression = value
		return property(**locals())

####################
 # ENTITY ifcsurfacetexture #
####################
class ifcsurfacetexture(BaseEntityClass):
	'''Entity ifcsurfacetexture definition.

	:param repeats
	:type repeats:BOOLEAN

	:param repeatt
	:type repeatt:BOOLEAN

	:param texturetype
	:type texturetype:ifcsurfacetextureenum

	:param texturetransform
	:type texturetransform:ifccartesiantransformationoperator2d
	'''
	def __init__( self , repeats,repeatt,texturetype,texturetransform, ):
		self.repeats = repeats
		self.repeatt = repeatt
		self.texturetype = texturetype
		self.texturetransform = texturetransform

	@apply
	def repeats():
		def fget( self ):
			return self._repeats
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument repeats is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._repeats = BOOLEAN(value)
			else:
				self._repeats = value
		return property(**locals())

	@apply
	def repeatt():
		def fget( self ):
			return self._repeatt
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument repeatt is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._repeatt = BOOLEAN(value)
			else:
				self._repeatt = value
		return property(**locals())

	@apply
	def texturetype():
		def fget( self ):
			return self._texturetype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument texturetype is mantatory and can not be set to None')
			if not check_type(value,ifcsurfacetextureenum):
				self._texturetype = ifcsurfacetextureenum(value)
			else:
				self._texturetype = value
		return property(**locals())

	@apply
	def texturetransform():
		def fget( self ):
			return self._texturetransform
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccartesiantransformationoperator2d):
					self._texturetransform = ifccartesiantransformationoperator2d(value)
				else:
					self._texturetransform = value
			else:
				self._texturetransform = value
		return property(**locals())

####################
 # ENTITY ifcpixeltexture #
####################
class ifcpixeltexture(ifcsurfacetexture):
	'''Entity ifcpixeltexture definition.

	:param width
	:type width:ifcinteger

	:param height
	:type height:ifcinteger

	:param colourcomponents
	:type colourcomponents:ifcinteger

	:param pixel
	:type pixel:LIST(1,None,'(null)', scope = schema_scope)
	'''
	def __init__( self , inherited0__repeats , inherited1__repeatt , inherited2__texturetype , inherited3__texturetransform , width,height,colourcomponents,pixel, ):
		ifcsurfacetexture.__init__(self , inherited0__repeats , inherited1__repeatt , inherited2__texturetype , inherited3__texturetransform , )
		self.width = width
		self.height = height
		self.colourcomponents = colourcomponents
		self.pixel = pixel

	@apply
	def width():
		def fget( self ):
			return self._width
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument width is mantatory and can not be set to None')
			if not check_type(value,ifcinteger):
				self._width = ifcinteger(value)
			else:
				self._width = value
		return property(**locals())

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,ifcinteger):
				self._height = ifcinteger(value)
			else:
				self._height = value
		return property(**locals())

	@apply
	def colourcomponents():
		def fget( self ):
			return self._colourcomponents
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument colourcomponents is mantatory and can not be set to None')
			if not check_type(value,ifcinteger):
				self._colourcomponents = ifcinteger(value)
			else:
				self._colourcomponents = value
		return property(**locals())

	@apply
	def pixel():
		def fget( self ):
			return self._pixel
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pixel is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'(null)', scope = schema_scope)):
				self._pixel = LIST(value)
			else:
				self._pixel = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (self.width  >=  1)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.height  >=  1)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr

	def wr23(self):
		eval_wr23_wr = ((1  <=  self.colourcomponents)  and  (self.colourcomponents  <=  4))
		if not eval_wr23_wr:
			raise AssertionError('Rule wr23 violated')
		else:
			return eval_wr23_wr

	def wr24(self):
		eval_wr24_wr = (SIZEOF(self.pixel)  ==  (self.width  *  self.height))
		if not eval_wr24_wr:
			raise AssertionError('Rule wr24 violated')
		else:
			return eval_wr24_wr


####################
 # ENTITY ifcrelassociates #
####################
class ifcrelassociates(ifcrelationship):
	'''Entity ifcrelassociates definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcroot', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedobjects, ):
		ifcrelationship.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedobjects = relatedobjects

	@apply
	def relatedobjects():
		def fget( self ):
			return self._relatedobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcroot', scope = schema_scope)):
				self._relatedobjects = SET(value)
			else:
				self._relatedobjects = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (SIZEOF(None)  ==  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcreldecomposes #
####################
class ifcreldecomposes(ifcrelationship):
	'''Entity ifcreldecomposes definition.

	:param relatingobject
	:type relatingobject:ifcobjectdefinition

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobjectdefinition', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingobject,relatedobjects, ):
		ifcrelationship.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingobject = relatingobject
		self.relatedobjects = relatedobjects

	@apply
	def relatingobject():
		def fget( self ):
			return self._relatingobject
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingobject is mantatory and can not be set to None')
			if not check_type(value,ifcobjectdefinition):
				self._relatingobject = ifcobjectdefinition(value)
			else:
				self._relatingobject = value
		return property(**locals())

	@apply
	def relatedobjects():
		def fget( self ):
			return self._relatedobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcobjectdefinition', scope = schema_scope)):
				self._relatedobjects = SET(value)
			else:
				self._relatedobjects = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (SIZEOF(None)  ==  0)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcrelnests #
####################
class ifcrelnests(ifcreldecomposes):
	'''Entity ifcrelnests definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingobject , inherited5__relatedobjects ,  ):
		ifcreldecomposes.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingobject , inherited5__relatedobjects , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcspatialstructureelementtype #
####################
class ifcspatialstructureelementtype(ifcelementtype):
	'''Entity ifcspatialstructureelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcspacetype #
####################
class ifcspacetype(ifcspatialstructureelementtype):
	'''Entity ifcspacetype definition.

	:param predefinedtype
	:type predefinedtype:ifcspacetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcspatialstructureelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcspacetypeenum):
				self._predefinedtype = ifcspacetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcplacement #
####################
class ifcplacement(ifcgeometricrepresentationitem):
	'''Entity ifcplacement definition.

	:param location
	:type location:ifccartesianpoint

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , location, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.location = location

	@apply
	def location():
		def fget( self ):
			return self._location
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument location is mantatory and can not be set to None')
			if not check_type(value,ifccartesianpoint):
				self._location = ifccartesianpoint(value)
			else:
				self._location = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.location.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcaxis1placement #
####################
class ifcaxis1placement(ifcplacement):
	'''Entity ifcaxis1placement definition.

	:param axis
	:type axis:ifcdirection

	:param z
	:type z:ifcdirection
	'''
	def __init__( self , inherited0__location , axis, ):
		ifcplacement.__init__(self , inherited0__location , )
		self.axis = axis

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._axis = ifcdirection(value)
				else:
					self._axis = value
			else:
				self._axis = value
		return property(**locals())

	@apply
	def z():
		def fget( self ):
			attribute_eval = NVL(ifcnormalise(self.axis),(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,0,1]))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument z is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not EXISTS(self.axis))  or  (self.axis.self.dim  ==  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.ifcplacement.self.location.self.dim  ==  3)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcelectricgeneratortype #
####################
class ifcelectricgeneratortype(ifcenergyconversiondevicetype):
	'''Entity ifcelectricgeneratortype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricgeneratortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectricgeneratortypeenum):
				self._predefinedtype = ifcelectricgeneratortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcflowfittingtype #
####################
class ifcflowfittingtype(ifcdistributionflowelementtype):
	'''Entity ifcflowfittingtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcpipefittingtype #
####################
class ifcpipefittingtype(ifcflowfittingtype):
	'''Entity ifcpipefittingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcpipefittingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowfittingtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcpipefittingtypeenum):
				self._predefinedtype = ifcpipefittingtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcpipefittingtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcpipefittingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcstructuralconnection #
####################
class ifcstructuralconnection(ifcstructuralitem):
	'''Entity ifcstructuralconnection definition.

	:param appliedcondition
	:type appliedcondition:ifcboundarycondition

	:param connectsstructuralmembers
	:type connectsstructuralmembers:SET(1,None,'ifcrelconnectsstructuralmember', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , appliedcondition, ):
		ifcstructuralitem.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.appliedcondition = appliedcondition

	@apply
	def appliedcondition():
		def fget( self ):
			return self._appliedcondition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcboundarycondition):
					self._appliedcondition = ifcboundarycondition(value)
				else:
					self._appliedcondition = value
			else:
				self._appliedcondition = value
		return property(**locals())

	@apply
	def connectsstructuralmembers():
		def fget( self ):
			return self._connectsstructuralmembers
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectsstructuralmembers is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcfillareastyletilesymbolwithstyle #
####################
class ifcfillareastyletilesymbolwithstyle(ifcgeometricrepresentationitem):
	'''Entity ifcfillareastyletilesymbolwithstyle definition.

	:param symbol
	:type symbol:ifcannotationsymboloccurrence
	'''
	def __init__( self , symbol, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.symbol = symbol

	@apply
	def symbol():
		def fget( self ):
			return self._symbol
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument symbol is mantatory and can not be set to None')
			if not check_type(value,ifcannotationsymboloccurrence):
				self._symbol = ifcannotationsymboloccurrence(value)
			else:
				self._symbol = value
		return property(**locals())

####################
 # ENTITY ifcflowterminaltype #
####################
class ifcflowterminaltype(ifcdistributionflowelementtype):
	'''Entity ifcflowterminaltype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcwasteterminaltype #
####################
class ifcwasteterminaltype(ifcflowterminaltype):
	'''Entity ifcwasteterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcwasteterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcwasteterminaltypeenum):
				self._predefinedtype = ifcwasteterminaltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcdistributionelement #
####################
class ifcdistributionelement(ifcelement):
	'''Entity ifcdistributionelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcdistributioncontrolelement #
####################
class ifcdistributioncontrolelement(ifcdistributionelement):
	'''Entity ifcdistributioncontrolelement definition.

	:param controlelementid
	:type controlelementid:ifcidentifier

	:param assignedtoflowelement
	:type assignedtoflowelement:SET(0,1,'ifcrelflowcontrolelements', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , controlelementid, ):
		ifcdistributionelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.controlelementid = controlelementid

	@apply
	def controlelementid():
		def fget( self ):
			return self._controlelementid
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._controlelementid = ifcidentifier(value)
				else:
					self._controlelementid = value
			else:
				self._controlelementid = value
		return property(**locals())

	@apply
	def assignedtoflowelement():
		def fget( self ):
			return self._assignedtoflowelement
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument assignedtoflowelement is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcelementcomponenttype #
####################
class ifcelementcomponenttype(ifcelementtype):
	'''Entity ifcelementcomponenttype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcfastenertype #
####################
class ifcfastenertype(ifcelementcomponenttype):
	'''Entity ifcfastenertype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementcomponenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifclamptype #
####################
class ifclamptype(ifcflowterminaltype):
	'''Entity ifclamptype definition.

	:param predefinedtype
	:type predefinedtype:ifclamptypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifclamptypeenum):
				self._predefinedtype = ifclamptypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcpredefineditem #
####################
class ifcpredefineditem(BaseEntityClass):
	'''Entity ifcpredefineditem definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifctrimmedcurve #
####################
class ifctrimmedcurve(ifcboundedcurve):
	'''Entity ifctrimmedcurve definition.

	:param basiscurve
	:type basiscurve:ifccurve

	:param trim1
	:type trim1:SET(1,2,'ifctrimmingselect', scope = schema_scope)

	:param trim2
	:type trim2:SET(1,2,'ifctrimmingselect', scope = schema_scope)

	:param senseagreement
	:type senseagreement:BOOLEAN

	:param masterrepresentation
	:type masterrepresentation:ifctrimmingpreference
	'''
	def __init__( self , basiscurve,trim1,trim2,senseagreement,masterrepresentation, ):
		ifcboundedcurve.__init__(self , )
		self.basiscurve = basiscurve
		self.trim1 = trim1
		self.trim2 = trim2
		self.senseagreement = senseagreement
		self.masterrepresentation = masterrepresentation

	@apply
	def basiscurve():
		def fget( self ):
			return self._basiscurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basiscurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._basiscurve = ifccurve(value)
			else:
				self._basiscurve = value
		return property(**locals())

	@apply
	def trim1():
		def fget( self ):
			return self._trim1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument trim1 is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'ifctrimmingselect', scope = schema_scope)):
				self._trim1 = SET(value)
			else:
				self._trim1 = value
		return property(**locals())

	@apply
	def trim2():
		def fget( self ):
			return self._trim2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument trim2 is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'ifctrimmingselect', scope = schema_scope)):
				self._trim2 = SET(value)
			else:
				self._trim2 = value
		return property(**locals())

	@apply
	def senseagreement():
		def fget( self ):
			return self._senseagreement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument senseagreement is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._senseagreement = BOOLEAN(value)
			else:
				self._senseagreement = value
		return property(**locals())

	@apply
	def masterrepresentation():
		def fget( self ):
			return self._masterrepresentation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument masterrepresentation is mantatory and can not be set to None')
			if not check_type(value,ifctrimmingpreference):
				self._masterrepresentation = ifctrimmingpreference(value)
			else:
				self._masterrepresentation = value
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = ((HIINDEX(self.trim1)  ==  1)  or  (TYPEOF(self.trim1[1])  !=  TYPEOF(self.trim1[2])))
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr

	def wr42(self):
		eval_wr42_wr = ((HIINDEX(self.trim2)  ==  1)  or  (TYPEOF(self.trim2[1])  !=  TYPEOF(self.trim2[2])))
		if not eval_wr42_wr:
			raise AssertionError('Rule wr42 violated')
		else:
			return eval_wr42_wr

	def wr43(self):
		eval_wr43_wr = ( not ('IFC2X3.IFCBOUNDEDCURVE'  ==  TYPEOF(self.basiscurve)))
		if not eval_wr43_wr:
			raise AssertionError('Rule wr43 violated')
		else:
			return eval_wr43_wr


####################
 # ENTITY ifcboundarynodecondition #
####################
class ifcboundarynodecondition(ifcboundarycondition):
	'''Entity ifcboundarynodecondition definition.

	:param linearstiffnessx
	:type linearstiffnessx:ifclinearstiffnessmeasure

	:param linearstiffnessy
	:type linearstiffnessy:ifclinearstiffnessmeasure

	:param linearstiffnessz
	:type linearstiffnessz:ifclinearstiffnessmeasure

	:param rotationalstiffnessx
	:type rotationalstiffnessx:ifcrotationalstiffnessmeasure

	:param rotationalstiffnessy
	:type rotationalstiffnessy:ifcrotationalstiffnessmeasure

	:param rotationalstiffnessz
	:type rotationalstiffnessz:ifcrotationalstiffnessmeasure
	'''
	def __init__( self , inherited0__name , linearstiffnessx,linearstiffnessy,linearstiffnessz,rotationalstiffnessx,rotationalstiffnessy,rotationalstiffnessz, ):
		ifcboundarycondition.__init__(self , inherited0__name , )
		self.linearstiffnessx = linearstiffnessx
		self.linearstiffnessy = linearstiffnessy
		self.linearstiffnessz = linearstiffnessz
		self.rotationalstiffnessx = rotationalstiffnessx
		self.rotationalstiffnessy = rotationalstiffnessy
		self.rotationalstiffnessz = rotationalstiffnessz

	@apply
	def linearstiffnessx():
		def fget( self ):
			return self._linearstiffnessx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearstiffnessmeasure):
					self._linearstiffnessx = ifclinearstiffnessmeasure(value)
				else:
					self._linearstiffnessx = value
			else:
				self._linearstiffnessx = value
		return property(**locals())

	@apply
	def linearstiffnessy():
		def fget( self ):
			return self._linearstiffnessy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearstiffnessmeasure):
					self._linearstiffnessy = ifclinearstiffnessmeasure(value)
				else:
					self._linearstiffnessy = value
			else:
				self._linearstiffnessy = value
		return property(**locals())

	@apply
	def linearstiffnessz():
		def fget( self ):
			return self._linearstiffnessz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearstiffnessmeasure):
					self._linearstiffnessz = ifclinearstiffnessmeasure(value)
				else:
					self._linearstiffnessz = value
			else:
				self._linearstiffnessz = value
		return property(**locals())

	@apply
	def rotationalstiffnessx():
		def fget( self ):
			return self._rotationalstiffnessx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrotationalstiffnessmeasure):
					self._rotationalstiffnessx = ifcrotationalstiffnessmeasure(value)
				else:
					self._rotationalstiffnessx = value
			else:
				self._rotationalstiffnessx = value
		return property(**locals())

	@apply
	def rotationalstiffnessy():
		def fget( self ):
			return self._rotationalstiffnessy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrotationalstiffnessmeasure):
					self._rotationalstiffnessy = ifcrotationalstiffnessmeasure(value)
				else:
					self._rotationalstiffnessy = value
			else:
				self._rotationalstiffnessy = value
		return property(**locals())

	@apply
	def rotationalstiffnessz():
		def fget( self ):
			return self._rotationalstiffnessz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcrotationalstiffnessmeasure):
					self._rotationalstiffnessz = ifcrotationalstiffnessmeasure(value)
				else:
					self._rotationalstiffnessz = value
			else:
				self._rotationalstiffnessz = value
		return property(**locals())

####################
 # ENTITY ifcboundarynodeconditionwarping #
####################
class ifcboundarynodeconditionwarping(ifcboundarynodecondition):
	'''Entity ifcboundarynodeconditionwarping definition.

	:param warpingstiffness
	:type warpingstiffness:ifcwarpingmomentmeasure
	'''
	def __init__( self , inherited0__name , inherited1__linearstiffnessx , inherited2__linearstiffnessy , inherited3__linearstiffnessz , inherited4__rotationalstiffnessx , inherited5__rotationalstiffnessy , inherited6__rotationalstiffnessz , warpingstiffness, ):
		ifcboundarynodecondition.__init__(self , inherited0__name , inherited1__linearstiffnessx , inherited2__linearstiffnessy , inherited3__linearstiffnessz , inherited4__rotationalstiffnessx , inherited5__rotationalstiffnessy , inherited6__rotationalstiffnessz , )
		self.warpingstiffness = warpingstiffness

	@apply
	def warpingstiffness():
		def fget( self ):
			return self._warpingstiffness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcwarpingmomentmeasure):
					self._warpingstiffness = ifcwarpingmomentmeasure(value)
				else:
					self._warpingstiffness = value
			else:
				self._warpingstiffness = value
		return property(**locals())

####################
 # ENTITY ifctopologicalrepresentationitem #
####################
class ifctopologicalrepresentationitem(ifcrepresentationitem):
	'''Entity ifctopologicalrepresentationitem definition.
	'''
	def __init__( self ,  ):
		ifcrepresentationitem.__init__(self , )

####################
 # ENTITY ifcedge #
####################
class ifcedge(ifctopologicalrepresentationitem):
	'''Entity ifcedge definition.

	:param edgestart
	:type edgestart:ifcvertex

	:param edgeend
	:type edgeend:ifcvertex
	'''
	def __init__( self , edgestart,edgeend, ):
		ifctopologicalrepresentationitem.__init__(self , )
		self.edgestart = edgestart
		self.edgeend = edgeend

	@apply
	def edgestart():
		def fget( self ):
			return self._edgestart
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgestart is mantatory and can not be set to None')
			if not check_type(value,ifcvertex):
				self._edgestart = ifcvertex(value)
			else:
				self._edgestart = value
		return property(**locals())

	@apply
	def edgeend():
		def fget( self ):
			return self._edgeend
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgeend is mantatory and can not be set to None')
			if not check_type(value,ifcvertex):
				self._edgeend = ifcvertex(value)
			else:
				self._edgeend = value
		return property(**locals())

####################
 # ENTITY ifcsubedge #
####################
class ifcsubedge(ifcedge):
	'''Entity ifcsubedge definition.

	:param parentedge
	:type parentedge:ifcedge
	'''
	def __init__( self , inherited0__edgestart , inherited1__edgeend , parentedge, ):
		ifcedge.__init__(self , inherited0__edgestart , inherited1__edgeend , )
		self.parentedge = parentedge

	@apply
	def parentedge():
		def fget( self ):
			return self._parentedge
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parentedge is mantatory and can not be set to None')
			if not check_type(value,ifcedge):
				self._parentedge = ifcedge(value)
			else:
				self._parentedge = value
		return property(**locals())

####################
 # ENTITY ifcairtoairheatrecoverytype #
####################
class ifcairtoairheatrecoverytype(ifcenergyconversiondevicetype):
	'''Entity ifcairtoairheatrecoverytype definition.

	:param predefinedtype
	:type predefinedtype:ifcairtoairheatrecoverytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcairtoairheatrecoverytypeenum):
				self._predefinedtype = ifcairtoairheatrecoverytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcairtoairheatrecoverytypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcairtoairheatrecoverytypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifccartesiantransformationoperator #
####################
class ifccartesiantransformationoperator(ifcgeometricrepresentationitem):
	'''Entity ifccartesiantransformationoperator definition.

	:param axis1
	:type axis1:ifcdirection

	:param axis2
	:type axis2:ifcdirection

	:param localorigin
	:type localorigin:ifccartesianpoint

	:param scale
	:type scale:REAL

	:param scl
	:type scl:REAL

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , axis1,axis2,localorigin,scale, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.axis1 = axis1
		self.axis2 = axis2
		self.localorigin = localorigin
		self.scale = scale

	@apply
	def axis1():
		def fget( self ):
			return self._axis1
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._axis1 = ifcdirection(value)
				else:
					self._axis1 = value
			else:
				self._axis1 = value
		return property(**locals())

	@apply
	def axis2():
		def fget( self ):
			return self._axis2
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._axis2 = ifcdirection(value)
				else:
					self._axis2 = value
			else:
				self._axis2 = value
		return property(**locals())

	@apply
	def localorigin():
		def fget( self ):
			return self._localorigin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument localorigin is mantatory and can not be set to None')
			if not check_type(value,ifccartesianpoint):
				self._localorigin = ifccartesianpoint(value)
			else:
				self._localorigin = value
		return property(**locals())

	@apply
	def scale():
		def fget( self ):
			return self._scale
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._scale = REAL(value)
				else:
					self._scale = value
			else:
				self._scale = value
		return property(**locals())

	@apply
	def scl():
		def fget( self ):
			attribute_eval = NVL(self.scale,1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scl is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.localorigin.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.scl  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifccartesiantransformationoperator3d #
####################
class ifccartesiantransformationoperator3d(ifccartesiantransformationoperator):
	'''Entity ifccartesiantransformationoperator3d definition.

	:param axis3
	:type axis3:ifcdirection

	:param u
	:type u:LIST(3,3,'ifcdirection', scope = schema_scope)
	'''
	def __init__( self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , axis3, ):
		ifccartesiantransformationoperator.__init__(self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , )
		self.axis3 = axis3

	@apply
	def axis3():
		def fget( self ):
			return self._axis3
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._axis3 = ifcdirection(value)
				else:
					self._axis3 = value
			else:
				self._axis3 = value
		return property(**locals())

	@apply
	def u():
		def fget( self ):
			attribute_eval = ifcbaseaxis(3,self.self.ifccartesiantransformationoperator.self.axis1,self.self.ifccartesiantransformationoperator.self.axis2,self.axis3)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument u is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.ifccartesiantransformationoperator.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.self.ifccartesiantransformationoperator.self.axis1))  or  (self.self.ifccartesiantransformationoperator.self.axis1.self.dim  ==  3))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not EXISTS(self.self.ifccartesiantransformationoperator.self.axis2))  or  (self.self.ifccartesiantransformationoperator.self.axis2.self.dim  ==  3))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not EXISTS(self.axis3))  or  (self.axis3.self.dim  ==  3))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY ifcconnectiongeometry #
####################
class ifcconnectiongeometry(BaseEntityClass):
	'''Entity ifcconnectiongeometry definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY ifcplanarextent #
####################
class ifcplanarextent(ifcgeometricrepresentationitem):
	'''Entity ifcplanarextent definition.

	:param sizeinx
	:type sizeinx:ifclengthmeasure

	:param sizeiny
	:type sizeiny:ifclengthmeasure
	'''
	def __init__( self , sizeinx,sizeiny, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.sizeinx = sizeinx
		self.sizeiny = sizeiny

	@apply
	def sizeinx():
		def fget( self ):
			return self._sizeinx
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sizeinx is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._sizeinx = ifclengthmeasure(value)
			else:
				self._sizeinx = value
		return property(**locals())

	@apply
	def sizeiny():
		def fget( self ):
			return self._sizeiny
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sizeiny is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._sizeiny = ifclengthmeasure(value)
			else:
				self._sizeiny = value
		return property(**locals())

####################
 # ENTITY ifcplanarbox #
####################
class ifcplanarbox(ifcplanarextent):
	'''Entity ifcplanarbox definition.

	:param placement
	:type placement:ifcaxis2placement
	'''
	def __init__( self , inherited0__sizeinx , inherited1__sizeiny , placement, ):
		ifcplanarextent.__init__(self , inherited0__sizeinx , inherited1__sizeiny , )
		self.placement = placement

	@apply
	def placement():
		def fget( self ):
			return self._placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placement is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._placement = ifcaxis2placement(value)
			else:
				self._placement = value
		return property(**locals())

####################
 # ENTITY ifcfooting #
####################
class ifcfooting(ifcbuildingelement):
	'''Entity ifcfooting definition.

	:param predefinedtype
	:type predefinedtype:ifcfootingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcfootingtypeenum):
				self._predefinedtype = ifcfootingtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcfootingtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcfootingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcpredefinedcolour #
####################
class ifcpredefinedcolour(ifcpredefineditem):
	'''Entity ifcpredefinedcolour definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefineditem.__init__(self , inherited0__name , )

####################
 # ENTITY ifcrelaggregates #
####################
class ifcrelaggregates(ifcreldecomposes):
	'''Entity ifcrelaggregates definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingobject , inherited5__relatedobjects ,  ):
		ifcreldecomposes.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingobject , inherited5__relatedobjects , )

####################
 # ENTITY ifcrelconnectsstructuralelement #
####################
class ifcrelconnectsstructuralelement(ifcrelconnects):
	'''Entity ifcrelconnectsstructuralelement definition.

	:param relatingelement
	:type relatingelement:ifcelement

	:param relatedstructuralmember
	:type relatedstructuralmember:ifcstructuralmember
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingelement,relatedstructuralmember, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingelement = relatingelement
		self.relatedstructuralmember = relatedstructuralmember

	@apply
	def relatingelement():
		def fget( self ):
			return self._relatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatingelement = ifcelement(value)
			else:
				self._relatingelement = value
		return property(**locals())

	@apply
	def relatedstructuralmember():
		def fget( self ):
			return self._relatedstructuralmember
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedstructuralmember is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralmember):
				self._relatedstructuralmember = ifcstructuralmember(value)
			else:
				self._relatedstructuralmember = value
		return property(**locals())

####################
 # ENTITY ifctextstyle #
####################
class ifctextstyle(ifcpresentationstyle):
	'''Entity ifctextstyle definition.

	:param textcharacterappearance
	:type textcharacterappearance:ifccharacterstyleselect

	:param textstyle
	:type textstyle:ifctextstyleselect

	:param textfontstyle
	:type textfontstyle:ifctextfontselect
	'''
	def __init__( self , inherited0__name , textcharacterappearance,textstyle,textfontstyle, ):
		ifcpresentationstyle.__init__(self , inherited0__name , )
		self.textcharacterappearance = textcharacterappearance
		self.textstyle = textstyle
		self.textfontstyle = textfontstyle

	@apply
	def textcharacterappearance():
		def fget( self ):
			return self._textcharacterappearance
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccharacterstyleselect):
					self._textcharacterappearance = ifccharacterstyleselect(value)
				else:
					self._textcharacterappearance = value
			else:
				self._textcharacterappearance = value
		return property(**locals())

	@apply
	def textstyle():
		def fget( self ):
			return self._textstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctextstyleselect):
					self._textstyle = ifctextstyleselect(value)
				else:
					self._textstyle = value
			else:
				self._textstyle = value
		return property(**locals())

	@apply
	def textfontstyle():
		def fget( self ):
			return self._textfontstyle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument textfontstyle is mantatory and can not be set to None')
			if not check_type(value,ifctextfontselect):
				self._textfontstyle = ifctextfontselect(value)
			else:
				self._textfontstyle = value
		return property(**locals())

####################
 # ENTITY ifcwall #
####################
class ifcwall(ifcbuildingelement):
	'''Entity ifcwall definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcdistributioncontrolelementtype #
####################
class ifcdistributioncontrolelementtype(ifcdistributionelementtype):
	'''Entity ifcdistributioncontrolelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcactuatortype #
####################
class ifcactuatortype(ifcdistributioncontrolelementtype):
	'''Entity ifcactuatortype definition.

	:param predefinedtype
	:type predefinedtype:ifcactuatortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcactuatortypeenum):
				self._predefinedtype = ifcactuatortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcfailureconnectioncondition #
####################
class ifcfailureconnectioncondition(ifcstructuralconnectioncondition):
	'''Entity ifcfailureconnectioncondition definition.

	:param tensionfailurex
	:type tensionfailurex:ifcforcemeasure

	:param tensionfailurey
	:type tensionfailurey:ifcforcemeasure

	:param tensionfailurez
	:type tensionfailurez:ifcforcemeasure

	:param compressionfailurex
	:type compressionfailurex:ifcforcemeasure

	:param compressionfailurey
	:type compressionfailurey:ifcforcemeasure

	:param compressionfailurez
	:type compressionfailurez:ifcforcemeasure
	'''
	def __init__( self , inherited0__name , tensionfailurex,tensionfailurey,tensionfailurez,compressionfailurex,compressionfailurey,compressionfailurez, ):
		ifcstructuralconnectioncondition.__init__(self , inherited0__name , )
		self.tensionfailurex = tensionfailurex
		self.tensionfailurey = tensionfailurey
		self.tensionfailurez = tensionfailurez
		self.compressionfailurex = compressionfailurex
		self.compressionfailurey = compressionfailurey
		self.compressionfailurez = compressionfailurez

	@apply
	def tensionfailurex():
		def fget( self ):
			return self._tensionfailurex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._tensionfailurex = ifcforcemeasure(value)
				else:
					self._tensionfailurex = value
			else:
				self._tensionfailurex = value
		return property(**locals())

	@apply
	def tensionfailurey():
		def fget( self ):
			return self._tensionfailurey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._tensionfailurey = ifcforcemeasure(value)
				else:
					self._tensionfailurey = value
			else:
				self._tensionfailurey = value
		return property(**locals())

	@apply
	def tensionfailurez():
		def fget( self ):
			return self._tensionfailurez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._tensionfailurez = ifcforcemeasure(value)
				else:
					self._tensionfailurez = value
			else:
				self._tensionfailurez = value
		return property(**locals())

	@apply
	def compressionfailurex():
		def fget( self ):
			return self._compressionfailurex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._compressionfailurex = ifcforcemeasure(value)
				else:
					self._compressionfailurex = value
			else:
				self._compressionfailurex = value
		return property(**locals())

	@apply
	def compressionfailurey():
		def fget( self ):
			return self._compressionfailurey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._compressionfailurey = ifcforcemeasure(value)
				else:
					self._compressionfailurey = value
			else:
				self._compressionfailurey = value
		return property(**locals())

	@apply
	def compressionfailurez():
		def fget( self ):
			return self._compressionfailurez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._compressionfailurez = ifcforcemeasure(value)
				else:
					self._compressionfailurez = value
			else:
				self._compressionfailurez = value
		return property(**locals())

####################
 # ENTITY ifcsymbolstyle #
####################
class ifcsymbolstyle(ifcpresentationstyle):
	'''Entity ifcsymbolstyle definition.

	:param styleofsymbol
	:type styleofsymbol:ifcsymbolstyleselect
	'''
	def __init__( self , inherited0__name , styleofsymbol, ):
		ifcpresentationstyle.__init__(self , inherited0__name , )
		self.styleofsymbol = styleofsymbol

	@apply
	def styleofsymbol():
		def fget( self ):
			return self._styleofsymbol
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styleofsymbol is mantatory and can not be set to None')
			if not check_type(value,ifcsymbolstyleselect):
				self._styleofsymbol = ifcsymbolstyleselect(value)
			else:
				self._styleofsymbol = value
		return property(**locals())

####################
 # ENTITY ifcstructuralsurfaceconnection #
####################
class ifcstructuralsurfaceconnection(ifcstructuralconnection):
	'''Entity ifcstructuralsurfaceconnection definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition ,  ):
		ifcstructuralconnection.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition , )

####################
 # ENTITY ifccomplexproperty #
####################
class ifccomplexproperty(ifcproperty):
	'''Entity ifccomplexproperty definition.

	:param usagename
	:type usagename:ifcidentifier

	:param hasproperties
	:type hasproperties:SET(1,None,'ifcproperty', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , usagename,hasproperties, ):
		ifcproperty.__init__(self , inherited0__name , inherited1__description , )
		self.usagename = usagename
		self.hasproperties = hasproperties

	@apply
	def usagename():
		def fget( self ):
			return self._usagename
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument usagename is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._usagename = ifcidentifier(value)
			else:
				self._usagename = value
		return property(**locals())

	@apply
	def hasproperties():
		def fget( self ):
			return self._hasproperties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hasproperties is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproperty', scope = schema_scope)):
				self._hasproperties = SET(value)
			else:
				self._hasproperties = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (SIZEOF(None)  ==  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = ifcuniquepropertyname(self.hasproperties)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcpredefinedsymbol #
####################
class ifcpredefinedsymbol(ifcpredefineditem):
	'''Entity ifcpredefinedsymbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefineditem.__init__(self , inherited0__name , )

####################
 # ENTITY ifcpredefineddimensionsymbol #
####################
class ifcpredefineddimensionsymbol(ifcpredefinedsymbol):
	'''Entity ifcpredefineddimensionsymbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefinedsymbol.__init__(self , inherited0__name , )
	def wr31(self):
		eval_wr31_wr = (self.self.ifcpredefineditem.self.name  ==  ['arc length','conical taper','counterbore','countersink','depth','diameter','plus minus','radius','slope','spherical diameter','spherical radius','square'])
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcboundedsurface #
####################
class ifcboundedsurface(ifcsurface):
	'''Entity ifcboundedsurface definition.
	'''
	def __init__( self ,  ):
		ifcsurface.__init__(self , )

####################
 # ENTITY ifccurveboundedplane #
####################
class ifccurveboundedplane(ifcboundedsurface):
	'''Entity ifccurveboundedplane definition.

	:param basissurface
	:type basissurface:ifcplane

	:param outerboundary
	:type outerboundary:ifccurve

	:param innerboundaries
	:type innerboundaries:SET(0,None,'ifccurve', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , basissurface,outerboundary,innerboundaries, ):
		ifcboundedsurface.__init__(self , )
		self.basissurface = basissurface
		self.outerboundary = outerboundary
		self.innerboundaries = innerboundaries

	@apply
	def basissurface():
		def fget( self ):
			return self._basissurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basissurface is mantatory and can not be set to None')
			if not check_type(value,ifcplane):
				self._basissurface = ifcplane(value)
			else:
				self._basissurface = value
		return property(**locals())

	@apply
	def outerboundary():
		def fget( self ):
			return self._outerboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outerboundary is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._outerboundary = ifccurve(value)
			else:
				self._outerboundary = value
		return property(**locals())

	@apply
	def innerboundaries():
		def fget( self ):
			return self._innerboundaries
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument innerboundaries is mantatory and can not be set to None')
			if not check_type(value,SET(0,None,'ifccurve', scope = schema_scope)):
				self._innerboundaries = SET(value)
			else:
				self._innerboundaries = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.basissurface.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcface #
####################
class ifcface(ifctopologicalrepresentationitem):
	'''Entity ifcface definition.

	:param bounds
	:type bounds:SET(1,None,'ifcfacebound', scope = schema_scope)
	'''
	def __init__( self , bounds, ):
		ifctopologicalrepresentationitem.__init__(self , )
		self.bounds = bounds

	@apply
	def bounds():
		def fget( self ):
			return self._bounds
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bounds is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcfacebound', scope = schema_scope)):
				self._bounds = SET(value)
			else:
				self._bounds = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcfacesurface #
####################
class ifcfacesurface(ifcface):
	'''Entity ifcfacesurface definition.

	:param facesurface
	:type facesurface:ifcsurface

	:param samesense
	:type samesense:BOOLEAN
	'''
	def __init__( self , inherited0__bounds , facesurface,samesense, ):
		ifcface.__init__(self , inherited0__bounds , )
		self.facesurface = facesurface
		self.samesense = samesense

	@apply
	def facesurface():
		def fget( self ):
			return self._facesurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument facesurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._facesurface = ifcsurface(value)
			else:
				self._facesurface = value
		return property(**locals())

	@apply
	def samesense():
		def fget( self ):
			return self._samesense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument samesense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._samesense = BOOLEAN(value)
			else:
				self._samesense = value
		return property(**locals())

####################
 # ENTITY ifcstructuralanalysismodel #
####################
class ifcstructuralanalysismodel(ifcsystem):
	'''Entity ifcstructuralanalysismodel definition.

	:param predefinedtype
	:type predefinedtype:ifcanalysismodeltypeenum

	:param orientationof2dplane
	:type orientationof2dplane:ifcaxis2placement3d

	:param loadedby
	:type loadedby:SET(1,None,'ifcstructuralloadgroup', scope = schema_scope)

	:param hasresults
	:type hasresults:SET(1,None,'ifcstructuralresultgroup', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , predefinedtype,orientationof2dplane,loadedby,hasresults, ):
		ifcsystem.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.predefinedtype = predefinedtype
		self.orientationof2dplane = orientationof2dplane
		self.loadedby = loadedby
		self.hasresults = hasresults

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcanalysismodeltypeenum):
				self._predefinedtype = ifcanalysismodeltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def orientationof2dplane():
		def fget( self ):
			return self._orientationof2dplane
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaxis2placement3d):
					self._orientationof2dplane = ifcaxis2placement3d(value)
				else:
					self._orientationof2dplane = value
			else:
				self._orientationof2dplane = value
		return property(**locals())

	@apply
	def loadedby():
		def fget( self ):
			return self._loadedby
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcstructuralloadgroup', scope = schema_scope)):
					self._loadedby = SET(value)
				else:
					self._loadedby = value
			else:
				self._loadedby = value
		return property(**locals())

	@apply
	def hasresults():
		def fget( self ):
			return self._hasresults
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcstructuralresultgroup', scope = schema_scope)):
					self._hasresults = SET(value)
				else:
					self._hasresults = value
			else:
				self._hasresults = value
		return property(**locals())

####################
 # ENTITY ifcstructuralloadsingleforce #
####################
class ifcstructuralloadsingleforce(ifcstructuralloadstatic):
	'''Entity ifcstructuralloadsingleforce definition.

	:param forcex
	:type forcex:ifcforcemeasure

	:param forcey
	:type forcey:ifcforcemeasure

	:param forcez
	:type forcez:ifcforcemeasure

	:param momentx
	:type momentx:ifctorquemeasure

	:param momenty
	:type momenty:ifctorquemeasure

	:param momentz
	:type momentz:ifctorquemeasure
	'''
	def __init__( self , inherited0__name , forcex,forcey,forcez,momentx,momenty,momentz, ):
		ifcstructuralloadstatic.__init__(self , inherited0__name , )
		self.forcex = forcex
		self.forcey = forcey
		self.forcez = forcez
		self.momentx = momentx
		self.momenty = momenty
		self.momentz = momentz

	@apply
	def forcex():
		def fget( self ):
			return self._forcex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._forcex = ifcforcemeasure(value)
				else:
					self._forcex = value
			else:
				self._forcex = value
		return property(**locals())

	@apply
	def forcey():
		def fget( self ):
			return self._forcey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._forcey = ifcforcemeasure(value)
				else:
					self._forcey = value
			else:
				self._forcey = value
		return property(**locals())

	@apply
	def forcez():
		def fget( self ):
			return self._forcez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._forcez = ifcforcemeasure(value)
				else:
					self._forcez = value
			else:
				self._forcez = value
		return property(**locals())

	@apply
	def momentx():
		def fget( self ):
			return self._momentx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctorquemeasure):
					self._momentx = ifctorquemeasure(value)
				else:
					self._momentx = value
			else:
				self._momentx = value
		return property(**locals())

	@apply
	def momenty():
		def fget( self ):
			return self._momenty
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctorquemeasure):
					self._momenty = ifctorquemeasure(value)
				else:
					self._momenty = value
			else:
				self._momenty = value
		return property(**locals())

	@apply
	def momentz():
		def fget( self ):
			return self._momentz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctorquemeasure):
					self._momentz = ifctorquemeasure(value)
				else:
					self._momentz = value
			else:
				self._momentz = value
		return property(**locals())

####################
 # ENTITY ifcstructuralloadsingleforcewarping #
####################
class ifcstructuralloadsingleforcewarping(ifcstructuralloadsingleforce):
	'''Entity ifcstructuralloadsingleforcewarping definition.

	:param warpingmoment
	:type warpingmoment:ifcwarpingmomentmeasure
	'''
	def __init__( self , inherited0__name , inherited1__forcex , inherited2__forcey , inherited3__forcez , inherited4__momentx , inherited5__momenty , inherited6__momentz , warpingmoment, ):
		ifcstructuralloadsingleforce.__init__(self , inherited0__name , inherited1__forcex , inherited2__forcey , inherited3__forcez , inherited4__momentx , inherited5__momenty , inherited6__momentz , )
		self.warpingmoment = warpingmoment

	@apply
	def warpingmoment():
		def fget( self ):
			return self._warpingmoment
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcwarpingmomentmeasure):
					self._warpingmoment = ifcwarpingmomentmeasure(value)
				else:
					self._warpingmoment = value
			else:
				self._warpingmoment = value
		return property(**locals())

####################
 # ENTITY ifcaxis2placement3d #
####################
class ifcaxis2placement3d(ifcplacement):
	'''Entity ifcaxis2placement3d definition.

	:param axis
	:type axis:ifcdirection

	:param refdirection
	:type refdirection:ifcdirection

	:param p
	:type p:LIST(3,3,'ifcdirection', scope = schema_scope)
	'''
	def __init__( self , inherited0__location , axis,refdirection, ):
		ifcplacement.__init__(self , inherited0__location , )
		self.axis = axis
		self.refdirection = refdirection

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._axis = ifcdirection(value)
				else:
					self._axis = value
			else:
				self._axis = value
		return property(**locals())

	@apply
	def refdirection():
		def fget( self ):
			return self._refdirection
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._refdirection = ifcdirection(value)
				else:
					self._refdirection = value
			else:
				self._refdirection = value
		return property(**locals())

	@apply
	def p():
		def fget( self ):
			attribute_eval = ifcbuildaxes(self.axis,self.refdirection)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.ifcplacement.self.location.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.axis))  or  (self.axis.self.dim  ==  3))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not EXISTS(self.refdirection))  or  (self.refdirection.self.dim  ==  3))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((( not EXISTS(self.axis))  or  ( not EXISTS(self.refdirection)))  or  (ifccrossproduct(self.axis,self.refdirection).self.magnitude  >  0))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ( not (EXISTS(self.axis) XOR EXISTS(self.refdirection)))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY ifchalfspacesolid #
####################
class ifchalfspacesolid(ifcgeometricrepresentationitem):
	'''Entity ifchalfspacesolid definition.

	:param basesurface
	:type basesurface:ifcsurface

	:param agreementflag
	:type agreementflag:BOOLEAN

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , basesurface,agreementflag, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.basesurface = basesurface
		self.agreementflag = agreementflag

	@apply
	def basesurface():
		def fget( self ):
			return self._basesurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basesurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._basesurface = ifcsurface(value)
			else:
				self._basesurface = value
		return property(**locals())

	@apply
	def agreementflag():
		def fget( self ):
			return self._agreementflag
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument agreementflag is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._agreementflag = BOOLEAN(value)
			else:
				self._agreementflag = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcboxedhalfspace #
####################
class ifcboxedhalfspace(ifchalfspacesolid):
	'''Entity ifcboxedhalfspace definition.

	:param enclosure
	:type enclosure:ifcboundingbox
	'''
	def __init__( self , inherited0__basesurface , inherited1__agreementflag , enclosure, ):
		ifchalfspacesolid.__init__(self , inherited0__basesurface , inherited1__agreementflag , )
		self.enclosure = enclosure

	@apply
	def enclosure():
		def fget( self ):
			return self._enclosure
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument enclosure is mantatory and can not be set to None')
			if not check_type(value,ifcboundingbox):
				self._enclosure = ifcboundingbox(value)
			else:
				self._enclosure = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('IFC2X3.IFCCURVEBOUNDEDPLANE'  ==  TYPEOF(self.self.ifchalfspacesolid.self.basesurface)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifccompositecurve #
####################
class ifccompositecurve(ifcboundedcurve):
	'''Entity ifccompositecurve definition.

	:param segments
	:type segments:LIST(1,None,'ifccompositecurvesegment', scope = schema_scope)

	:param selfintersect
	:type selfintersect:LOGICAL

	:param nsegments
	:type nsegments:INTEGER

	:param closedcurve
	:type closedcurve:LOGICAL
	'''
	def __init__( self , segments,selfintersect, ):
		ifcboundedcurve.__init__(self , )
		self.segments = segments
		self.selfintersect = selfintersect

	@apply
	def segments():
		def fget( self ):
			return self._segments
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument segments is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifccompositecurvesegment', scope = schema_scope)):
				self._segments = LIST(value)
			else:
				self._segments = value
		return property(**locals())

	@apply
	def selfintersect():
		def fget( self ):
			return self._selfintersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument selfintersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._selfintersect = LOGICAL(value)
			else:
				self._selfintersect = value
		return property(**locals())

	@apply
	def nsegments():
		def fget( self ):
			attribute_eval = SIZEOF(self.segments)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument nsegments is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def closedcurve():
		def fget( self ):
			attribute_eval = (self.segments[self.nsegments].self.transition  !=  discontinuous)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument closedcurve is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = ((( not self.closedcurve)  and  (SIZEOF(None)  ==  1))  or  (self.closedcurve  and  (SIZEOF(None)  ==  0)))
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr

	def wr42(self):
		eval_wr42_wr = (SIZEOF(None)  ==  0)
		if not eval_wr42_wr:
			raise AssertionError('Rule wr42 violated')
		else:
			return eval_wr42_wr


####################
 # ENTITY ifcroof #
####################
class ifcroof(ifcbuildingelement):
	'''Entity ifcroof definition.

	:param shapetype
	:type shapetype:ifcrooftypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , shapetype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.shapetype = shapetype

	@apply
	def shapetype():
		def fget( self ):
			return self._shapetype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument shapetype is mantatory and can not be set to None')
			if not check_type(value,ifcrooftypeenum):
				self._shapetype = ifcrooftypeenum(value)
			else:
				self._shapetype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  0)  or  ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  1)  and  ( not EXISTS(self.self.ifcproduct.self.representation))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcstructuralloadsingledisplacementdistortion #
####################
class ifcstructuralloadsingledisplacementdistortion(ifcstructuralloadsingledisplacement):
	'''Entity ifcstructuralloadsingledisplacementdistortion definition.

	:param distortion
	:type distortion:ifccurvaturemeasure
	'''
	def __init__( self , inherited0__name , inherited1__displacementx , inherited2__displacementy , inherited3__displacementz , inherited4__rotationaldisplacementrx , inherited5__rotationaldisplacementry , inherited6__rotationaldisplacementrz , distortion, ):
		ifcstructuralloadsingledisplacement.__init__(self , inherited0__name , inherited1__displacementx , inherited2__displacementy , inherited3__displacementz , inherited4__rotationaldisplacementrx , inherited5__rotationaldisplacementry , inherited6__rotationaldisplacementrz , )
		self.distortion = distortion

	@apply
	def distortion():
		def fget( self ):
			return self._distortion
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccurvaturemeasure):
					self._distortion = ifccurvaturemeasure(value)
				else:
					self._distortion = value
			else:
				self._distortion = value
		return property(**locals())

####################
 # ENTITY ifcrepresentation #
####################
class ifcrepresentation(BaseEntityClass):
	'''Entity ifcrepresentation definition.

	:param contextofitems
	:type contextofitems:ifcrepresentationcontext

	:param representationidentifier
	:type representationidentifier:ifclabel

	:param representationtype
	:type representationtype:ifclabel

	:param items
	:type items:SET(1,None,'ifcrepresentationitem', scope = schema_scope)

	:param representationmap
	:type representationmap:SET(0,1,'ifcrepresentationmap', scope = schema_scope)

	:param layerassignments
	:type layerassignments:SET(0,None,'ifcpresentationlayerassignment', scope = schema_scope)

	:param ofproductrepresentation
	:type ofproductrepresentation:SET(0,1,'ifcproductrepresentation', scope = schema_scope)
	'''
	def __init__( self , contextofitems,representationidentifier,representationtype,items, ):
		self.contextofitems = contextofitems
		self.representationidentifier = representationidentifier
		self.representationtype = representationtype
		self.items = items

	@apply
	def contextofitems():
		def fget( self ):
			return self._contextofitems
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument contextofitems is mantatory and can not be set to None')
			if not check_type(value,ifcrepresentationcontext):
				self._contextofitems = ifcrepresentationcontext(value)
			else:
				self._contextofitems = value
		return property(**locals())

	@apply
	def representationidentifier():
		def fget( self ):
			return self._representationidentifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._representationidentifier = ifclabel(value)
				else:
					self._representationidentifier = value
			else:
				self._representationidentifier = value
		return property(**locals())

	@apply
	def representationtype():
		def fget( self ):
			return self._representationtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._representationtype = ifclabel(value)
				else:
					self._representationtype = value
			else:
				self._representationtype = value
		return property(**locals())

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcrepresentationitem', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def representationmap():
		def fget( self ):
			return self._representationmap
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument representationmap is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def layerassignments():
		def fget( self ):
			return self._layerassignments
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument layerassignments is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ofproductrepresentation():
		def fget( self ):
			return self._ofproductrepresentation
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ofproductrepresentation is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifccompositecurvesegment #
####################
class ifccompositecurvesegment(ifcgeometricrepresentationitem):
	'''Entity ifccompositecurvesegment definition.

	:param transition
	:type transition:ifctransitioncode

	:param samesense
	:type samesense:BOOLEAN

	:param parentcurve
	:type parentcurve:ifccurve

	:param dim
	:type dim:ifcdimensioncount

	:param usingcurves
	:type usingcurves:SET(1,None,'ifccompositecurve', scope = schema_scope)
	'''
	def __init__( self , transition,samesense,parentcurve, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.transition = transition
		self.samesense = samesense
		self.parentcurve = parentcurve

	@apply
	def transition():
		def fget( self ):
			return self._transition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transition is mantatory and can not be set to None')
			if not check_type(value,ifctransitioncode):
				self._transition = ifctransitioncode(value)
			else:
				self._transition = value
		return property(**locals())

	@apply
	def samesense():
		def fget( self ):
			return self._samesense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument samesense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._samesense = BOOLEAN(value)
			else:
				self._samesense = value
		return property(**locals())

	@apply
	def parentcurve():
		def fget( self ):
			return self._parentcurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parentcurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._parentcurve = ifccurve(value)
			else:
				self._parentcurve = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.parentcurve.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def usingcurves():
		def fget( self ):
			return self._usingcurves
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument usingcurves is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('IFC2X3.IFCBOUNDEDCURVE'  ==  TYPEOF(self.parentcurve))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcclassificationitem #
####################
class ifcclassificationitem(BaseEntityClass):
	'''Entity ifcclassificationitem definition.

	:param notation
	:type notation:ifcclassificationnotationfacet

	:param itemof
	:type itemof:ifcclassification

	:param title
	:type title:ifclabel

	:param isclassifieditemin
	:type isclassifieditemin:SET(0,1,'ifcclassificationitemrelationship', scope = schema_scope)

	:param isclassifyingitemin
	:type isclassifyingitemin:SET(0,1,'ifcclassificationitemrelationship', scope = schema_scope)
	'''
	def __init__( self , notation,itemof,title, ):
		self.notation = notation
		self.itemof = itemof
		self.title = title

	@apply
	def notation():
		def fget( self ):
			return self._notation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument notation is mantatory and can not be set to None')
			if not check_type(value,ifcclassificationnotationfacet):
				self._notation = ifcclassificationnotationfacet(value)
			else:
				self._notation = value
		return property(**locals())

	@apply
	def itemof():
		def fget( self ):
			return self._itemof
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcclassification):
					self._itemof = ifcclassification(value)
				else:
					self._itemof = value
			else:
				self._itemof = value
		return property(**locals())

	@apply
	def title():
		def fget( self ):
			return self._title
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument title is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._title = ifclabel(value)
			else:
				self._title = value
		return property(**locals())

	@apply
	def isclassifieditemin():
		def fget( self ):
			return self._isclassifieditemin
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isclassifieditemin is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isclassifyingitemin():
		def fget( self ):
			return self._isclassifyingitemin
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isclassifyingitemin is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcoffsetcurve2d #
####################
class ifcoffsetcurve2d(ifccurve):
	'''Entity ifcoffsetcurve2d definition.

	:param basiscurve
	:type basiscurve:ifccurve

	:param distance
	:type distance:ifclengthmeasure

	:param selfintersect
	:type selfintersect:LOGICAL
	'''
	def __init__( self , basiscurve,distance,selfintersect, ):
		ifccurve.__init__(self , )
		self.basiscurve = basiscurve
		self.distance = distance
		self.selfintersect = selfintersect

	@apply
	def basiscurve():
		def fget( self ):
			return self._basiscurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basiscurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._basiscurve = ifccurve(value)
			else:
				self._basiscurve = value
		return property(**locals())

	@apply
	def distance():
		def fget( self ):
			return self._distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._distance = ifclengthmeasure(value)
			else:
				self._distance = value
		return property(**locals())

	@apply
	def selfintersect():
		def fget( self ):
			return self._selfintersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument selfintersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._selfintersect = LOGICAL(value)
			else:
				self._selfintersect = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.basiscurve.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcrelassignstogroup #
####################
class ifcrelassignstogroup(ifcrelassigns):
	'''Entity ifcrelassignstogroup definition.

	:param relatinggroup
	:type relatinggroup:ifcgroup
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatinggroup, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatinggroup = relatinggroup

	@apply
	def relatinggroup():
		def fget( self ):
			return self._relatinggroup
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatinggroup is mantatory and can not be set to None')
			if not check_type(value,ifcgroup):
				self._relatinggroup = ifcgroup(value)
			else:
				self._relatinggroup = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcequipmentelement #
####################
class ifcequipmentelement(ifcelement):
	'''Entity ifcequipmentelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcreinforcementdefinitionproperties #
####################
class ifcreinforcementdefinitionproperties(ifcpropertysetdefinition):
	'''Entity ifcreinforcementdefinitionproperties definition.

	:param definitiontype
	:type definitiontype:ifclabel

	:param reinforcementsectiondefinitions
	:type reinforcementsectiondefinitions:LIST(1,None,'ifcsectionreinforcementproperties', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , definitiontype,reinforcementsectiondefinitions, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.definitiontype = definitiontype
		self.reinforcementsectiondefinitions = reinforcementsectiondefinitions

	@apply
	def definitiontype():
		def fget( self ):
			return self._definitiontype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._definitiontype = ifclabel(value)
				else:
					self._definitiontype = value
			else:
				self._definitiontype = value
		return property(**locals())

	@apply
	def reinforcementsectiondefinitions():
		def fget( self ):
			return self._reinforcementsectiondefinitions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reinforcementsectiondefinitions is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcsectionreinforcementproperties', scope = schema_scope)):
				self._reinforcementsectiondefinitions = LIST(value)
			else:
				self._reinforcementsectiondefinitions = value
		return property(**locals())

####################
 # ENTITY ifcrelassociatesclassification #
####################
class ifcrelassociatesclassification(ifcrelassociates):
	'''Entity ifcrelassociatesclassification definition.

	:param relatingclassification
	:type relatingclassification:ifcclassificationnotationselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingclassification, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingclassification = relatingclassification

	@apply
	def relatingclassification():
		def fget( self ):
			return self._relatingclassification
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingclassification is mantatory and can not be set to None')
			if not check_type(value,ifcclassificationnotationselect):
				self._relatingclassification = ifcclassificationnotationselect(value)
			else:
				self._relatingclassification = value
		return property(**locals())

####################
 # ENTITY ifcrelvoidselement #
####################
class ifcrelvoidselement(ifcrelconnects):
	'''Entity ifcrelvoidselement definition.

	:param relatingbuildingelement
	:type relatingbuildingelement:ifcelement

	:param relatedopeningelement
	:type relatedopeningelement:ifcfeatureelementsubtraction
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingbuildingelement,relatedopeningelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingbuildingelement = relatingbuildingelement
		self.relatedopeningelement = relatedopeningelement

	@apply
	def relatingbuildingelement():
		def fget( self ):
			return self._relatingbuildingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingbuildingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatingbuildingelement = ifcelement(value)
			else:
				self._relatingbuildingelement = value
		return property(**locals())

	@apply
	def relatedopeningelement():
		def fget( self ):
			return self._relatedopeningelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedopeningelement is mantatory and can not be set to None')
			if not check_type(value,ifcfeatureelementsubtraction):
				self._relatedopeningelement = ifcfeatureelementsubtraction(value)
			else:
				self._relatedopeningelement = value
		return property(**locals())

####################
 # ENTITY ifcboundaryedgecondition #
####################
class ifcboundaryedgecondition(ifcboundarycondition):
	'''Entity ifcboundaryedgecondition definition.

	:param linearstiffnessbylengthx
	:type linearstiffnessbylengthx:ifcmodulusoflinearsubgradereactionmeasure

	:param linearstiffnessbylengthy
	:type linearstiffnessbylengthy:ifcmodulusoflinearsubgradereactionmeasure

	:param linearstiffnessbylengthz
	:type linearstiffnessbylengthz:ifcmodulusoflinearsubgradereactionmeasure

	:param rotationalstiffnessbylengthx
	:type rotationalstiffnessbylengthx:ifcmodulusofrotationalsubgradereactionmeasure

	:param rotationalstiffnessbylengthy
	:type rotationalstiffnessbylengthy:ifcmodulusofrotationalsubgradereactionmeasure

	:param rotationalstiffnessbylengthz
	:type rotationalstiffnessbylengthz:ifcmodulusofrotationalsubgradereactionmeasure
	'''
	def __init__( self , inherited0__name , linearstiffnessbylengthx,linearstiffnessbylengthy,linearstiffnessbylengthz,rotationalstiffnessbylengthx,rotationalstiffnessbylengthy,rotationalstiffnessbylengthz, ):
		ifcboundarycondition.__init__(self , inherited0__name , )
		self.linearstiffnessbylengthx = linearstiffnessbylengthx
		self.linearstiffnessbylengthy = linearstiffnessbylengthy
		self.linearstiffnessbylengthz = linearstiffnessbylengthz
		self.rotationalstiffnessbylengthx = rotationalstiffnessbylengthx
		self.rotationalstiffnessbylengthy = rotationalstiffnessbylengthy
		self.rotationalstiffnessbylengthz = rotationalstiffnessbylengthz

	@apply
	def linearstiffnessbylengthx():
		def fget( self ):
			return self._linearstiffnessbylengthx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusoflinearsubgradereactionmeasure):
					self._linearstiffnessbylengthx = ifcmodulusoflinearsubgradereactionmeasure(value)
				else:
					self._linearstiffnessbylengthx = value
			else:
				self._linearstiffnessbylengthx = value
		return property(**locals())

	@apply
	def linearstiffnessbylengthy():
		def fget( self ):
			return self._linearstiffnessbylengthy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusoflinearsubgradereactionmeasure):
					self._linearstiffnessbylengthy = ifcmodulusoflinearsubgradereactionmeasure(value)
				else:
					self._linearstiffnessbylengthy = value
			else:
				self._linearstiffnessbylengthy = value
		return property(**locals())

	@apply
	def linearstiffnessbylengthz():
		def fget( self ):
			return self._linearstiffnessbylengthz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusoflinearsubgradereactionmeasure):
					self._linearstiffnessbylengthz = ifcmodulusoflinearsubgradereactionmeasure(value)
				else:
					self._linearstiffnessbylengthz = value
			else:
				self._linearstiffnessbylengthz = value
		return property(**locals())

	@apply
	def rotationalstiffnessbylengthx():
		def fget( self ):
			return self._rotationalstiffnessbylengthx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofrotationalsubgradereactionmeasure):
					self._rotationalstiffnessbylengthx = ifcmodulusofrotationalsubgradereactionmeasure(value)
				else:
					self._rotationalstiffnessbylengthx = value
			else:
				self._rotationalstiffnessbylengthx = value
		return property(**locals())

	@apply
	def rotationalstiffnessbylengthy():
		def fget( self ):
			return self._rotationalstiffnessbylengthy
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofrotationalsubgradereactionmeasure):
					self._rotationalstiffnessbylengthy = ifcmodulusofrotationalsubgradereactionmeasure(value)
				else:
					self._rotationalstiffnessbylengthy = value
			else:
				self._rotationalstiffnessbylengthy = value
		return property(**locals())

	@apply
	def rotationalstiffnessbylengthz():
		def fget( self ):
			return self._rotationalstiffnessbylengthz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofrotationalsubgradereactionmeasure):
					self._rotationalstiffnessbylengthz = ifcmodulusofrotationalsubgradereactionmeasure(value)
				else:
					self._rotationalstiffnessbylengthz = value
			else:
				self._rotationalstiffnessbylengthz = value
		return property(**locals())

####################
 # ENTITY ifcflowtreatmentdevicetype #
####################
class ifcflowtreatmentdevicetype(ifcdistributionflowelementtype):
	'''Entity ifcflowtreatmentdevicetype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcgeometricset #
####################
class ifcgeometricset(ifcgeometricrepresentationitem):
	'''Entity ifcgeometricset definition.

	:param elements
	:type elements:SET(1,None,'ifcgeometricsetselect', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , elements, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.elements = elements

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument elements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcgeometricsetselect', scope = schema_scope)):
				self._elements = SET(value)
			else:
				self._elements = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.elements[1].self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (SIZEOF(None)  ==  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcmaterialclassificationrelationship #
####################
class ifcmaterialclassificationrelationship(BaseEntityClass):
	'''Entity ifcmaterialclassificationrelationship definition.

	:param materialclassifications
	:type materialclassifications:SET(1,None,'ifcclassificationnotationselect', scope = schema_scope)

	:param classifiedmaterial
	:type classifiedmaterial:ifcmaterial
	'''
	def __init__( self , materialclassifications,classifiedmaterial, ):
		self.materialclassifications = materialclassifications
		self.classifiedmaterial = classifiedmaterial

	@apply
	def materialclassifications():
		def fget( self ):
			return self._materialclassifications
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument materialclassifications is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcclassificationnotationselect', scope = schema_scope)):
				self._materialclassifications = SET(value)
			else:
				self._materialclassifications = value
		return property(**locals())

	@apply
	def classifiedmaterial():
		def fget( self ):
			return self._classifiedmaterial
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument classifiedmaterial is mantatory and can not be set to None')
			if not check_type(value,ifcmaterial):
				self._classifiedmaterial = ifcmaterial(value)
			else:
				self._classifiedmaterial = value
		return property(**locals())

####################
 # ENTITY ifcmechanicalmaterialproperties #
####################
class ifcmechanicalmaterialproperties(ifcmaterialproperties):
	'''Entity ifcmechanicalmaterialproperties definition.

	:param dynamicviscosity
	:type dynamicviscosity:ifcdynamicviscositymeasure

	:param youngmodulus
	:type youngmodulus:ifcmodulusofelasticitymeasure

	:param shearmodulus
	:type shearmodulus:ifcmodulusofelasticitymeasure

	:param poissonratio
	:type poissonratio:ifcpositiveratiomeasure

	:param thermalexpansioncoefficient
	:type thermalexpansioncoefficient:ifcthermalexpansioncoefficientmeasure
	'''
	def __init__( self , inherited0__material , dynamicviscosity,youngmodulus,shearmodulus,poissonratio,thermalexpansioncoefficient, ):
		ifcmaterialproperties.__init__(self , inherited0__material , )
		self.dynamicviscosity = dynamicviscosity
		self.youngmodulus = youngmodulus
		self.shearmodulus = shearmodulus
		self.poissonratio = poissonratio
		self.thermalexpansioncoefficient = thermalexpansioncoefficient

	@apply
	def dynamicviscosity():
		def fget( self ):
			return self._dynamicviscosity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdynamicviscositymeasure):
					self._dynamicviscosity = ifcdynamicviscositymeasure(value)
				else:
					self._dynamicviscosity = value
			else:
				self._dynamicviscosity = value
		return property(**locals())

	@apply
	def youngmodulus():
		def fget( self ):
			return self._youngmodulus
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofelasticitymeasure):
					self._youngmodulus = ifcmodulusofelasticitymeasure(value)
				else:
					self._youngmodulus = value
			else:
				self._youngmodulus = value
		return property(**locals())

	@apply
	def shearmodulus():
		def fget( self ):
			return self._shearmodulus
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofelasticitymeasure):
					self._shearmodulus = ifcmodulusofelasticitymeasure(value)
				else:
					self._shearmodulus = value
			else:
				self._shearmodulus = value
		return property(**locals())

	@apply
	def poissonratio():
		def fget( self ):
			return self._poissonratio
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._poissonratio = ifcpositiveratiomeasure(value)
				else:
					self._poissonratio = value
			else:
				self._poissonratio = value
		return property(**locals())

	@apply
	def thermalexpansioncoefficient():
		def fget( self ):
			return self._thermalexpansioncoefficient
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermalexpansioncoefficientmeasure):
					self._thermalexpansioncoefficient = ifcthermalexpansioncoefficientmeasure(value)
				else:
					self._thermalexpansioncoefficient = value
			else:
				self._thermalexpansioncoefficient = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.youngmodulus))  or  (self.youngmodulus  >=  0))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (( not EXISTS(self.shearmodulus))  or  (self.shearmodulus  >=  0))
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcmechanicalconcretematerialproperties #
####################
class ifcmechanicalconcretematerialproperties(ifcmechanicalmaterialproperties):
	'''Entity ifcmechanicalconcretematerialproperties definition.

	:param compressivestrength
	:type compressivestrength:ifcpressuremeasure

	:param maxaggregatesize
	:type maxaggregatesize:ifcpositivelengthmeasure

	:param admixturesdescription
	:type admixturesdescription:ifctext

	:param workability
	:type workability:ifctext

	:param protectiveporeratio
	:type protectiveporeratio:ifcnormalisedratiomeasure

	:param waterimpermeability
	:type waterimpermeability:ifctext
	'''
	def __init__( self , inherited0__material , inherited1__dynamicviscosity , inherited2__youngmodulus , inherited3__shearmodulus , inherited4__poissonratio , inherited5__thermalexpansioncoefficient , compressivestrength,maxaggregatesize,admixturesdescription,workability,protectiveporeratio,waterimpermeability, ):
		ifcmechanicalmaterialproperties.__init__(self , inherited0__material , inherited1__dynamicviscosity , inherited2__youngmodulus , inherited3__shearmodulus , inherited4__poissonratio , inherited5__thermalexpansioncoefficient , )
		self.compressivestrength = compressivestrength
		self.maxaggregatesize = maxaggregatesize
		self.admixturesdescription = admixturesdescription
		self.workability = workability
		self.protectiveporeratio = protectiveporeratio
		self.waterimpermeability = waterimpermeability

	@apply
	def compressivestrength():
		def fget( self ):
			return self._compressivestrength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpressuremeasure):
					self._compressivestrength = ifcpressuremeasure(value)
				else:
					self._compressivestrength = value
			else:
				self._compressivestrength = value
		return property(**locals())

	@apply
	def maxaggregatesize():
		def fget( self ):
			return self._maxaggregatesize
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._maxaggregatesize = ifcpositivelengthmeasure(value)
				else:
					self._maxaggregatesize = value
			else:
				self._maxaggregatesize = value
		return property(**locals())

	@apply
	def admixturesdescription():
		def fget( self ):
			return self._admixturesdescription
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._admixturesdescription = ifctext(value)
				else:
					self._admixturesdescription = value
			else:
				self._admixturesdescription = value
		return property(**locals())

	@apply
	def workability():
		def fget( self ):
			return self._workability
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._workability = ifctext(value)
				else:
					self._workability = value
			else:
				self._workability = value
		return property(**locals())

	@apply
	def protectiveporeratio():
		def fget( self ):
			return self._protectiveporeratio
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._protectiveporeratio = ifcnormalisedratiomeasure(value)
				else:
					self._protectiveporeratio = value
			else:
				self._protectiveporeratio = value
		return property(**locals())

	@apply
	def waterimpermeability():
		def fget( self ):
			return self._waterimpermeability
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._waterimpermeability = ifctext(value)
				else:
					self._waterimpermeability = value
			else:
				self._waterimpermeability = value
		return property(**locals())

####################
 # ENTITY ifcrelconnectselements #
####################
class ifcrelconnectselements(ifcrelconnects):
	'''Entity ifcrelconnectselements definition.

	:param connectiongeometry
	:type connectiongeometry:ifcconnectiongeometry

	:param relatingelement
	:type relatingelement:ifcelement

	:param relatedelement
	:type relatedelement:ifcelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , connectiongeometry,relatingelement,relatedelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.connectiongeometry = connectiongeometry
		self.relatingelement = relatingelement
		self.relatedelement = relatedelement

	@apply
	def connectiongeometry():
		def fget( self ):
			return self._connectiongeometry
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcconnectiongeometry):
					self._connectiongeometry = ifcconnectiongeometry(value)
				else:
					self._connectiongeometry = value
			else:
				self._connectiongeometry = value
		return property(**locals())

	@apply
	def relatingelement():
		def fget( self ):
			return self._relatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatingelement = ifcelement(value)
			else:
				self._relatingelement = value
		return property(**locals())

	@apply
	def relatedelement():
		def fget( self ):
			return self._relatedelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatedelement = ifcelement(value)
			else:
				self._relatedelement = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (self.relatingelement  !=  self.relatedelement)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcshapeaspect #
####################
class ifcshapeaspect(BaseEntityClass):
	'''Entity ifcshapeaspect definition.

	:param shaperepresentations
	:type shaperepresentations:LIST(1,None,'ifcshapemodel', scope = schema_scope)

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param productdefinitional
	:type productdefinitional:LOGICAL

	:param partofproductdefinitionshape
	:type partofproductdefinitionshape:ifcproductdefinitionshape
	'''
	def __init__( self , shaperepresentations,name,description,productdefinitional,partofproductdefinitionshape, ):
		self.shaperepresentations = shaperepresentations
		self.name = name
		self.description = description
		self.productdefinitional = productdefinitional
		self.partofproductdefinitionshape = partofproductdefinitionshape

	@apply
	def shaperepresentations():
		def fget( self ):
			return self._shaperepresentations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument shaperepresentations is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcshapemodel', scope = schema_scope)):
				self._shaperepresentations = LIST(value)
			else:
				self._shaperepresentations = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def productdefinitional():
		def fget( self ):
			return self._productdefinitional
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument productdefinitional is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._productdefinitional = LOGICAL(value)
			else:
				self._productdefinitional = value
		return property(**locals())

	@apply
	def partofproductdefinitionshape():
		def fget( self ):
			return self._partofproductdefinitionshape
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument partofproductdefinitionshape is mantatory and can not be set to None')
			if not check_type(value,ifcproductdefinitionshape):
				self._partofproductdefinitionshape = ifcproductdefinitionshape(value)
			else:
				self._partofproductdefinitionshape = value
		return property(**locals())

####################
 # ENTITY ifcstructuralcurveconnection #
####################
class ifcstructuralcurveconnection(ifcstructuralconnection):
	'''Entity ifcstructuralcurveconnection definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition ,  ):
		ifcstructuralconnection.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition , )

####################
 # ENTITY ifcushapeprofiledef #
####################
class ifcushapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifcushapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param flangewidth
	:type flangewidth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcpositivelengthmeasure

	:param edgeradius
	:type edgeradius:ifcpositivelengthmeasure

	:param flangeslope
	:type flangeslope:ifcplaneanglemeasure

	:param centreofgravityinx
	:type centreofgravityinx:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , depth,flangewidth,webthickness,flangethickness,filletradius,edgeradius,flangeslope,centreofgravityinx, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.depth = depth
		self.flangewidth = flangewidth
		self.webthickness = webthickness
		self.flangethickness = flangethickness
		self.filletradius = filletradius
		self.edgeradius = edgeradius
		self.flangeslope = flangeslope
		self.centreofgravityinx = centreofgravityinx

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def flangewidth():
		def fget( self ):
			return self._flangewidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangewidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangewidth = ifcpositivelengthmeasure(value)
			else:
				self._flangewidth = value
		return property(**locals())

	@apply
	def webthickness():
		def fget( self ):
			return self._webthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument webthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._webthickness = ifcpositivelengthmeasure(value)
			else:
				self._webthickness = value
		return property(**locals())

	@apply
	def flangethickness():
		def fget( self ):
			return self._flangethickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangethickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangethickness = ifcpositivelengthmeasure(value)
			else:
				self._flangethickness = value
		return property(**locals())

	@apply
	def filletradius():
		def fget( self ):
			return self._filletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._filletradius = ifcpositivelengthmeasure(value)
				else:
					self._filletradius = value
			else:
				self._filletradius = value
		return property(**locals())

	@apply
	def edgeradius():
		def fget( self ):
			return self._edgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._edgeradius = ifcpositivelengthmeasure(value)
				else:
					self._edgeradius = value
			else:
				self._edgeradius = value
		return property(**locals())

	@apply
	def flangeslope():
		def fget( self ):
			return self._flangeslope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._flangeslope = ifcplaneanglemeasure(value)
				else:
					self._flangeslope = value
			else:
				self._flangeslope = value
		return property(**locals())

	@apply
	def centreofgravityinx():
		def fget( self ):
			return self._centreofgravityinx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._centreofgravityinx = ifcpositivelengthmeasure(value)
				else:
					self._centreofgravityinx = value
			else:
				self._centreofgravityinx = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (self.flangethickness  <  (self.depth / 2))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.webthickness  <  self.flangewidth)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcexternallydefinedsurfacestyle #
####################
class ifcexternallydefinedsurfacestyle(ifcexternalreference):
	'''Entity ifcexternallydefinedsurfacestyle definition.
	'''
	def __init__( self , inherited0__location , inherited1__itemreference , inherited2__name ,  ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__itemreference , inherited2__name , )

####################
 # ENTITY ifcannotationsurfaceoccurrence #
####################
class ifcannotationsurfaceoccurrence(ifcannotationoccurrence):
	'''Entity ifcannotationsurfaceoccurrence definition.
	'''
	def __init__( self , inherited0__item , inherited1__styles , inherited2__name ,  ):
		ifcannotationoccurrence.__init__(self , inherited0__item , inherited1__styles , inherited2__name , )
	def wr31(self):
		eval_wr31_wr = (( not EXISTS(self.self.ifcstyleditem.self.item))  or  (SIZEOF(['IFC2X3.IFCSURFACE','IFC2X3.IFCFACEBASEDSURFACEMODEL','IFC2X3.IFCSHELLBASEDSURFACEMODEL','IFC2X3.IFCSOLIDMODEL']  *  TYPEOF(self.self.ifcstyleditem.self.item))  >  0))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcevaporatortype #
####################
class ifcevaporatortype(ifcenergyconversiondevicetype):
	'''Entity ifcevaporatortype definition.

	:param predefinedtype
	:type predefinedtype:ifcevaporatortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcevaporatortypeenum):
				self._predefinedtype = ifcevaporatortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcevaporatortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcevaporatortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcfurniturestandard #
####################
class ifcfurniturestandard(ifccontrol):
	'''Entity ifcfurniturestandard definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

####################
 # ENTITY ifcrectangleprofiledef #
####################
class ifcrectangleprofiledef(ifcparameterizedprofiledef):
	'''Entity ifcrectangleprofiledef definition.

	:param xdim
	:type xdim:ifcpositivelengthmeasure

	:param ydim
	:type ydim:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , xdim,ydim, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.xdim = xdim
		self.ydim = ydim

	@apply
	def xdim():
		def fget( self ):
			return self._xdim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument xdim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._xdim = ifcpositivelengthmeasure(value)
			else:
				self._xdim = value
		return property(**locals())

	@apply
	def ydim():
		def fget( self ):
			return self._ydim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ydim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._ydim = ifcpositivelengthmeasure(value)
			else:
				self._ydim = value
		return property(**locals())

####################
 # ENTITY ifcroundedrectangleprofiledef #
####################
class ifcroundedrectangleprofiledef(ifcrectangleprofiledef):
	'''Entity ifcroundedrectangleprofiledef definition.

	:param roundingradius
	:type roundingradius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__xdim , inherited4__ydim , roundingradius, ):
		ifcrectangleprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__xdim , inherited4__ydim , )
		self.roundingradius = roundingradius

	@apply
	def roundingradius():
		def fget( self ):
			return self._roundingradius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument roundingradius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._roundingradius = ifcpositivelengthmeasure(value)
			else:
				self._roundingradius = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = ((self.roundingradius  <=  (self.self.ifcrectangleprofiledef.self.xdim / 2))  and  (self.roundingradius  <=  (self.self.ifcrectangleprofiledef.self.ydim / 2)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifctshapeprofiledef #
####################
class ifctshapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifctshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param flangewidth
	:type flangewidth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcpositivelengthmeasure

	:param flangeedgeradius
	:type flangeedgeradius:ifcpositivelengthmeasure

	:param webedgeradius
	:type webedgeradius:ifcpositivelengthmeasure

	:param webslope
	:type webslope:ifcplaneanglemeasure

	:param flangeslope
	:type flangeslope:ifcplaneanglemeasure

	:param centreofgravityiny
	:type centreofgravityiny:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , depth,flangewidth,webthickness,flangethickness,filletradius,flangeedgeradius,webedgeradius,webslope,flangeslope,centreofgravityiny, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.depth = depth
		self.flangewidth = flangewidth
		self.webthickness = webthickness
		self.flangethickness = flangethickness
		self.filletradius = filletradius
		self.flangeedgeradius = flangeedgeradius
		self.webedgeradius = webedgeradius
		self.webslope = webslope
		self.flangeslope = flangeslope
		self.centreofgravityiny = centreofgravityiny

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def flangewidth():
		def fget( self ):
			return self._flangewidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangewidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangewidth = ifcpositivelengthmeasure(value)
			else:
				self._flangewidth = value
		return property(**locals())

	@apply
	def webthickness():
		def fget( self ):
			return self._webthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument webthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._webthickness = ifcpositivelengthmeasure(value)
			else:
				self._webthickness = value
		return property(**locals())

	@apply
	def flangethickness():
		def fget( self ):
			return self._flangethickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangethickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangethickness = ifcpositivelengthmeasure(value)
			else:
				self._flangethickness = value
		return property(**locals())

	@apply
	def filletradius():
		def fget( self ):
			return self._filletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._filletradius = ifcpositivelengthmeasure(value)
				else:
					self._filletradius = value
			else:
				self._filletradius = value
		return property(**locals())

	@apply
	def flangeedgeradius():
		def fget( self ):
			return self._flangeedgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._flangeedgeradius = ifcpositivelengthmeasure(value)
				else:
					self._flangeedgeradius = value
			else:
				self._flangeedgeradius = value
		return property(**locals())

	@apply
	def webedgeradius():
		def fget( self ):
			return self._webedgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._webedgeradius = ifcpositivelengthmeasure(value)
				else:
					self._webedgeradius = value
			else:
				self._webedgeradius = value
		return property(**locals())

	@apply
	def webslope():
		def fget( self ):
			return self._webslope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._webslope = ifcplaneanglemeasure(value)
				else:
					self._webslope = value
			else:
				self._webslope = value
		return property(**locals())

	@apply
	def flangeslope():
		def fget( self ):
			return self._flangeslope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._flangeslope = ifcplaneanglemeasure(value)
				else:
					self._flangeslope = value
			else:
				self._flangeslope = value
		return property(**locals())

	@apply
	def centreofgravityiny():
		def fget( self ):
			return self._centreofgravityiny
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._centreofgravityiny = ifcpositivelengthmeasure(value)
				else:
					self._centreofgravityiny = value
			else:
				self._centreofgravityiny = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.flangethickness  <  self.depth)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.webthickness  <  self.flangewidth)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcelectricappliancetype #
####################
class ifcelectricappliancetype(ifcflowterminaltype):
	'''Entity ifcelectricappliancetype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricappliancetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectricappliancetypeenum):
				self._predefinedtype = ifcelectricappliancetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcgasterminaltype #
####################
class ifcgasterminaltype(ifcflowterminaltype):
	'''Entity ifcgasterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcgasterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcgasterminaltypeenum):
				self._predefinedtype = ifcgasterminaltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcgasterminaltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcgasterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifctextliteral #
####################
class ifctextliteral(ifcgeometricrepresentationitem):
	'''Entity ifctextliteral definition.

	:param literal
	:type literal:ifcpresentabletext

	:param placement
	:type placement:ifcaxis2placement

	:param path
	:type path:ifctextpath
	'''
	def __init__( self , literal,placement,path, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.literal = literal
		self.placement = placement
		self.path = path

	@apply
	def literal():
		def fget( self ):
			return self._literal
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument literal is mantatory and can not be set to None')
			if not check_type(value,ifcpresentabletext):
				self._literal = ifcpresentabletext(value)
			else:
				self._literal = value
		return property(**locals())

	@apply
	def placement():
		def fget( self ):
			return self._placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placement is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._placement = ifcaxis2placement(value)
			else:
				self._placement = value
		return property(**locals())

	@apply
	def path():
		def fget( self ):
			return self._path
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument path is mantatory and can not be set to None')
			if not check_type(value,ifctextpath):
				self._path = ifctextpath(value)
			else:
				self._path = value
		return property(**locals())

####################
 # ENTITY ifcdocumentinformation #
####################
class ifcdocumentinformation(BaseEntityClass):
	'''Entity ifcdocumentinformation definition.

	:param documentid
	:type documentid:ifcidentifier

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param documentreferences
	:type documentreferences:SET(1,None,'ifcdocumentreference', scope = schema_scope)

	:param purpose
	:type purpose:ifctext

	:param intendeduse
	:type intendeduse:ifctext

	:param scope
	:type scope:ifctext

	:param revision
	:type revision:ifclabel

	:param documentowner
	:type documentowner:ifcactorselect

	:param editors
	:type editors:SET(1,None,'ifcactorselect', scope = schema_scope)

	:param creationtime
	:type creationtime:ifcdateandtime

	:param lastrevisiontime
	:type lastrevisiontime:ifcdateandtime

	:param electronicformat
	:type electronicformat:ifcdocumentelectronicformat

	:param validfrom
	:type validfrom:ifccalendardate

	:param validuntil
	:type validuntil:ifccalendardate

	:param confidentiality
	:type confidentiality:ifcdocumentconfidentialityenum

	:param status
	:type status:ifcdocumentstatusenum

	:param ispointedto
	:type ispointedto:SET(0,None,'ifcdocumentinformationrelationship', scope = schema_scope)

	:param ispointer
	:type ispointer:SET(0,1,'ifcdocumentinformationrelationship', scope = schema_scope)
	'''
	def __init__( self , documentid,name,description,documentreferences,purpose,intendeduse,scope,revision,documentowner,editors,creationtime,lastrevisiontime,electronicformat,validfrom,validuntil,confidentiality,status, ):
		self.documentid = documentid
		self.name = name
		self.description = description
		self.documentreferences = documentreferences
		self.purpose = purpose
		self.intendeduse = intendeduse
		self.scope = scope
		self.revision = revision
		self.documentowner = documentowner
		self.editors = editors
		self.creationtime = creationtime
		self.lastrevisiontime = lastrevisiontime
		self.electronicformat = electronicformat
		self.validfrom = validfrom
		self.validuntil = validuntil
		self.confidentiality = confidentiality
		self.status = status

	@apply
	def documentid():
		def fget( self ):
			return self._documentid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument documentid is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._documentid = ifcidentifier(value)
			else:
				self._documentid = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def documentreferences():
		def fget( self ):
			return self._documentreferences
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcdocumentreference', scope = schema_scope)):
					self._documentreferences = SET(value)
				else:
					self._documentreferences = value
			else:
				self._documentreferences = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._purpose = ifctext(value)
				else:
					self._purpose = value
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def intendeduse():
		def fget( self ):
			return self._intendeduse
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._intendeduse = ifctext(value)
				else:
					self._intendeduse = value
			else:
				self._intendeduse = value
		return property(**locals())

	@apply
	def scope():
		def fget( self ):
			return self._scope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._scope = ifctext(value)
				else:
					self._scope = value
			else:
				self._scope = value
		return property(**locals())

	@apply
	def revision():
		def fget( self ):
			return self._revision
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._revision = ifclabel(value)
				else:
					self._revision = value
			else:
				self._revision = value
		return property(**locals())

	@apply
	def documentowner():
		def fget( self ):
			return self._documentowner
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._documentowner = ifcactorselect(value)
				else:
					self._documentowner = value
			else:
				self._documentowner = value
		return property(**locals())

	@apply
	def editors():
		def fget( self ):
			return self._editors
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcactorselect', scope = schema_scope)):
					self._editors = SET(value)
				else:
					self._editors = value
			else:
				self._editors = value
		return property(**locals())

	@apply
	def creationtime():
		def fget( self ):
			return self._creationtime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdateandtime):
					self._creationtime = ifcdateandtime(value)
				else:
					self._creationtime = value
			else:
				self._creationtime = value
		return property(**locals())

	@apply
	def lastrevisiontime():
		def fget( self ):
			return self._lastrevisiontime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdateandtime):
					self._lastrevisiontime = ifcdateandtime(value)
				else:
					self._lastrevisiontime = value
			else:
				self._lastrevisiontime = value
		return property(**locals())

	@apply
	def electronicformat():
		def fget( self ):
			return self._electronicformat
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdocumentelectronicformat):
					self._electronicformat = ifcdocumentelectronicformat(value)
				else:
					self._electronicformat = value
			else:
				self._electronicformat = value
		return property(**locals())

	@apply
	def validfrom():
		def fget( self ):
			return self._validfrom
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccalendardate):
					self._validfrom = ifccalendardate(value)
				else:
					self._validfrom = value
			else:
				self._validfrom = value
		return property(**locals())

	@apply
	def validuntil():
		def fget( self ):
			return self._validuntil
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccalendardate):
					self._validuntil = ifccalendardate(value)
				else:
					self._validuntil = value
			else:
				self._validuntil = value
		return property(**locals())

	@apply
	def confidentiality():
		def fget( self ):
			return self._confidentiality
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdocumentconfidentialityenum):
					self._confidentiality = ifcdocumentconfidentialityenum(value)
				else:
					self._confidentiality = value
			else:
				self._confidentiality = value
		return property(**locals())

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdocumentstatusenum):
					self._status = ifcdocumentstatusenum(value)
				else:
					self._status = value
			else:
				self._status = value
		return property(**locals())

	@apply
	def ispointedto():
		def fget( self ):
			return self._ispointedto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ispointedto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ispointer():
		def fget( self ):
			return self._ispointer
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ispointer is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstylemodel #
####################
class ifcstylemodel(ifcrepresentation):
	'''Entity ifcstylemodel definition.
	'''
	def __init__( self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items ,  ):
		ifcrepresentation.__init__(self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items , )

####################
 # ENTITY ifcstyledrepresentation #
####################
class ifcstyledrepresentation(ifcstylemodel):
	'''Entity ifcstyledrepresentation definition.
	'''
	def __init__( self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items ,  ):
		ifcstylemodel.__init__(self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items , )
	def wr21(self):
		eval_wr21_wr = (SIZEOF(None)  ==  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcellipseprofiledef #
####################
class ifcellipseprofiledef(ifcparameterizedprofiledef):
	'''Entity ifcellipseprofiledef definition.

	:param semiaxis1
	:type semiaxis1:ifcpositivelengthmeasure

	:param semiaxis2
	:type semiaxis2:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , semiaxis1,semiaxis2, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.semiaxis1 = semiaxis1
		self.semiaxis2 = semiaxis2

	@apply
	def semiaxis1():
		def fget( self ):
			return self._semiaxis1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semiaxis1 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._semiaxis1 = ifcpositivelengthmeasure(value)
			else:
				self._semiaxis1 = value
		return property(**locals())

	@apply
	def semiaxis2():
		def fget( self ):
			return self._semiaxis2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semiaxis2 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._semiaxis2 = ifcpositivelengthmeasure(value)
			else:
				self._semiaxis2 = value
		return property(**locals())

####################
 # ENTITY ifcsectionedspine #
####################
class ifcsectionedspine(ifcgeometricrepresentationitem):
	'''Entity ifcsectionedspine definition.

	:param spinecurve
	:type spinecurve:ifccompositecurve

	:param crosssections
	:type crosssections:LIST(2,None,'ifcprofiledef', scope = schema_scope)

	:param crosssectionpositions
	:type crosssectionpositions:LIST(2,None,'ifcaxis2placement3d', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , spinecurve,crosssections,crosssectionpositions, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.spinecurve = spinecurve
		self.crosssections = crosssections
		self.crosssectionpositions = crosssectionpositions

	@apply
	def spinecurve():
		def fget( self ):
			return self._spinecurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument spinecurve is mantatory and can not be set to None')
			if not check_type(value,ifccompositecurve):
				self._spinecurve = ifccompositecurve(value)
			else:
				self._spinecurve = value
		return property(**locals())

	@apply
	def crosssections():
		def fget( self ):
			return self._crosssections
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument crosssections is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'ifcprofiledef', scope = schema_scope)):
				self._crosssections = LIST(value)
			else:
				self._crosssections = value
		return property(**locals())

	@apply
	def crosssectionpositions():
		def fget( self ):
			return self._crosssectionpositions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument crosssectionpositions is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'ifcaxis2placement3d', scope = schema_scope)):
				self._crosssectionpositions = LIST(value)
			else:
				self._crosssectionpositions = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.crosssections)  ==  SIZEOF(self.crosssectionpositions))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.spinecurve.self.dim  ==  3)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcvertex #
####################
class ifcvertex(ifctopologicalrepresentationitem):
	'''Entity ifcvertex definition.
	'''
	def __init__( self ,  ):
		ifctopologicalrepresentationitem.__init__(self , )

####################
 # ENTITY ifcvertexpoint #
####################
class ifcvertexpoint(ifcvertex):
	'''Entity ifcvertexpoint definition.

	:param vertexgeometry
	:type vertexgeometry:ifcpoint
	'''
	def __init__( self , vertexgeometry, ):
		ifcvertex.__init__(self , )
		self.vertexgeometry = vertexgeometry

	@apply
	def vertexgeometry():
		def fget( self ):
			return self._vertexgeometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vertexgeometry is mantatory and can not be set to None')
			if not check_type(value,ifcpoint):
				self._vertexgeometry = ifcpoint(value)
			else:
				self._vertexgeometry = value
		return property(**locals())

####################
 # ENTITY ifcwallstandardcase #
####################
class ifcwallstandardcase(ifcwall):
	'''Entity ifcwallstandardcase definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcwall.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifccablecarriersegmenttype #
####################
class ifccablecarriersegmenttype(ifcflowsegmenttype):
	'''Entity ifccablecarriersegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifccablecarriersegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowsegmenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccablecarriersegmenttypeenum):
				self._predefinedtype = ifccablecarriersegmenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcdraughtingcallout #
####################
class ifcdraughtingcallout(ifcgeometricrepresentationitem):
	'''Entity ifcdraughtingcallout definition.

	:param contents
	:type contents:SET(1,None,'ifcdraughtingcalloutelement', scope = schema_scope)

	:param isrelatedfromcallout
	:type isrelatedfromcallout:SET(0,None,'ifcdraughtingcalloutrelationship', scope = schema_scope)

	:param isrelatedtocallout
	:type isrelatedtocallout:SET(0,None,'ifcdraughtingcalloutrelationship', scope = schema_scope)
	'''
	def __init__( self , contents, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.contents = contents

	@apply
	def contents():
		def fget( self ):
			return self._contents
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument contents is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcdraughtingcalloutelement', scope = schema_scope)):
				self._contents = SET(value)
			else:
				self._contents = value
		return property(**locals())

	@apply
	def isrelatedfromcallout():
		def fget( self ):
			return self._isrelatedfromcallout
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isrelatedfromcallout is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isrelatedtocallout():
		def fget( self ):
			return self._isrelatedtocallout
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isrelatedtocallout is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcdimensioncurvedirectedcallout #
####################
class ifcdimensioncurvedirectedcallout(ifcdraughtingcallout):
	'''Entity ifcdimensioncurvedirectedcallout definition.
	'''
	def __init__( self , inherited0__contents ,  ):
		ifcdraughtingcallout.__init__(self , inherited0__contents , )
	def wr41(self):
		eval_wr41_wr = (SIZEOF(None)  ==  1)
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr

	def wr42(self):
		eval_wr42_wr = (SIZEOF(None)  <=  2)
		if not eval_wr42_wr:
			raise AssertionError('Rule wr42 violated')
		else:
			return eval_wr42_wr


####################
 # ENTITY ifcdiameterdimension #
####################
class ifcdiameterdimension(ifcdimensioncurvedirectedcallout):
	'''Entity ifcdiameterdimension definition.
	'''
	def __init__( self , inherited0__contents ,  ):
		ifcdimensioncurvedirectedcallout.__init__(self , inherited0__contents , )

####################
 # ENTITY ifcfeatureelementsubtraction #
####################
class ifcfeatureelementsubtraction(ifcfeatureelement):
	'''Entity ifcfeatureelementsubtraction definition.

	:param voidselements
	:type voidselements:ifcrelvoidselement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcfeatureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

	@apply
	def voidselements():
		def fget( self ):
			return self._voidselements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument voidselements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcedgefeature #
####################
class ifcedgefeature(ifcfeatureelementsubtraction):
	'''Entity ifcedgefeature definition.

	:param featurelength
	:type featurelength:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , featurelength, ):
		ifcfeatureelementsubtraction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.featurelength = featurelength

	@apply
	def featurelength():
		def fget( self ):
			return self._featurelength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._featurelength = ifcpositivelengthmeasure(value)
				else:
					self._featurelength = value
			else:
				self._featurelength = value
		return property(**locals())

####################
 # ENTITY ifcroundededgefeature #
####################
class ifcroundededgefeature(ifcedgefeature):
	'''Entity ifcroundededgefeature definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__featurelength , radius, ):
		ifcedgefeature.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__featurelength , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._radius = ifcpositivelengthmeasure(value)
				else:
					self._radius = value
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY ifcductsilencertype #
####################
class ifcductsilencertype(ifcflowtreatmentdevicetype):
	'''Entity ifcductsilencertype definition.

	:param predefinedtype
	:type predefinedtype:ifcductsilencertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowtreatmentdevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcductsilencertypeenum):
				self._predefinedtype = ifcductsilencertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcductsilencertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcductsilencertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcrelaxation #
####################
class ifcrelaxation(BaseEntityClass):
	'''Entity ifcrelaxation definition.

	:param relaxationvalue
	:type relaxationvalue:ifcnormalisedratiomeasure

	:param initialstress
	:type initialstress:ifcnormalisedratiomeasure
	'''
	def __init__( self , relaxationvalue,initialstress, ):
		self.relaxationvalue = relaxationvalue
		self.initialstress = initialstress

	@apply
	def relaxationvalue():
		def fget( self ):
			return self._relaxationvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relaxationvalue is mantatory and can not be set to None')
			if not check_type(value,ifcnormalisedratiomeasure):
				self._relaxationvalue = ifcnormalisedratiomeasure(value)
			else:
				self._relaxationvalue = value
		return property(**locals())

	@apply
	def initialstress():
		def fget( self ):
			return self._initialstress
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument initialstress is mantatory and can not be set to None')
			if not check_type(value,ifcnormalisedratiomeasure):
				self._initialstress = ifcnormalisedratiomeasure(value)
			else:
				self._initialstress = value
		return property(**locals())

####################
 # ENTITY ifcishapeprofiledef #
####################
class ifcishapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifcishapeprofiledef definition.

	:param overallwidth
	:type overallwidth:ifcpositivelengthmeasure

	:param overalldepth
	:type overalldepth:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param flangethickness
	:type flangethickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , overallwidth,overalldepth,webthickness,flangethickness,filletradius, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.overallwidth = overallwidth
		self.overalldepth = overalldepth
		self.webthickness = webthickness
		self.flangethickness = flangethickness
		self.filletradius = filletradius

	@apply
	def overallwidth():
		def fget( self ):
			return self._overallwidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument overallwidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._overallwidth = ifcpositivelengthmeasure(value)
			else:
				self._overallwidth = value
		return property(**locals())

	@apply
	def overalldepth():
		def fget( self ):
			return self._overalldepth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument overalldepth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._overalldepth = ifcpositivelengthmeasure(value)
			else:
				self._overalldepth = value
		return property(**locals())

	@apply
	def webthickness():
		def fget( self ):
			return self._webthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument webthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._webthickness = ifcpositivelengthmeasure(value)
			else:
				self._webthickness = value
		return property(**locals())

	@apply
	def flangethickness():
		def fget( self ):
			return self._flangethickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument flangethickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._flangethickness = ifcpositivelengthmeasure(value)
			else:
				self._flangethickness = value
		return property(**locals())

	@apply
	def filletradius():
		def fget( self ):
			return self._filletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._filletradius = ifcpositivelengthmeasure(value)
				else:
					self._filletradius = value
			else:
				self._filletradius = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.flangethickness  <  (self.overalldepth / 2))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.webthickness  <  self.overallwidth)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not EXISTS(self.filletradius))  or  ((self.filletradius  <=  ((self.overallwidth - self.webthickness) / 2))  and  (self.filletradius  <=  ((self.overalldepth - (2  *  self.flangethickness)) / 2))))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcasymmetricishapeprofiledef #
####################
class ifcasymmetricishapeprofiledef(ifcishapeprofiledef):
	'''Entity ifcasymmetricishapeprofiledef definition.

	:param topflangewidth
	:type topflangewidth:ifcpositivelengthmeasure

	:param topflangethickness
	:type topflangethickness:ifcpositivelengthmeasure

	:param topflangefilletradius
	:type topflangefilletradius:ifcpositivelengthmeasure

	:param centreofgravityiny
	:type centreofgravityiny:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__overallwidth , inherited4__overalldepth , inherited5__webthickness , inherited6__flangethickness , inherited7__filletradius , topflangewidth,topflangethickness,topflangefilletradius,centreofgravityiny, ):
		ifcishapeprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__overallwidth , inherited4__overalldepth , inherited5__webthickness , inherited6__flangethickness , inherited7__filletradius , )
		self.topflangewidth = topflangewidth
		self.topflangethickness = topflangethickness
		self.topflangefilletradius = topflangefilletradius
		self.centreofgravityiny = centreofgravityiny

	@apply
	def topflangewidth():
		def fget( self ):
			return self._topflangewidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument topflangewidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._topflangewidth = ifcpositivelengthmeasure(value)
			else:
				self._topflangewidth = value
		return property(**locals())

	@apply
	def topflangethickness():
		def fget( self ):
			return self._topflangethickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._topflangethickness = ifcpositivelengthmeasure(value)
				else:
					self._topflangethickness = value
			else:
				self._topflangethickness = value
		return property(**locals())

	@apply
	def topflangefilletradius():
		def fget( self ):
			return self._topflangefilletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._topflangefilletradius = ifcpositivelengthmeasure(value)
				else:
					self._topflangefilletradius = value
			else:
				self._topflangefilletradius = value
		return property(**locals())

	@apply
	def centreofgravityiny():
		def fget( self ):
			return self._centreofgravityiny
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._centreofgravityiny = ifcpositivelengthmeasure(value)
				else:
					self._centreofgravityiny = value
			else:
				self._centreofgravityiny = value
		return property(**locals())

####################
 # ENTITY ifcproductsofcombustionproperties #
####################
class ifcproductsofcombustionproperties(ifcmaterialproperties):
	'''Entity ifcproductsofcombustionproperties definition.

	:param specificheatcapacity
	:type specificheatcapacity:ifcspecificheatcapacitymeasure

	:param n20content
	:type n20content:ifcpositiveratiomeasure

	:param cocontent
	:type cocontent:ifcpositiveratiomeasure

	:param co2content
	:type co2content:ifcpositiveratiomeasure
	'''
	def __init__( self , inherited0__material , specificheatcapacity,n20content,cocontent,co2content, ):
		ifcmaterialproperties.__init__(self , inherited0__material , )
		self.specificheatcapacity = specificheatcapacity
		self.n20content = n20content
		self.cocontent = cocontent
		self.co2content = co2content

	@apply
	def specificheatcapacity():
		def fget( self ):
			return self._specificheatcapacity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcspecificheatcapacitymeasure):
					self._specificheatcapacity = ifcspecificheatcapacitymeasure(value)
				else:
					self._specificheatcapacity = value
			else:
				self._specificheatcapacity = value
		return property(**locals())

	@apply
	def n20content():
		def fget( self ):
			return self._n20content
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._n20content = ifcpositiveratiomeasure(value)
				else:
					self._n20content = value
			else:
				self._n20content = value
		return property(**locals())

	@apply
	def cocontent():
		def fget( self ):
			return self._cocontent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._cocontent = ifcpositiveratiomeasure(value)
				else:
					self._cocontent = value
			else:
				self._cocontent = value
		return property(**locals())

	@apply
	def co2content():
		def fget( self ):
			return self._co2content
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._co2content = ifcpositiveratiomeasure(value)
				else:
					self._co2content = value
			else:
				self._co2content = value
		return property(**locals())

####################
 # ENTITY ifccartesiantransformationoperator2d #
####################
class ifccartesiantransformationoperator2d(ifccartesiantransformationoperator):
	'''Entity ifccartesiantransformationoperator2d definition.

	:param u
	:type u:LIST(2,2,'ifcdirection', scope = schema_scope)
	'''
	def __init__( self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale ,  ):
		ifccartesiantransformationoperator.__init__(self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , )

	@apply
	def u():
		def fget( self ):
			attribute_eval = ifcbaseaxis(2,self.self.ifccartesiantransformationoperator.self.axis1,self.self.ifccartesiantransformationoperator.self.axis2, None )
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument u is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.ifccartesiantransformationoperator.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.self.ifccartesiantransformationoperator.self.axis1))  or  (self.self.ifccartesiantransformationoperator.self.axis1.self.dim  ==  2))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not EXISTS(self.self.ifccartesiantransformationoperator.self.axis2))  or  (self.self.ifccartesiantransformationoperator.self.axis2.self.dim  ==  2))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifccartesiantransformationoperator2dnonuniform #
####################
class ifccartesiantransformationoperator2dnonuniform(ifccartesiantransformationoperator2d):
	'''Entity ifccartesiantransformationoperator2dnonuniform definition.

	:param scale2
	:type scale2:REAL

	:param scl2
	:type scl2:REAL
	'''
	def __init__( self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , scale2, ):
		ifccartesiantransformationoperator2d.__init__(self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , )
		self.scale2 = scale2

	@apply
	def scale2():
		def fget( self ):
			return self._scale2
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._scale2 = REAL(value)
				else:
					self._scale2 = value
			else:
				self._scale2 = value
		return property(**locals())

	@apply
	def scl2():
		def fget( self ):
			attribute_eval = NVL(self.scale2,self.self.ifccartesiantransformationoperator.self.scl)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scl2 is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.scl2  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcdateandtime #
####################
class ifcdateandtime(BaseEntityClass):
	'''Entity ifcdateandtime definition.

	:param datecomponent
	:type datecomponent:ifccalendardate

	:param timecomponent
	:type timecomponent:ifclocaltime
	'''
	def __init__( self , datecomponent,timecomponent, ):
		self.datecomponent = datecomponent
		self.timecomponent = timecomponent

	@apply
	def datecomponent():
		def fget( self ):
			return self._datecomponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument datecomponent is mantatory and can not be set to None')
			if not check_type(value,ifccalendardate):
				self._datecomponent = ifccalendardate(value)
			else:
				self._datecomponent = value
		return property(**locals())

	@apply
	def timecomponent():
		def fget( self ):
			return self._timecomponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timecomponent is mantatory and can not be set to None')
			if not check_type(value,ifclocaltime):
				self._timecomponent = ifclocaltime(value)
			else:
				self._timecomponent = value
		return property(**locals())

####################
 # ENTITY ifcelementassembly #
####################
class ifcelementassembly(ifcelement):
	'''Entity ifcelementassembly definition.

	:param assemblyplace
	:type assemblyplace:ifcassemblyplaceenum

	:param predefinedtype
	:type predefinedtype:ifcelementassemblytypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , assemblyplace,predefinedtype, ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.assemblyplace = assemblyplace
		self.predefinedtype = predefinedtype

	@apply
	def assemblyplace():
		def fget( self ):
			return self._assemblyplace
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcassemblyplaceenum):
					self._assemblyplace = ifcassemblyplaceenum(value)
				else:
					self._assemblyplace = value
			else:
				self._assemblyplace = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelementassemblytypeenum):
				self._predefinedtype = ifcelementassemblytypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcelementassemblytypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcelementassemblytypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcelementcomponent #
####################
class ifcelementcomponent(ifcelement):
	'''Entity ifcelementcomponent definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcaddress #
####################
class ifcaddress(BaseEntityClass):
	'''Entity ifcaddress definition.

	:param purpose
	:type purpose:ifcaddresstypeenum

	:param description
	:type description:ifctext

	:param userdefinedpurpose
	:type userdefinedpurpose:ifclabel

	:param ofperson
	:type ofperson:SET(0,None,'ifcperson', scope = schema_scope)

	:param oforganization
	:type oforganization:SET(0,None,'ifcorganization', scope = schema_scope)
	'''
	def __init__( self , purpose,description,userdefinedpurpose, ):
		self.purpose = purpose
		self.description = description
		self.userdefinedpurpose = userdefinedpurpose

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaddresstypeenum):
					self._purpose = ifcaddresstypeenum(value)
				else:
					self._purpose = value
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def userdefinedpurpose():
		def fget( self ):
			return self._userdefinedpurpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedpurpose = ifclabel(value)
				else:
					self._userdefinedpurpose = value
			else:
				self._userdefinedpurpose = value
		return property(**locals())

	@apply
	def ofperson():
		def fget( self ):
			return self._ofperson
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ofperson is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def oforganization():
		def fget( self ):
			return self._oforganization
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument oforganization is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not EXISTS(self.purpose))  or  ((self.purpose  !=  ifcaddresstypeenum.self.userdefined)  or  ((self.purpose  ==  ifcaddresstypeenum.self.userdefined)  and  EXISTS(self.self.userdefinedpurpose))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifctelecomaddress #
####################
class ifctelecomaddress(ifcaddress):
	'''Entity ifctelecomaddress definition.

	:param telephonenumbers
	:type telephonenumbers:LIST(1,None,'STRING', scope = schema_scope)

	:param facsimilenumbers
	:type facsimilenumbers:LIST(1,None,'STRING', scope = schema_scope)

	:param pagernumber
	:type pagernumber:ifclabel

	:param electronicmailaddresses
	:type electronicmailaddresses:LIST(1,None,'STRING', scope = schema_scope)

	:param wwwhomepageurl
	:type wwwhomepageurl:ifclabel
	'''
	def __init__( self , inherited0__purpose , inherited1__description , inherited2__userdefinedpurpose , telephonenumbers,facsimilenumbers,pagernumber,electronicmailaddresses,wwwhomepageurl, ):
		ifcaddress.__init__(self , inherited0__purpose , inherited1__description , inherited2__userdefinedpurpose , )
		self.telephonenumbers = telephonenumbers
		self.facsimilenumbers = facsimilenumbers
		self.pagernumber = pagernumber
		self.electronicmailaddresses = electronicmailaddresses
		self.wwwhomepageurl = wwwhomepageurl

	@apply
	def telephonenumbers():
		def fget( self ):
			return self._telephonenumbers
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._telephonenumbers = LIST(value)
				else:
					self._telephonenumbers = value
			else:
				self._telephonenumbers = value
		return property(**locals())

	@apply
	def facsimilenumbers():
		def fget( self ):
			return self._facsimilenumbers
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._facsimilenumbers = LIST(value)
				else:
					self._facsimilenumbers = value
			else:
				self._facsimilenumbers = value
		return property(**locals())

	@apply
	def pagernumber():
		def fget( self ):
			return self._pagernumber
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._pagernumber = ifclabel(value)
				else:
					self._pagernumber = value
			else:
				self._pagernumber = value
		return property(**locals())

	@apply
	def electronicmailaddresses():
		def fget( self ):
			return self._electronicmailaddresses
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._electronicmailaddresses = LIST(value)
				else:
					self._electronicmailaddresses = value
			else:
				self._electronicmailaddresses = value
		return property(**locals())

	@apply
	def wwwhomepageurl():
		def fget( self ):
			return self._wwwhomepageurl
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._wwwhomepageurl = ifclabel(value)
				else:
					self._wwwhomepageurl = value
			else:
				self._wwwhomepageurl = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((((EXISTS(self.telephonenumbers)  or  EXISTS(self.pagernumber))  or  EXISTS(self.facsimilenumbers))  or  EXISTS(self.electronicmailaddresses))  or  EXISTS(self.wwwhomepageurl))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifccurvestylefontandscaling #
####################
class ifccurvestylefontandscaling(BaseEntityClass):
	'''Entity ifccurvestylefontandscaling definition.

	:param name
	:type name:ifclabel

	:param curvefont
	:type curvefont:ifccurvestylefontselect

	:param curvefontscaling
	:type curvefontscaling:ifcpositiveratiomeasure
	'''
	def __init__( self , name,curvefont,curvefontscaling, ):
		self.name = name
		self.curvefont = curvefont
		self.curvefontscaling = curvefontscaling

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def curvefont():
		def fget( self ):
			return self._curvefont
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curvefont is mantatory and can not be set to None')
			if not check_type(value,ifccurvestylefontselect):
				self._curvefont = ifccurvestylefontselect(value)
			else:
				self._curvefont = value
		return property(**locals())

	@apply
	def curvefontscaling():
		def fget( self ):
			return self._curvefontscaling
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curvefontscaling is mantatory and can not be set to None')
			if not check_type(value,ifcpositiveratiomeasure):
				self._curvefontscaling = ifcpositiveratiomeasure(value)
			else:
				self._curvefontscaling = value
		return property(**locals())

####################
 # ENTITY ifcsurfaceoflinearextrusion #
####################
class ifcsurfaceoflinearextrusion(ifcsweptsurface):
	'''Entity ifcsurfaceoflinearextrusion definition.

	:param extrudeddirection
	:type extrudeddirection:ifcdirection

	:param depth
	:type depth:ifclengthmeasure

	:param extrusionaxis
	:type extrusionaxis:ifcvector
	'''
	def __init__( self , inherited0__sweptcurve , inherited1__position , extrudeddirection,depth, ):
		ifcsweptsurface.__init__(self , inherited0__sweptcurve , inherited1__position , )
		self.extrudeddirection = extrudeddirection
		self.depth = depth

	@apply
	def extrudeddirection():
		def fget( self ):
			return self._extrudeddirection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extrudeddirection is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._extrudeddirection = ifcdirection(value)
			else:
				self._extrudeddirection = value
		return property(**locals())

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._depth = ifclengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def extrusionaxis():
		def fget( self ):
			attribute_eval = ((ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(self.extrudeddirection,self.depth))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument extrusionaxis is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = (self.depth  >  0)
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr


####################
 # ENTITY ifccolumntype #
####################
class ifccolumntype(ifcbuildingelementtype):
	'''Entity ifccolumntype definition.

	:param predefinedtype
	:type predefinedtype:ifccolumntypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccolumntypeenum):
				self._predefinedtype = ifccolumntypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcproductrepresentation #
####################
class ifcproductrepresentation(BaseEntityClass):
	'''Entity ifcproductrepresentation definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param representations
	:type representations:LIST(1,None,'ifcrepresentation', scope = schema_scope)
	'''
	def __init__( self , name,description,representations, ):
		self.name = name
		self.description = description
		self.representations = representations

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def representations():
		def fget( self ):
			return self._representations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representations is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcrepresentation', scope = schema_scope)):
				self._representations = LIST(value)
			else:
				self._representations = value
		return property(**locals())

####################
 # ENTITY ifcmaterialdefinitionrepresentation #
####################
class ifcmaterialdefinitionrepresentation(ifcproductrepresentation):
	'''Entity ifcmaterialdefinitionrepresentation definition.

	:param representedmaterial
	:type representedmaterial:ifcmaterial
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__representations , representedmaterial, ):
		ifcproductrepresentation.__init__(self , inherited0__name , inherited1__description , inherited2__representations , )
		self.representedmaterial = representedmaterial

	@apply
	def representedmaterial():
		def fget( self ):
			return self._representedmaterial
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representedmaterial is mantatory and can not be set to None')
			if not check_type(value,ifcmaterial):
				self._representedmaterial = ifcmaterial(value)
			else:
				self._representedmaterial = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcreldefines #
####################
class ifcreldefines(ifcrelationship):
	'''Entity ifcreldefines definition.

	:param relatedobjects
	:type relatedobjects:SET(1,None,'ifcobject', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedobjects, ):
		ifcrelationship.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedobjects = relatedobjects

	@apply
	def relatedobjects():
		def fget( self ):
			return self._relatedobjects
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedobjects is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcobject', scope = schema_scope)):
				self._relatedobjects = SET(value)
			else:
				self._relatedobjects = value
		return property(**locals())

####################
 # ENTITY ifcreldefinesbyproperties #
####################
class ifcreldefinesbyproperties(ifcreldefines):
	'''Entity ifcreldefinesbyproperties definition.

	:param relatingpropertydefinition
	:type relatingpropertydefinition:ifcpropertysetdefinition
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingpropertydefinition, ):
		ifcreldefines.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingpropertydefinition = relatingpropertydefinition

	@apply
	def relatingpropertydefinition():
		def fget( self ):
			return self._relatingpropertydefinition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingpropertydefinition is mantatory and can not be set to None')
			if not check_type(value,ifcpropertysetdefinition):
				self._relatingpropertydefinition = ifcpropertysetdefinition(value)
			else:
				self._relatingpropertydefinition = value
		return property(**locals())

####################
 # ENTITY ifcreloverridesproperties #
####################
class ifcreloverridesproperties(ifcreldefinesbyproperties):
	'''Entity ifcreloverridesproperties definition.

	:param overridingproperties
	:type overridingproperties:SET(1,None,'ifcproperty', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatingpropertydefinition , overridingproperties, ):
		ifcreldefinesbyproperties.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatingpropertydefinition , )
		self.overridingproperties = overridingproperties

	@apply
	def overridingproperties():
		def fget( self ):
			return self._overridingproperties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument overridingproperties is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproperty', scope = schema_scope)):
				self._overridingproperties = SET(value)
			else:
				self._overridingproperties = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.ifcreldefines.self.relatedobjects)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcspacethermalloadproperties #
####################
class ifcspacethermalloadproperties(ifcpropertysetdefinition):
	'''Entity ifcspacethermalloadproperties definition.

	:param applicablevalueratio
	:type applicablevalueratio:ifcpositiveratiomeasure

	:param thermalloadsource
	:type thermalloadsource:ifcthermalloadsourceenum

	:param propertysource
	:type propertysource:ifcpropertysourceenum

	:param sourcedescription
	:type sourcedescription:ifctext

	:param maximumvalue
	:type maximumvalue:ifcpowermeasure

	:param minimumvalue
	:type minimumvalue:ifcpowermeasure

	:param thermalloadtimeseriesvalues
	:type thermalloadtimeseriesvalues:ifctimeseries

	:param userdefinedthermalloadsource
	:type userdefinedthermalloadsource:ifclabel

	:param userdefinedpropertysource
	:type userdefinedpropertysource:ifclabel

	:param thermalloadtype
	:type thermalloadtype:ifcthermalloadtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , applicablevalueratio,thermalloadsource,propertysource,sourcedescription,maximumvalue,minimumvalue,thermalloadtimeseriesvalues,userdefinedthermalloadsource,userdefinedpropertysource,thermalloadtype, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.applicablevalueratio = applicablevalueratio
		self.thermalloadsource = thermalloadsource
		self.propertysource = propertysource
		self.sourcedescription = sourcedescription
		self.maximumvalue = maximumvalue
		self.minimumvalue = minimumvalue
		self.thermalloadtimeseriesvalues = thermalloadtimeseriesvalues
		self.userdefinedthermalloadsource = userdefinedthermalloadsource
		self.userdefinedpropertysource = userdefinedpropertysource
		self.thermalloadtype = thermalloadtype

	@apply
	def applicablevalueratio():
		def fget( self ):
			return self._applicablevalueratio
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._applicablevalueratio = ifcpositiveratiomeasure(value)
				else:
					self._applicablevalueratio = value
			else:
				self._applicablevalueratio = value
		return property(**locals())

	@apply
	def thermalloadsource():
		def fget( self ):
			return self._thermalloadsource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thermalloadsource is mantatory and can not be set to None')
			if not check_type(value,ifcthermalloadsourceenum):
				self._thermalloadsource = ifcthermalloadsourceenum(value)
			else:
				self._thermalloadsource = value
		return property(**locals())

	@apply
	def propertysource():
		def fget( self ):
			return self._propertysource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument propertysource is mantatory and can not be set to None')
			if not check_type(value,ifcpropertysourceenum):
				self._propertysource = ifcpropertysourceenum(value)
			else:
				self._propertysource = value
		return property(**locals())

	@apply
	def sourcedescription():
		def fget( self ):
			return self._sourcedescription
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._sourcedescription = ifctext(value)
				else:
					self._sourcedescription = value
			else:
				self._sourcedescription = value
		return property(**locals())

	@apply
	def maximumvalue():
		def fget( self ):
			return self._maximumvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument maximumvalue is mantatory and can not be set to None')
			if not check_type(value,ifcpowermeasure):
				self._maximumvalue = ifcpowermeasure(value)
			else:
				self._maximumvalue = value
		return property(**locals())

	@apply
	def minimumvalue():
		def fget( self ):
			return self._minimumvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpowermeasure):
					self._minimumvalue = ifcpowermeasure(value)
				else:
					self._minimumvalue = value
			else:
				self._minimumvalue = value
		return property(**locals())

	@apply
	def thermalloadtimeseriesvalues():
		def fget( self ):
			return self._thermalloadtimeseriesvalues
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimeseries):
					self._thermalloadtimeseriesvalues = ifctimeseries(value)
				else:
					self._thermalloadtimeseriesvalues = value
			else:
				self._thermalloadtimeseriesvalues = value
		return property(**locals())

	@apply
	def userdefinedthermalloadsource():
		def fget( self ):
			return self._userdefinedthermalloadsource
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedthermalloadsource = ifclabel(value)
				else:
					self._userdefinedthermalloadsource = value
			else:
				self._userdefinedthermalloadsource = value
		return property(**locals())

	@apply
	def userdefinedpropertysource():
		def fget( self ):
			return self._userdefinedpropertysource
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedpropertysource = ifclabel(value)
				else:
					self._userdefinedpropertysource = value
			else:
				self._userdefinedpropertysource = value
		return property(**locals())

	@apply
	def thermalloadtype():
		def fget( self ):
			return self._thermalloadtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thermalloadtype is mantatory and can not be set to None')
			if not check_type(value,ifcthermalloadtypeenum):
				self._thermalloadtype = ifcthermalloadtypeenum(value)
			else:
				self._thermalloadtype = value
		return property(**locals())

####################
 # ENTITY ifcdistributionflowelement #
####################
class ifcdistributionflowelement(ifcdistributionelement):
	'''Entity ifcdistributionflowelement definition.

	:param hascontrolelements
	:type hascontrolelements:SET(0,1,'ifcrelflowcontrolelements', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

	@apply
	def hascontrolelements():
		def fget( self ):
			return self._hascontrolelements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hascontrolelements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcflowstoragedevice #
####################
class ifcflowstoragedevice(ifcdistributionflowelement):
	'''Entity ifcflowstoragedevice definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcmateriallayersetusage #
####################
class ifcmateriallayersetusage(BaseEntityClass):
	'''Entity ifcmateriallayersetusage definition.

	:param forlayerset
	:type forlayerset:ifcmateriallayerset

	:param layersetdirection
	:type layersetdirection:ifclayersetdirectionenum

	:param directionsense
	:type directionsense:ifcdirectionsenseenum

	:param offsetfromreferenceline
	:type offsetfromreferenceline:ifclengthmeasure
	'''
	def __init__( self , forlayerset,layersetdirection,directionsense,offsetfromreferenceline, ):
		self.forlayerset = forlayerset
		self.layersetdirection = layersetdirection
		self.directionsense = directionsense
		self.offsetfromreferenceline = offsetfromreferenceline

	@apply
	def forlayerset():
		def fget( self ):
			return self._forlayerset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument forlayerset is mantatory and can not be set to None')
			if not check_type(value,ifcmateriallayerset):
				self._forlayerset = ifcmateriallayerset(value)
			else:
				self._forlayerset = value
		return property(**locals())

	@apply
	def layersetdirection():
		def fget( self ):
			return self._layersetdirection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layersetdirection is mantatory and can not be set to None')
			if not check_type(value,ifclayersetdirectionenum):
				self._layersetdirection = ifclayersetdirectionenum(value)
			else:
				self._layersetdirection = value
		return property(**locals())

	@apply
	def directionsense():
		def fget( self ):
			return self._directionsense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directionsense is mantatory and can not be set to None')
			if not check_type(value,ifcdirectionsenseenum):
				self._directionsense = ifcdirectionsenseenum(value)
			else:
				self._directionsense = value
		return property(**locals())

	@apply
	def offsetfromreferenceline():
		def fget( self ):
			return self._offsetfromreferenceline
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offsetfromreferenceline is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._offsetfromreferenceline = ifclengthmeasure(value)
			else:
				self._offsetfromreferenceline = value
		return property(**locals())

####################
 # ENTITY ifcshapemodel #
####################
class ifcshapemodel(ifcrepresentation):
	'''Entity ifcshapemodel definition.

	:param ofshapeaspect
	:type ofshapeaspect:SET(0,1,'ifcshapeaspect', scope = schema_scope)
	'''
	def __init__( self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items ,  ):
		ifcrepresentation.__init__(self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items , )

	@apply
	def ofshapeaspect():
		def fget( self ):
			return self._ofshapeaspect
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ofshapeaspect is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = ((SIZEOF(self.self.ifcrepresentation.self.ofproductrepresentation)  ==  1) XOR (SIZEOF(self.self.ifcrepresentation.self.representationmap)  ==  1) XOR (SIZEOF(self.ofshapeaspect)  ==  1))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcmateriallayerset #
####################
class ifcmateriallayerset(BaseEntityClass):
	'''Entity ifcmateriallayerset definition.

	:param materiallayers
	:type materiallayers:LIST(1,None,'ifcmateriallayer', scope = schema_scope)

	:param layersetname
	:type layersetname:ifclabel

	:param totalthickness
	:type totalthickness:ifclengthmeasure
	'''
	def __init__( self , materiallayers,layersetname, ):
		self.materiallayers = materiallayers
		self.layersetname = layersetname

	@apply
	def materiallayers():
		def fget( self ):
			return self._materiallayers
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument materiallayers is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcmateriallayer', scope = schema_scope)):
				self._materiallayers = LIST(value)
			else:
				self._materiallayers = value
		return property(**locals())

	@apply
	def layersetname():
		def fget( self ):
			return self._layersetname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._layersetname = ifclabel(value)
				else:
					self._layersetname = value
			else:
				self._layersetname = value
		return property(**locals())

	@apply
	def totalthickness():
		def fget( self ):
			attribute_eval = ifcmlstotalthickness(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument totalthickness is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcperformancehistory #
####################
class ifcperformancehistory(ifccontrol):
	'''Entity ifcperformancehistory definition.

	:param lifecyclephase
	:type lifecyclephase:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , lifecyclephase, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.lifecyclephase = lifecyclephase

	@apply
	def lifecyclephase():
		def fget( self ):
			return self._lifecyclephase
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lifecyclephase is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._lifecyclephase = ifclabel(value)
			else:
				self._lifecyclephase = value
		return property(**locals())

####################
 # ENTITY ifcductsegmenttype #
####################
class ifcductsegmenttype(ifcflowsegmenttype):
	'''Entity ifcductsegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcductsegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowsegmenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcductsegmenttypeenum):
				self._predefinedtype = ifcductsegmenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcductsegmenttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcductsegmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcribplateprofileproperties #
####################
class ifcribplateprofileproperties(ifcprofileproperties):
	'''Entity ifcribplateprofileproperties definition.

	:param thickness
	:type thickness:ifcpositivelengthmeasure

	:param ribheight
	:type ribheight:ifcpositivelengthmeasure

	:param ribwidth
	:type ribwidth:ifcpositivelengthmeasure

	:param ribspacing
	:type ribspacing:ifcpositivelengthmeasure

	:param direction
	:type direction:ifcribplatedirectionenum
	'''
	def __init__( self , inherited0__profilename , inherited1__profiledefinition , thickness,ribheight,ribwidth,ribspacing,direction, ):
		ifcprofileproperties.__init__(self , inherited0__profilename , inherited1__profiledefinition , )
		self.thickness = thickness
		self.ribheight = ribheight
		self.ribwidth = ribwidth
		self.ribspacing = ribspacing
		self.direction = direction

	@apply
	def thickness():
		def fget( self ):
			return self._thickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._thickness = ifcpositivelengthmeasure(value)
				else:
					self._thickness = value
			else:
				self._thickness = value
		return property(**locals())

	@apply
	def ribheight():
		def fget( self ):
			return self._ribheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._ribheight = ifcpositivelengthmeasure(value)
				else:
					self._ribheight = value
			else:
				self._ribheight = value
		return property(**locals())

	@apply
	def ribwidth():
		def fget( self ):
			return self._ribwidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._ribwidth = ifcpositivelengthmeasure(value)
				else:
					self._ribwidth = value
			else:
				self._ribwidth = value
		return property(**locals())

	@apply
	def ribspacing():
		def fget( self ):
			return self._ribspacing
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._ribspacing = ifcpositivelengthmeasure(value)
				else:
					self._ribspacing = value
			else:
				self._ribspacing = value
		return property(**locals())

	@apply
	def direction():
		def fget( self ):
			return self._direction
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument direction is mantatory and can not be set to None')
			if not check_type(value,ifcribplatedirectionenum):
				self._direction = ifcribplatedirectionenum(value)
			else:
				self._direction = value
		return property(**locals())

####################
 # ENTITY ifcdampertype #
####################
class ifcdampertype(ifcflowcontrollertype):
	'''Entity ifcdampertype definition.

	:param predefinedtype
	:type predefinedtype:ifcdampertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcdampertypeenum):
				self._predefinedtype = ifcdampertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcdampertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcdampertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcphysicalquantity #
####################
class ifcphysicalquantity(BaseEntityClass):
	'''Entity ifcphysicalquantity definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param partofcomplex
	:type partofcomplex:SET(0,1,'ifcphysicalcomplexquantity', scope = schema_scope)
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def partofcomplex():
		def fget( self ):
			return self._partofcomplex
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofcomplex is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcphysicalsimplequantity #
####################
class ifcphysicalsimplequantity(ifcphysicalquantity):
	'''Entity ifcphysicalsimplequantity definition.

	:param unit
	:type unit:ifcnamedunit
	'''
	def __init__( self , inherited0__name , inherited1__description , unit, ):
		ifcphysicalquantity.__init__(self , inherited0__name , inherited1__description , )
		self.unit = unit

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnamedunit):
					self._unit = ifcnamedunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())

####################
 # ENTITY ifcwindowliningproperties #
####################
class ifcwindowliningproperties(ifcpropertysetdefinition):
	'''Entity ifcwindowliningproperties definition.

	:param liningdepth
	:type liningdepth:ifcpositivelengthmeasure

	:param liningthickness
	:type liningthickness:ifcpositivelengthmeasure

	:param transomthickness
	:type transomthickness:ifcpositivelengthmeasure

	:param mullionthickness
	:type mullionthickness:ifcpositivelengthmeasure

	:param firsttransomoffset
	:type firsttransomoffset:ifcnormalisedratiomeasure

	:param secondtransomoffset
	:type secondtransomoffset:ifcnormalisedratiomeasure

	:param firstmullionoffset
	:type firstmullionoffset:ifcnormalisedratiomeasure

	:param secondmullionoffset
	:type secondmullionoffset:ifcnormalisedratiomeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , liningdepth,liningthickness,transomthickness,mullionthickness,firsttransomoffset,secondtransomoffset,firstmullionoffset,secondmullionoffset,shapeaspectstyle, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.liningdepth = liningdepth
		self.liningthickness = liningthickness
		self.transomthickness = transomthickness
		self.mullionthickness = mullionthickness
		self.firsttransomoffset = firsttransomoffset
		self.secondtransomoffset = secondtransomoffset
		self.firstmullionoffset = firstmullionoffset
		self.secondmullionoffset = secondmullionoffset
		self.shapeaspectstyle = shapeaspectstyle

	@apply
	def liningdepth():
		def fget( self ):
			return self._liningdepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._liningdepth = ifcpositivelengthmeasure(value)
				else:
					self._liningdepth = value
			else:
				self._liningdepth = value
		return property(**locals())

	@apply
	def liningthickness():
		def fget( self ):
			return self._liningthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._liningthickness = ifcpositivelengthmeasure(value)
				else:
					self._liningthickness = value
			else:
				self._liningthickness = value
		return property(**locals())

	@apply
	def transomthickness():
		def fget( self ):
			return self._transomthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._transomthickness = ifcpositivelengthmeasure(value)
				else:
					self._transomthickness = value
			else:
				self._transomthickness = value
		return property(**locals())

	@apply
	def mullionthickness():
		def fget( self ):
			return self._mullionthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._mullionthickness = ifcpositivelengthmeasure(value)
				else:
					self._mullionthickness = value
			else:
				self._mullionthickness = value
		return property(**locals())

	@apply
	def firsttransomoffset():
		def fget( self ):
			return self._firsttransomoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._firsttransomoffset = ifcnormalisedratiomeasure(value)
				else:
					self._firsttransomoffset = value
			else:
				self._firsttransomoffset = value
		return property(**locals())

	@apply
	def secondtransomoffset():
		def fget( self ):
			return self._secondtransomoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._secondtransomoffset = ifcnormalisedratiomeasure(value)
				else:
					self._secondtransomoffset = value
			else:
				self._secondtransomoffset = value
		return property(**locals())

	@apply
	def firstmullionoffset():
		def fget( self ):
			return self._firstmullionoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._firstmullionoffset = ifcnormalisedratiomeasure(value)
				else:
					self._firstmullionoffset = value
			else:
				self._firstmullionoffset = value
		return property(**locals())

	@apply
	def secondmullionoffset():
		def fget( self ):
			return self._secondmullionoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._secondmullionoffset = ifcnormalisedratiomeasure(value)
				else:
					self._secondmullionoffset = value
			else:
				self._secondmullionoffset = value
		return property(**locals())

	@apply
	def shapeaspectstyle():
		def fget( self ):
			return self._shapeaspectstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshapeaspect):
					self._shapeaspectstyle = ifcshapeaspect(value)
				else:
					self._shapeaspectstyle = value
			else:
				self._shapeaspectstyle = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = ( not (( not EXISTS(self.liningdepth))  and  EXISTS(self.liningthickness)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = ( not (( not EXISTS(self.firsttransomoffset))  and  EXISTS(self.secondtransomoffset)))
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr

	def wr33(self):
		eval_wr33_wr = ( not (( not EXISTS(self.firstmullionoffset))  and  EXISTS(self.secondmullionoffset)))
		if not eval_wr33_wr:
			raise AssertionError('Rule wr33 violated')
		else:
			return eval_wr33_wr

	def wr34(self):
		eval_wr34_wr = (EXISTS(self.self.ifcpropertysetdefinition.self.definestype[1])  and  ('IFC2X3.IFCWINDOWSTYLE'  ==  TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1])))
		if not eval_wr34_wr:
			raise AssertionError('Rule wr34 violated')
		else:
			return eval_wr34_wr


####################
 # ENTITY ifcorganization #
####################
class ifcorganization(BaseEntityClass):
	'''Entity ifcorganization definition.

	:param id
	:type id:ifcidentifier

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param roles
	:type roles:LIST(1,None,'ifcactorrole', scope = schema_scope)

	:param addresses
	:type addresses:LIST(1,None,'ifcaddress', scope = schema_scope)

	:param isrelatedby
	:type isrelatedby:SET(0,None,'ifcorganizationrelationship', scope = schema_scope)

	:param relates
	:type relates:SET(0,None,'ifcorganizationrelationship', scope = schema_scope)

	:param engages
	:type engages:SET(0,None,'ifcpersonandorganization', scope = schema_scope)
	'''
	def __init__( self , id,name,description,roles,addresses, ):
		self.id = id
		self.name = name
		self.description = description
		self.roles = roles
		self.addresses = addresses

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._id = ifcidentifier(value)
				else:
					self._id = value
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def roles():
		def fget( self ):
			return self._roles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcactorrole', scope = schema_scope)):
					self._roles = LIST(value)
				else:
					self._roles = value
			else:
				self._roles = value
		return property(**locals())

	@apply
	def addresses():
		def fget( self ):
			return self._addresses
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcaddress', scope = schema_scope)):
					self._addresses = LIST(value)
				else:
					self._addresses = value
			else:
				self._addresses = value
		return property(**locals())

	@apply
	def isrelatedby():
		def fget( self ):
			return self._isrelatedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isrelatedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def relates():
		def fget( self ):
			return self._relates
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument relates is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def engages():
		def fget( self ):
			return self._engages
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument engages is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcquantitycount #
####################
class ifcquantitycount(ifcphysicalsimplequantity):
	'''Entity ifcquantitycount definition.

	:param countvalue
	:type countvalue:ifccountmeasure
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , countvalue, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.countvalue = countvalue

	@apply
	def countvalue():
		def fget( self ):
			return self._countvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument countvalue is mantatory and can not be set to None')
			if not check_type(value,ifccountmeasure):
				self._countvalue = ifccountmeasure(value)
			else:
				self._countvalue = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (self.countvalue  >=  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcannotation #
####################
class ifcannotation(ifcproduct):
	'''Entity ifcannotation definition.

	:param containedinstructure
	:type containedinstructure:SET(0,1,'ifcrelcontainedinspatialstructure', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation ,  ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )

	@apply
	def containedinstructure():
		def fget( self ):
			return self._containedinstructure
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument containedinstructure is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcfacebasedsurfacemodel #
####################
class ifcfacebasedsurfacemodel(ifcgeometricrepresentationitem):
	'''Entity ifcfacebasedsurfacemodel definition.

	:param fbsmfaces
	:type fbsmfaces:SET(1,None,'ifcconnectedfaceset', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , fbsmfaces, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.fbsmfaces = fbsmfaces

	@apply
	def fbsmfaces():
		def fget( self ):
			return self._fbsmfaces
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fbsmfaces is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcconnectedfaceset', scope = schema_scope)):
				self._fbsmfaces = SET(value)
			else:
				self._fbsmfaces = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcpropertyenumeration #
####################
class ifcpropertyenumeration(BaseEntityClass):
	'''Entity ifcpropertyenumeration definition.

	:param name
	:type name:ifclabel

	:param enumerationvalues
	:type enumerationvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param unit
	:type unit:ifcunit
	'''
	def __init__( self , name,enumerationvalues,unit, ):
		self.name = name
		self.enumerationvalues = enumerationvalues
		self.unit = unit

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def enumerationvalues():
		def fget( self ):
			return self._enumerationvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument enumerationvalues is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
				self._enumerationvalues = LIST(value)
			else:
				self._enumerationvalues = value
		return property(**locals())

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._unit = ifcunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())
	def wr01(self):
		eval_wr01_wr = (SIZEOF(None)  ==  0)
		if not eval_wr01_wr:
			raise AssertionError('Rule wr01 violated')
		else:
			return eval_wr01_wr


####################
 # ENTITY ifcrelconnectsports #
####################
class ifcrelconnectsports(ifcrelconnects):
	'''Entity ifcrelconnectsports definition.

	:param relatingport
	:type relatingport:ifcport

	:param relatedport
	:type relatedport:ifcport

	:param realizingelement
	:type realizingelement:ifcelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingport,relatedport,realizingelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingport = relatingport
		self.relatedport = relatedport
		self.realizingelement = realizingelement

	@apply
	def relatingport():
		def fget( self ):
			return self._relatingport
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingport is mantatory and can not be set to None')
			if not check_type(value,ifcport):
				self._relatingport = ifcport(value)
			else:
				self._relatingport = value
		return property(**locals())

	@apply
	def relatedport():
		def fget( self ):
			return self._relatedport
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedport is mantatory and can not be set to None')
			if not check_type(value,ifcport):
				self._relatedport = ifcport(value)
			else:
				self._relatedport = value
		return property(**locals())

	@apply
	def realizingelement():
		def fget( self ):
			return self._realizingelement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelement):
					self._realizingelement = ifcelement(value)
				else:
					self._realizingelement = value
			else:
				self._realizingelement = value
		return property(**locals())

####################
 # ENTITY ifcrectangulartrimmedsurface #
####################
class ifcrectangulartrimmedsurface(ifcboundedsurface):
	'''Entity ifcrectangulartrimmedsurface definition.

	:param basissurface
	:type basissurface:ifcsurface

	:param u1
	:type u1:ifcparametervalue

	:param v1
	:type v1:ifcparametervalue

	:param u2
	:type u2:ifcparametervalue

	:param v2
	:type v2:ifcparametervalue

	:param usense
	:type usense:BOOLEAN

	:param vsense
	:type vsense:BOOLEAN

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , basissurface,u1,v1,u2,v2,usense,vsense, ):
		ifcboundedsurface.__init__(self , )
		self.basissurface = basissurface
		self.u1 = u1
		self.v1 = v1
		self.u2 = u2
		self.v2 = v2
		self.usense = usense
		self.vsense = vsense

	@apply
	def basissurface():
		def fget( self ):
			return self._basissurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basissurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._basissurface = ifcsurface(value)
			else:
				self._basissurface = value
		return property(**locals())

	@apply
	def u1():
		def fget( self ):
			return self._u1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u1 is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._u1 = ifcparametervalue(value)
			else:
				self._u1 = value
		return property(**locals())

	@apply
	def v1():
		def fget( self ):
			return self._v1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v1 is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._v1 = ifcparametervalue(value)
			else:
				self._v1 = value
		return property(**locals())

	@apply
	def u2():
		def fget( self ):
			return self._u2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u2 is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._u2 = ifcparametervalue(value)
			else:
				self._u2 = value
		return property(**locals())

	@apply
	def v2():
		def fget( self ):
			return self._v2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v2 is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._v2 = ifcparametervalue(value)
			else:
				self._v2 = value
		return property(**locals())

	@apply
	def usense():
		def fget( self ):
			return self._usense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument usense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._usense = BOOLEAN(value)
			else:
				self._usense = value
		return property(**locals())

	@apply
	def vsense():
		def fget( self ):
			return self._vsense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vsense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._vsense = BOOLEAN(value)
			else:
				self._vsense = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.basissurface.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.u1  !=  self.u2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.v1  !=  self.v2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (((('IFC2X3.IFCELEMENTARYSURFACE'  ==  TYPEOF(self.basissurface))  and  ( not ('IFC2X3.IFCPLANE'  ==  TYPEOF(self.basissurface))))  or  ('IFC2X3.IFCSURFACEOFREVOLUTION'  ==  TYPEOF(self.basissurface)))  or  (self.usense  ==  (self.u2  >  self.u1)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (self.vsense  ==  (self.v2  >  self.v1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY ifcspatialstructureelement #
####################
class ifcspatialstructureelement(ifcproduct):
	'''Entity ifcspatialstructureelement definition.

	:param longname
	:type longname:ifclabel

	:param compositiontype
	:type compositiontype:ifcelementcompositionenum

	:param referenceselements
	:type referenceselements:SET(0,None,'ifcrelreferencedinspatialstructure', scope = schema_scope)

	:param servicedbysystems
	:type servicedbysystems:SET(0,None,'ifcrelservicesbuildings', scope = schema_scope)

	:param containselements
	:type containselements:SET(0,None,'ifcrelcontainedinspatialstructure', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , longname,compositiontype, ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.longname = longname
		self.compositiontype = compositiontype

	@apply
	def longname():
		def fget( self ):
			return self._longname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._longname = ifclabel(value)
				else:
					self._longname = value
			else:
				self._longname = value
		return property(**locals())

	@apply
	def compositiontype():
		def fget( self ):
			return self._compositiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument compositiontype is mantatory and can not be set to None')
			if not check_type(value,ifcelementcompositionenum):
				self._compositiontype = ifcelementcompositionenum(value)
			else:
				self._compositiontype = value
		return property(**locals())

	@apply
	def referenceselements():
		def fget( self ):
			return self._referenceselements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referenceselements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def servicedbysystems():
		def fget( self ):
			return self._servicedbysystems
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument servicedbysystems is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def containselements():
		def fget( self ):
			return self._containselements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument containselements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = (((HIINDEX(self.self.ifcobjectdefinition.self.decomposes)  ==  1)  and  ('IFC2X3.IFCRELAGGREGATES'  ==  TYPEOF(self.self.ifcobjectdefinition.self.decomposes[1])))  and  (('IFC2X3.IFCPROJECT'  ==  TYPEOF(self.self.ifcobjectdefinition.self.decomposes[1].self.relatingobject))  or  ('IFC2X3.IFCSPATIALSTRUCTUREELEMENT'  ==  TYPEOF(self.self.ifcobjectdefinition.self.decomposes[1].self.relatingobject))))
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr


####################
 # ENTITY ifcbuilding #
####################
class ifcbuilding(ifcspatialstructureelement):
	'''Entity ifcbuilding definition.

	:param elevationofrefheight
	:type elevationofrefheight:ifclengthmeasure

	:param elevationofterrain
	:type elevationofterrain:ifclengthmeasure

	:param buildingaddress
	:type buildingaddress:ifcpostaladdress
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , elevationofrefheight,elevationofterrain,buildingaddress, ):
		ifcspatialstructureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , )
		self.elevationofrefheight = elevationofrefheight
		self.elevationofterrain = elevationofterrain
		self.buildingaddress = buildingaddress

	@apply
	def elevationofrefheight():
		def fget( self ):
			return self._elevationofrefheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._elevationofrefheight = ifclengthmeasure(value)
				else:
					self._elevationofrefheight = value
			else:
				self._elevationofrefheight = value
		return property(**locals())

	@apply
	def elevationofterrain():
		def fget( self ):
			return self._elevationofterrain
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._elevationofterrain = ifclengthmeasure(value)
				else:
					self._elevationofterrain = value
			else:
				self._elevationofterrain = value
		return property(**locals())

	@apply
	def buildingaddress():
		def fget( self ):
			return self._buildingaddress
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpostaladdress):
					self._buildingaddress = ifcpostaladdress(value)
				else:
					self._buildingaddress = value
			else:
				self._buildingaddress = value
		return property(**locals())

####################
 # ENTITY ifccolumn #
####################
class ifccolumn(ifcbuildingelement):
	'''Entity ifccolumn definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcextrudedareasolid #
####################
class ifcextrudedareasolid(ifcsweptareasolid):
	'''Entity ifcextrudedareasolid definition.

	:param extrudeddirection
	:type extrudeddirection:ifcdirection

	:param depth
	:type depth:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__sweptarea , inherited1__position , extrudeddirection,depth, ):
		ifcsweptareasolid.__init__(self , inherited0__sweptarea , inherited1__position , )
		self.extrudeddirection = extrudeddirection
		self.depth = depth

	@apply
	def extrudeddirection():
		def fget( self ):
			return self._extrudeddirection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extrudeddirection is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._extrudeddirection = ifcdirection(value)
			else:
				self._extrudeddirection = value
		return property(**locals())

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (ifcdotproduct((ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,0,1]),self.self.extrudeddirection)  !=  0)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcmechanicalsteelmaterialproperties #
####################
class ifcmechanicalsteelmaterialproperties(ifcmechanicalmaterialproperties):
	'''Entity ifcmechanicalsteelmaterialproperties definition.

	:param yieldstress
	:type yieldstress:ifcpressuremeasure

	:param ultimatestress
	:type ultimatestress:ifcpressuremeasure

	:param ultimatestrain
	:type ultimatestrain:ifcpositiveratiomeasure

	:param hardeningmodule
	:type hardeningmodule:ifcmodulusofelasticitymeasure

	:param proportionalstress
	:type proportionalstress:ifcpressuremeasure

	:param plasticstrain
	:type plasticstrain:ifcpositiveratiomeasure

	:param relaxations
	:type relaxations:SET(1,None,'ifcrelaxation', scope = schema_scope)
	'''
	def __init__( self , inherited0__material , inherited1__dynamicviscosity , inherited2__youngmodulus , inherited3__shearmodulus , inherited4__poissonratio , inherited5__thermalexpansioncoefficient , yieldstress,ultimatestress,ultimatestrain,hardeningmodule,proportionalstress,plasticstrain,relaxations, ):
		ifcmechanicalmaterialproperties.__init__(self , inherited0__material , inherited1__dynamicviscosity , inherited2__youngmodulus , inherited3__shearmodulus , inherited4__poissonratio , inherited5__thermalexpansioncoefficient , )
		self.yieldstress = yieldstress
		self.ultimatestress = ultimatestress
		self.ultimatestrain = ultimatestrain
		self.hardeningmodule = hardeningmodule
		self.proportionalstress = proportionalstress
		self.plasticstrain = plasticstrain
		self.relaxations = relaxations

	@apply
	def yieldstress():
		def fget( self ):
			return self._yieldstress
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpressuremeasure):
					self._yieldstress = ifcpressuremeasure(value)
				else:
					self._yieldstress = value
			else:
				self._yieldstress = value
		return property(**locals())

	@apply
	def ultimatestress():
		def fget( self ):
			return self._ultimatestress
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpressuremeasure):
					self._ultimatestress = ifcpressuremeasure(value)
				else:
					self._ultimatestress = value
			else:
				self._ultimatestress = value
		return property(**locals())

	@apply
	def ultimatestrain():
		def fget( self ):
			return self._ultimatestrain
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._ultimatestrain = ifcpositiveratiomeasure(value)
				else:
					self._ultimatestrain = value
			else:
				self._ultimatestrain = value
		return property(**locals())

	@apply
	def hardeningmodule():
		def fget( self ):
			return self._hardeningmodule
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofelasticitymeasure):
					self._hardeningmodule = ifcmodulusofelasticitymeasure(value)
				else:
					self._hardeningmodule = value
			else:
				self._hardeningmodule = value
		return property(**locals())

	@apply
	def proportionalstress():
		def fget( self ):
			return self._proportionalstress
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpressuremeasure):
					self._proportionalstress = ifcpressuremeasure(value)
				else:
					self._proportionalstress = value
			else:
				self._proportionalstress = value
		return property(**locals())

	@apply
	def plasticstrain():
		def fget( self ):
			return self._plasticstrain
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._plasticstrain = ifcpositiveratiomeasure(value)
				else:
					self._plasticstrain = value
			else:
				self._plasticstrain = value
		return property(**locals())

	@apply
	def relaxations():
		def fget( self ):
			return self._relaxations
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcrelaxation', scope = schema_scope)):
					self._relaxations = SET(value)
				else:
					self._relaxations = value
			else:
				self._relaxations = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (( not EXISTS(self.yieldstress))  or  (self.yieldstress  >=  0))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = (( not EXISTS(self.ultimatestress))  or  (self.ultimatestress  >=  0))
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr

	def wr33(self):
		eval_wr33_wr = (( not EXISTS(self.hardeningmodule))  or  (self.hardeningmodule  >=  0))
		if not eval_wr33_wr:
			raise AssertionError('Rule wr33 violated')
		else:
			return eval_wr33_wr

	def wr34(self):
		eval_wr34_wr = (( not EXISTS(self.proportionalstress))  or  (self.proportionalstress  >=  0))
		if not eval_wr34_wr:
			raise AssertionError('Rule wr34 violated')
		else:
			return eval_wr34_wr


####################
 # ENTITY ifcfurnishingelementtype #
####################
class ifcfurnishingelementtype(ifcelementtype):
	'''Entity ifcfurnishingelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcsystemfurnitureelementtype #
####################
class ifcsystemfurnitureelementtype(ifcfurnishingelementtype):
	'''Entity ifcsystemfurnitureelementtype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcfurnishingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcthermalmaterialproperties #
####################
class ifcthermalmaterialproperties(ifcmaterialproperties):
	'''Entity ifcthermalmaterialproperties definition.

	:param specificheatcapacity
	:type specificheatcapacity:ifcspecificheatcapacitymeasure

	:param boilingpoint
	:type boilingpoint:ifcthermodynamictemperaturemeasure

	:param freezingpoint
	:type freezingpoint:ifcthermodynamictemperaturemeasure

	:param thermalconductivity
	:type thermalconductivity:ifcthermalconductivitymeasure
	'''
	def __init__( self , inherited0__material , specificheatcapacity,boilingpoint,freezingpoint,thermalconductivity, ):
		ifcmaterialproperties.__init__(self , inherited0__material , )
		self.specificheatcapacity = specificheatcapacity
		self.boilingpoint = boilingpoint
		self.freezingpoint = freezingpoint
		self.thermalconductivity = thermalconductivity

	@apply
	def specificheatcapacity():
		def fget( self ):
			return self._specificheatcapacity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcspecificheatcapacitymeasure):
					self._specificheatcapacity = ifcspecificheatcapacitymeasure(value)
				else:
					self._specificheatcapacity = value
			else:
				self._specificheatcapacity = value
		return property(**locals())

	@apply
	def boilingpoint():
		def fget( self ):
			return self._boilingpoint
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermodynamictemperaturemeasure):
					self._boilingpoint = ifcthermodynamictemperaturemeasure(value)
				else:
					self._boilingpoint = value
			else:
				self._boilingpoint = value
		return property(**locals())

	@apply
	def freezingpoint():
		def fget( self ):
			return self._freezingpoint
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermodynamictemperaturemeasure):
					self._freezingpoint = ifcthermodynamictemperaturemeasure(value)
				else:
					self._freezingpoint = value
			else:
				self._freezingpoint = value
		return property(**locals())

	@apply
	def thermalconductivity():
		def fget( self ):
			return self._thermalconductivity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermalconductivitymeasure):
					self._thermalconductivity = ifcthermalconductivitymeasure(value)
				else:
					self._thermalconductivity = value
			else:
				self._thermalconductivity = value
		return property(**locals())

####################
 # ENTITY ifccsgprimitive3d #
####################
class ifccsgprimitive3d(ifcgeometricrepresentationitem):
	'''Entity ifccsgprimitive3d definition.

	:param position
	:type position:ifcaxis2placement3d

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , position, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement3d):
				self._position = ifcaxis2placement3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcrightcircularcylinder #
####################
class ifcrightcircularcylinder(ifccsgprimitive3d):
	'''Entity ifcrightcircularcylinder definition.

	:param height
	:type height:ifcpositivelengthmeasure

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , height,radius, ):
		ifccsgprimitive3d.__init__(self , inherited0__position , )
		self.height = height
		self.radius = radius

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._height = ifcpositivelengthmeasure(value)
			else:
				self._height = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY ifctextliteralwithextent #
####################
class ifctextliteralwithextent(ifctextliteral):
	'''Entity ifctextliteralwithextent definition.

	:param extent
	:type extent:ifcplanarextent

	:param boxalignment
	:type boxalignment:ifcboxalignment
	'''
	def __init__( self , inherited0__literal , inherited1__placement , inherited2__path , extent,boxalignment, ):
		ifctextliteral.__init__(self , inherited0__literal , inherited1__placement , inherited2__path , )
		self.extent = extent
		self.boxalignment = boxalignment

	@apply
	def extent():
		def fget( self ):
			return self._extent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extent is mantatory and can not be set to None')
			if not check_type(value,ifcplanarextent):
				self._extent = ifcplanarextent(value)
			else:
				self._extent = value
		return property(**locals())

	@apply
	def boxalignment():
		def fget( self ):
			return self._boxalignment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument boxalignment is mantatory and can not be set to None')
			if not check_type(value,ifcboxalignment):
				self._boxalignment = ifcboxalignment(value)
			else:
				self._boxalignment = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = ( not ('IFC2X3.IFCPLANARBOX'  ==  TYPEOF(self.extent)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcconstraint #
####################
class ifcconstraint(BaseEntityClass):
	'''Entity ifcconstraint definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param constraintgrade
	:type constraintgrade:ifcconstraintenum

	:param constraintsource
	:type constraintsource:ifclabel

	:param creatingactor
	:type creatingactor:ifcactorselect

	:param creationtime
	:type creationtime:ifcdatetimeselect

	:param userdefinedgrade
	:type userdefinedgrade:ifclabel

	:param classifiedas
	:type classifiedas:SET(0,None,'ifcconstraintclassificationrelationship', scope = schema_scope)

	:param relatesconstraints
	:type relatesconstraints:SET(0,None,'ifcconstraintrelationship', scope = schema_scope)

	:param isrelatedwith
	:type isrelatedwith:SET(0,None,'ifcconstraintrelationship', scope = schema_scope)

	:param propertiesforconstraint
	:type propertiesforconstraint:SET(0,None,'ifcpropertyconstraintrelationship', scope = schema_scope)

	:param aggregates
	:type aggregates:SET(0,None,'ifcconstraintaggregationrelationship', scope = schema_scope)

	:param isaggregatedin
	:type isaggregatedin:SET(0,None,'ifcconstraintaggregationrelationship', scope = schema_scope)
	'''
	def __init__( self , name,description,constraintgrade,constraintsource,creatingactor,creationtime,userdefinedgrade, ):
		self.name = name
		self.description = description
		self.constraintgrade = constraintgrade
		self.constraintsource = constraintsource
		self.creatingactor = creatingactor
		self.creationtime = creationtime
		self.userdefinedgrade = userdefinedgrade

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def constraintgrade():
		def fget( self ):
			return self._constraintgrade
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constraintgrade is mantatory and can not be set to None')
			if not check_type(value,ifcconstraintenum):
				self._constraintgrade = ifcconstraintenum(value)
			else:
				self._constraintgrade = value
		return property(**locals())

	@apply
	def constraintsource():
		def fget( self ):
			return self._constraintsource
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._constraintsource = ifclabel(value)
				else:
					self._constraintsource = value
			else:
				self._constraintsource = value
		return property(**locals())

	@apply
	def creatingactor():
		def fget( self ):
			return self._creatingactor
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._creatingactor = ifcactorselect(value)
				else:
					self._creatingactor = value
			else:
				self._creatingactor = value
		return property(**locals())

	@apply
	def creationtime():
		def fget( self ):
			return self._creationtime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._creationtime = ifcdatetimeselect(value)
				else:
					self._creationtime = value
			else:
				self._creationtime = value
		return property(**locals())

	@apply
	def userdefinedgrade():
		def fget( self ):
			return self._userdefinedgrade
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedgrade = ifclabel(value)
				else:
					self._userdefinedgrade = value
			else:
				self._userdefinedgrade = value
		return property(**locals())

	@apply
	def classifiedas():
		def fget( self ):
			return self._classifiedas
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument classifiedas is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def relatesconstraints():
		def fget( self ):
			return self._relatesconstraints
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument relatesconstraints is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isrelatedwith():
		def fget( self ):
			return self._isrelatedwith
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isrelatedwith is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def propertiesforconstraint():
		def fget( self ):
			return self._propertiesforconstraint
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument propertiesforconstraint is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def aggregates():
		def fget( self ):
			return self._aggregates
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument aggregates is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isaggregatedin():
		def fget( self ):
			return self._isaggregatedin
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isaggregatedin is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = ((self.constraintgrade  !=  ifcconstraintenum.self.userdefined)  or  ((self.constraintgrade  ==  ifcconstraintenum.self.userdefined)  and  EXISTS(self.self.ifcconstraint.self.userdefinedgrade)))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcobjective #
####################
class ifcobjective(ifcconstraint):
	'''Entity ifcobjective definition.

	:param benchmarkvalues
	:type benchmarkvalues:ifcmetric

	:param resultvalues
	:type resultvalues:ifcmetric

	:param objectivequalifier
	:type objectivequalifier:ifcobjectiveenum

	:param userdefinedqualifier
	:type userdefinedqualifier:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__constraintgrade , inherited3__constraintsource , inherited4__creatingactor , inherited5__creationtime , inherited6__userdefinedgrade , benchmarkvalues,resultvalues,objectivequalifier,userdefinedqualifier, ):
		ifcconstraint.__init__(self , inherited0__name , inherited1__description , inherited2__constraintgrade , inherited3__constraintsource , inherited4__creatingactor , inherited5__creationtime , inherited6__userdefinedgrade , )
		self.benchmarkvalues = benchmarkvalues
		self.resultvalues = resultvalues
		self.objectivequalifier = objectivequalifier
		self.userdefinedqualifier = userdefinedqualifier

	@apply
	def benchmarkvalues():
		def fget( self ):
			return self._benchmarkvalues
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmetric):
					self._benchmarkvalues = ifcmetric(value)
				else:
					self._benchmarkvalues = value
			else:
				self._benchmarkvalues = value
		return property(**locals())

	@apply
	def resultvalues():
		def fget( self ):
			return self._resultvalues
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmetric):
					self._resultvalues = ifcmetric(value)
				else:
					self._resultvalues = value
			else:
				self._resultvalues = value
		return property(**locals())

	@apply
	def objectivequalifier():
		def fget( self ):
			return self._objectivequalifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument objectivequalifier is mantatory and can not be set to None')
			if not check_type(value,ifcobjectiveenum):
				self._objectivequalifier = ifcobjectiveenum(value)
			else:
				self._objectivequalifier = value
		return property(**locals())

	@apply
	def userdefinedqualifier():
		def fget( self ):
			return self._userdefinedqualifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedqualifier = ifclabel(value)
				else:
					self._userdefinedqualifier = value
			else:
				self._userdefinedqualifier = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = ((self.objectivequalifier  !=  ifcobjectiveenum.self.userdefined)  or  ((self.objectivequalifier  ==  ifcobjectiveenum.self.userdefined)  and  EXISTS(self.self.ifcobjective.self.userdefinedqualifier)))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcbuildingelementcomponent #
####################
class ifcbuildingelementcomponent(ifcbuildingelement):
	'''Entity ifcbuildingelementcomponent definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcreinforcingelement #
####################
class ifcreinforcingelement(ifcbuildingelementcomponent):
	'''Entity ifcreinforcingelement definition.

	:param steelgrade
	:type steelgrade:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , steelgrade, ):
		ifcbuildingelementcomponent.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.steelgrade = steelgrade

	@apply
	def steelgrade():
		def fget( self ):
			return self._steelgrade
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._steelgrade = ifclabel(value)
				else:
					self._steelgrade = value
			else:
				self._steelgrade = value
		return property(**locals())

####################
 # ENTITY ifcreinforcingmesh #
####################
class ifcreinforcingmesh(ifcreinforcingelement):
	'''Entity ifcreinforcingmesh definition.

	:param meshlength
	:type meshlength:ifcpositivelengthmeasure

	:param meshwidth
	:type meshwidth:ifcpositivelengthmeasure

	:param longitudinalbarnominaldiameter
	:type longitudinalbarnominaldiameter:ifcpositivelengthmeasure

	:param transversebarnominaldiameter
	:type transversebarnominaldiameter:ifcpositivelengthmeasure

	:param longitudinalbarcrosssectionarea
	:type longitudinalbarcrosssectionarea:ifcareameasure

	:param transversebarcrosssectionarea
	:type transversebarcrosssectionarea:ifcareameasure

	:param longitudinalbarspacing
	:type longitudinalbarspacing:ifcpositivelengthmeasure

	:param transversebarspacing
	:type transversebarspacing:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , meshlength,meshwidth,longitudinalbarnominaldiameter,transversebarnominaldiameter,longitudinalbarcrosssectionarea,transversebarcrosssectionarea,longitudinalbarspacing,transversebarspacing, ):
		ifcreinforcingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , )
		self.meshlength = meshlength
		self.meshwidth = meshwidth
		self.longitudinalbarnominaldiameter = longitudinalbarnominaldiameter
		self.transversebarnominaldiameter = transversebarnominaldiameter
		self.longitudinalbarcrosssectionarea = longitudinalbarcrosssectionarea
		self.transversebarcrosssectionarea = transversebarcrosssectionarea
		self.longitudinalbarspacing = longitudinalbarspacing
		self.transversebarspacing = transversebarspacing

	@apply
	def meshlength():
		def fget( self ):
			return self._meshlength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._meshlength = ifcpositivelengthmeasure(value)
				else:
					self._meshlength = value
			else:
				self._meshlength = value
		return property(**locals())

	@apply
	def meshwidth():
		def fget( self ):
			return self._meshwidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._meshwidth = ifcpositivelengthmeasure(value)
				else:
					self._meshwidth = value
			else:
				self._meshwidth = value
		return property(**locals())

	@apply
	def longitudinalbarnominaldiameter():
		def fget( self ):
			return self._longitudinalbarnominaldiameter
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument longitudinalbarnominaldiameter is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._longitudinalbarnominaldiameter = ifcpositivelengthmeasure(value)
			else:
				self._longitudinalbarnominaldiameter = value
		return property(**locals())

	@apply
	def transversebarnominaldiameter():
		def fget( self ):
			return self._transversebarnominaldiameter
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transversebarnominaldiameter is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._transversebarnominaldiameter = ifcpositivelengthmeasure(value)
			else:
				self._transversebarnominaldiameter = value
		return property(**locals())

	@apply
	def longitudinalbarcrosssectionarea():
		def fget( self ):
			return self._longitudinalbarcrosssectionarea
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument longitudinalbarcrosssectionarea is mantatory and can not be set to None')
			if not check_type(value,ifcareameasure):
				self._longitudinalbarcrosssectionarea = ifcareameasure(value)
			else:
				self._longitudinalbarcrosssectionarea = value
		return property(**locals())

	@apply
	def transversebarcrosssectionarea():
		def fget( self ):
			return self._transversebarcrosssectionarea
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transversebarcrosssectionarea is mantatory and can not be set to None')
			if not check_type(value,ifcareameasure):
				self._transversebarcrosssectionarea = ifcareameasure(value)
			else:
				self._transversebarcrosssectionarea = value
		return property(**locals())

	@apply
	def longitudinalbarspacing():
		def fget( self ):
			return self._longitudinalbarspacing
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument longitudinalbarspacing is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._longitudinalbarspacing = ifcpositivelengthmeasure(value)
			else:
				self._longitudinalbarspacing = value
		return property(**locals())

	@apply
	def transversebarspacing():
		def fget( self ):
			return self._transversebarspacing
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transversebarspacing is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._transversebarspacing = ifcpositivelengthmeasure(value)
			else:
				self._transversebarspacing = value
		return property(**locals())

####################
 # ENTITY ifctubebundletype #
####################
class ifctubebundletype(ifcenergyconversiondevicetype):
	'''Entity ifctubebundletype definition.

	:param predefinedtype
	:type predefinedtype:ifctubebundletypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctubebundletypeenum):
				self._predefinedtype = ifctubebundletypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifctubebundletypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifctubebundletypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcdoorliningproperties #
####################
class ifcdoorliningproperties(ifcpropertysetdefinition):
	'''Entity ifcdoorliningproperties definition.

	:param liningdepth
	:type liningdepth:ifcpositivelengthmeasure

	:param liningthickness
	:type liningthickness:ifcpositivelengthmeasure

	:param thresholddepth
	:type thresholddepth:ifcpositivelengthmeasure

	:param thresholdthickness
	:type thresholdthickness:ifcpositivelengthmeasure

	:param transomthickness
	:type transomthickness:ifcpositivelengthmeasure

	:param transomoffset
	:type transomoffset:ifclengthmeasure

	:param liningoffset
	:type liningoffset:ifclengthmeasure

	:param thresholdoffset
	:type thresholdoffset:ifclengthmeasure

	:param casingthickness
	:type casingthickness:ifcpositivelengthmeasure

	:param casingdepth
	:type casingdepth:ifcpositivelengthmeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , liningdepth,liningthickness,thresholddepth,thresholdthickness,transomthickness,transomoffset,liningoffset,thresholdoffset,casingthickness,casingdepth,shapeaspectstyle, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.liningdepth = liningdepth
		self.liningthickness = liningthickness
		self.thresholddepth = thresholddepth
		self.thresholdthickness = thresholdthickness
		self.transomthickness = transomthickness
		self.transomoffset = transomoffset
		self.liningoffset = liningoffset
		self.thresholdoffset = thresholdoffset
		self.casingthickness = casingthickness
		self.casingdepth = casingdepth
		self.shapeaspectstyle = shapeaspectstyle

	@apply
	def liningdepth():
		def fget( self ):
			return self._liningdepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._liningdepth = ifcpositivelengthmeasure(value)
				else:
					self._liningdepth = value
			else:
				self._liningdepth = value
		return property(**locals())

	@apply
	def liningthickness():
		def fget( self ):
			return self._liningthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._liningthickness = ifcpositivelengthmeasure(value)
				else:
					self._liningthickness = value
			else:
				self._liningthickness = value
		return property(**locals())

	@apply
	def thresholddepth():
		def fget( self ):
			return self._thresholddepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._thresholddepth = ifcpositivelengthmeasure(value)
				else:
					self._thresholddepth = value
			else:
				self._thresholddepth = value
		return property(**locals())

	@apply
	def thresholdthickness():
		def fget( self ):
			return self._thresholdthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._thresholdthickness = ifcpositivelengthmeasure(value)
				else:
					self._thresholdthickness = value
			else:
				self._thresholdthickness = value
		return property(**locals())

	@apply
	def transomthickness():
		def fget( self ):
			return self._transomthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._transomthickness = ifcpositivelengthmeasure(value)
				else:
					self._transomthickness = value
			else:
				self._transomthickness = value
		return property(**locals())

	@apply
	def transomoffset():
		def fget( self ):
			return self._transomoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._transomoffset = ifclengthmeasure(value)
				else:
					self._transomoffset = value
			else:
				self._transomoffset = value
		return property(**locals())

	@apply
	def liningoffset():
		def fget( self ):
			return self._liningoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._liningoffset = ifclengthmeasure(value)
				else:
					self._liningoffset = value
			else:
				self._liningoffset = value
		return property(**locals())

	@apply
	def thresholdoffset():
		def fget( self ):
			return self._thresholdoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._thresholdoffset = ifclengthmeasure(value)
				else:
					self._thresholdoffset = value
			else:
				self._thresholdoffset = value
		return property(**locals())

	@apply
	def casingthickness():
		def fget( self ):
			return self._casingthickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._casingthickness = ifcpositivelengthmeasure(value)
				else:
					self._casingthickness = value
			else:
				self._casingthickness = value
		return property(**locals())

	@apply
	def casingdepth():
		def fget( self ):
			return self._casingdepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._casingdepth = ifcpositivelengthmeasure(value)
				else:
					self._casingdepth = value
			else:
				self._casingdepth = value
		return property(**locals())

	@apply
	def shapeaspectstyle():
		def fget( self ):
			return self._shapeaspectstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshapeaspect):
					self._shapeaspectstyle = ifcshapeaspect(value)
				else:
					self._shapeaspectstyle = value
			else:
				self._shapeaspectstyle = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = ( not (( not EXISTS(self.liningdepth))  and  EXISTS(self.liningthickness)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = ( not (( not EXISTS(self.thresholddepth))  and  EXISTS(self.thresholdthickness)))
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr

	def wr33(self):
		eval_wr33_wr = ((EXISTS(self.transomoffset)  and  EXISTS(self.transomthickness)) XOR (( not EXISTS(self.transomoffset))  and  ( not EXISTS(self.transomthickness))))
		if not eval_wr33_wr:
			raise AssertionError('Rule wr33 violated')
		else:
			return eval_wr33_wr

	def wr34(self):
		eval_wr34_wr = ((EXISTS(self.casingdepth)  and  EXISTS(self.casingthickness)) XOR (( not EXISTS(self.casingdepth))  and  ( not EXISTS(self.casingthickness))))
		if not eval_wr34_wr:
			raise AssertionError('Rule wr34 violated')
		else:
			return eval_wr34_wr

	def wr35(self):
		eval_wr35_wr = (EXISTS(self.self.ifcpropertysetdefinition.self.definestype[1])  and  ('IFC2X3.IFCDOORSTYLE'  ==  TYPEOF(self.self.ifcpropertysetdefinition.self.definestype[1])))
		if not eval_wr35_wr:
			raise AssertionError('Rule wr35 violated')
		else:
			return eval_wr35_wr


####################
 # ENTITY ifcstructuralmember #
####################
class ifcstructuralmember(ifcstructuralitem):
	'''Entity ifcstructuralmember definition.

	:param referenceselement
	:type referenceselement:SET(0,None,'ifcrelconnectsstructuralelement', scope = schema_scope)

	:param connectedby
	:type connectedby:SET(0,None,'ifcrelconnectsstructuralmember', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation ,  ):
		ifcstructuralitem.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )

	@apply
	def referenceselement():
		def fget( self ):
			return self._referenceselement
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referenceselement is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def connectedby():
		def fget( self ):
			return self._connectedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstructuralsurfacemember #
####################
class ifcstructuralsurfacemember(ifcstructuralmember):
	'''Entity ifcstructuralsurfacemember definition.

	:param predefinedtype
	:type predefinedtype:ifcstructuralsurfacetypeenum

	:param thickness
	:type thickness:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , predefinedtype,thickness, ):
		ifcstructuralmember.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.predefinedtype = predefinedtype
		self.thickness = thickness

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralsurfacetypeenum):
				self._predefinedtype = ifcstructuralsurfacetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def thickness():
		def fget( self ):
			return self._thickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._thickness = ifcpositivelengthmeasure(value)
				else:
					self._thickness = value
			else:
				self._thickness = value
		return property(**locals())

####################
 # ENTITY ifcedgecurve #
####################
class ifcedgecurve(ifcedge):
	'''Entity ifcedgecurve definition.

	:param edgegeometry
	:type edgegeometry:ifccurve

	:param samesense
	:type samesense:BOOLEAN
	'''
	def __init__( self , inherited0__edgestart , inherited1__edgeend , edgegeometry,samesense, ):
		ifcedge.__init__(self , inherited0__edgestart , inherited1__edgeend , )
		self.edgegeometry = edgegeometry
		self.samesense = samesense

	@apply
	def edgegeometry():
		def fget( self ):
			return self._edgegeometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgegeometry is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._edgegeometry = ifccurve(value)
			else:
				self._edgegeometry = value
		return property(**locals())

	@apply
	def samesense():
		def fget( self ):
			return self._samesense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument samesense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._samesense = BOOLEAN(value)
			else:
				self._samesense = value
		return property(**locals())

####################
 # ENTITY ifcflowtreatmentdevice #
####################
class ifcflowtreatmentdevice(ifcdistributionflowelement):
	'''Entity ifcflowtreatmentdevice definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifclightfixturetype #
####################
class ifclightfixturetype(ifcflowterminaltype):
	'''Entity ifclightfixturetype definition.

	:param predefinedtype
	:type predefinedtype:ifclightfixturetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifclightfixturetypeenum):
				self._predefinedtype = ifclightfixturetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcline #
####################
class ifcline(ifccurve):
	'''Entity ifcline definition.

	:param pnt
	:type pnt:ifccartesianpoint

	:param dir
	:type dir:ifcvector
	'''
	def __init__( self , pnt,dir, ):
		ifccurve.__init__(self , )
		self.pnt = pnt
		self.dir = dir

	@apply
	def pnt():
		def fget( self ):
			return self._pnt
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pnt is mantatory and can not be set to None')
			if not check_type(value,ifccartesianpoint):
				self._pnt = ifccartesianpoint(value)
			else:
				self._pnt = value
		return property(**locals())

	@apply
	def dir():
		def fget( self ):
			return self._dir
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dir is mantatory and can not be set to None')
			if not check_type(value,ifcvector):
				self._dir = ifcvector(value)
			else:
				self._dir = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.dir.self.dim  ==  self.pnt.self.dim)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcconic #
####################
class ifcconic(ifccurve):
	'''Entity ifcconic definition.

	:param position
	:type position:ifcaxis2placement
	'''
	def __init__( self , position, ):
		ifccurve.__init__(self , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._position = ifcaxis2placement(value)
			else:
				self._position = value
		return property(**locals())

####################
 # ENTITY ifcrelconnectsporttoelement #
####################
class ifcrelconnectsporttoelement(ifcrelconnects):
	'''Entity ifcrelconnectsporttoelement definition.

	:param relatingport
	:type relatingport:ifcport

	:param relatedelement
	:type relatedelement:ifcelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingport,relatedelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingport = relatingport
		self.relatedelement = relatedelement

	@apply
	def relatingport():
		def fget( self ):
			return self._relatingport
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingport is mantatory and can not be set to None')
			if not check_type(value,ifcport):
				self._relatingport = ifcport(value)
			else:
				self._relatingport = value
		return property(**locals())

	@apply
	def relatedelement():
		def fget( self ):
			return self._relatedelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatedelement = ifcelement(value)
			else:
				self._relatedelement = value
		return property(**locals())

####################
 # ENTITY ifcequipmentstandard #
####################
class ifcequipmentstandard(ifccontrol):
	'''Entity ifcequipmentstandard definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

####################
 # ENTITY ifcflowmetertype #
####################
class ifcflowmetertype(ifcflowcontrollertype):
	'''Entity ifcflowmetertype definition.

	:param predefinedtype
	:type predefinedtype:ifcflowmetertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcflowmetertypeenum):
				self._predefinedtype = ifcflowmetertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcflowmetertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcflowmetertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcprojectorderrecord #
####################
class ifcprojectorderrecord(ifccontrol):
	'''Entity ifcprojectorderrecord definition.

	:param records
	:type records:LIST(1,None,'ifcrelassignstoprojectorder', scope = schema_scope)

	:param predefinedtype
	:type predefinedtype:ifcprojectorderrecordtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , records,predefinedtype, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.records = records
		self.predefinedtype = predefinedtype

	@apply
	def records():
		def fget( self ):
			return self._records
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument records is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcrelassignstoprojectorder', scope = schema_scope)):
				self._records = LIST(value)
			else:
				self._records = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcprojectorderrecordtypeenum):
				self._predefinedtype = ifcprojectorderrecordtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcquantityarea #
####################
class ifcquantityarea(ifcphysicalsimplequantity):
	'''Entity ifcquantityarea definition.

	:param areavalue
	:type areavalue:ifcareameasure
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , areavalue, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.areavalue = areavalue

	@apply
	def areavalue():
		def fget( self ):
			return self._areavalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument areavalue is mantatory and can not be set to None')
			if not check_type(value,ifcareameasure):
				self._areavalue = ifcareameasure(value)
			else:
				self._areavalue = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.self.ifcphysicalsimplequantity.self.unit))  or  (self.self.ifcphysicalsimplequantity.self.unit.self.unittype  ==  ifcunitenum.self.areaunit))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.areavalue  >=  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcworkcontrol #
####################
class ifcworkcontrol(ifccontrol):
	'''Entity ifcworkcontrol definition.

	:param identifier
	:type identifier:ifcidentifier

	:param creationdate
	:type creationdate:ifcdatetimeselect

	:param creators
	:type creators:SET(1,None,'ifcperson', scope = schema_scope)

	:param purpose
	:type purpose:ifclabel

	:param duration
	:type duration:ifctimemeasure

	:param totalfloat
	:type totalfloat:ifctimemeasure

	:param starttime
	:type starttime:ifcdatetimeselect

	:param finishtime
	:type finishtime:ifcdatetimeselect

	:param workcontroltype
	:type workcontroltype:ifcworkcontroltypeenum

	:param userdefinedcontroltype
	:type userdefinedcontroltype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , identifier,creationdate,creators,purpose,duration,totalfloat,starttime,finishtime,workcontroltype,userdefinedcontroltype, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.identifier = identifier
		self.creationdate = creationdate
		self.creators = creators
		self.purpose = purpose
		self.duration = duration
		self.totalfloat = totalfloat
		self.starttime = starttime
		self.finishtime = finishtime
		self.workcontroltype = workcontroltype
		self.userdefinedcontroltype = userdefinedcontroltype

	@apply
	def identifier():
		def fget( self ):
			return self._identifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument identifier is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._identifier = ifcidentifier(value)
			else:
				self._identifier = value
		return property(**locals())

	@apply
	def creationdate():
		def fget( self ):
			return self._creationdate
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument creationdate is mantatory and can not be set to None')
			if not check_type(value,ifcdatetimeselect):
				self._creationdate = ifcdatetimeselect(value)
			else:
				self._creationdate = value
		return property(**locals())

	@apply
	def creators():
		def fget( self ):
			return self._creators
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcperson', scope = schema_scope)):
					self._creators = SET(value)
				else:
					self._creators = value
			else:
				self._creators = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._purpose = ifclabel(value)
				else:
					self._purpose = value
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def duration():
		def fget( self ):
			return self._duration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimemeasure):
					self._duration = ifctimemeasure(value)
				else:
					self._duration = value
			else:
				self._duration = value
		return property(**locals())

	@apply
	def totalfloat():
		def fget( self ):
			return self._totalfloat
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimemeasure):
					self._totalfloat = ifctimemeasure(value)
				else:
					self._totalfloat = value
			else:
				self._totalfloat = value
		return property(**locals())

	@apply
	def starttime():
		def fget( self ):
			return self._starttime
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument starttime is mantatory and can not be set to None')
			if not check_type(value,ifcdatetimeselect):
				self._starttime = ifcdatetimeselect(value)
			else:
				self._starttime = value
		return property(**locals())

	@apply
	def finishtime():
		def fget( self ):
			return self._finishtime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._finishtime = ifcdatetimeselect(value)
				else:
					self._finishtime = value
			else:
				self._finishtime = value
		return property(**locals())

	@apply
	def workcontroltype():
		def fget( self ):
			return self._workcontroltype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcworkcontroltypeenum):
					self._workcontroltype = ifcworkcontroltypeenum(value)
				else:
					self._workcontroltype = value
			else:
				self._workcontroltype = value
		return property(**locals())

	@apply
	def userdefinedcontroltype():
		def fget( self ):
			return self._userdefinedcontroltype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedcontroltype = ifclabel(value)
				else:
					self._userdefinedcontroltype = value
			else:
				self._userdefinedcontroltype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.workcontroltype  !=  ifcworkcontroltypeenum.self.userdefined)  or  ((self.workcontroltype  ==  ifcworkcontroltypeenum.self.userdefined)  and  EXISTS(self.self.ifcworkcontrol.self.userdefinedcontroltype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcworkplan #
####################
class ifcworkplan(ifcworkcontrol):
	'''Entity ifcworkplan definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identifier , inherited6__creationdate , inherited7__creators , inherited8__purpose , inherited9__duration , inherited10__totalfloat , inherited11__starttime , inherited12__finishtime , inherited13__workcontroltype , inherited14__userdefinedcontroltype ,  ):
		ifcworkcontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identifier , inherited6__creationdate , inherited7__creators , inherited8__purpose , inherited9__duration , inherited10__totalfloat , inherited11__starttime , inherited12__finishtime , inherited13__workcontroltype , inherited14__userdefinedcontroltype , )

####################
 # ENTITY ifcenergyconversiondevice #
####################
class ifcenergyconversiondevice(ifcdistributionflowelement):
	'''Entity ifcenergyconversiondevice definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcpropertydependencyrelationship #
####################
class ifcpropertydependencyrelationship(BaseEntityClass):
	'''Entity ifcpropertydependencyrelationship definition.

	:param dependingproperty
	:type dependingproperty:ifcproperty

	:param dependantproperty
	:type dependantproperty:ifcproperty

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param expression
	:type expression:ifctext
	'''
	def __init__( self , dependingproperty,dependantproperty,name,description,expression, ):
		self.dependingproperty = dependingproperty
		self.dependantproperty = dependantproperty
		self.name = name
		self.description = description
		self.expression = expression

	@apply
	def dependingproperty():
		def fget( self ):
			return self._dependingproperty
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dependingproperty is mantatory and can not be set to None')
			if not check_type(value,ifcproperty):
				self._dependingproperty = ifcproperty(value)
			else:
				self._dependingproperty = value
		return property(**locals())

	@apply
	def dependantproperty():
		def fget( self ):
			return self._dependantproperty
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dependantproperty is mantatory and can not be set to None')
			if not check_type(value,ifcproperty):
				self._dependantproperty = ifcproperty(value)
			else:
				self._dependantproperty = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def expression():
		def fget( self ):
			return self._expression
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._expression = ifctext(value)
				else:
					self._expression = value
			else:
				self._expression = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.dependingproperty  !=  self.dependantproperty)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcrelspaceboundary #
####################
class ifcrelspaceboundary(ifcrelconnects):
	'''Entity ifcrelspaceboundary definition.

	:param relatingspace
	:type relatingspace:ifcspace

	:param relatedbuildingelement
	:type relatedbuildingelement:ifcelement

	:param connectiongeometry
	:type connectiongeometry:ifcconnectiongeometry

	:param physicalorvirtualboundary
	:type physicalorvirtualboundary:ifcphysicalorvirtualenum

	:param internalorexternalboundary
	:type internalorexternalboundary:ifcinternalorexternalenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingspace,relatedbuildingelement,connectiongeometry,physicalorvirtualboundary,internalorexternalboundary, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingspace = relatingspace
		self.relatedbuildingelement = relatedbuildingelement
		self.connectiongeometry = connectiongeometry
		self.physicalorvirtualboundary = physicalorvirtualboundary
		self.internalorexternalboundary = internalorexternalboundary

	@apply
	def relatingspace():
		def fget( self ):
			return self._relatingspace
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingspace is mantatory and can not be set to None')
			if not check_type(value,ifcspace):
				self._relatingspace = ifcspace(value)
			else:
				self._relatingspace = value
		return property(**locals())

	@apply
	def relatedbuildingelement():
		def fget( self ):
			return self._relatedbuildingelement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelement):
					self._relatedbuildingelement = ifcelement(value)
				else:
					self._relatedbuildingelement = value
			else:
				self._relatedbuildingelement = value
		return property(**locals())

	@apply
	def connectiongeometry():
		def fget( self ):
			return self._connectiongeometry
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcconnectiongeometry):
					self._connectiongeometry = ifcconnectiongeometry(value)
				else:
					self._connectiongeometry = value
			else:
				self._connectiongeometry = value
		return property(**locals())

	@apply
	def physicalorvirtualboundary():
		def fget( self ):
			return self._physicalorvirtualboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument physicalorvirtualboundary is mantatory and can not be set to None')
			if not check_type(value,ifcphysicalorvirtualenum):
				self._physicalorvirtualboundary = ifcphysicalorvirtualenum(value)
			else:
				self._physicalorvirtualboundary = value
		return property(**locals())

	@apply
	def internalorexternalboundary():
		def fget( self ):
			return self._internalorexternalboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument internalorexternalboundary is mantatory and can not be set to None')
			if not check_type(value,ifcinternalorexternalenum):
				self._internalorexternalboundary = ifcinternalorexternalenum(value)
			else:
				self._internalorexternalboundary = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((((self.physicalorvirtualboundary  ==  ifcphysicalorvirtualenum.self.physical)  and  (EXISTS(self.relatedbuildingelement)  and  ( not ('IFC2X3.IFCVIRTUALELEMENT'  ==  TYPEOF(self.relatedbuildingelement)))))  or  ((self.physicalorvirtualboundary  ==  ifcphysicalorvirtualenum.self.virtual)  and  (( not EXISTS(self.relatedbuildingelement))  or  ('IFC2X3.IFCVIRTUALELEMENT'  ==  TYPEOF(self.relatedbuildingelement)))))  or  (self.physicalorvirtualboundary  ==  ifcphysicalorvirtualenum.self.notdefined))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcappliedvalue #
####################
class ifcappliedvalue(BaseEntityClass):
	'''Entity ifcappliedvalue definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param appliedvalue
	:type appliedvalue:ifcappliedvalueselect

	:param unitbasis
	:type unitbasis:ifcmeasurewithunit

	:param applicabledate
	:type applicabledate:ifcdatetimeselect

	:param fixeduntildate
	:type fixeduntildate:ifcdatetimeselect

	:param valuesreferenced
	:type valuesreferenced:SET(0,None,'ifcreferencesvaluedocument', scope = schema_scope)

	:param valueofcomponents
	:type valueofcomponents:SET(0,None,'ifcappliedvaluerelationship', scope = schema_scope)

	:param iscomponentin
	:type iscomponentin:SET(0,None,'ifcappliedvaluerelationship', scope = schema_scope)
	'''
	def __init__( self , name,description,appliedvalue,unitbasis,applicabledate,fixeduntildate, ):
		self.name = name
		self.description = description
		self.appliedvalue = appliedvalue
		self.unitbasis = unitbasis
		self.applicabledate = applicabledate
		self.fixeduntildate = fixeduntildate

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def appliedvalue():
		def fget( self ):
			return self._appliedvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcappliedvalueselect):
					self._appliedvalue = ifcappliedvalueselect(value)
				else:
					self._appliedvalue = value
			else:
				self._appliedvalue = value
		return property(**locals())

	@apply
	def unitbasis():
		def fget( self ):
			return self._unitbasis
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmeasurewithunit):
					self._unitbasis = ifcmeasurewithunit(value)
				else:
					self._unitbasis = value
			else:
				self._unitbasis = value
		return property(**locals())

	@apply
	def applicabledate():
		def fget( self ):
			return self._applicabledate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._applicabledate = ifcdatetimeselect(value)
				else:
					self._applicabledate = value
			else:
				self._applicabledate = value
		return property(**locals())

	@apply
	def fixeduntildate():
		def fget( self ):
			return self._fixeduntildate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._fixeduntildate = ifcdatetimeselect(value)
				else:
					self._fixeduntildate = value
			else:
				self._fixeduntildate = value
		return property(**locals())

	@apply
	def valuesreferenced():
		def fget( self ):
			return self._valuesreferenced
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument valuesreferenced is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def valueofcomponents():
		def fget( self ):
			return self._valueofcomponents
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument valueofcomponents is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def iscomponentin():
		def fget( self ):
			return self._iscomponentin
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument iscomponentin is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.appliedvalue)  or  EXISTS(self.valueofcomponents))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcenvironmentalimpactvalue #
####################
class ifcenvironmentalimpactvalue(ifcappliedvalue):
	'''Entity ifcenvironmentalimpactvalue definition.

	:param impacttype
	:type impacttype:ifclabel

	:param category
	:type category:ifcenvironmentalimpactcategoryenum

	:param userdefinedcategory
	:type userdefinedcategory:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__appliedvalue , inherited3__unitbasis , inherited4__applicabledate , inherited5__fixeduntildate , impacttype,category,userdefinedcategory, ):
		ifcappliedvalue.__init__(self , inherited0__name , inherited1__description , inherited2__appliedvalue , inherited3__unitbasis , inherited4__applicabledate , inherited5__fixeduntildate , )
		self.impacttype = impacttype
		self.category = category
		self.userdefinedcategory = userdefinedcategory

	@apply
	def impacttype():
		def fget( self ):
			return self._impacttype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument impacttype is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._impacttype = ifclabel(value)
			else:
				self._impacttype = value
		return property(**locals())

	@apply
	def category():
		def fget( self ):
			return self._category
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument category is mantatory and can not be set to None')
			if not check_type(value,ifcenvironmentalimpactcategoryenum):
				self._category = ifcenvironmentalimpactcategoryenum(value)
			else:
				self._category = value
		return property(**locals())

	@apply
	def userdefinedcategory():
		def fget( self ):
			return self._userdefinedcategory
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedcategory = ifclabel(value)
				else:
					self._userdefinedcategory = value
			else:
				self._userdefinedcategory = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.category  !=  ifcenvironmentalimpactcategoryenum.self.userdefined)  or  ((self.category  ==  ifcenvironmentalimpactcategoryenum.self.userdefined)  and  EXISTS(self.self.ifcenvironmentalimpactvalue.self.userdefinedcategory)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcfillareastylehatching #
####################
class ifcfillareastylehatching(ifcgeometricrepresentationitem):
	'''Entity ifcfillareastylehatching definition.

	:param hatchlineappearance
	:type hatchlineappearance:ifccurvestyle

	:param startofnexthatchline
	:type startofnexthatchline:ifchatchlinedistanceselect

	:param pointofreferencehatchline
	:type pointofreferencehatchline:ifccartesianpoint

	:param patternstart
	:type patternstart:ifccartesianpoint

	:param hatchlineangle
	:type hatchlineangle:ifcplaneanglemeasure
	'''
	def __init__( self , hatchlineappearance,startofnexthatchline,pointofreferencehatchline,patternstart,hatchlineangle, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.hatchlineappearance = hatchlineappearance
		self.startofnexthatchline = startofnexthatchline
		self.pointofreferencehatchline = pointofreferencehatchline
		self.patternstart = patternstart
		self.hatchlineangle = hatchlineangle

	@apply
	def hatchlineappearance():
		def fget( self ):
			return self._hatchlineappearance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hatchlineappearance is mantatory and can not be set to None')
			if not check_type(value,ifccurvestyle):
				self._hatchlineappearance = ifccurvestyle(value)
			else:
				self._hatchlineappearance = value
		return property(**locals())

	@apply
	def startofnexthatchline():
		def fget( self ):
			return self._startofnexthatchline
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument startofnexthatchline is mantatory and can not be set to None')
			if not check_type(value,ifchatchlinedistanceselect):
				self._startofnexthatchline = ifchatchlinedistanceselect(value)
			else:
				self._startofnexthatchline = value
		return property(**locals())

	@apply
	def pointofreferencehatchline():
		def fget( self ):
			return self._pointofreferencehatchline
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccartesianpoint):
					self._pointofreferencehatchline = ifccartesianpoint(value)
				else:
					self._pointofreferencehatchline = value
			else:
				self._pointofreferencehatchline = value
		return property(**locals())

	@apply
	def patternstart():
		def fget( self ):
			return self._patternstart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccartesianpoint):
					self._patternstart = ifccartesianpoint(value)
				else:
					self._patternstart = value
			else:
				self._patternstart = value
		return property(**locals())

	@apply
	def hatchlineangle():
		def fget( self ):
			return self._hatchlineangle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hatchlineangle is mantatory and can not be set to None')
			if not check_type(value,ifcplaneanglemeasure):
				self._hatchlineangle = ifcplaneanglemeasure(value)
			else:
				self._hatchlineangle = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = ( not ('IFC2X3.IFCTWODIRECTIONREPEATFACTOR'  ==  TYPEOF(self.startofnexthatchline)))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (( not EXISTS(self.patternstart))  or  (self.patternstart.self.dim  ==  2))
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr

	def wr23(self):
		eval_wr23_wr = (( not EXISTS(self.pointofreferencehatchline))  or  (self.pointofreferencehatchline.self.dim  ==  2))
		if not eval_wr23_wr:
			raise AssertionError('Rule wr23 violated')
		else:
			return eval_wr23_wr


####################
 # ENTITY ifcheatexchangertype #
####################
class ifcheatexchangertype(ifcenergyconversiondevicetype):
	'''Entity ifcheatexchangertype definition.

	:param predefinedtype
	:type predefinedtype:ifcheatexchangertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcheatexchangertypeenum):
				self._predefinedtype = ifcheatexchangertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcheatexchangertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcheatexchangertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifconedirectionrepeatfactor #
####################
class ifconedirectionrepeatfactor(ifcgeometricrepresentationitem):
	'''Entity ifconedirectionrepeatfactor definition.

	:param repeatfactor
	:type repeatfactor:ifcvector
	'''
	def __init__( self , repeatfactor, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.repeatfactor = repeatfactor

	@apply
	def repeatfactor():
		def fget( self ):
			return self._repeatfactor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument repeatfactor is mantatory and can not be set to None')
			if not check_type(value,ifcvector):
				self._repeatfactor = ifcvector(value)
			else:
				self._repeatfactor = value
		return property(**locals())

####################
 # ENTITY ifcpolygonalboundedhalfspace #
####################
class ifcpolygonalboundedhalfspace(ifchalfspacesolid):
	'''Entity ifcpolygonalboundedhalfspace definition.

	:param position
	:type position:ifcaxis2placement3d

	:param polygonalboundary
	:type polygonalboundary:ifcboundedcurve
	'''
	def __init__( self , inherited0__basesurface , inherited1__agreementflag , position,polygonalboundary, ):
		ifchalfspacesolid.__init__(self , inherited0__basesurface , inherited1__agreementflag , )
		self.position = position
		self.polygonalboundary = polygonalboundary

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement3d):
				self._position = ifcaxis2placement3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def polygonalboundary():
		def fget( self ):
			return self._polygonalboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument polygonalboundary is mantatory and can not be set to None')
			if not check_type(value,ifcboundedcurve):
				self._polygonalboundary = ifcboundedcurve(value)
			else:
				self._polygonalboundary = value
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = (self.polygonalboundary.self.dim  ==  2)
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr

	def wr42(self):
		eval_wr42_wr = (SIZEOF(TYPEOF(self.polygonalboundary)  *  ['IFC2X3.IFCPOLYLINE','IFC2X3.IFCCOMPOSITECURVE'])  ==  1)
		if not eval_wr42_wr:
			raise AssertionError('Rule wr42 violated')
		else:
			return eval_wr42_wr


####################
 # ENTITY ifccondensertype #
####################
class ifccondensertype(ifcenergyconversiondevicetype):
	'''Entity ifccondensertype definition.

	:param predefinedtype
	:type predefinedtype:ifccondensertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccondensertypeenum):
				self._predefinedtype = ifccondensertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifccondensertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccondensertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcslab #
####################
class ifcslab(ifcbuildingelement):
	'''Entity ifcslab definition.

	:param predefinedtype
	:type predefinedtype:ifcslabtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcslabtypeenum):
					self._predefinedtype = ifcslabtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr61(self):
		eval_wr61_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifcslabtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifcslabtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_wr61_wr:
			raise AssertionError('Rule wr61 violated')
		else:
			return eval_wr61_wr


####################
 # ENTITY ifccoolingtowertype #
####################
class ifccoolingtowertype(ifcenergyconversiondevicetype):
	'''Entity ifccoolingtowertype definition.

	:param predefinedtype
	:type predefinedtype:ifccoolingtowertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccoolingtowertypeenum):
				self._predefinedtype = ifccoolingtowertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifccoolingtowertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccoolingtowertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcpredefinedtextfont #
####################
class ifcpredefinedtextfont(ifcpredefineditem):
	'''Entity ifcpredefinedtextfont definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefineditem.__init__(self , inherited0__name , )

####################
 # ENTITY ifcdraughtingpredefinedtextfont #
####################
class ifcdraughtingpredefinedtextfont(ifcpredefinedtextfont):
	'''Entity ifcdraughtingpredefinedtextfont definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefinedtextfont.__init__(self , inherited0__name , )
	def wr31(self):
		eval_wr31_wr = (self.self.ifcpredefineditem.self.name  ==  ['ISO 3098-1 font A','ISO 3098-1 font B'])
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcannotationcurveoccurrence #
####################
class ifcannotationcurveoccurrence(ifcannotationoccurrence):
	'''Entity ifcannotationcurveoccurrence definition.
	'''
	def __init__( self , inherited0__item , inherited1__styles , inherited2__name ,  ):
		ifcannotationoccurrence.__init__(self , inherited0__item , inherited1__styles , inherited2__name , )
	def wr31(self):
		eval_wr31_wr = (( not EXISTS(self.self.ifcstyleditem.self.item))  or  ('IFC2X3.IFCCURVE'  ==  TYPEOF(self.self.ifcstyleditem.self.item)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcdimensioncurve #
####################
class ifcdimensioncurve(ifcannotationcurveoccurrence):
	'''Entity ifcdimensioncurve definition.

	:param annotatedbysymbols
	:type annotatedbysymbols:SET(0,2,'ifcterminatorsymbol', scope = schema_scope)
	'''
	def __init__( self , inherited0__item , inherited1__styles , inherited2__name ,  ):
		ifcannotationcurveoccurrence.__init__(self , inherited0__item , inherited1__styles , inherited2__name , )

	@apply
	def annotatedbysymbols():
		def fget( self ):
			return self._annotatedbysymbols
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument annotatedbysymbols is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr51(self):
		eval_wr51_wr = (SIZEOF(USEDIN(self,'IFC2X3.IFCDRAUGHTINGCALLOUT.CONTENTS'))  >=  1)
		if not eval_wr51_wr:
			raise AssertionError('Rule wr51 violated')
		else:
			return eval_wr51_wr

	def wr52(self):
		eval_wr52_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr52_wr:
			raise AssertionError('Rule wr52 violated')
		else:
			return eval_wr52_wr

	def wr53(self):
		eval_wr53_wr = (SIZEOF(None)  ==  0)
		if not eval_wr53_wr:
			raise AssertionError('Rule wr53 violated')
		else:
			return eval_wr53_wr


####################
 # ENTITY ifcclassification #
####################
class ifcclassification(BaseEntityClass):
	'''Entity ifcclassification definition.

	:param source
	:type source:ifclabel

	:param edition
	:type edition:ifclabel

	:param editiondate
	:type editiondate:ifccalendardate

	:param name
	:type name:ifclabel

	:param contains
	:type contains:SET(0,None,'ifcclassificationitem', scope = schema_scope)
	'''
	def __init__( self , source,edition,editiondate,name, ):
		self.source = source
		self.edition = edition
		self.editiondate = editiondate
		self.name = name

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._source = ifclabel(value)
			else:
				self._source = value
		return property(**locals())

	@apply
	def edition():
		def fget( self ):
			return self._edition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edition is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._edition = ifclabel(value)
			else:
				self._edition = value
		return property(**locals())

	@apply
	def editiondate():
		def fget( self ):
			return self._editiondate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccalendardate):
					self._editiondate = ifccalendardate(value)
				else:
					self._editiondate = value
			else:
				self._editiondate = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def contains():
		def fget( self ):
			return self._contains
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument contains is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcdraughtingcalloutrelationship #
####################
class ifcdraughtingcalloutrelationship(BaseEntityClass):
	'''Entity ifcdraughtingcalloutrelationship definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param relatingdraughtingcallout
	:type relatingdraughtingcallout:ifcdraughtingcallout

	:param relateddraughtingcallout
	:type relateddraughtingcallout:ifcdraughtingcallout
	'''
	def __init__( self , name,description,relatingdraughtingcallout,relateddraughtingcallout, ):
		self.name = name
		self.description = description
		self.relatingdraughtingcallout = relatingdraughtingcallout
		self.relateddraughtingcallout = relateddraughtingcallout

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relatingdraughtingcallout():
		def fget( self ):
			return self._relatingdraughtingcallout
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingdraughtingcallout is mantatory and can not be set to None')
			if not check_type(value,ifcdraughtingcallout):
				self._relatingdraughtingcallout = ifcdraughtingcallout(value)
			else:
				self._relatingdraughtingcallout = value
		return property(**locals())

	@apply
	def relateddraughtingcallout():
		def fget( self ):
			return self._relateddraughtingcallout
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relateddraughtingcallout is mantatory and can not be set to None')
			if not check_type(value,ifcdraughtingcallout):
				self._relateddraughtingcallout = ifcdraughtingcallout(value)
			else:
				self._relateddraughtingcallout = value
		return property(**locals())

####################
 # ENTITY ifcgridaxis #
####################
class ifcgridaxis(BaseEntityClass):
	'''Entity ifcgridaxis definition.

	:param axistag
	:type axistag:ifclabel

	:param axiscurve
	:type axiscurve:ifccurve

	:param samesense
	:type samesense:ifcboolean

	:param partofw
	:type partofw:SET(0,1,'ifcgrid', scope = schema_scope)

	:param partofv
	:type partofv:SET(0,1,'ifcgrid', scope = schema_scope)

	:param partofu
	:type partofu:SET(0,1,'ifcgrid', scope = schema_scope)

	:param hasintersections
	:type hasintersections:SET(0,None,'ifcvirtualgridintersection', scope = schema_scope)
	'''
	def __init__( self , axistag,axiscurve,samesense, ):
		self.axistag = axistag
		self.axiscurve = axiscurve
		self.samesense = samesense

	@apply
	def axistag():
		def fget( self ):
			return self._axistag
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._axistag = ifclabel(value)
				else:
					self._axistag = value
			else:
				self._axistag = value
		return property(**locals())

	@apply
	def axiscurve():
		def fget( self ):
			return self._axiscurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axiscurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._axiscurve = ifccurve(value)
			else:
				self._axiscurve = value
		return property(**locals())

	@apply
	def samesense():
		def fget( self ):
			return self._samesense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument samesense is mantatory and can not be set to None')
			if not check_type(value,ifcboolean):
				self._samesense = ifcboolean(value)
			else:
				self._samesense = value
		return property(**locals())

	@apply
	def partofw():
		def fget( self ):
			return self._partofw
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofw is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def partofv():
		def fget( self ):
			return self._partofv
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofv is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def partofu():
		def fget( self ):
			return self._partofu
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument partofu is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasintersections():
		def fget( self ):
			return self._hasintersections
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasintersections is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.axiscurve.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(self.partofu)  ==  1) XOR (SIZEOF(self.partofv)  ==  1) XOR (SIZEOF(self.partofw)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifctransportelement #
####################
class ifctransportelement(ifcelement):
	'''Entity ifctransportelement definition.

	:param operationtype
	:type operationtype:ifctransportelementtypeenum

	:param capacitybyweight
	:type capacitybyweight:ifcmassmeasure

	:param capacitybynumber
	:type capacitybynumber:ifccountmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , operationtype,capacitybyweight,capacitybynumber, ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.operationtype = operationtype
		self.capacitybyweight = capacitybyweight
		self.capacitybynumber = capacitybynumber

	@apply
	def operationtype():
		def fget( self ):
			return self._operationtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctransportelementtypeenum):
					self._operationtype = ifctransportelementtypeenum(value)
				else:
					self._operationtype = value
			else:
				self._operationtype = value
		return property(**locals())

	@apply
	def capacitybyweight():
		def fget( self ):
			return self._capacitybyweight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmassmeasure):
					self._capacitybyweight = ifcmassmeasure(value)
				else:
					self._capacitybyweight = value
			else:
				self._capacitybyweight = value
		return property(**locals())

	@apply
	def capacitybynumber():
		def fget( self ):
			return self._capacitybynumber
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccountmeasure):
					self._capacitybynumber = ifccountmeasure(value)
				else:
					self._capacitybynumber = value
			else:
				self._capacitybynumber = value
		return property(**locals())

####################
 # ENTITY ifcderivedunit #
####################
class ifcderivedunit(BaseEntityClass):
	'''Entity ifcderivedunit definition.

	:param elements
	:type elements:SET(1,None,'ifcderivedunitelement', scope = schema_scope)

	:param unittype
	:type unittype:ifcderivedunitenum

	:param userdefinedtype
	:type userdefinedtype:ifclabel

	:param dimensions
	:type dimensions:ifcdimensionalexponents
	'''
	def __init__( self , elements,unittype,userdefinedtype, ):
		self.elements = elements
		self.unittype = unittype
		self.userdefinedtype = userdefinedtype

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument elements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcderivedunitelement', scope = schema_scope)):
				self._elements = SET(value)
			else:
				self._elements = value
		return property(**locals())

	@apply
	def unittype():
		def fget( self ):
			return self._unittype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unittype is mantatory and can not be set to None')
			if not check_type(value,ifcderivedunitenum):
				self._unittype = ifcderivedunitenum(value)
			else:
				self._unittype = value
		return property(**locals())

	@apply
	def userdefinedtype():
		def fget( self ):
			return self._userdefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedtype = ifclabel(value)
				else:
					self._userdefinedtype = value
			else:
				self._userdefinedtype = value
		return property(**locals())

	@apply
	def dimensions():
		def fget( self ):
			attribute_eval = ifcderivedimensionalexponents(self.elements)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dimensions is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.elements)  >  1)  or  ((SIZEOF(self.elements)  ==  1)  and  (self.elements[1].self.exponent  !=  1)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((self.unittype  !=  ifcderivedunitenum.self.userdefined)  or  ((self.unittype  ==  ifcderivedunitenum.self.userdefined)  and  EXISTS(self.self.userdefinedtype)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifccontrollertype #
####################
class ifccontrollertype(ifcdistributioncontrolelementtype):
	'''Entity ifccontrollertype definition.

	:param predefinedtype
	:type predefinedtype:ifccontrollertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccontrollertypeenum):
				self._predefinedtype = ifccontrollertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcrelassignstoproduct #
####################
class ifcrelassignstoproduct(ifcrelassigns):
	'''Entity ifcrelassignstoproduct definition.

	:param relatingproduct
	:type relatingproduct:ifcproduct
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatingproduct, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatingproduct = relatingproduct

	@apply
	def relatingproduct():
		def fget( self ):
			return self._relatingproduct
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingproduct is mantatory and can not be set to None')
			if not check_type(value,ifcproduct):
				self._relatingproduct = ifcproduct(value)
			else:
				self._relatingproduct = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcelectricheatertype #
####################
class ifcelectricheatertype(ifcflowterminaltype):
	'''Entity ifcelectricheatertype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricheatertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectricheatertypeenum):
				self._predefinedtype = ifcelectricheatertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcrepresentationcontext #
####################
class ifcrepresentationcontext(BaseEntityClass):
	'''Entity ifcrepresentationcontext definition.

	:param contextidentifier
	:type contextidentifier:ifclabel

	:param contexttype
	:type contexttype:ifclabel

	:param representationsincontext
	:type representationsincontext:SET(0,None,'ifcrepresentation', scope = schema_scope)
	'''
	def __init__( self , contextidentifier,contexttype, ):
		self.contextidentifier = contextidentifier
		self.contexttype = contexttype

	@apply
	def contextidentifier():
		def fget( self ):
			return self._contextidentifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._contextidentifier = ifclabel(value)
				else:
					self._contextidentifier = value
			else:
				self._contextidentifier = value
		return property(**locals())

	@apply
	def contexttype():
		def fget( self ):
			return self._contexttype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._contexttype = ifclabel(value)
				else:
					self._contexttype = value
			else:
				self._contexttype = value
		return property(**locals())

	@apply
	def representationsincontext():
		def fget( self ):
			return self._representationsincontext
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument representationsincontext is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcgeometricrepresentationcontext #
####################
class ifcgeometricrepresentationcontext(ifcrepresentationcontext):
	'''Entity ifcgeometricrepresentationcontext definition.

	:param coordinatespacedimension
	:type coordinatespacedimension:ifcdimensioncount

	:param precision
	:type precision:REAL

	:param worldcoordinatesystem
	:type worldcoordinatesystem:ifcaxis2placement

	:param truenorth
	:type truenorth:ifcdirection

	:param hassubcontexts
	:type hassubcontexts:SET(0,None,'ifcgeometricrepresentationsubcontext', scope = schema_scope)
	'''
	def __init__( self , inherited0__contextidentifier , inherited1__contexttype , coordinatespacedimension,precision,worldcoordinatesystem,truenorth, ):
		ifcrepresentationcontext.__init__(self , inherited0__contextidentifier , inherited1__contexttype , )
		self.coordinatespacedimension = coordinatespacedimension
		self.precision = precision
		self.worldcoordinatesystem = worldcoordinatesystem
		self.truenorth = truenorth

	@apply
	def coordinatespacedimension():
		def fget( self ):
			return self._coordinatespacedimension
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordinatespacedimension is mantatory and can not be set to None')
			if not check_type(value,ifcdimensioncount):
				self._coordinatespacedimension = ifcdimensioncount(value)
			else:
				self._coordinatespacedimension = value
		return property(**locals())

	@apply
	def precision():
		def fget( self ):
			return self._precision
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._precision = REAL(value)
				else:
					self._precision = value
			else:
				self._precision = value
		return property(**locals())

	@apply
	def worldcoordinatesystem():
		def fget( self ):
			return self._worldcoordinatesystem
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument worldcoordinatesystem is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._worldcoordinatesystem = ifcaxis2placement(value)
			else:
				self._worldcoordinatesystem = value
		return property(**locals())

	@apply
	def truenorth():
		def fget( self ):
			return self._truenorth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._truenorth = ifcdirection(value)
				else:
					self._truenorth = value
			else:
				self._truenorth = value
		return property(**locals())

	@apply
	def hassubcontexts():
		def fget( self ):
			return self._hassubcontexts
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hassubcontexts is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstairflight #
####################
class ifcstairflight(ifcbuildingelement):
	'''Entity ifcstairflight definition.

	:param numberofriser
	:type numberofriser:INTEGER

	:param numberoftreads
	:type numberoftreads:INTEGER

	:param riserheight
	:type riserheight:ifcpositivelengthmeasure

	:param treadlength
	:type treadlength:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , numberofriser,numberoftreads,riserheight,treadlength, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.numberofriser = numberofriser
		self.numberoftreads = numberoftreads
		self.riserheight = riserheight
		self.treadlength = treadlength

	@apply
	def numberofriser():
		def fget( self ):
			return self._numberofriser
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,INTEGER):
					self._numberofriser = INTEGER(value)
				else:
					self._numberofriser = value
			else:
				self._numberofriser = value
		return property(**locals())

	@apply
	def numberoftreads():
		def fget( self ):
			return self._numberoftreads
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,INTEGER):
					self._numberoftreads = INTEGER(value)
				else:
					self._numberoftreads = value
			else:
				self._numberoftreads = value
		return property(**locals())

	@apply
	def riserheight():
		def fget( self ):
			return self._riserheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._riserheight = ifcpositivelengthmeasure(value)
				else:
					self._riserheight = value
			else:
				self._riserheight = value
		return property(**locals())

	@apply
	def treadlength():
		def fget( self ):
			return self._treadlength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._treadlength = ifcpositivelengthmeasure(value)
				else:
					self._treadlength = value
			else:
				self._treadlength = value
		return property(**locals())

####################
 # ENTITY ifcpath #
####################
class ifcpath(ifctopologicalrepresentationitem):
	'''Entity ifcpath definition.

	:param edgelist
	:type edgelist:LIST(1,None,'ifcorientededge', scope = schema_scope)
	'''
	def __init__( self , edgelist, ):
		ifctopologicalrepresentationitem.__init__(self , )
		self.edgelist = edgelist

	@apply
	def edgelist():
		def fget( self ):
			return self._edgelist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgelist is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcorientededge', scope = schema_scope)):
				self._edgelist = LIST(value)
			else:
				self._edgelist = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ifcpathheadtotail(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcstair #
####################
class ifcstair(ifcbuildingelement):
	'''Entity ifcstair definition.

	:param shapetype
	:type shapetype:ifcstairtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , shapetype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.shapetype = shapetype

	@apply
	def shapetype():
		def fget( self ):
			return self._shapetype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument shapetype is mantatory and can not be set to None')
			if not check_type(value,ifcstairtypeenum):
				self._shapetype = ifcstairtypeenum(value)
			else:
				self._shapetype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  0)  or  ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  1)  and  ( not EXISTS(self.self.ifcproduct.self.representation))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifc2dcompositecurve #
####################
class ifc2dcompositecurve(ifccompositecurve):
	'''Entity ifc2dcompositecurve definition.
	'''
	def __init__( self , inherited0__segments , inherited1__selfintersect ,  ):
		ifccompositecurve.__init__(self , inherited0__segments , inherited1__selfintersect , )
	def wr1(self):
		eval_wr1_wr = self.self.ifccompositecurve.self.closedcurve
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.ifccurve.self.dim  ==  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcactorrole #
####################
class ifcactorrole(BaseEntityClass):
	'''Entity ifcactorrole definition.

	:param role
	:type role:ifcroleenum

	:param userdefinedrole
	:type userdefinedrole:ifclabel

	:param description
	:type description:ifctext
	'''
	def __init__( self , role,userdefinedrole,description, ):
		self.role = role
		self.userdefinedrole = userdefinedrole
		self.description = description

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,ifcroleenum):
				self._role = ifcroleenum(value)
			else:
				self._role = value
		return property(**locals())

	@apply
	def userdefinedrole():
		def fget( self ):
			return self._userdefinedrole
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedrole = ifclabel(value)
				else:
					self._userdefinedrole = value
			else:
				self._userdefinedrole = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.role  !=  ifcroleenum.self.userdefined)  or  ((self.role  ==  ifcroleenum.self.userdefined)  and  EXISTS(self.self.userdefinedrole)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcpolyline #
####################
class ifcpolyline(ifcboundedcurve):
	'''Entity ifcpolyline definition.

	:param points
	:type points:LIST(2,None,'ifccartesianpoint', scope = schema_scope)
	'''
	def __init__( self , points, ):
		ifcboundedcurve.__init__(self , )
		self.points = points

	@apply
	def points():
		def fget( self ):
			return self._points
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument points is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'ifccartesianpoint', scope = schema_scope)):
				self._points = LIST(value)
			else:
				self._points = value
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = (SIZEOF(None)  ==  0)
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr


####################
 # ENTITY ifcgeometriccurveset #
####################
class ifcgeometriccurveset(ifcgeometricset):
	'''Entity ifcgeometriccurveset definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		ifcgeometricset.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifctablerow #
####################
class ifctablerow(BaseEntityClass):
	'''Entity ifctablerow definition.

	:param rowcells
	:type rowcells:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param isheading
	:type isheading:BOOLEAN

	:param oftable
	:type oftable:ifctable
	'''
	def __init__( self , rowcells,isheading, ):
		self.rowcells = rowcells
		self.isheading = isheading

	@apply
	def rowcells():
		def fget( self ):
			return self._rowcells
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rowcells is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
				self._rowcells = LIST(value)
			else:
				self._rowcells = value
		return property(**locals())

	@apply
	def isheading():
		def fget( self ):
			return self._isheading
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument isheading is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._isheading = BOOLEAN(value)
			else:
				self._isheading = value
		return property(**locals())

	@apply
	def oftable():
		def fget( self ):
			return self._oftable
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument oftable is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcconnectionsurfacegeometry #
####################
class ifcconnectionsurfacegeometry(ifcconnectiongeometry):
	'''Entity ifcconnectionsurfacegeometry definition.

	:param surfaceonrelatingelement
	:type surfaceonrelatingelement:ifcsurfaceorfacesurface

	:param surfaceonrelatedelement
	:type surfaceonrelatedelement:ifcsurfaceorfacesurface
	'''
	def __init__( self , surfaceonrelatingelement,surfaceonrelatedelement, ):
		ifcconnectiongeometry.__init__(self , )
		self.surfaceonrelatingelement = surfaceonrelatingelement
		self.surfaceonrelatedelement = surfaceonrelatedelement

	@apply
	def surfaceonrelatingelement():
		def fget( self ):
			return self._surfaceonrelatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument surfaceonrelatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcsurfaceorfacesurface):
				self._surfaceonrelatingelement = ifcsurfaceorfacesurface(value)
			else:
				self._surfaceonrelatingelement = value
		return property(**locals())

	@apply
	def surfaceonrelatedelement():
		def fget( self ):
			return self._surfaceonrelatedelement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsurfaceorfacesurface):
					self._surfaceonrelatedelement = ifcsurfaceorfacesurface(value)
				else:
					self._surfaceonrelatedelement = value
			else:
				self._surfaceonrelatedelement = value
		return property(**locals())

####################
 # ENTITY ifcopticalmaterialproperties #
####################
class ifcopticalmaterialproperties(ifcmaterialproperties):
	'''Entity ifcopticalmaterialproperties definition.

	:param visibletransmittance
	:type visibletransmittance:ifcpositiveratiomeasure

	:param solartransmittance
	:type solartransmittance:ifcpositiveratiomeasure

	:param thermalirtransmittance
	:type thermalirtransmittance:ifcpositiveratiomeasure

	:param thermaliremissivityback
	:type thermaliremissivityback:ifcpositiveratiomeasure

	:param thermaliremissivityfront
	:type thermaliremissivityfront:ifcpositiveratiomeasure

	:param visiblereflectanceback
	:type visiblereflectanceback:ifcpositiveratiomeasure

	:param visiblereflectancefront
	:type visiblereflectancefront:ifcpositiveratiomeasure

	:param solarreflectancefront
	:type solarreflectancefront:ifcpositiveratiomeasure

	:param solarreflectanceback
	:type solarreflectanceback:ifcpositiveratiomeasure
	'''
	def __init__( self , inherited0__material , visibletransmittance,solartransmittance,thermalirtransmittance,thermaliremissivityback,thermaliremissivityfront,visiblereflectanceback,visiblereflectancefront,solarreflectancefront,solarreflectanceback, ):
		ifcmaterialproperties.__init__(self , inherited0__material , )
		self.visibletransmittance = visibletransmittance
		self.solartransmittance = solartransmittance
		self.thermalirtransmittance = thermalirtransmittance
		self.thermaliremissivityback = thermaliremissivityback
		self.thermaliremissivityfront = thermaliremissivityfront
		self.visiblereflectanceback = visiblereflectanceback
		self.visiblereflectancefront = visiblereflectancefront
		self.solarreflectancefront = solarreflectancefront
		self.solarreflectanceback = solarreflectanceback

	@apply
	def visibletransmittance():
		def fget( self ):
			return self._visibletransmittance
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._visibletransmittance = ifcpositiveratiomeasure(value)
				else:
					self._visibletransmittance = value
			else:
				self._visibletransmittance = value
		return property(**locals())

	@apply
	def solartransmittance():
		def fget( self ):
			return self._solartransmittance
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._solartransmittance = ifcpositiveratiomeasure(value)
				else:
					self._solartransmittance = value
			else:
				self._solartransmittance = value
		return property(**locals())

	@apply
	def thermalirtransmittance():
		def fget( self ):
			return self._thermalirtransmittance
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._thermalirtransmittance = ifcpositiveratiomeasure(value)
				else:
					self._thermalirtransmittance = value
			else:
				self._thermalirtransmittance = value
		return property(**locals())

	@apply
	def thermaliremissivityback():
		def fget( self ):
			return self._thermaliremissivityback
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._thermaliremissivityback = ifcpositiveratiomeasure(value)
				else:
					self._thermaliremissivityback = value
			else:
				self._thermaliremissivityback = value
		return property(**locals())

	@apply
	def thermaliremissivityfront():
		def fget( self ):
			return self._thermaliremissivityfront
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._thermaliremissivityfront = ifcpositiveratiomeasure(value)
				else:
					self._thermaliremissivityfront = value
			else:
				self._thermaliremissivityfront = value
		return property(**locals())

	@apply
	def visiblereflectanceback():
		def fget( self ):
			return self._visiblereflectanceback
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._visiblereflectanceback = ifcpositiveratiomeasure(value)
				else:
					self._visiblereflectanceback = value
			else:
				self._visiblereflectanceback = value
		return property(**locals())

	@apply
	def visiblereflectancefront():
		def fget( self ):
			return self._visiblereflectancefront
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._visiblereflectancefront = ifcpositiveratiomeasure(value)
				else:
					self._visiblereflectancefront = value
			else:
				self._visiblereflectancefront = value
		return property(**locals())

	@apply
	def solarreflectancefront():
		def fget( self ):
			return self._solarreflectancefront
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._solarreflectancefront = ifcpositiveratiomeasure(value)
				else:
					self._solarreflectancefront = value
			else:
				self._solarreflectancefront = value
		return property(**locals())

	@apply
	def solarreflectanceback():
		def fget( self ):
			return self._solarreflectanceback
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._solarreflectanceback = ifcpositiveratiomeasure(value)
				else:
					self._solarreflectanceback = value
			else:
				self._solarreflectanceback = value
		return property(**locals())

####################
 # ENTITY ifcprojectioncurve #
####################
class ifcprojectioncurve(ifcannotationcurveoccurrence):
	'''Entity ifcprojectioncurve definition.
	'''
	def __init__( self , inherited0__item , inherited1__styles , inherited2__name ,  ):
		ifcannotationcurveoccurrence.__init__(self , inherited0__item , inherited1__styles , inherited2__name , )

####################
 # ENTITY ifcsoundvalue #
####################
class ifcsoundvalue(ifcpropertysetdefinition):
	'''Entity ifcsoundvalue definition.

	:param soundleveltimeseries
	:type soundleveltimeseries:ifctimeseries

	:param frequency
	:type frequency:ifcfrequencymeasure

	:param soundlevelsinglevalue
	:type soundlevelsinglevalue:ifcderivedmeasurevalue
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , soundleveltimeseries,frequency,soundlevelsinglevalue, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.soundleveltimeseries = soundleveltimeseries
		self.frequency = frequency
		self.soundlevelsinglevalue = soundlevelsinglevalue

	@apply
	def soundleveltimeseries():
		def fget( self ):
			return self._soundleveltimeseries
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimeseries):
					self._soundleveltimeseries = ifctimeseries(value)
				else:
					self._soundleveltimeseries = value
			else:
				self._soundleveltimeseries = value
		return property(**locals())

	@apply
	def frequency():
		def fget( self ):
			return self._frequency
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument frequency is mantatory and can not be set to None')
			if not check_type(value,ifcfrequencymeasure):
				self._frequency = ifcfrequencymeasure(value)
			else:
				self._frequency = value
		return property(**locals())

	@apply
	def soundlevelsinglevalue():
		def fget( self ):
			return self._soundlevelsinglevalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcderivedmeasurevalue):
					self._soundlevelsinglevalue = ifcderivedmeasurevalue(value)
				else:
					self._soundlevelsinglevalue = value
			else:
				self._soundlevelsinglevalue = value
		return property(**locals())

####################
 # ENTITY ifccalendardate #
####################
class ifccalendardate(BaseEntityClass):
	'''Entity ifccalendardate definition.

	:param daycomponent
	:type daycomponent:ifcdayinmonthnumber

	:param monthcomponent
	:type monthcomponent:ifcmonthinyearnumber

	:param yearcomponent
	:type yearcomponent:ifcyearnumber
	'''
	def __init__( self , daycomponent,monthcomponent,yearcomponent, ):
		self.daycomponent = daycomponent
		self.monthcomponent = monthcomponent
		self.yearcomponent = yearcomponent

	@apply
	def daycomponent():
		def fget( self ):
			return self._daycomponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument daycomponent is mantatory and can not be set to None')
			if not check_type(value,ifcdayinmonthnumber):
				self._daycomponent = ifcdayinmonthnumber(value)
			else:
				self._daycomponent = value
		return property(**locals())

	@apply
	def monthcomponent():
		def fget( self ):
			return self._monthcomponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument monthcomponent is mantatory and can not be set to None')
			if not check_type(value,ifcmonthinyearnumber):
				self._monthcomponent = ifcmonthinyearnumber(value)
			else:
				self._monthcomponent = value
		return property(**locals())

	@apply
	def yearcomponent():
		def fget( self ):
			return self._yearcomponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument yearcomponent is mantatory and can not be set to None')
			if not check_type(value,ifcyearnumber):
				self._yearcomponent = ifcyearnumber(value)
			else:
				self._yearcomponent = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = ifcvalidcalendardate(self)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcderivedprofiledef #
####################
class ifcderivedprofiledef(ifcprofiledef):
	'''Entity ifcderivedprofiledef definition.

	:param parentprofile
	:type parentprofile:ifcprofiledef

	:param operator
	:type operator:ifccartesiantransformationoperator2d

	:param label
	:type label:ifclabel
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , parentprofile,operator,label, ):
		ifcprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , )
		self.parentprofile = parentprofile
		self.operator = operator
		self.label = label

	@apply
	def parentprofile():
		def fget( self ):
			return self._parentprofile
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parentprofile is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._parentprofile = ifcprofiledef(value)
			else:
				self._parentprofile = value
		return property(**locals())

	@apply
	def operator():
		def fget( self ):
			return self._operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operator is mantatory and can not be set to None')
			if not check_type(value,ifccartesiantransformationoperator2d):
				self._operator = ifccartesiantransformationoperator2d(value)
			else:
				self._operator = value
		return property(**locals())

	@apply
	def label():
		def fget( self ):
			return self._label
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._label = ifclabel(value)
				else:
					self._label = value
			else:
				self._label = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.ifcprofiledef.self.profiletype  ==  self.parentprofile.self.profiletype)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcflowmovingdevicetype #
####################
class ifcflowmovingdevicetype(ifcdistributionflowelementtype):
	'''Entity ifcflowmovingdevicetype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcfantype #
####################
class ifcfantype(ifcflowmovingdevicetype):
	'''Entity ifcfantype definition.

	:param predefinedtype
	:type predefinedtype:ifcfantypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowmovingdevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcfantypeenum):
				self._predefinedtype = ifcfantypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcfantypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcfantypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcobjectplacement #
####################
class ifcobjectplacement(BaseEntityClass):
	'''Entity ifcobjectplacement definition.

	:param placesobject
	:type placesobject:SET(1,1,'ifcproduct', scope = schema_scope)

	:param referencedbyplacements
	:type referencedbyplacements:SET(0,None,'ifclocalplacement', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def placesobject():
		def fget( self ):
			return self._placesobject
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument placesobject is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def referencedbyplacements():
		def fget( self ):
			return self._referencedbyplacements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referencedbyplacements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcgridplacement #
####################
class ifcgridplacement(ifcobjectplacement):
	'''Entity ifcgridplacement definition.

	:param placementlocation
	:type placementlocation:ifcvirtualgridintersection

	:param placementrefdirection
	:type placementrefdirection:ifcvirtualgridintersection
	'''
	def __init__( self , placementlocation,placementrefdirection, ):
		ifcobjectplacement.__init__(self , )
		self.placementlocation = placementlocation
		self.placementrefdirection = placementrefdirection

	@apply
	def placementlocation():
		def fget( self ):
			return self._placementlocation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placementlocation is mantatory and can not be set to None')
			if not check_type(value,ifcvirtualgridintersection):
				self._placementlocation = ifcvirtualgridintersection(value)
			else:
				self._placementlocation = value
		return property(**locals())

	@apply
	def placementrefdirection():
		def fget( self ):
			return self._placementrefdirection
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvirtualgridintersection):
					self._placementrefdirection = ifcvirtualgridintersection(value)
				else:
					self._placementrefdirection = value
			else:
				self._placementrefdirection = value
		return property(**locals())

####################
 # ENTITY ifctextstylefontmodel #
####################
class ifctextstylefontmodel(ifcpredefinedtextfont):
	'''Entity ifctextstylefontmodel definition.

	:param fontfamily
	:type fontfamily:LIST(1,None,'STRING', scope = schema_scope)

	:param fontstyle
	:type fontstyle:ifcfontstyle

	:param fontvariant
	:type fontvariant:ifcfontvariant

	:param fontweight
	:type fontweight:ifcfontweight

	:param fontsize
	:type fontsize:ifcsizeselect
	'''
	def __init__( self , inherited0__name , fontfamily,fontstyle,fontvariant,fontweight,fontsize, ):
		ifcpredefinedtextfont.__init__(self , inherited0__name , )
		self.fontfamily = fontfamily
		self.fontstyle = fontstyle
		self.fontvariant = fontvariant
		self.fontweight = fontweight
		self.fontsize = fontsize

	@apply
	def fontfamily():
		def fget( self ):
			return self._fontfamily
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._fontfamily = LIST(value)
				else:
					self._fontfamily = value
			else:
				self._fontfamily = value
		return property(**locals())

	@apply
	def fontstyle():
		def fget( self ):
			return self._fontstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfontstyle):
					self._fontstyle = ifcfontstyle(value)
				else:
					self._fontstyle = value
			else:
				self._fontstyle = value
		return property(**locals())

	@apply
	def fontvariant():
		def fget( self ):
			return self._fontvariant
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfontvariant):
					self._fontvariant = ifcfontvariant(value)
				else:
					self._fontvariant = value
			else:
				self._fontvariant = value
		return property(**locals())

	@apply
	def fontweight():
		def fget( self ):
			return self._fontweight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcfontweight):
					self._fontweight = ifcfontweight(value)
				else:
					self._fontweight = value
			else:
				self._fontweight = value
		return property(**locals())

	@apply
	def fontsize():
		def fget( self ):
			return self._fontsize
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fontsize is mantatory and can not be set to None')
			if not check_type(value,ifcsizeselect):
				self._fontsize = ifcsizeselect(value)
			else:
				self._fontsize = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (('IFC2X3.IFCLENGTHMEASURE'  ==  TYPEOF(self.self.fontsize))  and  (self.self.fontsize  >  0))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcflowfitting #
####################
class ifcflowfitting(ifcdistributionflowelement):
	'''Entity ifcflowfitting definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcprotectivedevicetype #
####################
class ifcprotectivedevicetype(ifcflowcontrollertype):
	'''Entity ifcprotectivedevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcprotectivedevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcprotectivedevicetypeenum):
				self._predefinedtype = ifcprotectivedevicetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifccircleprofiledef #
####################
class ifccircleprofiledef(ifcparameterizedprofiledef):
	'''Entity ifccircleprofiledef definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , radius, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY ifcwindowpanelproperties #
####################
class ifcwindowpanelproperties(ifcpropertysetdefinition):
	'''Entity ifcwindowpanelproperties definition.

	:param operationtype
	:type operationtype:ifcwindowpaneloperationenum

	:param panelposition
	:type panelposition:ifcwindowpanelpositionenum

	:param framedepth
	:type framedepth:ifcpositivelengthmeasure

	:param framethickness
	:type framethickness:ifcpositivelengthmeasure

	:param shapeaspectstyle
	:type shapeaspectstyle:ifcshapeaspect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , operationtype,panelposition,framedepth,framethickness,shapeaspectstyle, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.operationtype = operationtype
		self.panelposition = panelposition
		self.framedepth = framedepth
		self.framethickness = framethickness
		self.shapeaspectstyle = shapeaspectstyle

	@apply
	def operationtype():
		def fget( self ):
			return self._operationtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operationtype is mantatory and can not be set to None')
			if not check_type(value,ifcwindowpaneloperationenum):
				self._operationtype = ifcwindowpaneloperationenum(value)
			else:
				self._operationtype = value
		return property(**locals())

	@apply
	def panelposition():
		def fget( self ):
			return self._panelposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument panelposition is mantatory and can not be set to None')
			if not check_type(value,ifcwindowpanelpositionenum):
				self._panelposition = ifcwindowpanelpositionenum(value)
			else:
				self._panelposition = value
		return property(**locals())

	@apply
	def framedepth():
		def fget( self ):
			return self._framedepth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._framedepth = ifcpositivelengthmeasure(value)
				else:
					self._framedepth = value
			else:
				self._framedepth = value
		return property(**locals())

	@apply
	def framethickness():
		def fget( self ):
			return self._framethickness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._framethickness = ifcpositivelengthmeasure(value)
				else:
					self._framethickness = value
			else:
				self._framethickness = value
		return property(**locals())

	@apply
	def shapeaspectstyle():
		def fget( self ):
			return self._shapeaspectstyle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshapeaspect):
					self._shapeaspectstyle = ifcshapeaspect(value)
				else:
					self._shapeaspectstyle = value
			else:
				self._shapeaspectstyle = value
		return property(**locals())

####################
 # ENTITY ifcdimensionalexponents #
####################
class ifcdimensionalexponents(BaseEntityClass):
	'''Entity ifcdimensionalexponents definition.

	:param lengthexponent
	:type lengthexponent:INTEGER

	:param massexponent
	:type massexponent:INTEGER

	:param timeexponent
	:type timeexponent:INTEGER

	:param electriccurrentexponent
	:type electriccurrentexponent:INTEGER

	:param thermodynamictemperatureexponent
	:type thermodynamictemperatureexponent:INTEGER

	:param amountofsubstanceexponent
	:type amountofsubstanceexponent:INTEGER

	:param luminousintensityexponent
	:type luminousintensityexponent:INTEGER
	'''
	def __init__( self , lengthexponent,massexponent,timeexponent,electriccurrentexponent,thermodynamictemperatureexponent,amountofsubstanceexponent,luminousintensityexponent, ):
		self.lengthexponent = lengthexponent
		self.massexponent = massexponent
		self.timeexponent = timeexponent
		self.electriccurrentexponent = electriccurrentexponent
		self.thermodynamictemperatureexponent = thermodynamictemperatureexponent
		self.amountofsubstanceexponent = amountofsubstanceexponent
		self.luminousintensityexponent = luminousintensityexponent

	@apply
	def lengthexponent():
		def fget( self ):
			return self._lengthexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lengthexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._lengthexponent = INTEGER(value)
			else:
				self._lengthexponent = value
		return property(**locals())

	@apply
	def massexponent():
		def fget( self ):
			return self._massexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument massexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._massexponent = INTEGER(value)
			else:
				self._massexponent = value
		return property(**locals())

	@apply
	def timeexponent():
		def fget( self ):
			return self._timeexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timeexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._timeexponent = INTEGER(value)
			else:
				self._timeexponent = value
		return property(**locals())

	@apply
	def electriccurrentexponent():
		def fget( self ):
			return self._electriccurrentexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument electriccurrentexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._electriccurrentexponent = INTEGER(value)
			else:
				self._electriccurrentexponent = value
		return property(**locals())

	@apply
	def thermodynamictemperatureexponent():
		def fget( self ):
			return self._thermodynamictemperatureexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thermodynamictemperatureexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._thermodynamictemperatureexponent = INTEGER(value)
			else:
				self._thermodynamictemperatureexponent = value
		return property(**locals())

	@apply
	def amountofsubstanceexponent():
		def fget( self ):
			return self._amountofsubstanceexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument amountofsubstanceexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._amountofsubstanceexponent = INTEGER(value)
			else:
				self._amountofsubstanceexponent = value
		return property(**locals())

	@apply
	def luminousintensityexponent():
		def fget( self ):
			return self._luminousintensityexponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument luminousintensityexponent is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._luminousintensityexponent = INTEGER(value)
			else:
				self._luminousintensityexponent = value
		return property(**locals())

####################
 # ENTITY ifcextendedmaterialproperties #
####################
class ifcextendedmaterialproperties(ifcmaterialproperties):
	'''Entity ifcextendedmaterialproperties definition.

	:param extendedproperties
	:type extendedproperties:SET(1,None,'ifcproperty', scope = schema_scope)

	:param description
	:type description:ifctext

	:param name
	:type name:ifclabel
	'''
	def __init__( self , inherited0__material , extendedproperties,description,name, ):
		ifcmaterialproperties.__init__(self , inherited0__material , )
		self.extendedproperties = extendedproperties
		self.description = description
		self.name = name

	@apply
	def extendedproperties():
		def fget( self ):
			return self._extendedproperties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extendedproperties is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproperty', scope = schema_scope)):
				self._extendedproperties = SET(value)
			else:
				self._extendedproperties = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifcmetric #
####################
class ifcmetric(ifcconstraint):
	'''Entity ifcmetric definition.

	:param benchmark
	:type benchmark:ifcbenchmarkenum

	:param valuesource
	:type valuesource:ifclabel

	:param datavalue
	:type datavalue:ifcmetricvalueselect
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__constraintgrade , inherited3__constraintsource , inherited4__creatingactor , inherited5__creationtime , inherited6__userdefinedgrade , benchmark,valuesource,datavalue, ):
		ifcconstraint.__init__(self , inherited0__name , inherited1__description , inherited2__constraintgrade , inherited3__constraintsource , inherited4__creatingactor , inherited5__creationtime , inherited6__userdefinedgrade , )
		self.benchmark = benchmark
		self.valuesource = valuesource
		self.datavalue = datavalue

	@apply
	def benchmark():
		def fget( self ):
			return self._benchmark
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument benchmark is mantatory and can not be set to None')
			if not check_type(value,ifcbenchmarkenum):
				self._benchmark = ifcbenchmarkenum(value)
			else:
				self._benchmark = value
		return property(**locals())

	@apply
	def valuesource():
		def fget( self ):
			return self._valuesource
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._valuesource = ifclabel(value)
				else:
					self._valuesource = value
			else:
				self._valuesource = value
		return property(**locals())

	@apply
	def datavalue():
		def fget( self ):
			return self._datavalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument datavalue is mantatory and can not be set to None')
			if not check_type(value,ifcmetricvalueselect):
				self._datavalue = ifcmetricvalueselect(value)
			else:
				self._datavalue = value
		return property(**locals())

####################
 # ENTITY ifcpredefinedpointmarkersymbol #
####################
class ifcpredefinedpointmarkersymbol(ifcpredefinedsymbol):
	'''Entity ifcpredefinedpointmarkersymbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefinedsymbol.__init__(self , inherited0__name , )
	def wr31(self):
		eval_wr31_wr = (self.self.ifcpredefineditem.self.name  ==  ['asterisk','circle','dot','plus','square','triangle','x'])
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcapprovalpropertyrelationship #
####################
class ifcapprovalpropertyrelationship(BaseEntityClass):
	'''Entity ifcapprovalpropertyrelationship definition.

	:param approvedproperties
	:type approvedproperties:SET(1,None,'ifcproperty', scope = schema_scope)

	:param approval
	:type approval:ifcapproval
	'''
	def __init__( self , approvedproperties,approval, ):
		self.approvedproperties = approvedproperties
		self.approval = approval

	@apply
	def approvedproperties():
		def fget( self ):
			return self._approvedproperties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument approvedproperties is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproperty', scope = schema_scope)):
				self._approvedproperties = SET(value)
			else:
				self._approvedproperties = value
		return property(**locals())

	@apply
	def approval():
		def fget( self ):
			return self._approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument approval is mantatory and can not be set to None')
			if not check_type(value,ifcapproval):
				self._approval = ifcapproval(value)
			else:
				self._approval = value
		return property(**locals())

####################
 # ENTITY ifccoordinateduniversaltimeoffset #
####################
class ifccoordinateduniversaltimeoffset(BaseEntityClass):
	'''Entity ifccoordinateduniversaltimeoffset definition.

	:param houroffset
	:type houroffset:ifchourinday

	:param minuteoffset
	:type minuteoffset:ifcminuteinhour

	:param sense
	:type sense:ifcaheadorbehind
	'''
	def __init__( self , houroffset,minuteoffset,sense, ):
		self.houroffset = houroffset
		self.minuteoffset = minuteoffset
		self.sense = sense

	@apply
	def houroffset():
		def fget( self ):
			return self._houroffset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument houroffset is mantatory and can not be set to None')
			if not check_type(value,ifchourinday):
				self._houroffset = ifchourinday(value)
			else:
				self._houroffset = value
		return property(**locals())

	@apply
	def minuteoffset():
		def fget( self ):
			return self._minuteoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcminuteinhour):
					self._minuteoffset = ifcminuteinhour(value)
				else:
					self._minuteoffset = value
			else:
				self._minuteoffset = value
		return property(**locals())

	@apply
	def sense():
		def fget( self ):
			return self._sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sense is mantatory and can not be set to None')
			if not check_type(value,ifcaheadorbehind):
				self._sense = ifcaheadorbehind(value)
			else:
				self._sense = value
		return property(**locals())

####################
 # ENTITY ifcrelconnectswithrealizingelements #
####################
class ifcrelconnectswithrealizingelements(ifcrelconnectselements):
	'''Entity ifcrelconnectswithrealizingelements definition.

	:param realizingelements
	:type realizingelements:SET(1,None,'ifcelement', scope = schema_scope)

	:param connectiontype
	:type connectiontype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__connectiongeometry , inherited5__relatingelement , inherited6__relatedelement , realizingelements,connectiontype, ):
		ifcrelconnectselements.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__connectiongeometry , inherited5__relatingelement , inherited6__relatedelement , )
		self.realizingelements = realizingelements
		self.connectiontype = connectiontype

	@apply
	def realizingelements():
		def fget( self ):
			return self._realizingelements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument realizingelements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcelement', scope = schema_scope)):
				self._realizingelements = SET(value)
			else:
				self._realizingelements = value
		return property(**locals())

	@apply
	def connectiontype():
		def fget( self ):
			return self._connectiontype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._connectiontype = ifclabel(value)
				else:
					self._connectiontype = value
			else:
				self._connectiontype = value
		return property(**locals())

####################
 # ENTITY ifcprocess #
####################
class ifcprocess(ifcobject):
	'''Entity ifcprocess definition.

	:param operateson
	:type operateson:SET(0,None,'ifcrelassignstoprocess', scope = schema_scope)

	:param issuccessorfrom
	:type issuccessorfrom:SET(0,None,'ifcrelsequence', scope = schema_scope)

	:param ispredecessorto
	:type ispredecessorto:SET(0,None,'ifcrelsequence', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

	@apply
	def operateson():
		def fget( self ):
			return self._operateson
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument operateson is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def issuccessorfrom():
		def fget( self ):
			return self._issuccessorfrom
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument issuccessorfrom is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ispredecessorto():
		def fget( self ):
			return self._ispredecessorto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument ispredecessorto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifctask #
####################
class ifctask(ifcprocess):
	'''Entity ifctask definition.

	:param taskid
	:type taskid:ifcidentifier

	:param status
	:type status:ifclabel

	:param workmethod
	:type workmethod:ifclabel

	:param ismilestone
	:type ismilestone:BOOLEAN

	:param priority
	:type priority:INTEGER
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , taskid,status,workmethod,ismilestone,priority, ):
		ifcprocess.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.taskid = taskid
		self.status = status
		self.workmethod = workmethod
		self.ismilestone = ismilestone
		self.priority = priority

	@apply
	def taskid():
		def fget( self ):
			return self._taskid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument taskid is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._taskid = ifcidentifier(value)
			else:
				self._taskid = value
		return property(**locals())

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._status = ifclabel(value)
				else:
					self._status = value
			else:
				self._status = value
		return property(**locals())

	@apply
	def workmethod():
		def fget( self ):
			return self._workmethod
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._workmethod = ifclabel(value)
				else:
					self._workmethod = value
			else:
				self._workmethod = value
		return property(**locals())

	@apply
	def ismilestone():
		def fget( self ):
			return self._ismilestone
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ismilestone is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._ismilestone = BOOLEAN(value)
			else:
				self._ismilestone = value
		return property(**locals())

	@apply
	def priority():
		def fget( self ):
			return self._priority
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,INTEGER):
					self._priority = INTEGER(value)
				else:
					self._priority = value
			else:
				self._priority = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcresource #
####################
class ifcresource(ifcobject):
	'''Entity ifcresource definition.

	:param resourceof
	:type resourceof:SET(0,None,'ifcrelassignstoresource', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

	@apply
	def resourceof():
		def fget( self ):
			return self._resourceof
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument resourceof is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcconstructionresource #
####################
class ifcconstructionresource(ifcresource):
	'''Entity ifcconstructionresource definition.

	:param resourceidentifier
	:type resourceidentifier:ifcidentifier

	:param resourcegroup
	:type resourcegroup:ifclabel

	:param resourceconsumption
	:type resourceconsumption:ifcresourceconsumptionenum

	:param basequantity
	:type basequantity:ifcmeasurewithunit
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , resourceidentifier,resourcegroup,resourceconsumption,basequantity, ):
		ifcresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.resourceidentifier = resourceidentifier
		self.resourcegroup = resourcegroup
		self.resourceconsumption = resourceconsumption
		self.basequantity = basequantity

	@apply
	def resourceidentifier():
		def fget( self ):
			return self._resourceidentifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._resourceidentifier = ifcidentifier(value)
				else:
					self._resourceidentifier = value
			else:
				self._resourceidentifier = value
		return property(**locals())

	@apply
	def resourcegroup():
		def fget( self ):
			return self._resourcegroup
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._resourcegroup = ifclabel(value)
				else:
					self._resourcegroup = value
			else:
				self._resourcegroup = value
		return property(**locals())

	@apply
	def resourceconsumption():
		def fget( self ):
			return self._resourceconsumption
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcresourceconsumptionenum):
					self._resourceconsumption = ifcresourceconsumptionenum(value)
				else:
					self._resourceconsumption = value
			else:
				self._resourceconsumption = value
		return property(**locals())

	@apply
	def basequantity():
		def fget( self ):
			return self._basequantity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmeasurewithunit):
					self._basequantity = ifcmeasurewithunit(value)
				else:
					self._basequantity = value
			else:
				self._basequantity = value
		return property(**locals())

####################
 # ENTITY ifccrewresource #
####################
class ifccrewresource(ifcconstructionresource):
	'''Entity ifccrewresource definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity ,  ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity , )

####################
 # ENTITY ifcmanifoldsolidbrep #
####################
class ifcmanifoldsolidbrep(ifcsolidmodel):
	'''Entity ifcmanifoldsolidbrep definition.

	:param outer
	:type outer:ifcclosedshell
	'''
	def __init__( self , outer, ):
		ifcsolidmodel.__init__(self , )
		self.outer = outer

	@apply
	def outer():
		def fget( self ):
			return self._outer
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outer is mantatory and can not be set to None')
			if not check_type(value,ifcclosedshell):
				self._outer = ifcclosedshell(value)
			else:
				self._outer = value
		return property(**locals())

####################
 # ENTITY ifcfacetedbrep #
####################
class ifcfacetedbrep(ifcmanifoldsolidbrep):
	'''Entity ifcfacetedbrep definition.
	'''
	def __init__( self , inherited0__outer ,  ):
		ifcmanifoldsolidbrep.__init__(self , inherited0__outer , )

####################
 # ENTITY ifcbooleanresult #
####################
class ifcbooleanresult(ifcgeometricrepresentationitem):
	'''Entity ifcbooleanresult definition.

	:param operator
	:type operator:ifcbooleanoperator

	:param firstoperand
	:type firstoperand:ifcbooleanoperand

	:param secondoperand
	:type secondoperand:ifcbooleanoperand

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , operator,firstoperand,secondoperand, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.operator = operator
		self.firstoperand = firstoperand
		self.secondoperand = secondoperand

	@apply
	def operator():
		def fget( self ):
			return self._operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operator is mantatory and can not be set to None')
			if not check_type(value,ifcbooleanoperator):
				self._operator = ifcbooleanoperator(value)
			else:
				self._operator = value
		return property(**locals())

	@apply
	def firstoperand():
		def fget( self ):
			return self._firstoperand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument firstoperand is mantatory and can not be set to None')
			if not check_type(value,ifcbooleanoperand):
				self._firstoperand = ifcbooleanoperand(value)
			else:
				self._firstoperand = value
		return property(**locals())

	@apply
	def secondoperand():
		def fget( self ):
			return self._secondoperand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument secondoperand is mantatory and can not be set to None')
			if not check_type(value,ifcbooleanoperand):
				self._secondoperand = ifcbooleanoperand(value)
			else:
				self._secondoperand = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.firstoperand.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.firstoperand.self.dim  ==  self.secondoperand.self.dim)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcslabtype #
####################
class ifcslabtype(ifcbuildingelementtype):
	'''Entity ifcslabtype definition.

	:param predefinedtype
	:type predefinedtype:ifcslabtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcslabtypeenum):
				self._predefinedtype = ifcslabtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifctextstyletextmodel #
####################
class ifctextstyletextmodel(BaseEntityClass):
	'''Entity ifctextstyletextmodel definition.

	:param textindent
	:type textindent:ifcsizeselect

	:param textalign
	:type textalign:ifctextalignment

	:param textdecoration
	:type textdecoration:ifctextdecoration

	:param letterspacing
	:type letterspacing:ifcsizeselect

	:param wordspacing
	:type wordspacing:ifcsizeselect

	:param texttransform
	:type texttransform:ifctexttransformation

	:param lineheight
	:type lineheight:ifcsizeselect
	'''
	def __init__( self , textindent,textalign,textdecoration,letterspacing,wordspacing,texttransform,lineheight, ):
		self.textindent = textindent
		self.textalign = textalign
		self.textdecoration = textdecoration
		self.letterspacing = letterspacing
		self.wordspacing = wordspacing
		self.texttransform = texttransform
		self.lineheight = lineheight

	@apply
	def textindent():
		def fget( self ):
			return self._textindent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsizeselect):
					self._textindent = ifcsizeselect(value)
				else:
					self._textindent = value
			else:
				self._textindent = value
		return property(**locals())

	@apply
	def textalign():
		def fget( self ):
			return self._textalign
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctextalignment):
					self._textalign = ifctextalignment(value)
				else:
					self._textalign = value
			else:
				self._textalign = value
		return property(**locals())

	@apply
	def textdecoration():
		def fget( self ):
			return self._textdecoration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctextdecoration):
					self._textdecoration = ifctextdecoration(value)
				else:
					self._textdecoration = value
			else:
				self._textdecoration = value
		return property(**locals())

	@apply
	def letterspacing():
		def fget( self ):
			return self._letterspacing
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsizeselect):
					self._letterspacing = ifcsizeselect(value)
				else:
					self._letterspacing = value
			else:
				self._letterspacing = value
		return property(**locals())

	@apply
	def wordspacing():
		def fget( self ):
			return self._wordspacing
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsizeselect):
					self._wordspacing = ifcsizeselect(value)
				else:
					self._wordspacing = value
			else:
				self._wordspacing = value
		return property(**locals())

	@apply
	def texttransform():
		def fget( self ):
			return self._texttransform
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctexttransformation):
					self._texttransform = ifctexttransformation(value)
				else:
					self._texttransform = value
			else:
				self._texttransform = value
		return property(**locals())

	@apply
	def lineheight():
		def fget( self ):
			return self._lineheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsizeselect):
					self._lineheight = ifcsizeselect(value)
				else:
					self._lineheight = value
			else:
				self._lineheight = value
		return property(**locals())

####################
 # ENTITY ifcunitassignment #
####################
class ifcunitassignment(BaseEntityClass):
	'''Entity ifcunitassignment definition.

	:param units
	:type units:SET(1,None,'ifcunit', scope = schema_scope)
	'''
	def __init__( self , units, ):
		self.units = units

	@apply
	def units():
		def fget( self ):
			return self._units
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument units is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcunit', scope = schema_scope)):
				self._units = SET(value)
			else:
				self._units = value
		return property(**locals())
	def wr01(self):
		eval_wr01_wr = ifccorrectunitassignment(self.units)
		if not eval_wr01_wr:
			raise AssertionError('Rule wr01 violated')
		else:
			return eval_wr01_wr


####################
 # ENTITY ifcbeam #
####################
class ifcbeam(ifcbuildingelement):
	'''Entity ifcbeam definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcevaporativecoolertype #
####################
class ifcevaporativecoolertype(ifcenergyconversiondevicetype):
	'''Entity ifcevaporativecoolertype definition.

	:param predefinedtype
	:type predefinedtype:ifcevaporativecoolertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcevaporativecoolertypeenum):
				self._predefinedtype = ifcevaporativecoolertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcevaporativecoolertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcevaporativecoolertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcelementarysurface #
####################
class ifcelementarysurface(ifcsurface):
	'''Entity ifcelementarysurface definition.

	:param position
	:type position:ifcaxis2placement3d

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , position, ):
		ifcsurface.__init__(self , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement3d):
				self._position = ifcaxis2placement3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.position.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcalarmtype #
####################
class ifcalarmtype(ifcdistributioncontrolelementtype):
	'''Entity ifcalarmtype definition.

	:param predefinedtype
	:type predefinedtype:ifcalarmtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcalarmtypeenum):
				self._predefinedtype = ifcalarmtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcmembertype #
####################
class ifcmembertype(ifcbuildingelementtype):
	'''Entity ifcmembertype definition.

	:param predefinedtype
	:type predefinedtype:ifcmembertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcmembertypeenum):
				self._predefinedtype = ifcmembertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcrelflowcontrolelements #
####################
class ifcrelflowcontrolelements(ifcrelconnects):
	'''Entity ifcrelflowcontrolelements definition.

	:param relatedcontrolelements
	:type relatedcontrolelements:SET(1,None,'ifcdistributioncontrolelement', scope = schema_scope)

	:param relatingflowelement
	:type relatingflowelement:ifcdistributionflowelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedcontrolelements,relatingflowelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedcontrolelements = relatedcontrolelements
		self.relatingflowelement = relatingflowelement

	@apply
	def relatedcontrolelements():
		def fget( self ):
			return self._relatedcontrolelements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedcontrolelements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcdistributioncontrolelement', scope = schema_scope)):
				self._relatedcontrolelements = SET(value)
			else:
				self._relatedcontrolelements = value
		return property(**locals())

	@apply
	def relatingflowelement():
		def fget( self ):
			return self._relatingflowelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingflowelement is mantatory and can not be set to None')
			if not check_type(value,ifcdistributionflowelement):
				self._relatingflowelement = ifcdistributionflowelement(value)
			else:
				self._relatingflowelement = value
		return property(**locals())

####################
 # ENTITY ifcvertexbasedtexturemap #
####################
class ifcvertexbasedtexturemap(BaseEntityClass):
	'''Entity ifcvertexbasedtexturemap definition.

	:param texturevertices
	:type texturevertices:LIST(3,None,'ifctexturevertex', scope = schema_scope)

	:param texturepoints
	:type texturepoints:LIST(3,None,'ifccartesianpoint', scope = schema_scope)
	'''
	def __init__( self , texturevertices,texturepoints, ):
		self.texturevertices = texturevertices
		self.texturepoints = texturepoints

	@apply
	def texturevertices():
		def fget( self ):
			return self._texturevertices
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument texturevertices is mantatory and can not be set to None')
			if not check_type(value,LIST(3,None,'ifctexturevertex', scope = schema_scope)):
				self._texturevertices = LIST(value)
			else:
				self._texturevertices = value
		return property(**locals())

	@apply
	def texturepoints():
		def fget( self ):
			return self._texturepoints
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument texturepoints is mantatory and can not be set to None')
			if not check_type(value,LIST(3,None,'ifccartesianpoint', scope = schema_scope)):
				self._texturepoints = LIST(value)
			else:
				self._texturepoints = value
		return property(**locals())

####################
 # ENTITY ifcpropertylistvalue #
####################
class ifcpropertylistvalue(ifcsimpleproperty):
	'''Entity ifcpropertylistvalue definition.

	:param listvalues
	:type listvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param unit
	:type unit:ifcunit
	'''
	def __init__( self , inherited0__name , inherited1__description , listvalues,unit, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.listvalues = listvalues
		self.unit = unit

	@apply
	def listvalues():
		def fget( self ):
			return self._listvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument listvalues is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
				self._listvalues = LIST(value)
			else:
				self._listvalues = value
		return property(**locals())

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._unit = ifcunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (SIZEOF(None)  ==  0)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcstructuralactivity #
####################
class ifcstructuralactivity(ifcproduct):
	'''Entity ifcstructuralactivity definition.

	:param appliedload
	:type appliedload:ifcstructuralload

	:param globalorlocal
	:type globalorlocal:ifcglobalorlocalenum

	:param assignedtostructuralitem
	:type assignedtostructuralitem:ifcrelconnectsstructuralactivity
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , appliedload,globalorlocal, ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.appliedload = appliedload
		self.globalorlocal = globalorlocal

	@apply
	def appliedload():
		def fget( self ):
			return self._appliedload
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument appliedload is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralload):
				self._appliedload = ifcstructuralload(value)
			else:
				self._appliedload = value
		return property(**locals())

	@apply
	def globalorlocal():
		def fget( self ):
			return self._globalorlocal
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument globalorlocal is mantatory and can not be set to None')
			if not check_type(value,ifcglobalorlocalenum):
				self._globalorlocal = ifcglobalorlocalenum(value)
			else:
				self._globalorlocal = value
		return property(**locals())

	@apply
	def assignedtostructuralitem():
		def fget( self ):
			return self._assignedtostructuralitem
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument assignedtostructuralitem is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstructuralaction #
####################
class ifcstructuralaction(ifcstructuralactivity):
	'''Entity ifcstructuralaction definition.

	:param destabilizingload
	:type destabilizingload:BOOLEAN

	:param causedby
	:type causedby:ifcstructuralreaction
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , destabilizingload,causedby, ):
		ifcstructuralactivity.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , )
		self.destabilizingload = destabilizingload
		self.causedby = causedby

	@apply
	def destabilizingload():
		def fget( self ):
			return self._destabilizingload
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument destabilizingload is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._destabilizingload = BOOLEAN(value)
			else:
				self._destabilizingload = value
		return property(**locals())

	@apply
	def causedby():
		def fget( self ):
			return self._causedby
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcstructuralreaction):
					self._causedby = ifcstructuralreaction(value)
				else:
					self._causedby = value
			else:
				self._causedby = value
		return property(**locals())

####################
 # ENTITY ifcsurfacestylerefraction #
####################
class ifcsurfacestylerefraction(BaseEntityClass):
	'''Entity ifcsurfacestylerefraction definition.

	:param refractionindex
	:type refractionindex:ifcreal

	:param dispersionfactor
	:type dispersionfactor:ifcreal
	'''
	def __init__( self , refractionindex,dispersionfactor, ):
		self.refractionindex = refractionindex
		self.dispersionfactor = dispersionfactor

	@apply
	def refractionindex():
		def fget( self ):
			return self._refractionindex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreal):
					self._refractionindex = ifcreal(value)
				else:
					self._refractionindex = value
			else:
				self._refractionindex = value
		return property(**locals())

	@apply
	def dispersionfactor():
		def fget( self ):
			return self._dispersionfactor
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreal):
					self._dispersionfactor = ifcreal(value)
				else:
					self._dispersionfactor = value
			else:
				self._dispersionfactor = value
		return property(**locals())

####################
 # ENTITY ifcpredefinedcurvefont #
####################
class ifcpredefinedcurvefont(ifcpredefineditem):
	'''Entity ifcpredefinedcurvefont definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefineditem.__init__(self , inherited0__name , )

####################
 # ENTITY ifcrampflight #
####################
class ifcrampflight(ifcbuildingelement):
	'''Entity ifcrampflight definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcdiscreteaccessory #
####################
class ifcdiscreteaccessory(ifcelementcomponent):
	'''Entity ifcdiscreteaccessory definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelementcomponent.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcperson #
####################
class ifcperson(BaseEntityClass):
	'''Entity ifcperson definition.

	:param id
	:type id:ifcidentifier

	:param familyname
	:type familyname:ifclabel

	:param givenname
	:type givenname:ifclabel

	:param middlenames
	:type middlenames:LIST(1,None,'STRING', scope = schema_scope)

	:param prefixtitles
	:type prefixtitles:LIST(1,None,'STRING', scope = schema_scope)

	:param suffixtitles
	:type suffixtitles:LIST(1,None,'STRING', scope = schema_scope)

	:param roles
	:type roles:LIST(1,None,'ifcactorrole', scope = schema_scope)

	:param addresses
	:type addresses:LIST(1,None,'ifcaddress', scope = schema_scope)

	:param engagedin
	:type engagedin:SET(0,None,'ifcpersonandorganization', scope = schema_scope)
	'''
	def __init__( self , id,familyname,givenname,middlenames,prefixtitles,suffixtitles,roles,addresses, ):
		self.id = id
		self.familyname = familyname
		self.givenname = givenname
		self.middlenames = middlenames
		self.prefixtitles = prefixtitles
		self.suffixtitles = suffixtitles
		self.roles = roles
		self.addresses = addresses

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._id = ifcidentifier(value)
				else:
					self._id = value
			else:
				self._id = value
		return property(**locals())

	@apply
	def familyname():
		def fget( self ):
			return self._familyname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._familyname = ifclabel(value)
				else:
					self._familyname = value
			else:
				self._familyname = value
		return property(**locals())

	@apply
	def givenname():
		def fget( self ):
			return self._givenname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._givenname = ifclabel(value)
				else:
					self._givenname = value
			else:
				self._givenname = value
		return property(**locals())

	@apply
	def middlenames():
		def fget( self ):
			return self._middlenames
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._middlenames = LIST(value)
				else:
					self._middlenames = value
			else:
				self._middlenames = value
		return property(**locals())

	@apply
	def prefixtitles():
		def fget( self ):
			return self._prefixtitles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._prefixtitles = LIST(value)
				else:
					self._prefixtitles = value
			else:
				self._prefixtitles = value
		return property(**locals())

	@apply
	def suffixtitles():
		def fget( self ):
			return self._suffixtitles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._suffixtitles = LIST(value)
				else:
					self._suffixtitles = value
			else:
				self._suffixtitles = value
		return property(**locals())

	@apply
	def roles():
		def fget( self ):
			return self._roles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcactorrole', scope = schema_scope)):
					self._roles = LIST(value)
				else:
					self._roles = value
			else:
				self._roles = value
		return property(**locals())

	@apply
	def addresses():
		def fget( self ):
			return self._addresses
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcaddress', scope = schema_scope)):
					self._addresses = LIST(value)
				else:
					self._addresses = value
			else:
				self._addresses = value
		return property(**locals())

	@apply
	def engagedin():
		def fget( self ):
			return self._engagedin
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument engagedin is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.familyname)  or  EXISTS(self.givenname))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcairterminaltype #
####################
class ifcairterminaltype(ifcflowterminaltype):
	'''Entity ifcairterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcairterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcairterminaltypeenum):
				self._predefinedtype = ifcairterminaltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcairterminaltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcairterminaltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcfacebound #
####################
class ifcfacebound(ifctopologicalrepresentationitem):
	'''Entity ifcfacebound definition.

	:param bound
	:type bound:ifcloop

	:param orientation
	:type orientation:BOOLEAN
	'''
	def __init__( self , bound,orientation, ):
		ifctopologicalrepresentationitem.__init__(self , )
		self.bound = bound
		self.orientation = orientation

	@apply
	def bound():
		def fget( self ):
			return self._bound
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bound is mantatory and can not be set to None')
			if not check_type(value,ifcloop):
				self._bound = ifcloop(value)
			else:
				self._bound = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY ifcclassificationnotation #
####################
class ifcclassificationnotation(BaseEntityClass):
	'''Entity ifcclassificationnotation definition.

	:param notationfacets
	:type notationfacets:SET(1,None,'ifcclassificationnotationfacet', scope = schema_scope)
	'''
	def __init__( self , notationfacets, ):
		self.notationfacets = notationfacets

	@apply
	def notationfacets():
		def fget( self ):
			return self._notationfacets
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument notationfacets is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcclassificationnotationfacet', scope = schema_scope)):
				self._notationfacets = SET(value)
			else:
				self._notationfacets = value
		return property(**locals())

####################
 # ENTITY ifcsurfacestylelighting #
####################
class ifcsurfacestylelighting(BaseEntityClass):
	'''Entity ifcsurfacestylelighting definition.

	:param diffusetransmissioncolour
	:type diffusetransmissioncolour:ifccolourrgb

	:param diffusereflectioncolour
	:type diffusereflectioncolour:ifccolourrgb

	:param transmissioncolour
	:type transmissioncolour:ifccolourrgb

	:param reflectancecolour
	:type reflectancecolour:ifccolourrgb
	'''
	def __init__( self , diffusetransmissioncolour,diffusereflectioncolour,transmissioncolour,reflectancecolour, ):
		self.diffusetransmissioncolour = diffusetransmissioncolour
		self.diffusereflectioncolour = diffusereflectioncolour
		self.transmissioncolour = transmissioncolour
		self.reflectancecolour = reflectancecolour

	@apply
	def diffusetransmissioncolour():
		def fget( self ):
			return self._diffusetransmissioncolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument diffusetransmissioncolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._diffusetransmissioncolour = ifccolourrgb(value)
			else:
				self._diffusetransmissioncolour = value
		return property(**locals())

	@apply
	def diffusereflectioncolour():
		def fget( self ):
			return self._diffusereflectioncolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument diffusereflectioncolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._diffusereflectioncolour = ifccolourrgb(value)
			else:
				self._diffusereflectioncolour = value
		return property(**locals())

	@apply
	def transmissioncolour():
		def fget( self ):
			return self._transmissioncolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transmissioncolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._transmissioncolour = ifccolourrgb(value)
			else:
				self._transmissioncolour = value
		return property(**locals())

	@apply
	def reflectancecolour():
		def fget( self ):
			return self._reflectancecolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reflectancecolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._reflectancecolour = ifccolourrgb(value)
			else:
				self._reflectancecolour = value
		return property(**locals())

####################
 # ENTITY ifctendon #
####################
class ifctendon(ifcreinforcingelement):
	'''Entity ifctendon definition.

	:param predefinedtype
	:type predefinedtype:ifctendontypeenum

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param crosssectionarea
	:type crosssectionarea:ifcareameasure

	:param tensionforce
	:type tensionforce:ifcforcemeasure

	:param prestress
	:type prestress:ifcpressuremeasure

	:param frictioncoefficient
	:type frictioncoefficient:ifcnormalisedratiomeasure

	:param anchorageslip
	:type anchorageslip:ifcpositivelengthmeasure

	:param mincurvatureradius
	:type mincurvatureradius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , predefinedtype,nominaldiameter,crosssectionarea,tensionforce,prestress,frictioncoefficient,anchorageslip,mincurvatureradius, ):
		ifcreinforcingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , )
		self.predefinedtype = predefinedtype
		self.nominaldiameter = nominaldiameter
		self.crosssectionarea = crosssectionarea
		self.tensionforce = tensionforce
		self.prestress = prestress
		self.frictioncoefficient = frictioncoefficient
		self.anchorageslip = anchorageslip
		self.mincurvatureradius = mincurvatureradius

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctendontypeenum):
				self._predefinedtype = ifctendontypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def nominaldiameter():
		def fget( self ):
			return self._nominaldiameter
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument nominaldiameter is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._nominaldiameter = ifcpositivelengthmeasure(value)
			else:
				self._nominaldiameter = value
		return property(**locals())

	@apply
	def crosssectionarea():
		def fget( self ):
			return self._crosssectionarea
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument crosssectionarea is mantatory and can not be set to None')
			if not check_type(value,ifcareameasure):
				self._crosssectionarea = ifcareameasure(value)
			else:
				self._crosssectionarea = value
		return property(**locals())

	@apply
	def tensionforce():
		def fget( self ):
			return self._tensionforce
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcforcemeasure):
					self._tensionforce = ifcforcemeasure(value)
				else:
					self._tensionforce = value
			else:
				self._tensionforce = value
		return property(**locals())

	@apply
	def prestress():
		def fget( self ):
			return self._prestress
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpressuremeasure):
					self._prestress = ifcpressuremeasure(value)
				else:
					self._prestress = value
			else:
				self._prestress = value
		return property(**locals())

	@apply
	def frictioncoefficient():
		def fget( self ):
			return self._frictioncoefficient
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._frictioncoefficient = ifcnormalisedratiomeasure(value)
				else:
					self._frictioncoefficient = value
			else:
				self._frictioncoefficient = value
		return property(**locals())

	@apply
	def anchorageslip():
		def fget( self ):
			return self._anchorageslip
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._anchorageslip = ifcpositivelengthmeasure(value)
				else:
					self._anchorageslip = value
			else:
				self._anchorageslip = value
		return property(**locals())

	@apply
	def mincurvatureradius():
		def fget( self ):
			return self._mincurvatureradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._mincurvatureradius = ifcpositivelengthmeasure(value)
				else:
					self._mincurvatureradius = value
			else:
				self._mincurvatureradius = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifctendontypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifctendontypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcownerhistory #
####################
class ifcownerhistory(BaseEntityClass):
	'''Entity ifcownerhistory definition.

	:param owninguser
	:type owninguser:ifcpersonandorganization

	:param owningapplication
	:type owningapplication:ifcapplication

	:param state
	:type state:ifcstateenum

	:param changeaction
	:type changeaction:ifcchangeactionenum

	:param lastmodifieddate
	:type lastmodifieddate:ifctimestamp

	:param lastmodifyinguser
	:type lastmodifyinguser:ifcpersonandorganization

	:param lastmodifyingapplication
	:type lastmodifyingapplication:ifcapplication

	:param creationdate
	:type creationdate:ifctimestamp
	'''
	def __init__( self , owninguser,owningapplication,state,changeaction,lastmodifieddate,lastmodifyinguser,lastmodifyingapplication,creationdate, ):
		self.owninguser = owninguser
		self.owningapplication = owningapplication
		self.state = state
		self.changeaction = changeaction
		self.lastmodifieddate = lastmodifieddate
		self.lastmodifyinguser = lastmodifyinguser
		self.lastmodifyingapplication = lastmodifyingapplication
		self.creationdate = creationdate

	@apply
	def owninguser():
		def fget( self ):
			return self._owninguser
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument owninguser is mantatory and can not be set to None')
			if not check_type(value,ifcpersonandorganization):
				self._owninguser = ifcpersonandorganization(value)
			else:
				self._owninguser = value
		return property(**locals())

	@apply
	def owningapplication():
		def fget( self ):
			return self._owningapplication
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument owningapplication is mantatory and can not be set to None')
			if not check_type(value,ifcapplication):
				self._owningapplication = ifcapplication(value)
			else:
				self._owningapplication = value
		return property(**locals())

	@apply
	def state():
		def fget( self ):
			return self._state
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcstateenum):
					self._state = ifcstateenum(value)
				else:
					self._state = value
			else:
				self._state = value
		return property(**locals())

	@apply
	def changeaction():
		def fget( self ):
			return self._changeaction
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument changeaction is mantatory and can not be set to None')
			if not check_type(value,ifcchangeactionenum):
				self._changeaction = ifcchangeactionenum(value)
			else:
				self._changeaction = value
		return property(**locals())

	@apply
	def lastmodifieddate():
		def fget( self ):
			return self._lastmodifieddate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimestamp):
					self._lastmodifieddate = ifctimestamp(value)
				else:
					self._lastmodifieddate = value
			else:
				self._lastmodifieddate = value
		return property(**locals())

	@apply
	def lastmodifyinguser():
		def fget( self ):
			return self._lastmodifyinguser
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpersonandorganization):
					self._lastmodifyinguser = ifcpersonandorganization(value)
				else:
					self._lastmodifyinguser = value
			else:
				self._lastmodifyinguser = value
		return property(**locals())

	@apply
	def lastmodifyingapplication():
		def fget( self ):
			return self._lastmodifyingapplication
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcapplication):
					self._lastmodifyingapplication = ifcapplication(value)
				else:
					self._lastmodifyingapplication = value
			else:
				self._lastmodifyingapplication = value
		return property(**locals())

	@apply
	def creationdate():
		def fget( self ):
			return self._creationdate
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument creationdate is mantatory and can not be set to None')
			if not check_type(value,ifctimestamp):
				self._creationdate = ifctimestamp(value)
			else:
				self._creationdate = value
		return property(**locals())

####################
 # ENTITY ifcservicelife #
####################
class ifcservicelife(ifccontrol):
	'''Entity ifcservicelife definition.

	:param servicelifetype
	:type servicelifetype:ifcservicelifetypeenum

	:param servicelifeduration
	:type servicelifeduration:ifctimemeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , servicelifetype,servicelifeduration, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.servicelifetype = servicelifetype
		self.servicelifeduration = servicelifeduration

	@apply
	def servicelifetype():
		def fget( self ):
			return self._servicelifetype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument servicelifetype is mantatory and can not be set to None')
			if not check_type(value,ifcservicelifetypeenum):
				self._servicelifetype = ifcservicelifetypeenum(value)
			else:
				self._servicelifetype = value
		return property(**locals())

	@apply
	def servicelifeduration():
		def fget( self ):
			return self._servicelifeduration
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument servicelifeduration is mantatory and can not be set to None')
			if not check_type(value,ifctimemeasure):
				self._servicelifeduration = ifctimemeasure(value)
			else:
				self._servicelifeduration = value
		return property(**locals())

####################
 # ENTITY ifcsurfacestylewithtextures #
####################
class ifcsurfacestylewithtextures(BaseEntityClass):
	'''Entity ifcsurfacestylewithtextures definition.

	:param textures
	:type textures:LIST(1,None,'ifcsurfacetexture', scope = schema_scope)
	'''
	def __init__( self , textures, ):
		self.textures = textures

	@apply
	def textures():
		def fget( self ):
			return self._textures
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument textures is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcsurfacetexture', scope = schema_scope)):
				self._textures = LIST(value)
			else:
				self._textures = value
		return property(**locals())

####################
 # ENTITY ifcproject #
####################
class ifcproject(ifcobject):
	'''Entity ifcproject definition.

	:param longname
	:type longname:ifclabel

	:param phase
	:type phase:ifclabel

	:param representationcontexts
	:type representationcontexts:SET(1,None,'ifcrepresentationcontext', scope = schema_scope)

	:param unitsincontext
	:type unitsincontext:ifcunitassignment
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , longname,phase,representationcontexts,unitsincontext, ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.longname = longname
		self.phase = phase
		self.representationcontexts = representationcontexts
		self.unitsincontext = unitsincontext

	@apply
	def longname():
		def fget( self ):
			return self._longname
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._longname = ifclabel(value)
				else:
					self._longname = value
			else:
				self._longname = value
		return property(**locals())

	@apply
	def phase():
		def fget( self ):
			return self._phase
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._phase = ifclabel(value)
				else:
					self._phase = value
			else:
				self._phase = value
		return property(**locals())

	@apply
	def representationcontexts():
		def fget( self ):
			return self._representationcontexts
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representationcontexts is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcrepresentationcontext', scope = schema_scope)):
				self._representationcontexts = SET(value)
			else:
				self._representationcontexts = value
		return property(**locals())

	@apply
	def unitsincontext():
		def fget( self ):
			return self._unitsincontext
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unitsincontext is mantatory and can not be set to None')
			if not check_type(value,ifcunitassignment):
				self._unitsincontext = ifcunitassignment(value)
			else:
				self._unitsincontext = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = (SIZEOF(None)  ==  0)
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr

	def wr33(self):
		eval_wr33_wr = (SIZEOF(self.self.ifcobjectdefinition.self.decomposes)  ==  0)
		if not eval_wr33_wr:
			raise AssertionError('Rule wr33 violated')
		else:
			return eval_wr33_wr


####################
 # ENTITY ifcflowstoragedevicetype #
####################
class ifcflowstoragedevicetype(ifcdistributionflowelementtype):
	'''Entity ifcflowstoragedevicetype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcelectricflowstoragedevicetype #
####################
class ifcelectricflowstoragedevicetype(ifcflowstoragedevicetype):
	'''Entity ifcelectricflowstoragedevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricflowstoragedevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowstoragedevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectricflowstoragedevicetypeenum):
				self._predefinedtype = ifcelectricflowstoragedevicetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcplane #
####################
class ifcplane(ifcelementarysurface):
	'''Entity ifcplane definition.
	'''
	def __init__( self , inherited0__position ,  ):
		ifcelementarysurface.__init__(self , inherited0__position , )

####################
 # ENTITY ifccolourspecification #
####################
class ifccolourspecification(BaseEntityClass):
	'''Entity ifccolourspecification definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifccolourrgb #
####################
class ifccolourrgb(ifccolourspecification):
	'''Entity ifccolourrgb definition.

	:param red
	:type red:ifcnormalisedratiomeasure

	:param green
	:type green:ifcnormalisedratiomeasure

	:param blue
	:type blue:ifcnormalisedratiomeasure
	'''
	def __init__( self , inherited0__name , red,green,blue, ):
		ifccolourspecification.__init__(self , inherited0__name , )
		self.red = red
		self.green = green
		self.blue = blue

	@apply
	def red():
		def fget( self ):
			return self._red
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument red is mantatory and can not be set to None')
			if not check_type(value,ifcnormalisedratiomeasure):
				self._red = ifcnormalisedratiomeasure(value)
			else:
				self._red = value
		return property(**locals())

	@apply
	def green():
		def fget( self ):
			return self._green
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument green is mantatory and can not be set to None')
			if not check_type(value,ifcnormalisedratiomeasure):
				self._green = ifcnormalisedratiomeasure(value)
			else:
				self._green = value
		return property(**locals())

	@apply
	def blue():
		def fget( self ):
			return self._blue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument blue is mantatory and can not be set to None')
			if not check_type(value,ifcnormalisedratiomeasure):
				self._blue = ifcnormalisedratiomeasure(value)
			else:
				self._blue = value
		return property(**locals())

####################
 # ENTITY ifcfluidflowproperties #
####################
class ifcfluidflowproperties(ifcpropertysetdefinition):
	'''Entity ifcfluidflowproperties definition.

	:param propertysource
	:type propertysource:ifcpropertysourceenum

	:param flowconditiontimeseries
	:type flowconditiontimeseries:ifctimeseries

	:param velocitytimeseries
	:type velocitytimeseries:ifctimeseries

	:param flowratetimeseries
	:type flowratetimeseries:ifctimeseries

	:param fluid
	:type fluid:ifcmaterial

	:param pressuretimeseries
	:type pressuretimeseries:ifctimeseries

	:param userdefinedpropertysource
	:type userdefinedpropertysource:ifclabel

	:param temperaturesinglevalue
	:type temperaturesinglevalue:ifcthermodynamictemperaturemeasure

	:param wetbulbtemperaturesinglevalue
	:type wetbulbtemperaturesinglevalue:ifcthermodynamictemperaturemeasure

	:param wetbulbtemperaturetimeseries
	:type wetbulbtemperaturetimeseries:ifctimeseries

	:param temperaturetimeseries
	:type temperaturetimeseries:ifctimeseries

	:param flowratesinglevalue
	:type flowratesinglevalue:ifcderivedmeasurevalue

	:param flowconditionsinglevalue
	:type flowconditionsinglevalue:ifcpositiveratiomeasure

	:param velocitysinglevalue
	:type velocitysinglevalue:ifclinearvelocitymeasure

	:param pressuresinglevalue
	:type pressuresinglevalue:ifcpressuremeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , propertysource,flowconditiontimeseries,velocitytimeseries,flowratetimeseries,fluid,pressuretimeseries,userdefinedpropertysource,temperaturesinglevalue,wetbulbtemperaturesinglevalue,wetbulbtemperaturetimeseries,temperaturetimeseries,flowratesinglevalue,flowconditionsinglevalue,velocitysinglevalue,pressuresinglevalue, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.propertysource = propertysource
		self.flowconditiontimeseries = flowconditiontimeseries
		self.velocitytimeseries = velocitytimeseries
		self.flowratetimeseries = flowratetimeseries
		self.fluid = fluid
		self.pressuretimeseries = pressuretimeseries
		self.userdefinedpropertysource = userdefinedpropertysource
		self.temperaturesinglevalue = temperaturesinglevalue
		self.wetbulbtemperaturesinglevalue = wetbulbtemperaturesinglevalue
		self.wetbulbtemperaturetimeseries = wetbulbtemperaturetimeseries
		self.temperaturetimeseries = temperaturetimeseries
		self.flowratesinglevalue = flowratesinglevalue
		self.flowconditionsinglevalue = flowconditionsinglevalue
		self.velocitysinglevalue = velocitysinglevalue
		self.pressuresinglevalue = pressuresinglevalue

	@apply
	def propertysource():
		def fget( self ):
			return self._propertysource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument propertysource is mantatory and can not be set to None')
			if not check_type(value,ifcpropertysourceenum):
				self._propertysource = ifcpropertysourceenum(value)
			else:
				self._propertysource = value
		return property(**locals())

	@apply
	def flowconditiontimeseries():
		def fget( self ):
			return self._flowconditiontimeseries
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimeseries):
					self._flowconditiontimeseries = ifctimeseries(value)
				else:
					self._flowconditiontimeseries = value
			else:
				self._flowconditiontimeseries = value
		return property(**locals())

	@apply
	def velocitytimeseries():
		def fget( self ):
			return self._velocitytimeseries
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimeseries):
					self._velocitytimeseries = ifctimeseries(value)
				else:
					self._velocitytimeseries = value
			else:
				self._velocitytimeseries = value
		return property(**locals())

	@apply
	def flowratetimeseries():
		def fget( self ):
			return self._flowratetimeseries
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimeseries):
					self._flowratetimeseries = ifctimeseries(value)
				else:
					self._flowratetimeseries = value
			else:
				self._flowratetimeseries = value
		return property(**locals())

	@apply
	def fluid():
		def fget( self ):
			return self._fluid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fluid is mantatory and can not be set to None')
			if not check_type(value,ifcmaterial):
				self._fluid = ifcmaterial(value)
			else:
				self._fluid = value
		return property(**locals())

	@apply
	def pressuretimeseries():
		def fget( self ):
			return self._pressuretimeseries
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimeseries):
					self._pressuretimeseries = ifctimeseries(value)
				else:
					self._pressuretimeseries = value
			else:
				self._pressuretimeseries = value
		return property(**locals())

	@apply
	def userdefinedpropertysource():
		def fget( self ):
			return self._userdefinedpropertysource
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedpropertysource = ifclabel(value)
				else:
					self._userdefinedpropertysource = value
			else:
				self._userdefinedpropertysource = value
		return property(**locals())

	@apply
	def temperaturesinglevalue():
		def fget( self ):
			return self._temperaturesinglevalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermodynamictemperaturemeasure):
					self._temperaturesinglevalue = ifcthermodynamictemperaturemeasure(value)
				else:
					self._temperaturesinglevalue = value
			else:
				self._temperaturesinglevalue = value
		return property(**locals())

	@apply
	def wetbulbtemperaturesinglevalue():
		def fget( self ):
			return self._wetbulbtemperaturesinglevalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermodynamictemperaturemeasure):
					self._wetbulbtemperaturesinglevalue = ifcthermodynamictemperaturemeasure(value)
				else:
					self._wetbulbtemperaturesinglevalue = value
			else:
				self._wetbulbtemperaturesinglevalue = value
		return property(**locals())

	@apply
	def wetbulbtemperaturetimeseries():
		def fget( self ):
			return self._wetbulbtemperaturetimeseries
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimeseries):
					self._wetbulbtemperaturetimeseries = ifctimeseries(value)
				else:
					self._wetbulbtemperaturetimeseries = value
			else:
				self._wetbulbtemperaturetimeseries = value
		return property(**locals())

	@apply
	def temperaturetimeseries():
		def fget( self ):
			return self._temperaturetimeseries
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimeseries):
					self._temperaturetimeseries = ifctimeseries(value)
				else:
					self._temperaturetimeseries = value
			else:
				self._temperaturetimeseries = value
		return property(**locals())

	@apply
	def flowratesinglevalue():
		def fget( self ):
			return self._flowratesinglevalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcderivedmeasurevalue):
					self._flowratesinglevalue = ifcderivedmeasurevalue(value)
				else:
					self._flowratesinglevalue = value
			else:
				self._flowratesinglevalue = value
		return property(**locals())

	@apply
	def flowconditionsinglevalue():
		def fget( self ):
			return self._flowconditionsinglevalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._flowconditionsinglevalue = ifcpositiveratiomeasure(value)
				else:
					self._flowconditionsinglevalue = value
			else:
				self._flowconditionsinglevalue = value
		return property(**locals())

	@apply
	def velocitysinglevalue():
		def fget( self ):
			return self._velocitysinglevalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearvelocitymeasure):
					self._velocitysinglevalue = ifclinearvelocitymeasure(value)
				else:
					self._velocitysinglevalue = value
			else:
				self._velocitysinglevalue = value
		return property(**locals())

	@apply
	def pressuresinglevalue():
		def fget( self ):
			return self._pressuresinglevalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpressuremeasure):
					self._pressuresinglevalue = ifcpressuremeasure(value)
				else:
					self._pressuresinglevalue = value
			else:
				self._pressuresinglevalue = value
		return property(**locals())

####################
 # ENTITY ifcreinforcingbar #
####################
class ifcreinforcingbar(ifcreinforcingelement):
	'''Entity ifcreinforcingbar definition.

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param crosssectionarea
	:type crosssectionarea:ifcareameasure

	:param barlength
	:type barlength:ifcpositivelengthmeasure

	:param barrole
	:type barrole:ifcreinforcingbarroleenum

	:param barsurface
	:type barsurface:ifcreinforcingbarsurfaceenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , nominaldiameter,crosssectionarea,barlength,barrole,barsurface, ):
		ifcreinforcingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , )
		self.nominaldiameter = nominaldiameter
		self.crosssectionarea = crosssectionarea
		self.barlength = barlength
		self.barrole = barrole
		self.barsurface = barsurface

	@apply
	def nominaldiameter():
		def fget( self ):
			return self._nominaldiameter
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument nominaldiameter is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._nominaldiameter = ifcpositivelengthmeasure(value)
			else:
				self._nominaldiameter = value
		return property(**locals())

	@apply
	def crosssectionarea():
		def fget( self ):
			return self._crosssectionarea
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument crosssectionarea is mantatory and can not be set to None')
			if not check_type(value,ifcareameasure):
				self._crosssectionarea = ifcareameasure(value)
			else:
				self._crosssectionarea = value
		return property(**locals())

	@apply
	def barlength():
		def fget( self ):
			return self._barlength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._barlength = ifcpositivelengthmeasure(value)
				else:
					self._barlength = value
			else:
				self._barlength = value
		return property(**locals())

	@apply
	def barrole():
		def fget( self ):
			return self._barrole
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument barrole is mantatory and can not be set to None')
			if not check_type(value,ifcreinforcingbarroleenum):
				self._barrole = ifcreinforcingbarroleenum(value)
			else:
				self._barrole = value
		return property(**locals())

	@apply
	def barsurface():
		def fget( self ):
			return self._barsurface
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreinforcingbarsurfaceenum):
					self._barsurface = ifcreinforcingbarsurfaceenum(value)
				else:
					self._barsurface = value
			else:
				self._barsurface = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.barrole  !=  ifcreinforcingbarroleenum.self.userdefined)  or  ((self.barrole  ==  ifcreinforcingbarroleenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcpermit #
####################
class ifcpermit(ifccontrol):
	'''Entity ifcpermit definition.

	:param permitid
	:type permitid:ifcidentifier
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , permitid, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.permitid = permitid

	@apply
	def permitid():
		def fget( self ):
			return self._permitid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument permitid is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._permitid = ifcidentifier(value)
			else:
				self._permitid = value
		return property(**locals())

####################
 # ENTITY ifcreferencesvaluedocument #
####################
class ifcreferencesvaluedocument(BaseEntityClass):
	'''Entity ifcreferencesvaluedocument definition.

	:param referenceddocument
	:type referenceddocument:ifcdocumentselect

	:param referencingvalues
	:type referencingvalues:SET(1,None,'ifcappliedvalue', scope = schema_scope)

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext
	'''
	def __init__( self , referenceddocument,referencingvalues,name,description, ):
		self.referenceddocument = referenceddocument
		self.referencingvalues = referencingvalues
		self.name = name
		self.description = description

	@apply
	def referenceddocument():
		def fget( self ):
			return self._referenceddocument
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument referenceddocument is mantatory and can not be set to None')
			if not check_type(value,ifcdocumentselect):
				self._referenceddocument = ifcdocumentselect(value)
			else:
				self._referenceddocument = value
		return property(**locals())

	@apply
	def referencingvalues():
		def fget( self ):
			return self._referencingvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument referencingvalues is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcappliedvalue', scope = schema_scope)):
				self._referencingvalues = SET(value)
			else:
				self._referencingvalues = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY ifcsurfacestyleshading #
####################
class ifcsurfacestyleshading(BaseEntityClass):
	'''Entity ifcsurfacestyleshading definition.

	:param surfacecolour
	:type surfacecolour:ifccolourrgb
	'''
	def __init__( self , surfacecolour, ):
		self.surfacecolour = surfacecolour

	@apply
	def surfacecolour():
		def fget( self ):
			return self._surfacecolour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument surfacecolour is mantatory and can not be set to None')
			if not check_type(value,ifccolourrgb):
				self._surfacecolour = ifccolourrgb(value)
			else:
				self._surfacecolour = value
		return property(**locals())

####################
 # ENTITY ifcsurfacestylerendering #
####################
class ifcsurfacestylerendering(ifcsurfacestyleshading):
	'''Entity ifcsurfacestylerendering definition.

	:param transparency
	:type transparency:ifcnormalisedratiomeasure

	:param diffusecolour
	:type diffusecolour:ifccolourorfactor

	:param transmissioncolour
	:type transmissioncolour:ifccolourorfactor

	:param diffusetransmissioncolour
	:type diffusetransmissioncolour:ifccolourorfactor

	:param reflectioncolour
	:type reflectioncolour:ifccolourorfactor

	:param specularcolour
	:type specularcolour:ifccolourorfactor

	:param specularhighlight
	:type specularhighlight:ifcspecularhighlightselect

	:param reflectancemethod
	:type reflectancemethod:ifcreflectancemethodenum
	'''
	def __init__( self , inherited0__surfacecolour , transparency,diffusecolour,transmissioncolour,diffusetransmissioncolour,reflectioncolour,specularcolour,specularhighlight,reflectancemethod, ):
		ifcsurfacestyleshading.__init__(self , inherited0__surfacecolour , )
		self.transparency = transparency
		self.diffusecolour = diffusecolour
		self.transmissioncolour = transmissioncolour
		self.diffusetransmissioncolour = diffusetransmissioncolour
		self.reflectioncolour = reflectioncolour
		self.specularcolour = specularcolour
		self.specularhighlight = specularhighlight
		self.reflectancemethod = reflectancemethod

	@apply
	def transparency():
		def fget( self ):
			return self._transparency
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._transparency = ifcnormalisedratiomeasure(value)
				else:
					self._transparency = value
			else:
				self._transparency = value
		return property(**locals())

	@apply
	def diffusecolour():
		def fget( self ):
			return self._diffusecolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourorfactor):
					self._diffusecolour = ifccolourorfactor(value)
				else:
					self._diffusecolour = value
			else:
				self._diffusecolour = value
		return property(**locals())

	@apply
	def transmissioncolour():
		def fget( self ):
			return self._transmissioncolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourorfactor):
					self._transmissioncolour = ifccolourorfactor(value)
				else:
					self._transmissioncolour = value
			else:
				self._transmissioncolour = value
		return property(**locals())

	@apply
	def diffusetransmissioncolour():
		def fget( self ):
			return self._diffusetransmissioncolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourorfactor):
					self._diffusetransmissioncolour = ifccolourorfactor(value)
				else:
					self._diffusetransmissioncolour = value
			else:
				self._diffusetransmissioncolour = value
		return property(**locals())

	@apply
	def reflectioncolour():
		def fget( self ):
			return self._reflectioncolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourorfactor):
					self._reflectioncolour = ifccolourorfactor(value)
				else:
					self._reflectioncolour = value
			else:
				self._reflectioncolour = value
		return property(**locals())

	@apply
	def specularcolour():
		def fget( self ):
			return self._specularcolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourorfactor):
					self._specularcolour = ifccolourorfactor(value)
				else:
					self._specularcolour = value
			else:
				self._specularcolour = value
		return property(**locals())

	@apply
	def specularhighlight():
		def fget( self ):
			return self._specularhighlight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcspecularhighlightselect):
					self._specularhighlight = ifcspecularhighlightselect(value)
				else:
					self._specularhighlight = value
			else:
				self._specularhighlight = value
		return property(**locals())

	@apply
	def reflectancemethod():
		def fget( self ):
			return self._reflectancemethod
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reflectancemethod is mantatory and can not be set to None')
			if not check_type(value,ifcreflectancemethodenum):
				self._reflectancemethod = ifcreflectancemethodenum(value)
			else:
				self._reflectancemethod = value
		return property(**locals())

####################
 # ENTITY ifcelectrictimecontroltype #
####################
class ifcelectrictimecontroltype(ifcflowcontrollertype):
	'''Entity ifcelectrictimecontroltype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectrictimecontroltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectrictimecontroltypeenum):
				self._predefinedtype = ifcelectrictimecontroltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcstackterminaltype #
####################
class ifcstackterminaltype(ifcflowterminaltype):
	'''Entity ifcstackterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcstackterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstackterminaltypeenum):
				self._predefinedtype = ifcstackterminaltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcstructuralplanaraction #
####################
class ifcstructuralplanaraction(ifcstructuralaction):
	'''Entity ifcstructuralplanaraction definition.

	:param projectedortrue
	:type projectedortrue:ifcprojectedortruelengthenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__causedby , projectedortrue, ):
		ifcstructuralaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__causedby , )
		self.projectedortrue = projectedortrue

	@apply
	def projectedortrue():
		def fget( self ):
			return self._projectedortrue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument projectedortrue is mantatory and can not be set to None')
			if not check_type(value,ifcprojectedortruelengthenum):
				self._projectedortrue = ifcprojectedortruelengthenum(value)
			else:
				self._projectedortrue = value
		return property(**locals())
	def wr61(self):
		eval_wr61_wr = (SIZEOF(['IFC2X3.IFCSTRUCTURALLOADPLANARFORCE','IFC2X3.IFCSTRUCTURALLOADTEMPERATURE']  *  TYPEOF(self.self.ifcstructuralactivity.self.appliedload))  ==  1)
		if not eval_wr61_wr:
			raise AssertionError('Rule wr61 violated')
		else:
			return eval_wr61_wr


####################
 # ENTITY ifcstructuralplanaractionvarying #
####################
class ifcstructuralplanaractionvarying(ifcstructuralplanaraction):
	'''Entity ifcstructuralplanaractionvarying definition.

	:param varyingappliedloadlocation
	:type varyingappliedloadlocation:ifcshapeaspect

	:param subsequentappliedloads
	:type subsequentappliedloads:LIST(2,None,'ifcstructuralload', scope = schema_scope)

	:param varyingappliedloads
	:type varyingappliedloads:LIST(3,None,'ifcstructuralload', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__causedby , inherited11__projectedortrue , varyingappliedloadlocation,subsequentappliedloads, ):
		ifcstructuralplanaraction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__causedby , inherited11__projectedortrue , )
		self.varyingappliedloadlocation = varyingappliedloadlocation
		self.subsequentappliedloads = subsequentappliedloads

	@apply
	def varyingappliedloadlocation():
		def fget( self ):
			return self._varyingappliedloadlocation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument varyingappliedloadlocation is mantatory and can not be set to None')
			if not check_type(value,ifcshapeaspect):
				self._varyingappliedloadlocation = ifcshapeaspect(value)
			else:
				self._varyingappliedloadlocation = value
		return property(**locals())

	@apply
	def subsequentappliedloads():
		def fget( self ):
			return self._subsequentappliedloads
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument subsequentappliedloads is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'ifcstructuralload', scope = schema_scope)):
				self._subsequentappliedloads = LIST(value)
			else:
				self._subsequentappliedloads = value
		return property(**locals())

	@apply
	def varyingappliedloads():
		def fget( self ):
			attribute_eval = ifcaddtobeginoflist(self.self.ifcstructuralactivity.self.appliedload,self.subsequentappliedloads)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument varyingappliedloads is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcport #
####################
class ifcport(ifcproduct):
	'''Entity ifcport definition.

	:param containedin
	:type containedin:ifcrelconnectsporttoelement

	:param connectedfrom
	:type connectedfrom:SET(0,1,'ifcrelconnectsports', scope = schema_scope)

	:param connectedto
	:type connectedto:SET(0,1,'ifcrelconnectsports', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation ,  ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )

	@apply
	def containedin():
		def fget( self ):
			return self._containedin
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument containedin is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def connectedfrom():
		def fget( self ):
			return self._connectedfrom
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectedfrom is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def connectedto():
		def fget( self ):
			return self._connectedto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument connectedto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcchillertype #
####################
class ifcchillertype(ifcenergyconversiondevicetype):
	'''Entity ifcchillertype definition.

	:param predefinedtype
	:type predefinedtype:ifcchillertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcchillertypeenum):
				self._predefinedtype = ifcchillertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcchillertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcchillertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifccooledbeamtype #
####################
class ifccooledbeamtype(ifcenergyconversiondevicetype):
	'''Entity ifccooledbeamtype definition.

	:param predefinedtype
	:type predefinedtype:ifccooledbeamtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccooledbeamtypeenum):
				self._predefinedtype = ifccooledbeamtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifccooledbeamtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccooledbeamtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifccranerailfshapeprofiledef #
####################
class ifccranerailfshapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifccranerailfshapeprofiledef definition.

	:param overallheight
	:type overallheight:ifcpositivelengthmeasure

	:param headwidth
	:type headwidth:ifcpositivelengthmeasure

	:param radius
	:type radius:ifcpositivelengthmeasure

	:param headdepth2
	:type headdepth2:ifcpositivelengthmeasure

	:param headdepth3
	:type headdepth3:ifcpositivelengthmeasure

	:param webthickness
	:type webthickness:ifcpositivelengthmeasure

	:param basedepth1
	:type basedepth1:ifcpositivelengthmeasure

	:param basedepth2
	:type basedepth2:ifcpositivelengthmeasure

	:param centreofgravityiny
	:type centreofgravityiny:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , overallheight,headwidth,radius,headdepth2,headdepth3,webthickness,basedepth1,basedepth2,centreofgravityiny, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.overallheight = overallheight
		self.headwidth = headwidth
		self.radius = radius
		self.headdepth2 = headdepth2
		self.headdepth3 = headdepth3
		self.webthickness = webthickness
		self.basedepth1 = basedepth1
		self.basedepth2 = basedepth2
		self.centreofgravityiny = centreofgravityiny

	@apply
	def overallheight():
		def fget( self ):
			return self._overallheight
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument overallheight is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._overallheight = ifcpositivelengthmeasure(value)
			else:
				self._overallheight = value
		return property(**locals())

	@apply
	def headwidth():
		def fget( self ):
			return self._headwidth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument headwidth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._headwidth = ifcpositivelengthmeasure(value)
			else:
				self._headwidth = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._radius = ifcpositivelengthmeasure(value)
				else:
					self._radius = value
			else:
				self._radius = value
		return property(**locals())

	@apply
	def headdepth2():
		def fget( self ):
			return self._headdepth2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument headdepth2 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._headdepth2 = ifcpositivelengthmeasure(value)
			else:
				self._headdepth2 = value
		return property(**locals())

	@apply
	def headdepth3():
		def fget( self ):
			return self._headdepth3
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument headdepth3 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._headdepth3 = ifcpositivelengthmeasure(value)
			else:
				self._headdepth3 = value
		return property(**locals())

	@apply
	def webthickness():
		def fget( self ):
			return self._webthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument webthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._webthickness = ifcpositivelengthmeasure(value)
			else:
				self._webthickness = value
		return property(**locals())

	@apply
	def basedepth1():
		def fget( self ):
			return self._basedepth1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basedepth1 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._basedepth1 = ifcpositivelengthmeasure(value)
			else:
				self._basedepth1 = value
		return property(**locals())

	@apply
	def basedepth2():
		def fget( self ):
			return self._basedepth2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basedepth2 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._basedepth2 = ifcpositivelengthmeasure(value)
			else:
				self._basedepth2 = value
		return property(**locals())

	@apply
	def centreofgravityiny():
		def fget( self ):
			return self._centreofgravityiny
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._centreofgravityiny = ifcpositivelengthmeasure(value)
				else:
					self._centreofgravityiny = value
			else:
				self._centreofgravityiny = value
		return property(**locals())

####################
 # ENTITY ifcpersonandorganization #
####################
class ifcpersonandorganization(BaseEntityClass):
	'''Entity ifcpersonandorganization definition.

	:param theperson
	:type theperson:ifcperson

	:param theorganization
	:type theorganization:ifcorganization

	:param roles
	:type roles:LIST(1,None,'ifcactorrole', scope = schema_scope)
	'''
	def __init__( self , theperson,theorganization,roles, ):
		self.theperson = theperson
		self.theorganization = theorganization
		self.roles = roles

	@apply
	def theperson():
		def fget( self ):
			return self._theperson
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument theperson is mantatory and can not be set to None')
			if not check_type(value,ifcperson):
				self._theperson = ifcperson(value)
			else:
				self._theperson = value
		return property(**locals())

	@apply
	def theorganization():
		def fget( self ):
			return self._theorganization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument theorganization is mantatory and can not be set to None')
			if not check_type(value,ifcorganization):
				self._theorganization = ifcorganization(value)
			else:
				self._theorganization = value
		return property(**locals())

	@apply
	def roles():
		def fget( self ):
			return self._roles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcactorrole', scope = schema_scope)):
					self._roles = LIST(value)
				else:
					self._roles = value
			else:
				self._roles = value
		return property(**locals())

####################
 # ENTITY ifcpostaladdress #
####################
class ifcpostaladdress(ifcaddress):
	'''Entity ifcpostaladdress definition.

	:param internallocation
	:type internallocation:ifclabel

	:param addresslines
	:type addresslines:LIST(1,None,'STRING', scope = schema_scope)

	:param postalbox
	:type postalbox:ifclabel

	:param town
	:type town:ifclabel

	:param region
	:type region:ifclabel

	:param postalcode
	:type postalcode:ifclabel

	:param country
	:type country:ifclabel
	'''
	def __init__( self , inherited0__purpose , inherited1__description , inherited2__userdefinedpurpose , internallocation,addresslines,postalbox,town,region,postalcode,country, ):
		ifcaddress.__init__(self , inherited0__purpose , inherited1__description , inherited2__userdefinedpurpose , )
		self.internallocation = internallocation
		self.addresslines = addresslines
		self.postalbox = postalbox
		self.town = town
		self.region = region
		self.postalcode = postalcode
		self.country = country

	@apply
	def internallocation():
		def fget( self ):
			return self._internallocation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._internallocation = ifclabel(value)
				else:
					self._internallocation = value
			else:
				self._internallocation = value
		return property(**locals())

	@apply
	def addresslines():
		def fget( self ):
			return self._addresslines
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._addresslines = LIST(value)
				else:
					self._addresslines = value
			else:
				self._addresslines = value
		return property(**locals())

	@apply
	def postalbox():
		def fget( self ):
			return self._postalbox
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._postalbox = ifclabel(value)
				else:
					self._postalbox = value
			else:
				self._postalbox = value
		return property(**locals())

	@apply
	def town():
		def fget( self ):
			return self._town
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._town = ifclabel(value)
				else:
					self._town = value
			else:
				self._town = value
		return property(**locals())

	@apply
	def region():
		def fget( self ):
			return self._region
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._region = ifclabel(value)
				else:
					self._region = value
			else:
				self._region = value
		return property(**locals())

	@apply
	def postalcode():
		def fget( self ):
			return self._postalcode
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._postalcode = ifclabel(value)
				else:
					self._postalcode = value
			else:
				self._postalcode = value
		return property(**locals())

	@apply
	def country():
		def fget( self ):
			return self._country
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._country = ifclabel(value)
				else:
					self._country = value
			else:
				self._country = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((((((EXISTS(self.internallocation)  or  EXISTS(self.addresslines))  or  EXISTS(self.postalbox))  or  EXISTS(self.postalcode))  or  EXISTS(self.town))  or  EXISTS(self.region))  or  EXISTS(self.country))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifccondition #
####################
class ifccondition(ifcgroup):
	'''Entity ifccondition definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )

####################
 # ENTITY ifcmappeditem #
####################
class ifcmappeditem(ifcrepresentationitem):
	'''Entity ifcmappeditem definition.

	:param mappingsource
	:type mappingsource:ifcrepresentationmap

	:param mappingtarget
	:type mappingtarget:ifccartesiantransformationoperator
	'''
	def __init__( self , mappingsource,mappingtarget, ):
		ifcrepresentationitem.__init__(self , )
		self.mappingsource = mappingsource
		self.mappingtarget = mappingtarget

	@apply
	def mappingsource():
		def fget( self ):
			return self._mappingsource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mappingsource is mantatory and can not be set to None')
			if not check_type(value,ifcrepresentationmap):
				self._mappingsource = ifcrepresentationmap(value)
			else:
				self._mappingsource = value
		return property(**locals())

	@apply
	def mappingtarget():
		def fget( self ):
			return self._mappingtarget
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mappingtarget is mantatory and can not be set to None')
			if not check_type(value,ifccartesiantransformationoperator):
				self._mappingtarget = ifccartesiantransformationoperator(value)
			else:
				self._mappingtarget = value
		return property(**locals())

####################
 # ENTITY ifcmove #
####################
class ifcmove(ifctask):
	'''Entity ifcmove definition.

	:param movefrom
	:type movefrom:ifcspatialstructureelement

	:param moveto
	:type moveto:ifcspatialstructureelement

	:param punchlist
	:type punchlist:LIST(1,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__taskid , inherited6__status , inherited7__workmethod , inherited8__ismilestone , inherited9__priority , movefrom,moveto,punchlist, ):
		ifctask.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__taskid , inherited6__status , inherited7__workmethod , inherited8__ismilestone , inherited9__priority , )
		self.movefrom = movefrom
		self.moveto = moveto
		self.punchlist = punchlist

	@apply
	def movefrom():
		def fget( self ):
			return self._movefrom
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument movefrom is mantatory and can not be set to None')
			if not check_type(value,ifcspatialstructureelement):
				self._movefrom = ifcspatialstructureelement(value)
			else:
				self._movefrom = value
		return property(**locals())

	@apply
	def moveto():
		def fget( self ):
			return self._moveto
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument moveto is mantatory and can not be set to None')
			if not check_type(value,ifcspatialstructureelement):
				self._moveto = ifcspatialstructureelement(value)
			else:
				self._moveto = value
		return property(**locals())

	@apply
	def punchlist():
		def fget( self ):
			return self._punchlist
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._punchlist = LIST(value)
				else:
					self._punchlist = value
			else:
				self._punchlist = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.ifcprocess.self.operateson)  >=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcoutlettype #
####################
class ifcoutlettype(ifcflowterminaltype):
	'''Entity ifcoutlettype definition.

	:param predefinedtype
	:type predefinedtype:ifcoutlettypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcoutlettypeenum):
				self._predefinedtype = ifcoutlettypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcconstraintclassificationrelationship #
####################
class ifcconstraintclassificationrelationship(BaseEntityClass):
	'''Entity ifcconstraintclassificationrelationship definition.

	:param classifiedconstraint
	:type classifiedconstraint:ifcconstraint

	:param relatedclassifications
	:type relatedclassifications:SET(1,None,'ifcclassificationnotationselect', scope = schema_scope)
	'''
	def __init__( self , classifiedconstraint,relatedclassifications, ):
		self.classifiedconstraint = classifiedconstraint
		self.relatedclassifications = relatedclassifications

	@apply
	def classifiedconstraint():
		def fget( self ):
			return self._classifiedconstraint
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument classifiedconstraint is mantatory and can not be set to None')
			if not check_type(value,ifcconstraint):
				self._classifiedconstraint = ifcconstraint(value)
			else:
				self._classifiedconstraint = value
		return property(**locals())

	@apply
	def relatedclassifications():
		def fget( self ):
			return self._relatedclassifications
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedclassifications is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcclassificationnotationselect', scope = schema_scope)):
				self._relatedclassifications = SET(value)
			else:
				self._relatedclassifications = value
		return property(**locals())

####################
 # ENTITY ifcgeneralmaterialproperties #
####################
class ifcgeneralmaterialproperties(ifcmaterialproperties):
	'''Entity ifcgeneralmaterialproperties definition.

	:param molecularweight
	:type molecularweight:ifcmolecularweightmeasure

	:param porosity
	:type porosity:ifcnormalisedratiomeasure

	:param massdensity
	:type massdensity:ifcmassdensitymeasure
	'''
	def __init__( self , inherited0__material , molecularweight,porosity,massdensity, ):
		ifcmaterialproperties.__init__(self , inherited0__material , )
		self.molecularweight = molecularweight
		self.porosity = porosity
		self.massdensity = massdensity

	@apply
	def molecularweight():
		def fget( self ):
			return self._molecularweight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmolecularweightmeasure):
					self._molecularweight = ifcmolecularweightmeasure(value)
				else:
					self._molecularweight = value
			else:
				self._molecularweight = value
		return property(**locals())

	@apply
	def porosity():
		def fget( self ):
			return self._porosity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._porosity = ifcnormalisedratiomeasure(value)
				else:
					self._porosity = value
			else:
				self._porosity = value
		return property(**locals())

	@apply
	def massdensity():
		def fget( self ):
			return self._massdensity
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmassdensitymeasure):
					self._massdensity = ifcmassdensitymeasure(value)
				else:
					self._massdensity = value
			else:
				self._massdensity = value
		return property(**locals())

####################
 # ENTITY ifcannotationsymboloccurrence #
####################
class ifcannotationsymboloccurrence(ifcannotationoccurrence):
	'''Entity ifcannotationsymboloccurrence definition.
	'''
	def __init__( self , inherited0__item , inherited1__styles , inherited2__name ,  ):
		ifcannotationoccurrence.__init__(self , inherited0__item , inherited1__styles , inherited2__name , )
	def wr31(self):
		eval_wr31_wr = (( not EXISTS(self.self.ifcstyleditem.self.item))  or  ('IFC2X3.IFCDEFINEDSYMBOL'  ==  TYPEOF(self.self.ifcstyleditem.self.item)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcterminatorsymbol #
####################
class ifcterminatorsymbol(ifcannotationsymboloccurrence):
	'''Entity ifcterminatorsymbol definition.

	:param annotatedcurve
	:type annotatedcurve:ifcannotationcurveoccurrence
	'''
	def __init__( self , inherited0__item , inherited1__styles , inherited2__name , annotatedcurve, ):
		ifcannotationsymboloccurrence.__init__(self , inherited0__item , inherited1__styles , inherited2__name , )
		self.annotatedcurve = annotatedcurve

	@apply
	def annotatedcurve():
		def fget( self ):
			return self._annotatedcurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument annotatedcurve is mantatory and can not be set to None')
			if not check_type(value,ifcannotationcurveoccurrence):
				self._annotatedcurve = ifcannotationcurveoccurrence(value)
			else:
				self._annotatedcurve = value
		return property(**locals())

####################
 # ENTITY ifcconstraintrelationship #
####################
class ifcconstraintrelationship(BaseEntityClass):
	'''Entity ifcconstraintrelationship definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param relatingconstraint
	:type relatingconstraint:ifcconstraint

	:param relatedconstraints
	:type relatedconstraints:SET(1,None,'ifcconstraint', scope = schema_scope)
	'''
	def __init__( self , name,description,relatingconstraint,relatedconstraints, ):
		self.name = name
		self.description = description
		self.relatingconstraint = relatingconstraint
		self.relatedconstraints = relatedconstraints

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relatingconstraint():
		def fget( self ):
			return self._relatingconstraint
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingconstraint is mantatory and can not be set to None')
			if not check_type(value,ifcconstraint):
				self._relatingconstraint = ifcconstraint(value)
			else:
				self._relatingconstraint = value
		return property(**locals())

	@apply
	def relatedconstraints():
		def fget( self ):
			return self._relatedconstraints
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedconstraints is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcconstraint', scope = schema_scope)):
				self._relatedconstraints = SET(value)
			else:
				self._relatedconstraints = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcpointoncurve #
####################
class ifcpointoncurve(ifcpoint):
	'''Entity ifcpointoncurve definition.

	:param basiscurve
	:type basiscurve:ifccurve

	:param pointparameter
	:type pointparameter:ifcparametervalue

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , basiscurve,pointparameter, ):
		ifcpoint.__init__(self , )
		self.basiscurve = basiscurve
		self.pointparameter = pointparameter

	@apply
	def basiscurve():
		def fget( self ):
			return self._basiscurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basiscurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._basiscurve = ifccurve(value)
			else:
				self._basiscurve = value
		return property(**locals())

	@apply
	def pointparameter():
		def fget( self ):
			return self._pointparameter
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pointparameter is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._pointparameter = ifcparametervalue(value)
			else:
				self._pointparameter = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.basiscurve.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcrelsequence #
####################
class ifcrelsequence(ifcrelconnects):
	'''Entity ifcrelsequence definition.

	:param relatingprocess
	:type relatingprocess:ifcprocess

	:param relatedprocess
	:type relatedprocess:ifcprocess

	:param timelag
	:type timelag:ifctimemeasure

	:param sequencetype
	:type sequencetype:ifcsequenceenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingprocess,relatedprocess,timelag,sequencetype, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingprocess = relatingprocess
		self.relatedprocess = relatedprocess
		self.timelag = timelag
		self.sequencetype = sequencetype

	@apply
	def relatingprocess():
		def fget( self ):
			return self._relatingprocess
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingprocess is mantatory and can not be set to None')
			if not check_type(value,ifcprocess):
				self._relatingprocess = ifcprocess(value)
			else:
				self._relatingprocess = value
		return property(**locals())

	@apply
	def relatedprocess():
		def fget( self ):
			return self._relatedprocess
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedprocess is mantatory and can not be set to None')
			if not check_type(value,ifcprocess):
				self._relatedprocess = ifcprocess(value)
			else:
				self._relatedprocess = value
		return property(**locals())

	@apply
	def timelag():
		def fget( self ):
			return self._timelag
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timelag is mantatory and can not be set to None')
			if not check_type(value,ifctimemeasure):
				self._timelag = ifctimemeasure(value)
			else:
				self._timelag = value
		return property(**locals())

	@apply
	def sequencetype():
		def fget( self ):
			return self._sequencetype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sequencetype is mantatory and can not be set to None')
			if not check_type(value,ifcsequenceenum):
				self._sequencetype = ifcsequenceenum(value)
			else:
				self._sequencetype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.relatingprocess  !=  self.relatedprocess)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcfacetedbrepwithvoids #
####################
class ifcfacetedbrepwithvoids(ifcmanifoldsolidbrep):
	'''Entity ifcfacetedbrepwithvoids definition.

	:param voids
	:type voids:SET(1,None,'ifcclosedshell', scope = schema_scope)
	'''
	def __init__( self , inherited0__outer , voids, ):
		ifcmanifoldsolidbrep.__init__(self , inherited0__outer , )
		self.voids = voids

	@apply
	def voids():
		def fget( self ):
			return self._voids
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument voids is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcclosedshell', scope = schema_scope)):
				self._voids = SET(value)
			else:
				self._voids = value
		return property(**locals())

####################
 # ENTITY ifcrelassignstasks #
####################
class ifcrelassignstasks(ifcrelassignstocontrol):
	'''Entity ifcrelassignstasks definition.

	:param timefortask
	:type timefortask:ifcscheduletimecontrol
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , inherited6__relatingcontrol , timefortask, ):
		ifcrelassignstocontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , inherited6__relatingcontrol , )
		self.timefortask = timefortask

	@apply
	def timefortask():
		def fget( self ):
			return self._timefortask
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcscheduletimecontrol):
					self._timefortask = ifcscheduletimecontrol(value)
				else:
					self._timefortask = value
			else:
				self._timefortask = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (HIINDEX(self.self.ifcrelassigns.self.relatedobjects)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('IFC2X3.IFCTASK'  ==  TYPEOF(self.self.ifcrelassigns.self.relatedobjects[1]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ('IFC2X3.IFCWORKCONTROL'  ==  TYPEOF(self.self.ifcrelassignstocontrol.self.relatingcontrol))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifccoiltype #
####################
class ifccoiltype(ifcenergyconversiondevicetype):
	'''Entity ifccoiltype definition.

	:param predefinedtype
	:type predefinedtype:ifccoiltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccoiltypeenum):
				self._predefinedtype = ifccoiltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifccoiltypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccoiltypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcfurnishingelement #
####################
class ifcfurnishingelement(ifcelement):
	'''Entity ifcfurnishingelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcrelconnectsstructuralmember #
####################
class ifcrelconnectsstructuralmember(ifcrelconnects):
	'''Entity ifcrelconnectsstructuralmember definition.

	:param relatingstructuralmember
	:type relatingstructuralmember:ifcstructuralmember

	:param relatedstructuralconnection
	:type relatedstructuralconnection:ifcstructuralconnection

	:param appliedcondition
	:type appliedcondition:ifcboundarycondition

	:param additionalconditions
	:type additionalconditions:ifcstructuralconnectioncondition

	:param supportedlength
	:type supportedlength:ifclengthmeasure

	:param conditioncoordinatesystem
	:type conditioncoordinatesystem:ifcaxis2placement3d
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingstructuralmember,relatedstructuralconnection,appliedcondition,additionalconditions,supportedlength,conditioncoordinatesystem, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingstructuralmember = relatingstructuralmember
		self.relatedstructuralconnection = relatedstructuralconnection
		self.appliedcondition = appliedcondition
		self.additionalconditions = additionalconditions
		self.supportedlength = supportedlength
		self.conditioncoordinatesystem = conditioncoordinatesystem

	@apply
	def relatingstructuralmember():
		def fget( self ):
			return self._relatingstructuralmember
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingstructuralmember is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralmember):
				self._relatingstructuralmember = ifcstructuralmember(value)
			else:
				self._relatingstructuralmember = value
		return property(**locals())

	@apply
	def relatedstructuralconnection():
		def fget( self ):
			return self._relatedstructuralconnection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedstructuralconnection is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralconnection):
				self._relatedstructuralconnection = ifcstructuralconnection(value)
			else:
				self._relatedstructuralconnection = value
		return property(**locals())

	@apply
	def appliedcondition():
		def fget( self ):
			return self._appliedcondition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcboundarycondition):
					self._appliedcondition = ifcboundarycondition(value)
				else:
					self._appliedcondition = value
			else:
				self._appliedcondition = value
		return property(**locals())

	@apply
	def additionalconditions():
		def fget( self ):
			return self._additionalconditions
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcstructuralconnectioncondition):
					self._additionalconditions = ifcstructuralconnectioncondition(value)
				else:
					self._additionalconditions = value
			else:
				self._additionalconditions = value
		return property(**locals())

	@apply
	def supportedlength():
		def fget( self ):
			return self._supportedlength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._supportedlength = ifclengthmeasure(value)
				else:
					self._supportedlength = value
			else:
				self._supportedlength = value
		return property(**locals())

	@apply
	def conditioncoordinatesystem():
		def fget( self ):
			return self._conditioncoordinatesystem
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaxis2placement3d):
					self._conditioncoordinatesystem = ifcaxis2placement3d(value)
				else:
					self._conditioncoordinatesystem = value
			else:
				self._conditioncoordinatesystem = value
		return property(**locals())

####################
 # ENTITY ifcrelconnectswitheccentricity #
####################
class ifcrelconnectswitheccentricity(ifcrelconnectsstructuralmember):
	'''Entity ifcrelconnectswitheccentricity definition.

	:param connectionconstraint
	:type connectionconstraint:ifcconnectiongeometry
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingstructuralmember , inherited5__relatedstructuralconnection , inherited6__appliedcondition , inherited7__additionalconditions , inherited8__supportedlength , inherited9__conditioncoordinatesystem , connectionconstraint, ):
		ifcrelconnectsstructuralmember.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatingstructuralmember , inherited5__relatedstructuralconnection , inherited6__appliedcondition , inherited7__additionalconditions , inherited8__supportedlength , inherited9__conditioncoordinatesystem , )
		self.connectionconstraint = connectionconstraint

	@apply
	def connectionconstraint():
		def fget( self ):
			return self._connectionconstraint
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument connectionconstraint is mantatory and can not be set to None')
			if not check_type(value,ifcconnectiongeometry):
				self._connectionconstraint = ifcconnectiongeometry(value)
			else:
				self._connectionconstraint = value
		return property(**locals())

####################
 # ENTITY ifcrelfillselement #
####################
class ifcrelfillselement(ifcrelconnects):
	'''Entity ifcrelfillselement definition.

	:param relatingopeningelement
	:type relatingopeningelement:ifcopeningelement

	:param relatedbuildingelement
	:type relatedbuildingelement:ifcelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingopeningelement,relatedbuildingelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingopeningelement = relatingopeningelement
		self.relatedbuildingelement = relatedbuildingelement

	@apply
	def relatingopeningelement():
		def fget( self ):
			return self._relatingopeningelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingopeningelement is mantatory and can not be set to None')
			if not check_type(value,ifcopeningelement):
				self._relatingopeningelement = ifcopeningelement(value)
			else:
				self._relatingopeningelement = value
		return property(**locals())

	@apply
	def relatedbuildingelement():
		def fget( self ):
			return self._relatedbuildingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedbuildingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatedbuildingelement = ifcelement(value)
			else:
				self._relatedbuildingelement = value
		return property(**locals())

####################
 # ENTITY ifcrepresentationmap #
####################
class ifcrepresentationmap(BaseEntityClass):
	'''Entity ifcrepresentationmap definition.

	:param mappingorigin
	:type mappingorigin:ifcaxis2placement

	:param mappedrepresentation
	:type mappedrepresentation:ifcrepresentation

	:param mapusage
	:type mapusage:SET(0,None,'ifcmappeditem', scope = schema_scope)
	'''
	def __init__( self , mappingorigin,mappedrepresentation, ):
		self.mappingorigin = mappingorigin
		self.mappedrepresentation = mappedrepresentation

	@apply
	def mappingorigin():
		def fget( self ):
			return self._mappingorigin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mappingorigin is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._mappingorigin = ifcaxis2placement(value)
			else:
				self._mappingorigin = value
		return property(**locals())

	@apply
	def mappedrepresentation():
		def fget( self ):
			return self._mappedrepresentation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mappedrepresentation is mantatory and can not be set to None')
			if not check_type(value,ifcrepresentation):
				self._mappedrepresentation = ifcrepresentation(value)
			else:
				self._mappedrepresentation = value
		return property(**locals())

	@apply
	def mapusage():
		def fget( self ):
			return self._mapusage
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument mapusage is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstructurallinearaction #
####################
class ifcstructurallinearaction(ifcstructuralaction):
	'''Entity ifcstructurallinearaction definition.

	:param projectedortrue
	:type projectedortrue:ifcprojectedortruelengthenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__causedby , projectedortrue, ):
		ifcstructuralaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__causedby , )
		self.projectedortrue = projectedortrue

	@apply
	def projectedortrue():
		def fget( self ):
			return self._projectedortrue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument projectedortrue is mantatory and can not be set to None')
			if not check_type(value,ifcprojectedortruelengthenum):
				self._projectedortrue = ifcprojectedortruelengthenum(value)
			else:
				self._projectedortrue = value
		return property(**locals())
	def wr61(self):
		eval_wr61_wr = (SIZEOF(['IFC2X3.IFCSTRUCTURALLOADLINEARFORCE','IFC2X3.IFCSTRUCTURALLOADTEMPERATURE']  *  TYPEOF(self.self.ifcstructuralactivity.self.appliedload))  ==  1)
		if not eval_wr61_wr:
			raise AssertionError('Rule wr61 violated')
		else:
			return eval_wr61_wr


####################
 # ENTITY ifcstructurallinearactionvarying #
####################
class ifcstructurallinearactionvarying(ifcstructurallinearaction):
	'''Entity ifcstructurallinearactionvarying definition.

	:param varyingappliedloadlocation
	:type varyingappliedloadlocation:ifcshapeaspect

	:param subsequentappliedloads
	:type subsequentappliedloads:LIST(1,None,'ifcstructuralload', scope = schema_scope)

	:param varyingappliedloads
	:type varyingappliedloads:LIST(2,None,'ifcstructuralload', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__causedby , inherited11__projectedortrue , varyingappliedloadlocation,subsequentappliedloads, ):
		ifcstructurallinearaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__causedby , inherited11__projectedortrue , )
		self.varyingappliedloadlocation = varyingappliedloadlocation
		self.subsequentappliedloads = subsequentappliedloads

	@apply
	def varyingappliedloadlocation():
		def fget( self ):
			return self._varyingappliedloadlocation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument varyingappliedloadlocation is mantatory and can not be set to None')
			if not check_type(value,ifcshapeaspect):
				self._varyingappliedloadlocation = ifcshapeaspect(value)
			else:
				self._varyingappliedloadlocation = value
		return property(**locals())

	@apply
	def subsequentappliedloads():
		def fget( self ):
			return self._subsequentappliedloads
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument subsequentappliedloads is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcstructuralload', scope = schema_scope)):
				self._subsequentappliedloads = LIST(value)
			else:
				self._subsequentappliedloads = value
		return property(**locals())

	@apply
	def varyingappliedloads():
		def fget( self ):
			attribute_eval = ifcaddtobeginoflist(self.self.ifcstructuralactivity.self.appliedload,self.subsequentappliedloads)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument varyingappliedloads is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcflowcontroller #
####################
class ifcflowcontroller(ifcdistributionflowelement):
	'''Entity ifcflowcontroller definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcvirtualgridintersection #
####################
class ifcvirtualgridintersection(BaseEntityClass):
	'''Entity ifcvirtualgridintersection definition.

	:param intersectingaxes
	:type intersectingaxes:LIST(2,2,'ifcgridaxis', scope = schema_scope)

	:param offsetdistances
	:type offsetdistances:LIST(2,3,'REAL', scope = schema_scope)
	'''
	def __init__( self , intersectingaxes,offsetdistances, ):
		self.intersectingaxes = intersectingaxes
		self.offsetdistances = offsetdistances

	@apply
	def intersectingaxes():
		def fget( self ):
			return self._intersectingaxes
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument intersectingaxes is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'ifcgridaxis', scope = schema_scope)):
				self._intersectingaxes = LIST(value)
			else:
				self._intersectingaxes = value
		return property(**locals())

	@apply
	def offsetdistances():
		def fget( self ):
			return self._offsetdistances
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offsetdistances is mantatory and can not be set to None')
			if not check_type(value,LIST(2,3,'REAL', scope = schema_scope)):
				self._offsetdistances = LIST(value)
			else:
				self._offsetdistances = value
		return property(**locals())

####################
 # ENTITY ifclightsourceambient #
####################
class ifclightsourceambient(ifclightsource):
	'''Entity ifclightsourceambient definition.
	'''
	def __init__( self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity ,  ):
		ifclightsource.__init__(self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , )

####################
 # ENTITY ifcrelreferencedinspatialstructure #
####################
class ifcrelreferencedinspatialstructure(ifcrelconnects):
	'''Entity ifcrelreferencedinspatialstructure definition.

	:param relatedelements
	:type relatedelements:SET(1,None,'ifcproduct', scope = schema_scope)

	:param relatingstructure
	:type relatingstructure:ifcspatialstructureelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedelements,relatingstructure, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedelements = relatedelements
		self.relatingstructure = relatingstructure

	@apply
	def relatedelements():
		def fget( self ):
			return self._relatedelements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedelements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproduct', scope = schema_scope)):
				self._relatedelements = SET(value)
			else:
				self._relatedelements = value
		return property(**locals())

	@apply
	def relatingstructure():
		def fget( self ):
			return self._relatingstructure
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingstructure is mantatory and can not be set to None')
			if not check_type(value,ifcspatialstructureelement):
				self._relatingstructure = ifcspatialstructureelement(value)
			else:
				self._relatingstructure = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (SIZEOF(None)  ==  0)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifccostvalue #
####################
class ifccostvalue(ifcappliedvalue):
	'''Entity ifccostvalue definition.

	:param costtype
	:type costtype:ifclabel

	:param condition
	:type condition:ifctext
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__appliedvalue , inherited3__unitbasis , inherited4__applicabledate , inherited5__fixeduntildate , costtype,condition, ):
		ifcappliedvalue.__init__(self , inherited0__name , inherited1__description , inherited2__appliedvalue , inherited3__unitbasis , inherited4__applicabledate , inherited5__fixeduntildate , )
		self.costtype = costtype
		self.condition = condition

	@apply
	def costtype():
		def fget( self ):
			return self._costtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument costtype is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._costtype = ifclabel(value)
			else:
				self._costtype = value
		return property(**locals())

	@apply
	def condition():
		def fget( self ):
			return self._condition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._condition = ifctext(value)
				else:
					self._condition = value
			else:
				self._condition = value
		return property(**locals())

####################
 # ENTITY ifcflowmovingdevice #
####################
class ifcflowmovingdevice(ifcdistributionflowelement):
	'''Entity ifcflowmovingdevice definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifctwodirectionrepeatfactor #
####################
class ifctwodirectionrepeatfactor(ifconedirectionrepeatfactor):
	'''Entity ifctwodirectionrepeatfactor definition.

	:param secondrepeatfactor
	:type secondrepeatfactor:ifcvector
	'''
	def __init__( self , inherited0__repeatfactor , secondrepeatfactor, ):
		ifconedirectionrepeatfactor.__init__(self , inherited0__repeatfactor , )
		self.secondrepeatfactor = secondrepeatfactor

	@apply
	def secondrepeatfactor():
		def fget( self ):
			return self._secondrepeatfactor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument secondrepeatfactor is mantatory and can not be set to None')
			if not check_type(value,ifcvector):
				self._secondrepeatfactor = ifcvector(value)
			else:
				self._secondrepeatfactor = value
		return property(**locals())

####################
 # ENTITY ifcimagetexture #
####################
class ifcimagetexture(ifcsurfacetexture):
	'''Entity ifcimagetexture definition.

	:param urlreference
	:type urlreference:ifcidentifier
	'''
	def __init__( self , inherited0__repeats , inherited1__repeatt , inherited2__texturetype , inherited3__texturetransform , urlreference, ):
		ifcsurfacetexture.__init__(self , inherited0__repeats , inherited1__repeatt , inherited2__texturetype , inherited3__texturetransform , )
		self.urlreference = urlreference

	@apply
	def urlreference():
		def fget( self ):
			return self._urlreference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument urlreference is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._urlreference = ifcidentifier(value)
			else:
				self._urlreference = value
		return property(**locals())

####################
 # ENTITY ifcloop #
####################
class ifcloop(ifctopologicalrepresentationitem):
	'''Entity ifcloop definition.
	'''
	def __init__( self ,  ):
		ifctopologicalrepresentationitem.__init__(self , )

####################
 # ENTITY ifcvertexloop #
####################
class ifcvertexloop(ifcloop):
	'''Entity ifcvertexloop definition.

	:param loopvertex
	:type loopvertex:ifcvertex
	'''
	def __init__( self , loopvertex, ):
		ifcloop.__init__(self , )
		self.loopvertex = loopvertex

	@apply
	def loopvertex():
		def fget( self ):
			return self._loopvertex
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument loopvertex is mantatory and can not be set to None')
			if not check_type(value,ifcvertex):
				self._loopvertex = ifcvertex(value)
			else:
				self._loopvertex = value
		return property(**locals())

####################
 # ENTITY ifcarbitraryclosedprofiledef #
####################
class ifcarbitraryclosedprofiledef(ifcprofiledef):
	'''Entity ifcarbitraryclosedprofiledef definition.

	:param outercurve
	:type outercurve:ifccurve
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , outercurve, ):
		ifcprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , )
		self.outercurve = outercurve

	@apply
	def outercurve():
		def fget( self ):
			return self._outercurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outercurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._outercurve = ifccurve(value)
			else:
				self._outercurve = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.outercurve.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not ('IFC2X3.IFCLINE'  ==  TYPEOF(self.outercurve)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ( not ('IFC2X3.IFCOFFSETCURVE2D'  ==  TYPEOF(self.outercurve)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcarbitraryprofiledefwithvoids #
####################
class ifcarbitraryprofiledefwithvoids(ifcarbitraryclosedprofiledef):
	'''Entity ifcarbitraryprofiledefwithvoids definition.

	:param innercurves
	:type innercurves:SET(1,None,'ifccurve', scope = schema_scope)
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__outercurve , innercurves, ):
		ifcarbitraryclosedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__outercurve , )
		self.innercurves = innercurves

	@apply
	def innercurves():
		def fget( self ):
			return self._innercurves
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument innercurves is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifccurve', scope = schema_scope)):
				self._innercurves = SET(value)
			else:
				self._innercurves = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.ifcprofiledef.self.profiletype  ==  area)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcsanitaryterminaltype #
####################
class ifcsanitaryterminaltype(ifcflowterminaltype):
	'''Entity ifcsanitaryterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcsanitaryterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcsanitaryterminaltypeenum):
				self._predefinedtype = ifcsanitaryterminaltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcswitchingdevicetype #
####################
class ifcswitchingdevicetype(ifcflowcontrollertype):
	'''Entity ifcswitchingdevicetype definition.

	:param predefinedtype
	:type predefinedtype:ifcswitchingdevicetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowcontrollertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcswitchingdevicetypeenum):
				self._predefinedtype = ifcswitchingdevicetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcapproval #
####################
class ifcapproval(BaseEntityClass):
	'''Entity ifcapproval definition.

	:param description
	:type description:ifctext

	:param approvaldatetime
	:type approvaldatetime:ifcdatetimeselect

	:param approvalstatus
	:type approvalstatus:ifclabel

	:param approvallevel
	:type approvallevel:ifclabel

	:param approvalqualifier
	:type approvalqualifier:ifctext

	:param name
	:type name:ifclabel

	:param identifier
	:type identifier:ifcidentifier

	:param actors
	:type actors:SET(0,None,'ifcapprovalactorrelationship', scope = schema_scope)

	:param isrelatedwith
	:type isrelatedwith:SET(0,None,'ifcapprovalrelationship', scope = schema_scope)

	:param relates
	:type relates:SET(0,None,'ifcapprovalrelationship', scope = schema_scope)
	'''
	def __init__( self , description,approvaldatetime,approvalstatus,approvallevel,approvalqualifier,name,identifier, ):
		self.description = description
		self.approvaldatetime = approvaldatetime
		self.approvalstatus = approvalstatus
		self.approvallevel = approvallevel
		self.approvalqualifier = approvalqualifier
		self.name = name
		self.identifier = identifier

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def approvaldatetime():
		def fget( self ):
			return self._approvaldatetime
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument approvaldatetime is mantatory and can not be set to None')
			if not check_type(value,ifcdatetimeselect):
				self._approvaldatetime = ifcdatetimeselect(value)
			else:
				self._approvaldatetime = value
		return property(**locals())

	@apply
	def approvalstatus():
		def fget( self ):
			return self._approvalstatus
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._approvalstatus = ifclabel(value)
				else:
					self._approvalstatus = value
			else:
				self._approvalstatus = value
		return property(**locals())

	@apply
	def approvallevel():
		def fget( self ):
			return self._approvallevel
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._approvallevel = ifclabel(value)
				else:
					self._approvallevel = value
			else:
				self._approvallevel = value
		return property(**locals())

	@apply
	def approvalqualifier():
		def fget( self ):
			return self._approvalqualifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._approvalqualifier = ifctext(value)
				else:
					self._approvalqualifier = value
			else:
				self._approvalqualifier = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def identifier():
		def fget( self ):
			return self._identifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument identifier is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._identifier = ifcidentifier(value)
			else:
				self._identifier = value
		return property(**locals())

	@apply
	def actors():
		def fget( self ):
			return self._actors
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument actors is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def isrelatedwith():
		def fget( self ):
			return self._isrelatedwith
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isrelatedwith is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def relates():
		def fget( self ):
			return self._relates
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument relates is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifccostschedule #
####################
class ifccostschedule(ifccontrol):
	'''Entity ifccostschedule definition.

	:param submittedby
	:type submittedby:ifcactorselect

	:param preparedby
	:type preparedby:ifcactorselect

	:param submittedon
	:type submittedon:ifcdatetimeselect

	:param status
	:type status:ifclabel

	:param targetusers
	:type targetusers:SET(1,None,'ifcactorselect', scope = schema_scope)

	:param updatedate
	:type updatedate:ifcdatetimeselect

	:param id
	:type id:ifcidentifier

	:param predefinedtype
	:type predefinedtype:ifccostscheduletypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , submittedby,preparedby,submittedon,status,targetusers,updatedate,id,predefinedtype, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.submittedby = submittedby
		self.preparedby = preparedby
		self.submittedon = submittedon
		self.status = status
		self.targetusers = targetusers
		self.updatedate = updatedate
		self.id = id
		self.predefinedtype = predefinedtype

	@apply
	def submittedby():
		def fget( self ):
			return self._submittedby
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._submittedby = ifcactorselect(value)
				else:
					self._submittedby = value
			else:
				self._submittedby = value
		return property(**locals())

	@apply
	def preparedby():
		def fget( self ):
			return self._preparedby
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._preparedby = ifcactorselect(value)
				else:
					self._preparedby = value
			else:
				self._preparedby = value
		return property(**locals())

	@apply
	def submittedon():
		def fget( self ):
			return self._submittedon
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._submittedon = ifcdatetimeselect(value)
				else:
					self._submittedon = value
			else:
				self._submittedon = value
		return property(**locals())

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._status = ifclabel(value)
				else:
					self._status = value
			else:
				self._status = value
		return property(**locals())

	@apply
	def targetusers():
		def fget( self ):
			return self._targetusers
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcactorselect', scope = schema_scope)):
					self._targetusers = SET(value)
				else:
					self._targetusers = value
			else:
				self._targetusers = value
		return property(**locals())

	@apply
	def updatedate():
		def fget( self ):
			return self._updatedate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._updatedate = ifcdatetimeselect(value)
				else:
					self._updatedate = value
			else:
				self._updatedate = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._id = ifcidentifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccostscheduletypeenum):
				self._predefinedtype = ifccostscheduletypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifclibraryreference #
####################
class ifclibraryreference(ifcexternalreference):
	'''Entity ifclibraryreference definition.

	:param referenceintolibrary
	:type referenceintolibrary:SET(0,1,'ifclibraryinformation', scope = schema_scope)
	'''
	def __init__( self , inherited0__location , inherited1__itemreference , inherited2__name ,  ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__itemreference , inherited2__name , )

	@apply
	def referenceintolibrary():
		def fget( self ):
			return self._referenceintolibrary
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referenceintolibrary is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcmateriallist #
####################
class ifcmateriallist(BaseEntityClass):
	'''Entity ifcmateriallist definition.

	:param materials
	:type materials:LIST(1,None,'ifcmaterial', scope = schema_scope)
	'''
	def __init__( self , materials, ):
		self.materials = materials

	@apply
	def materials():
		def fget( self ):
			return self._materials
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument materials is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcmaterial', scope = schema_scope)):
				self._materials = LIST(value)
			else:
				self._materials = value
		return property(**locals())

####################
 # ENTITY ifcplatetype #
####################
class ifcplatetype(ifcbuildingelementtype):
	'''Entity ifcplatetype definition.

	:param predefinedtype
	:type predefinedtype:ifcplatetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcplatetypeenum):
				self._predefinedtype = ifcplatetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcreldefinesbytype #
####################
class ifcreldefinesbytype(ifcreldefines):
	'''Entity ifcreldefinesbytype definition.

	:param relatingtype
	:type relatingtype:ifctypeobject
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingtype, ):
		ifcreldefines.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingtype = relatingtype

	@apply
	def relatingtype():
		def fget( self ):
			return self._relatingtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingtype is mantatory and can not be set to None')
			if not check_type(value,ifctypeobject):
				self._relatingtype = ifctypeobject(value)
			else:
				self._relatingtype = value
		return property(**locals())

####################
 # ENTITY ifctable #
####################
class ifctable(BaseEntityClass):
	'''Entity ifctable definition.

	:param name
	:type name:STRING

	:param rows
	:type rows:LIST(1,None,'ifctablerow', scope = schema_scope)

	:param numberofcellsinrow
	:type numberofcellsinrow:INTEGER

	:param numberofheadings
	:type numberofheadings:INTEGER

	:param numberofdatarows
	:type numberofdatarows:INTEGER
	'''
	def __init__( self , name,rows, ):
		self.name = name
		self.rows = rows

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,STRING):
				self._name = STRING(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def rows():
		def fget( self ):
			return self._rows
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rows is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifctablerow', scope = schema_scope)):
				self._rows = LIST(value)
			else:
				self._rows = value
		return property(**locals())

	@apply
	def numberofcellsinrow():
		def fget( self ):
			attribute_eval = HIINDEX(self.rows[1].self.rowcells)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument numberofcellsinrow is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def numberofheadings():
		def fget( self ):
			attribute_eval = SIZEOF(None)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument numberofheadings is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def numberofdatarows():
		def fget( self ):
			attribute_eval = SIZEOF(None)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument numberofdatarows is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((0  <=  self.numberofheadings)  and  (self.numberofheadings  <=  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcrailingtype #
####################
class ifcrailingtype(ifcbuildingelementtype):
	'''Entity ifcrailingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcrailingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcrailingtypeenum):
				self._predefinedtype = ifcrailingtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcfurnituretype #
####################
class ifcfurnituretype(ifcfurnishingelementtype):
	'''Entity ifcfurnituretype definition.

	:param assemblyplace
	:type assemblyplace:ifcassemblyplaceenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , assemblyplace, ):
		ifcfurnishingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.assemblyplace = assemblyplace

	@apply
	def assemblyplace():
		def fget( self ):
			return self._assemblyplace
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assemblyplace is mantatory and can not be set to None')
			if not check_type(value,ifcassemblyplaceenum):
				self._assemblyplace = ifcassemblyplaceenum(value)
			else:
				self._assemblyplace = value
		return property(**locals())

####################
 # ENTITY ifcdefinedsymbol #
####################
class ifcdefinedsymbol(ifcgeometricrepresentationitem):
	'''Entity ifcdefinedsymbol definition.

	:param definition
	:type definition:ifcdefinedsymbolselect

	:param target
	:type target:ifccartesiantransformationoperator2d
	'''
	def __init__( self , definition,target, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.definition = definition
		self.target = target

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,ifcdefinedsymbolselect):
				self._definition = ifcdefinedsymbolselect(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def target():
		def fget( self ):
			return self._target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument target is mantatory and can not be set to None')
			if not check_type(value,ifccartesiantransformationoperator2d):
				self._target = ifccartesiantransformationoperator2d(value)
			else:
				self._target = value
		return property(**locals())

####################
 # ENTITY ifcfiresuppressionterminaltype #
####################
class ifcfiresuppressionterminaltype(ifcflowterminaltype):
	'''Entity ifcfiresuppressionterminaltype definition.

	:param predefinedtype
	:type predefinedtype:ifcfiresuppressionterminaltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowterminaltype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcfiresuppressionterminaltypeenum):
				self._predefinedtype = ifcfiresuppressionterminaltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifctendonanchor #
####################
class ifctendonanchor(ifcreinforcingelement):
	'''Entity ifctendonanchor definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade ,  ):
		ifcreinforcingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__steelgrade , )

####################
 # ENTITY ifcconstructionequipmentresource #
####################
class ifcconstructionequipmentresource(ifcconstructionresource):
	'''Entity ifcconstructionequipmentresource definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity ,  ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity , )

####################
 # ENTITY ifctexturevertex #
####################
class ifctexturevertex(BaseEntityClass):
	'''Entity ifctexturevertex definition.

	:param coordinates
	:type coordinates:LIST(2,2,'REAL', scope = schema_scope)
	'''
	def __init__( self , coordinates, ):
		self.coordinates = coordinates

	@apply
	def coordinates():
		def fget( self ):
			return self._coordinates
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordinates is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'REAL', scope = schema_scope)):
				self._coordinates = LIST(value)
			else:
				self._coordinates = value
		return property(**locals())

####################
 # ENTITY ifcpile #
####################
class ifcpile(ifcbuildingelement):
	'''Entity ifcpile definition.

	:param predefinedtype
	:type predefinedtype:ifcpiletypeenum

	:param constructiontype
	:type constructiontype:ifcpileconstructionenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype,constructiontype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype
		self.constructiontype = constructiontype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcpiletypeenum):
				self._predefinedtype = ifcpiletypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def constructiontype():
		def fget( self ):
			return self._constructiontype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpileconstructionenum):
					self._constructiontype = ifcpileconstructionenum(value)
				else:
					self._constructiontype = value
			else:
				self._constructiontype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcpiletypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcpiletypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcrelassociatesappliedvalue #
####################
class ifcrelassociatesappliedvalue(ifcrelassociates):
	'''Entity ifcrelassociatesappliedvalue definition.

	:param relatingappliedvalue
	:type relatingappliedvalue:ifcappliedvalue
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingappliedvalue, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingappliedvalue = relatingappliedvalue

	@apply
	def relatingappliedvalue():
		def fget( self ):
			return self._relatingappliedvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingappliedvalue is mantatory and can not be set to None')
			if not check_type(value,ifcappliedvalue):
				self._relatingappliedvalue = ifcappliedvalue(value)
			else:
				self._relatingappliedvalue = value
		return property(**locals())

####################
 # ENTITY ifcrelassociateslibrary #
####################
class ifcrelassociateslibrary(ifcrelassociates):
	'''Entity ifcrelassociateslibrary definition.

	:param relatinglibrary
	:type relatinglibrary:ifclibraryselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatinglibrary, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatinglibrary = relatinglibrary

	@apply
	def relatinglibrary():
		def fget( self ):
			return self._relatinglibrary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatinglibrary is mantatory and can not be set to None')
			if not check_type(value,ifclibraryselect):
				self._relatinglibrary = ifclibraryselect(value)
			else:
				self._relatinglibrary = value
		return property(**locals())

####################
 # ENTITY ifcdimensioncalloutrelationship #
####################
class ifcdimensioncalloutrelationship(ifcdraughtingcalloutrelationship):
	'''Entity ifcdimensioncalloutrelationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relatingdraughtingcallout , inherited3__relateddraughtingcallout ,  ):
		ifcdraughtingcalloutrelationship.__init__(self , inherited0__name , inherited1__description , inherited2__relatingdraughtingcallout , inherited3__relateddraughtingcallout , )
	def wr11(self):
		eval_wr11_wr = (self.self.ifcdraughtingcalloutrelationship.self.name  ==  ['primary','secondary'])
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(TYPEOF(self.self.ifcdraughtingcalloutrelationship.self.relatingdraughtingcallout)  *  ['IFC2X3.IFCANGULARDIMENSION','IFC2X3.IFCDIAMETERDIMENSION','IFC2X3.IFCLINEARDIMENSION','IFC2X3.IFCRADIUSDIMENSION'])  ==  1)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = ( not ('IFC2X3.IFCDIMENSIONCURVEDIRECTEDCALLOUT'  ==  TYPEOF(self.self.ifcdraughtingcalloutrelationship.self.relateddraughtingcallout)))
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr


####################
 # ENTITY ifcrectanglehollowprofiledef #
####################
class ifcrectanglehollowprofiledef(ifcrectangleprofiledef):
	'''Entity ifcrectanglehollowprofiledef definition.

	:param wallthickness
	:type wallthickness:ifcpositivelengthmeasure

	:param innerfilletradius
	:type innerfilletradius:ifcpositivelengthmeasure

	:param outerfilletradius
	:type outerfilletradius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__xdim , inherited4__ydim , wallthickness,innerfilletradius,outerfilletradius, ):
		ifcrectangleprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__xdim , inherited4__ydim , )
		self.wallthickness = wallthickness
		self.innerfilletradius = innerfilletradius
		self.outerfilletradius = outerfilletradius

	@apply
	def wallthickness():
		def fget( self ):
			return self._wallthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument wallthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._wallthickness = ifcpositivelengthmeasure(value)
			else:
				self._wallthickness = value
		return property(**locals())

	@apply
	def innerfilletradius():
		def fget( self ):
			return self._innerfilletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._innerfilletradius = ifcpositivelengthmeasure(value)
				else:
					self._innerfilletradius = value
			else:
				self._innerfilletradius = value
		return property(**locals())

	@apply
	def outerfilletradius():
		def fget( self ):
			return self._outerfilletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._outerfilletradius = ifcpositivelengthmeasure(value)
				else:
					self._outerfilletradius = value
			else:
				self._outerfilletradius = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = ((self.wallthickness  <  (self.self.ifcrectangleprofiledef.self.xdim / 2))  and  (self.wallthickness  <  (self.self.ifcrectangleprofiledef.self.ydim / 2)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = (( not EXISTS(self.outerfilletradius))  or  ((self.outerfilletradius  <=  (self.self.ifcrectangleprofiledef.self.xdim / 2))  and  (self.outerfilletradius  <=  (self.self.ifcrectangleprofiledef.self.ydim / 2))))
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr

	def wr33(self):
		eval_wr33_wr = (( not EXISTS(self.innerfilletradius))  or  ((self.innerfilletradius  <=  ((self.self.ifcrectangleprofiledef.self.xdim / 2) - self.wallthickness))  and  (self.innerfilletradius  <=  ((self.self.ifcrectangleprofiledef.self.ydim / 2) - self.wallthickness))))
		if not eval_wr33_wr:
			raise AssertionError('Rule wr33 violated')
		else:
			return eval_wr33_wr


####################
 # ENTITY ifcproxy #
####################
class ifcproxy(ifcproduct):
	'''Entity ifcproxy definition.

	:param proxytype
	:type proxytype:ifcobjecttypeenum

	:param tag
	:type tag:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , proxytype,tag, ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.proxytype = proxytype
		self.tag = tag

	@apply
	def proxytype():
		def fget( self ):
			return self._proxytype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument proxytype is mantatory and can not be set to None')
			if not check_type(value,ifcobjecttypeenum):
				self._proxytype = ifcobjecttypeenum(value)
			else:
				self._proxytype = value
		return property(**locals())

	@apply
	def tag():
		def fget( self ):
			return self._tag
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._tag = ifclabel(value)
				else:
					self._tag = value
			else:
				self._tag = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcpropertyboundedvalue #
####################
class ifcpropertyboundedvalue(ifcsimpleproperty):
	'''Entity ifcpropertyboundedvalue definition.

	:param upperboundvalue
	:type upperboundvalue:ifcvalue

	:param lowerboundvalue
	:type lowerboundvalue:ifcvalue

	:param unit
	:type unit:ifcunit
	'''
	def __init__( self , inherited0__name , inherited1__description , upperboundvalue,lowerboundvalue,unit, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.upperboundvalue = upperboundvalue
		self.lowerboundvalue = lowerboundvalue
		self.unit = unit

	@apply
	def upperboundvalue():
		def fget( self ):
			return self._upperboundvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvalue):
					self._upperboundvalue = ifcvalue(value)
				else:
					self._upperboundvalue = value
			else:
				self._upperboundvalue = value
		return property(**locals())

	@apply
	def lowerboundvalue():
		def fget( self ):
			return self._lowerboundvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvalue):
					self._lowerboundvalue = ifcvalue(value)
				else:
					self._lowerboundvalue = value
			else:
				self._lowerboundvalue = value
		return property(**locals())

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._unit = ifcunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = ((( not EXISTS(self.upperboundvalue))  or  ( not EXISTS(self.lowerboundvalue)))  or  (TYPEOF(self.upperboundvalue)  ==  TYPEOF(self.lowerboundvalue)))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (EXISTS(self.upperboundvalue)  or  EXISTS(self.lowerboundvalue))
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcpresentationstyleassignment #
####################
class ifcpresentationstyleassignment(BaseEntityClass):
	'''Entity ifcpresentationstyleassignment definition.

	:param styles
	:type styles:SET(1,None,'ifcpresentationstyleselect', scope = schema_scope)
	'''
	def __init__( self , styles, ):
		self.styles = styles

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcpresentationstyleselect', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())

####################
 # ENTITY ifcspaceprogram #
####################
class ifcspaceprogram(ifccontrol):
	'''Entity ifcspaceprogram definition.

	:param spaceprogramidentifier
	:type spaceprogramidentifier:ifcidentifier

	:param maxrequiredarea
	:type maxrequiredarea:ifcareameasure

	:param minrequiredarea
	:type minrequiredarea:ifcareameasure

	:param requestedlocation
	:type requestedlocation:ifcspatialstructureelement

	:param standardrequiredarea
	:type standardrequiredarea:ifcareameasure

	:param hasinteractionreqsfrom
	:type hasinteractionreqsfrom:SET(0,None,'ifcrelinteractionrequirements', scope = schema_scope)

	:param hasinteractionreqsto
	:type hasinteractionreqsto:SET(0,None,'ifcrelinteractionrequirements', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , spaceprogramidentifier,maxrequiredarea,minrequiredarea,requestedlocation,standardrequiredarea, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.spaceprogramidentifier = spaceprogramidentifier
		self.maxrequiredarea = maxrequiredarea
		self.minrequiredarea = minrequiredarea
		self.requestedlocation = requestedlocation
		self.standardrequiredarea = standardrequiredarea

	@apply
	def spaceprogramidentifier():
		def fget( self ):
			return self._spaceprogramidentifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument spaceprogramidentifier is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._spaceprogramidentifier = ifcidentifier(value)
			else:
				self._spaceprogramidentifier = value
		return property(**locals())

	@apply
	def maxrequiredarea():
		def fget( self ):
			return self._maxrequiredarea
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._maxrequiredarea = ifcareameasure(value)
				else:
					self._maxrequiredarea = value
			else:
				self._maxrequiredarea = value
		return property(**locals())

	@apply
	def minrequiredarea():
		def fget( self ):
			return self._minrequiredarea
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._minrequiredarea = ifcareameasure(value)
				else:
					self._minrequiredarea = value
			else:
				self._minrequiredarea = value
		return property(**locals())

	@apply
	def requestedlocation():
		def fget( self ):
			return self._requestedlocation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcspatialstructureelement):
					self._requestedlocation = ifcspatialstructureelement(value)
				else:
					self._requestedlocation = value
			else:
				self._requestedlocation = value
		return property(**locals())

	@apply
	def standardrequiredarea():
		def fget( self ):
			return self._standardrequiredarea
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument standardrequiredarea is mantatory and can not be set to None')
			if not check_type(value,ifcareameasure):
				self._standardrequiredarea = ifcareameasure(value)
			else:
				self._standardrequiredarea = value
		return property(**locals())

	@apply
	def hasinteractionreqsfrom():
		def fget( self ):
			return self._hasinteractionreqsfrom
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasinteractionreqsfrom is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasinteractionreqsto():
		def fget( self ):
			return self._hasinteractionreqsto
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasinteractionreqsto is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcsite #
####################
class ifcsite(ifcspatialstructureelement):
	'''Entity ifcsite definition.

	:param reflatitude
	:type reflatitude:LIST(3,4,'INTEGER', scope = schema_scope)

	:param reflongitude
	:type reflongitude:LIST(3,4,'INTEGER', scope = schema_scope)

	:param refelevation
	:type refelevation:ifclengthmeasure

	:param landtitlenumber
	:type landtitlenumber:ifclabel

	:param siteaddress
	:type siteaddress:ifcpostaladdress
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , reflatitude,reflongitude,refelevation,landtitlenumber,siteaddress, ):
		ifcspatialstructureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , )
		self.reflatitude = reflatitude
		self.reflongitude = reflongitude
		self.refelevation = refelevation
		self.landtitlenumber = landtitlenumber
		self.siteaddress = siteaddress

	@apply
	def reflatitude():
		def fget( self ):
			return self._reflatitude
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(3,4,'INTEGER', scope = schema_scope)):
					self._reflatitude = LIST(value)
				else:
					self._reflatitude = value
			else:
				self._reflatitude = value
		return property(**locals())

	@apply
	def reflongitude():
		def fget( self ):
			return self._reflongitude
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(3,4,'INTEGER', scope = schema_scope)):
					self._reflongitude = LIST(value)
				else:
					self._reflongitude = value
			else:
				self._reflongitude = value
		return property(**locals())

	@apply
	def refelevation():
		def fget( self ):
			return self._refelevation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._refelevation = ifclengthmeasure(value)
				else:
					self._refelevation = value
			else:
				self._refelevation = value
		return property(**locals())

	@apply
	def landtitlenumber():
		def fget( self ):
			return self._landtitlenumber
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._landtitlenumber = ifclabel(value)
				else:
					self._landtitlenumber = value
			else:
				self._landtitlenumber = value
		return property(**locals())

	@apply
	def siteaddress():
		def fget( self ):
			return self._siteaddress
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpostaladdress):
					self._siteaddress = ifcpostaladdress(value)
				else:
					self._siteaddress = value
			else:
				self._siteaddress = value
		return property(**locals())

####################
 # ENTITY ifcarbitraryopenprofiledef #
####################
class ifcarbitraryopenprofiledef(ifcprofiledef):
	'''Entity ifcarbitraryopenprofiledef definition.

	:param curve
	:type curve:ifcboundedcurve
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , curve, ):
		ifcprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , )
		self.curve = curve

	@apply
	def curve():
		def fget( self ):
			return self._curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve is mantatory and can not be set to None')
			if not check_type(value,ifcboundedcurve):
				self._curve = ifcboundedcurve(value)
			else:
				self._curve = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (('IFC2X3.IFCCENTERLINEPROFILEDEF'  ==  TYPEOF(self))  or  (self.self.ifcprofiledef.self.profiletype  ==  ifcprofiletypeenum.self.curve))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (self.curve.self.dim  ==  2)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr


####################
 # ENTITY ifcquantitylength #
####################
class ifcquantitylength(ifcphysicalsimplequantity):
	'''Entity ifcquantitylength definition.

	:param lengthvalue
	:type lengthvalue:ifclengthmeasure
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , lengthvalue, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.lengthvalue = lengthvalue

	@apply
	def lengthvalue():
		def fget( self ):
			return self._lengthvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lengthvalue is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._lengthvalue = ifclengthmeasure(value)
			else:
				self._lengthvalue = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.self.ifcphysicalsimplequantity.self.unit))  or  (self.self.ifcphysicalsimplequantity.self.unit.self.unittype  ==  ifcunitenum.self.lengthunit))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.lengthvalue  >=  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcsubcontractresource #
####################
class ifcsubcontractresource(ifcconstructionresource):
	'''Entity ifcsubcontractresource definition.

	:param subcontractor
	:type subcontractor:ifcactorselect

	:param jobdescription
	:type jobdescription:ifctext
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity , subcontractor,jobdescription, ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity , )
		self.subcontractor = subcontractor
		self.jobdescription = jobdescription

	@apply
	def subcontractor():
		def fget( self ):
			return self._subcontractor
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorselect):
					self._subcontractor = ifcactorselect(value)
				else:
					self._subcontractor = value
			else:
				self._subcontractor = value
		return property(**locals())

	@apply
	def jobdescription():
		def fget( self ):
			return self._jobdescription
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._jobdescription = ifctext(value)
				else:
					self._jobdescription = value
			else:
				self._jobdescription = value
		return property(**locals())

####################
 # ENTITY ifcdoor #
####################
class ifcdoor(ifcbuildingelement):
	'''Entity ifcdoor definition.

	:param overallheight
	:type overallheight:ifcpositivelengthmeasure

	:param overallwidth
	:type overallwidth:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , overallheight,overallwidth, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.overallheight = overallheight
		self.overallwidth = overallwidth

	@apply
	def overallheight():
		def fget( self ):
			return self._overallheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._overallheight = ifcpositivelengthmeasure(value)
				else:
					self._overallheight = value
			else:
				self._overallheight = value
		return property(**locals())

	@apply
	def overallwidth():
		def fget( self ):
			return self._overallwidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._overallwidth = ifcpositivelengthmeasure(value)
				else:
					self._overallwidth = value
			else:
				self._overallwidth = value
		return property(**locals())

####################
 # ENTITY ifctimeseries #
####################
class ifctimeseries(BaseEntityClass):
	'''Entity ifctimeseries definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param starttime
	:type starttime:ifcdatetimeselect

	:param endtime
	:type endtime:ifcdatetimeselect

	:param timeseriesdatatype
	:type timeseriesdatatype:ifctimeseriesdatatypeenum

	:param dataorigin
	:type dataorigin:ifcdataoriginenum

	:param userdefineddataorigin
	:type userdefineddataorigin:ifclabel

	:param unit
	:type unit:ifcunit

	:param documentedby
	:type documentedby:SET(0,1,'ifctimeseriesreferencerelationship', scope = schema_scope)
	'''
	def __init__( self , name,description,starttime,endtime,timeseriesdatatype,dataorigin,userdefineddataorigin,unit, ):
		self.name = name
		self.description = description
		self.starttime = starttime
		self.endtime = endtime
		self.timeseriesdatatype = timeseriesdatatype
		self.dataorigin = dataorigin
		self.userdefineddataorigin = userdefineddataorigin
		self.unit = unit

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def starttime():
		def fget( self ):
			return self._starttime
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument starttime is mantatory and can not be set to None')
			if not check_type(value,ifcdatetimeselect):
				self._starttime = ifcdatetimeselect(value)
			else:
				self._starttime = value
		return property(**locals())

	@apply
	def endtime():
		def fget( self ):
			return self._endtime
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument endtime is mantatory and can not be set to None')
			if not check_type(value,ifcdatetimeselect):
				self._endtime = ifcdatetimeselect(value)
			else:
				self._endtime = value
		return property(**locals())

	@apply
	def timeseriesdatatype():
		def fget( self ):
			return self._timeseriesdatatype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timeseriesdatatype is mantatory and can not be set to None')
			if not check_type(value,ifctimeseriesdatatypeenum):
				self._timeseriesdatatype = ifctimeseriesdatatypeenum(value)
			else:
				self._timeseriesdatatype = value
		return property(**locals())

	@apply
	def dataorigin():
		def fget( self ):
			return self._dataorigin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dataorigin is mantatory and can not be set to None')
			if not check_type(value,ifcdataoriginenum):
				self._dataorigin = ifcdataoriginenum(value)
			else:
				self._dataorigin = value
		return property(**locals())

	@apply
	def userdefineddataorigin():
		def fget( self ):
			return self._userdefineddataorigin
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefineddataorigin = ifclabel(value)
				else:
					self._userdefineddataorigin = value
			else:
				self._userdefineddataorigin = value
		return property(**locals())

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._unit = ifcunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())

	@apply
	def documentedby():
		def fget( self ):
			return self._documentedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument documentedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcregulartimeseries #
####################
class ifcregulartimeseries(ifctimeseries):
	'''Entity ifcregulartimeseries definition.

	:param timestep
	:type timestep:ifctimemeasure

	:param values
	:type values:LIST(1,None,'ifctimeseriesvalue', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__starttime , inherited3__endtime , inherited4__timeseriesdatatype , inherited5__dataorigin , inherited6__userdefineddataorigin , inherited7__unit , timestep,values, ):
		ifctimeseries.__init__(self , inherited0__name , inherited1__description , inherited2__starttime , inherited3__endtime , inherited4__timeseriesdatatype , inherited5__dataorigin , inherited6__userdefineddataorigin , inherited7__unit , )
		self.timestep = timestep
		self.values = values

	@apply
	def timestep():
		def fget( self ):
			return self._timestep
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timestep is mantatory and can not be set to None')
			if not check_type(value,ifctimemeasure):
				self._timestep = ifctimemeasure(value)
			else:
				self._timestep = value
		return property(**locals())

	@apply
	def values():
		def fget( self ):
			return self._values
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument values is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifctimeseriesvalue', scope = schema_scope)):
				self._values = LIST(value)
			else:
				self._values = value
		return property(**locals())

####################
 # ENTITY ifcdimensionpair #
####################
class ifcdimensionpair(ifcdraughtingcalloutrelationship):
	'''Entity ifcdimensionpair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relatingdraughtingcallout , inherited3__relateddraughtingcallout ,  ):
		ifcdraughtingcalloutrelationship.__init__(self , inherited0__name , inherited1__description , inherited2__relatingdraughtingcallout , inherited3__relateddraughtingcallout , )
	def wr11(self):
		eval_wr11_wr = (self.self.name  ==  ['chained','parallel'])
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(TYPEOF(self.self.relatingdraughtingcallout)  *  ['IFC2X3.IFCANGULARDIMENSION','IFC2X3.IFCDIAMETERDIMENSION','IFC2X3.IFCLINEARDIMENSION','IFC2X3.IFCRADIUSDIMENSION'])  ==  1)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(TYPEOF(self.self.relateddraughtingcallout)  *  ['IFC2X3.IFCANGULARDIMENSION','IFC2X3.IFCDIAMETERDIMENSION','IFC2X3.IFCLINEARDIMENSION','IFC2X3.IFCRADIUSDIMENSION'])  ==  1)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr


####################
 # ENTITY ifcdistributionport #
####################
class ifcdistributionport(ifcport):
	'''Entity ifcdistributionport definition.

	:param flowdirection
	:type flowdirection:ifcflowdirectionenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , flowdirection, ):
		ifcport.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.flowdirection = flowdirection

	@apply
	def flowdirection():
		def fget( self ):
			return self._flowdirection
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcflowdirectionenum):
					self._flowdirection = ifcflowdirectionenum(value)
				else:
					self._flowdirection = value
			else:
				self._flowdirection = value
		return property(**locals())

####################
 # ENTITY ifcenergyproperties #
####################
class ifcenergyproperties(ifcpropertysetdefinition):
	'''Entity ifcenergyproperties definition.

	:param energysequence
	:type energysequence:ifcenergysequenceenum

	:param userdefinedenergysequence
	:type userdefinedenergysequence:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , energysequence,userdefinedenergysequence, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.energysequence = energysequence
		self.userdefinedenergysequence = userdefinedenergysequence

	@apply
	def energysequence():
		def fget( self ):
			return self._energysequence
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcenergysequenceenum):
					self._energysequence = ifcenergysequenceenum(value)
				else:
					self._energysequence = value
			else:
				self._energysequence = value
		return property(**locals())

	@apply
	def userdefinedenergysequence():
		def fget( self ):
			return self._userdefinedenergysequence
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedenergysequence = ifclabel(value)
				else:
					self._userdefinedenergysequence = value
			else:
				self._userdefinedenergysequence = value
		return property(**locals())

####################
 # ENTITY ifcelectricalelement #
####################
class ifcelectricalelement(ifcelement):
	'''Entity ifcelectricalelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifclightsourcepositional #
####################
class ifclightsourcepositional(ifclightsource):
	'''Entity ifclightsourcepositional definition.

	:param position
	:type position:ifccartesianpoint

	:param radius
	:type radius:ifcpositivelengthmeasure

	:param constantattenuation
	:type constantattenuation:ifcreal

	:param distanceattenuation
	:type distanceattenuation:ifcreal

	:param quadricattenuation
	:type quadricattenuation:ifcreal
	'''
	def __init__( self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , position,radius,constantattenuation,distanceattenuation,quadricattenuation, ):
		ifclightsource.__init__(self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , )
		self.position = position
		self.radius = radius
		self.constantattenuation = constantattenuation
		self.distanceattenuation = distanceattenuation
		self.quadricattenuation = quadricattenuation

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifccartesianpoint):
				self._position = ifccartesianpoint(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def constantattenuation():
		def fget( self ):
			return self._constantattenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constantattenuation is mantatory and can not be set to None')
			if not check_type(value,ifcreal):
				self._constantattenuation = ifcreal(value)
			else:
				self._constantattenuation = value
		return property(**locals())

	@apply
	def distanceattenuation():
		def fget( self ):
			return self._distanceattenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distanceattenuation is mantatory and can not be set to None')
			if not check_type(value,ifcreal):
				self._distanceattenuation = ifcreal(value)
			else:
				self._distanceattenuation = value
		return property(**locals())

	@apply
	def quadricattenuation():
		def fget( self ):
			return self._quadricattenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument quadricattenuation is mantatory and can not be set to None')
			if not check_type(value,ifcreal):
				self._quadricattenuation = ifcreal(value)
			else:
				self._quadricattenuation = value
		return property(**locals())

####################
 # ENTITY ifclightsourcedirectional #
####################
class ifclightsourcedirectional(ifclightsource):
	'''Entity ifclightsourcedirectional definition.

	:param orientation
	:type orientation:ifcdirection
	'''
	def __init__( self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , orientation, ):
		ifclightsource.__init__(self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , )
		self.orientation = orientation

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._orientation = ifcdirection(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY ifcstructuralreaction #
####################
class ifcstructuralreaction(ifcstructuralactivity):
	'''Entity ifcstructuralreaction definition.

	:param causes
	:type causes:SET(0,None,'ifcstructuralaction', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal ,  ):
		ifcstructuralactivity.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , )

	@apply
	def causes():
		def fget( self ):
			return self._causes
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument causes is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcstructuralpointreaction #
####################
class ifcstructuralpointreaction(ifcstructuralreaction):
	'''Entity ifcstructuralpointreaction definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal ,  ):
		ifcstructuralreaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , )
	def wr61(self):
		eval_wr61_wr = (SIZEOF(['IFC2X3.IFCSTRUCTURALLOADSINGLEFORCE','IFC2X3.IFCSTRUCTURALLOADSINGLEDISPLACEMENT']  *  TYPEOF(self.self.ifcstructuralactivity.self.appliedload))  ==  1)
		if not eval_wr61_wr:
			raise AssertionError('Rule wr61 violated')
		else:
			return eval_wr61_wr


####################
 # ENTITY ifcsoundproperties #
####################
class ifcsoundproperties(ifcpropertysetdefinition):
	'''Entity ifcsoundproperties definition.

	:param isattenuating
	:type isattenuating:ifcboolean

	:param soundscale
	:type soundscale:ifcsoundscaleenum

	:param soundvalues
	:type soundvalues:LIST(1,8,'ifcsoundvalue', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , isattenuating,soundscale,soundvalues, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.isattenuating = isattenuating
		self.soundscale = soundscale
		self.soundvalues = soundvalues

	@apply
	def isattenuating():
		def fget( self ):
			return self._isattenuating
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument isattenuating is mantatory and can not be set to None')
			if not check_type(value,ifcboolean):
				self._isattenuating = ifcboolean(value)
			else:
				self._isattenuating = value
		return property(**locals())

	@apply
	def soundscale():
		def fget( self ):
			return self._soundscale
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsoundscaleenum):
					self._soundscale = ifcsoundscaleenum(value)
				else:
					self._soundscale = value
			else:
				self._soundscale = value
		return property(**locals())

	@apply
	def soundvalues():
		def fget( self ):
			return self._soundvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument soundvalues is mantatory and can not be set to None')
			if not check_type(value,LIST(1,8,'ifcsoundvalue', scope = schema_scope)):
				self._soundvalues = LIST(value)
			else:
				self._soundvalues = value
		return property(**locals())

####################
 # ENTITY ifcfastener #
####################
class ifcfastener(ifcelementcomponent):
	'''Entity ifcfastener definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcelementcomponent.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcorientededge #
####################
class ifcorientededge(ifcedge):
	'''Entity ifcorientededge definition.

	:param edgeelement
	:type edgeelement:ifcedge

	:param orientation
	:type orientation:BOOLEAN

	:param ifcedge_edgestart
	:type ifcedge_edgestart:ifcvertex

	:param ifcedge_edgeend
	:type ifcedge_edgeend:ifcvertex
	'''
	def __init__( self , inherited0__edgestart , inherited1__edgeend , edgeelement,orientation, ):
		ifcedge.__init__(self , inherited0__edgestart , inherited1__edgeend , )
		self.edgeelement = edgeelement
		self.orientation = orientation

	@apply
	def edgeelement():
		def fget( self ):
			return self._edgeelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgeelement is mantatory and can not be set to None')
			if not check_type(value,ifcedge):
				self._edgeelement = ifcedge(value)
			else:
				self._edgeelement = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def ifcedge_edgestart():
		def fget( self ):
			attribute_eval = ifcbooleanchoose(self.orientation,self.edgeelement.self.edgestart,self.edgeelement.self.edgeend)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcedge_edgestart is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ifcedge_edgeend():
		def fget( self ):
			attribute_eval = ifcbooleanchoose(self.orientation,self.edgeelement.self.edgeend,self.edgeelement.self.edgestart)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcedge_edgeend is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('IFC2X3.IFCORIENTEDEDGE'  ==  TYPEOF(self.edgeelement)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcrelassociatesconstraint #
####################
class ifcrelassociatesconstraint(ifcrelassociates):
	'''Entity ifcrelassociatesconstraint definition.

	:param intent
	:type intent:ifclabel

	:param relatingconstraint
	:type relatingconstraint:ifcconstraint
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , intent,relatingconstraint, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.intent = intent
		self.relatingconstraint = relatingconstraint

	@apply
	def intent():
		def fget( self ):
			return self._intent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument intent is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._intent = ifclabel(value)
			else:
				self._intent = value
		return property(**locals())

	@apply
	def relatingconstraint():
		def fget( self ):
			return self._relatingconstraint
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingconstraint is mantatory and can not be set to None')
			if not check_type(value,ifcconstraint):
				self._relatingconstraint = ifcconstraint(value)
			else:
				self._relatingconstraint = value
		return property(**locals())

####################
 # ENTITY ifctimeseriesvalue #
####################
class ifctimeseriesvalue(BaseEntityClass):
	'''Entity ifctimeseriesvalue definition.

	:param listvalues
	:type listvalues:LIST(1,None,'ifcvalue', scope = schema_scope)
	'''
	def __init__( self , listvalues, ):
		self.listvalues = listvalues

	@apply
	def listvalues():
		def fget( self ):
			return self._listvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument listvalues is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
				self._listvalues = LIST(value)
			else:
				self._listvalues = value
		return property(**locals())

####################
 # ENTITY ifcbuildingelementpart #
####################
class ifcbuildingelementpart(ifcbuildingelementcomponent):
	'''Entity ifcbuildingelementpart definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcbuildingelementcomponent.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifctimeseriesreferencerelationship #
####################
class ifctimeseriesreferencerelationship(BaseEntityClass):
	'''Entity ifctimeseriesreferencerelationship definition.

	:param referencedtimeseries
	:type referencedtimeseries:ifctimeseries

	:param timeseriesreferences
	:type timeseriesreferences:SET(1,None,'ifcdocumentselect', scope = schema_scope)
	'''
	def __init__( self , referencedtimeseries,timeseriesreferences, ):
		self.referencedtimeseries = referencedtimeseries
		self.timeseriesreferences = timeseriesreferences

	@apply
	def referencedtimeseries():
		def fget( self ):
			return self._referencedtimeseries
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument referencedtimeseries is mantatory and can not be set to None')
			if not check_type(value,ifctimeseries):
				self._referencedtimeseries = ifctimeseries(value)
			else:
				self._referencedtimeseries = value
		return property(**locals())

	@apply
	def timeseriesreferences():
		def fget( self ):
			return self._timeseriesreferences
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timeseriesreferences is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcdocumentselect', scope = schema_scope)):
				self._timeseriesreferences = SET(value)
			else:
				self._timeseriesreferences = value
		return property(**locals())

####################
 # ENTITY ifcbuildingelementproxy #
####################
class ifcbuildingelementproxy(ifcbuildingelement):
	'''Entity ifcbuildingelementproxy definition.

	:param compositiontype
	:type compositiontype:ifcelementcompositionenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , compositiontype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.compositiontype = compositiontype

	@apply
	def compositiontype():
		def fget( self ):
			return self._compositiontype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelementcompositionenum):
					self._compositiontype = ifcelementcompositionenum(value)
				else:
					self._compositiontype = value
			else:
				self._compositiontype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcdiscreteaccessorytype #
####################
class ifcdiscreteaccessorytype(ifcelementcomponenttype):
	'''Entity ifcdiscreteaccessorytype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcelementcomponenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcplate #
####################
class ifcplate(ifcbuildingelement):
	'''Entity ifcplate definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcconnectedfaceset #
####################
class ifcconnectedfaceset(ifctopologicalrepresentationitem):
	'''Entity ifcconnectedfaceset definition.

	:param cfsfaces
	:type cfsfaces:SET(1,None,'ifcface', scope = schema_scope)
	'''
	def __init__( self , cfsfaces, ):
		ifctopologicalrepresentationitem.__init__(self , )
		self.cfsfaces = cfsfaces

	@apply
	def cfsfaces():
		def fget( self ):
			return self._cfsfaces
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument cfsfaces is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcface', scope = schema_scope)):
				self._cfsfaces = SET(value)
			else:
				self._cfsfaces = value
		return property(**locals())

####################
 # ENTITY ifcclosedshell #
####################
class ifcclosedshell(ifcconnectedfaceset):
	'''Entity ifcclosedshell definition.
	'''
	def __init__( self , inherited0__cfsfaces ,  ):
		ifcconnectedfaceset.__init__(self , inherited0__cfsfaces , )

####################
 # ENTITY ifcrelassociatesprofileproperties #
####################
class ifcrelassociatesprofileproperties(ifcrelassociates):
	'''Entity ifcrelassociatesprofileproperties definition.

	:param relatingprofileproperties
	:type relatingprofileproperties:ifcprofileproperties

	:param profilesectionlocation
	:type profilesectionlocation:ifcshapeaspect

	:param profileorientation
	:type profileorientation:ifcorientationselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingprofileproperties,profilesectionlocation,profileorientation, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingprofileproperties = relatingprofileproperties
		self.profilesectionlocation = profilesectionlocation
		self.profileorientation = profileorientation

	@apply
	def relatingprofileproperties():
		def fget( self ):
			return self._relatingprofileproperties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingprofileproperties is mantatory and can not be set to None')
			if not check_type(value,ifcprofileproperties):
				self._relatingprofileproperties = ifcprofileproperties(value)
			else:
				self._relatingprofileproperties = value
		return property(**locals())

	@apply
	def profilesectionlocation():
		def fget( self ):
			return self._profilesectionlocation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcshapeaspect):
					self._profilesectionlocation = ifcshapeaspect(value)
				else:
					self._profilesectionlocation = value
			else:
				self._profilesectionlocation = value
		return property(**locals())

	@apply
	def profileorientation():
		def fget( self ):
			return self._profileorientation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcorientationselect):
					self._profileorientation = ifcorientationselect(value)
				else:
					self._profileorientation = value
			else:
				self._profileorientation = value
		return property(**locals())

####################
 # ENTITY ifcorganizationrelationship #
####################
class ifcorganizationrelationship(BaseEntityClass):
	'''Entity ifcorganizationrelationship definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param relatingorganization
	:type relatingorganization:ifcorganization

	:param relatedorganizations
	:type relatedorganizations:SET(1,None,'ifcorganization', scope = schema_scope)
	'''
	def __init__( self , name,description,relatingorganization,relatedorganizations, ):
		self.name = name
		self.description = description
		self.relatingorganization = relatingorganization
		self.relatedorganizations = relatedorganizations

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relatingorganization():
		def fget( self ):
			return self._relatingorganization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingorganization is mantatory and can not be set to None')
			if not check_type(value,ifcorganization):
				self._relatingorganization = ifcorganization(value)
			else:
				self._relatingorganization = value
		return property(**locals())

	@apply
	def relatedorganizations():
		def fget( self ):
			return self._relatedorganizations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedorganizations is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcorganization', scope = schema_scope)):
				self._relatedorganizations = SET(value)
			else:
				self._relatedorganizations = value
		return property(**locals())

####################
 # ENTITY ifcsweptdisksolid #
####################
class ifcsweptdisksolid(ifcsolidmodel):
	'''Entity ifcsweptdisksolid definition.

	:param directrix
	:type directrix:ifccurve

	:param radius
	:type radius:ifcpositivelengthmeasure

	:param innerradius
	:type innerradius:ifcpositivelengthmeasure

	:param startparam
	:type startparam:ifcparametervalue

	:param endparam
	:type endparam:ifcparametervalue
	'''
	def __init__( self , directrix,radius,innerradius,startparam,endparam, ):
		ifcsolidmodel.__init__(self , )
		self.directrix = directrix
		self.radius = radius
		self.innerradius = innerradius
		self.startparam = startparam
		self.endparam = endparam

	@apply
	def directrix():
		def fget( self ):
			return self._directrix
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directrix is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._directrix = ifccurve(value)
			else:
				self._directrix = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def innerradius():
		def fget( self ):
			return self._innerradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._innerradius = ifcpositivelengthmeasure(value)
				else:
					self._innerradius = value
			else:
				self._innerradius = value
		return property(**locals())

	@apply
	def startparam():
		def fget( self ):
			return self._startparam
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument startparam is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._startparam = ifcparametervalue(value)
			else:
				self._startparam = value
		return property(**locals())

	@apply
	def endparam():
		def fget( self ):
			return self._endparam
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument endparam is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._endparam = ifcparametervalue(value)
			else:
				self._endparam = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.directrix.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.innerradius))  or  (self.radius  >  self.innerradius))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifccovering #
####################
class ifccovering(ifcbuildingelement):
	'''Entity ifccovering definition.

	:param predefinedtype
	:type predefinedtype:ifccoveringtypeenum

	:param coversspaces
	:type coversspaces:SET(0,1,'ifcrelcoversspaces', scope = schema_scope)

	:param covers
	:type covers:SET(0,1,'ifcrelcoversbldgelements', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , predefinedtype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccoveringtypeenum):
					self._predefinedtype = ifccoveringtypeenum(value)
				else:
					self._predefinedtype = value
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def coversspaces():
		def fget( self ):
			return self._coversspaces
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument coversspaces is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def covers():
		def fget( self ):
			return self._covers
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument covers is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr61(self):
		eval_wr61_wr = ((( not EXISTS(self.predefinedtype))  or  (self.predefinedtype  !=  ifccoveringtypeenum.self.userdefined))  or  ((self.predefinedtype  ==  ifccoveringtypeenum.self.userdefined)  and  EXISTS(self.self.ifcobject.self.objecttype)))
		if not eval_wr61_wr:
			raise AssertionError('Rule wr61 violated')
		else:
			return eval_wr61_wr


####################
 # ENTITY ifcquantitytime #
####################
class ifcquantitytime(ifcphysicalsimplequantity):
	'''Entity ifcquantitytime definition.

	:param timevalue
	:type timevalue:ifctimemeasure
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , timevalue, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.timevalue = timevalue

	@apply
	def timevalue():
		def fget( self ):
			return self._timevalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timevalue is mantatory and can not be set to None')
			if not check_type(value,ifctimemeasure):
				self._timevalue = ifctimemeasure(value)
			else:
				self._timevalue = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.self.ifcphysicalsimplequantity.self.unit))  or  (self.self.ifcphysicalsimplequantity.self.unit.self.unittype  ==  ifcunitenum.self.timeunit))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.timevalue  >=  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcdocumentinformationrelationship #
####################
class ifcdocumentinformationrelationship(BaseEntityClass):
	'''Entity ifcdocumentinformationrelationship definition.

	:param relatingdocument
	:type relatingdocument:ifcdocumentinformation

	:param relateddocuments
	:type relateddocuments:SET(1,None,'ifcdocumentinformation', scope = schema_scope)

	:param relationshiptype
	:type relationshiptype:ifclabel
	'''
	def __init__( self , relatingdocument,relateddocuments,relationshiptype, ):
		self.relatingdocument = relatingdocument
		self.relateddocuments = relateddocuments
		self.relationshiptype = relationshiptype

	@apply
	def relatingdocument():
		def fget( self ):
			return self._relatingdocument
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingdocument is mantatory and can not be set to None')
			if not check_type(value,ifcdocumentinformation):
				self._relatingdocument = ifcdocumentinformation(value)
			else:
				self._relatingdocument = value
		return property(**locals())

	@apply
	def relateddocuments():
		def fget( self ):
			return self._relateddocuments
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relateddocuments is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcdocumentinformation', scope = schema_scope)):
				self._relateddocuments = SET(value)
			else:
				self._relateddocuments = value
		return property(**locals())

	@apply
	def relationshiptype():
		def fget( self ):
			return self._relationshiptype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._relationshiptype = ifclabel(value)
				else:
					self._relationshiptype = value
			else:
				self._relationshiptype = value
		return property(**locals())

####################
 # ENTITY ifcgeometricrepresentationsubcontext #
####################
class ifcgeometricrepresentationsubcontext(ifcgeometricrepresentationcontext):
	'''Entity ifcgeometricrepresentationsubcontext definition.

	:param parentcontext
	:type parentcontext:ifcgeometricrepresentationcontext

	:param targetscale
	:type targetscale:ifcpositiveratiomeasure

	:param targetview
	:type targetview:ifcgeometricprojectionenum

	:param userdefinedtargetview
	:type userdefinedtargetview:ifclabel

	:param ifcgeometricrepresentationcontext_worldcoordinatesystem
	:type ifcgeometricrepresentationcontext_worldcoordinatesystem:ifcaxis2placement

	:param ifcgeometricrepresentationcontext_coordinatespacedimension
	:type ifcgeometricrepresentationcontext_coordinatespacedimension:ifcdimensioncount

	:param ifcgeometricrepresentationcontext_truenorth
	:type ifcgeometricrepresentationcontext_truenorth:ifcdirection

	:param ifcgeometricrepresentationcontext_precision
	:type ifcgeometricrepresentationcontext_precision:REAL
	'''
	def __init__( self , inherited0__contextidentifier , inherited1__contexttype , inherited2__coordinatespacedimension , inherited3__precision , inherited4__worldcoordinatesystem , inherited5__truenorth , parentcontext,targetscale,targetview,userdefinedtargetview, ):
		ifcgeometricrepresentationcontext.__init__(self , inherited0__contextidentifier , inherited1__contexttype , inherited2__coordinatespacedimension , inherited3__precision , inherited4__worldcoordinatesystem , inherited5__truenorth , )
		self.parentcontext = parentcontext
		self.targetscale = targetscale
		self.targetview = targetview
		self.userdefinedtargetview = userdefinedtargetview

	@apply
	def parentcontext():
		def fget( self ):
			return self._parentcontext
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parentcontext is mantatory and can not be set to None')
			if not check_type(value,ifcgeometricrepresentationcontext):
				self._parentcontext = ifcgeometricrepresentationcontext(value)
			else:
				self._parentcontext = value
		return property(**locals())

	@apply
	def targetscale():
		def fget( self ):
			return self._targetscale
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._targetscale = ifcpositiveratiomeasure(value)
				else:
					self._targetscale = value
			else:
				self._targetscale = value
		return property(**locals())

	@apply
	def targetview():
		def fget( self ):
			return self._targetview
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument targetview is mantatory and can not be set to None')
			if not check_type(value,ifcgeometricprojectionenum):
				self._targetview = ifcgeometricprojectionenum(value)
			else:
				self._targetview = value
		return property(**locals())

	@apply
	def userdefinedtargetview():
		def fget( self ):
			return self._userdefinedtargetview
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedtargetview = ifclabel(value)
				else:
					self._userdefinedtargetview = value
			else:
				self._userdefinedtargetview = value
		return property(**locals())

	@apply
	def ifcgeometricrepresentationcontext_worldcoordinatesystem():
		def fget( self ):
			attribute_eval = self.parentcontext.self.worldcoordinatesystem
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcgeometricrepresentationcontext_worldcoordinatesystem is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ifcgeometricrepresentationcontext_coordinatespacedimension():
		def fget( self ):
			attribute_eval = self.parentcontext.self.coordinatespacedimension
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcgeometricrepresentationcontext_coordinatespacedimension is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ifcgeometricrepresentationcontext_truenorth():
		def fget( self ):
			attribute_eval = NVL(self.parentcontext.self.truenorth,self.self.worldcoordinatesystem.self.p[2])
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcgeometricrepresentationcontext_truenorth is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ifcgeometricrepresentationcontext_precision():
		def fget( self ):
			attribute_eval = NVL(self.parentcontext.self.precision,1e-005)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcgeometricrepresentationcontext_precision is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = ( not ('IFC2X3.IFCGEOMETRICREPRESENTATIONSUBCONTEXT'  ==  TYPEOF(self.parentcontext)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = ((self.targetview  !=  ifcgeometricprojectionenum.self.userdefined)  or  ((self.targetview  ==  ifcgeometricprojectionenum.self.userdefined)  and  EXISTS(self.userdefinedtargetview)))
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr


####################
 # ENTITY ifcdocumentreference #
####################
class ifcdocumentreference(ifcexternalreference):
	'''Entity ifcdocumentreference definition.

	:param referencetodocument
	:type referencetodocument:SET(0,1,'ifcdocumentinformation', scope = schema_scope)
	'''
	def __init__( self , inherited0__location , inherited1__itemreference , inherited2__name ,  ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__itemreference , inherited2__name , )

	@apply
	def referencetodocument():
		def fget( self ):
			return self._referencetodocument
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument referencetodocument is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.name) XOR EXISTS(self.referencetodocument[1]))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcexternallydefinedtextfont #
####################
class ifcexternallydefinedtextfont(ifcexternalreference):
	'''Entity ifcexternallydefinedtextfont definition.
	'''
	def __init__( self , inherited0__location , inherited1__itemreference , inherited2__name ,  ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__itemreference , inherited2__name , )

####################
 # ENTITY ifcnamedunit #
####################
class ifcnamedunit(BaseEntityClass):
	'''Entity ifcnamedunit definition.

	:param dimensions
	:type dimensions:ifcdimensionalexponents

	:param unittype
	:type unittype:ifcunitenum
	'''
	def __init__( self , dimensions,unittype, ):
		self.dimensions = dimensions
		self.unittype = unittype

	@apply
	def dimensions():
		def fget( self ):
			return self._dimensions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dimensions is mantatory and can not be set to None')
			if not check_type(value,ifcdimensionalexponents):
				self._dimensions = ifcdimensionalexponents(value)
			else:
				self._dimensions = value
		return property(**locals())

	@apply
	def unittype():
		def fget( self ):
			return self._unittype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unittype is mantatory and can not be set to None')
			if not check_type(value,ifcunitenum):
				self._unittype = ifcunitenum(value)
			else:
				self._unittype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ifccorrectdimensions(self.self.unittype,self.self.dimensions)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcconstraintaggregationrelationship #
####################
class ifcconstraintaggregationrelationship(BaseEntityClass):
	'''Entity ifcconstraintaggregationrelationship definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param relatingconstraint
	:type relatingconstraint:ifcconstraint

	:param relatedconstraints
	:type relatedconstraints:LIST(1,None,'ifcconstraint', scope = schema_scope)

	:param logicalaggregator
	:type logicalaggregator:ifclogicaloperatorenum
	'''
	def __init__( self , name,description,relatingconstraint,relatedconstraints,logicalaggregator, ):
		self.name = name
		self.description = description
		self.relatingconstraint = relatingconstraint
		self.relatedconstraints = relatedconstraints
		self.logicalaggregator = logicalaggregator

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relatingconstraint():
		def fget( self ):
			return self._relatingconstraint
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingconstraint is mantatory and can not be set to None')
			if not check_type(value,ifcconstraint):
				self._relatingconstraint = ifcconstraint(value)
			else:
				self._relatingconstraint = value
		return property(**locals())

	@apply
	def relatedconstraints():
		def fget( self ):
			return self._relatedconstraints
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedconstraints is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcconstraint', scope = schema_scope)):
				self._relatedconstraints = LIST(value)
			else:
				self._relatedconstraints = value
		return property(**locals())

	@apply
	def logicalaggregator():
		def fget( self ):
			return self._logicalaggregator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument logicalaggregator is mantatory and can not be set to None')
			if not check_type(value,ifclogicaloperatorenum):
				self._logicalaggregator = ifclogicaloperatorenum(value)
			else:
				self._logicalaggregator = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcrelassignstoprojectorder #
####################
class ifcrelassignstoprojectorder(ifcrelassignstocontrol):
	'''Entity ifcrelassignstoprojectorder definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , inherited6__relatingcontrol ,  ):
		ifcrelassignstocontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , inherited6__relatingcontrol , )

####################
 # ENTITY ifcconnectioncurvegeometry #
####################
class ifcconnectioncurvegeometry(ifcconnectiongeometry):
	'''Entity ifcconnectioncurvegeometry definition.

	:param curveonrelatingelement
	:type curveonrelatingelement:ifccurveoredgecurve

	:param curveonrelatedelement
	:type curveonrelatedelement:ifccurveoredgecurve
	'''
	def __init__( self , curveonrelatingelement,curveonrelatedelement, ):
		ifcconnectiongeometry.__init__(self , )
		self.curveonrelatingelement = curveonrelatingelement
		self.curveonrelatedelement = curveonrelatedelement

	@apply
	def curveonrelatingelement():
		def fget( self ):
			return self._curveonrelatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curveonrelatingelement is mantatory and can not be set to None')
			if not check_type(value,ifccurveoredgecurve):
				self._curveonrelatingelement = ifccurveoredgecurve(value)
			else:
				self._curveonrelatingelement = value
		return property(**locals())

	@apply
	def curveonrelatedelement():
		def fget( self ):
			return self._curveonrelatedelement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccurveoredgecurve):
					self._curveonrelatedelement = ifccurveoredgecurve(value)
				else:
					self._curveonrelatedelement = value
			else:
				self._curveonrelatedelement = value
		return property(**locals())

####################
 # ENTITY ifcdraughtingpredefinedcolour #
####################
class ifcdraughtingpredefinedcolour(ifcpredefinedcolour):
	'''Entity ifcdraughtingpredefinedcolour definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefinedcolour.__init__(self , inherited0__name , )
	def wr31(self):
		eval_wr31_wr = (self.self.ifcpredefineditem.self.name  ==  ['black','red','green','blue','yellow','magenta','cyan','white','by layer'])
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcrelcoversspaces #
####################
class ifcrelcoversspaces(ifcrelconnects):
	'''Entity ifcrelcoversspaces definition.

	:param relatedspace
	:type relatedspace:ifcspace

	:param relatedcoverings
	:type relatedcoverings:SET(1,None,'ifccovering', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedspace,relatedcoverings, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedspace = relatedspace
		self.relatedcoverings = relatedcoverings

	@apply
	def relatedspace():
		def fget( self ):
			return self._relatedspace
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedspace is mantatory and can not be set to None')
			if not check_type(value,ifcspace):
				self._relatedspace = ifcspace(value)
			else:
				self._relatedspace = value
		return property(**locals())

	@apply
	def relatedcoverings():
		def fget( self ):
			return self._relatedcoverings
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedcoverings is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifccovering', scope = schema_scope)):
				self._relatedcoverings = SET(value)
			else:
				self._relatedcoverings = value
		return property(**locals())

####################
 # ENTITY ifcstructureddimensioncallout #
####################
class ifcstructureddimensioncallout(ifcdraughtingcallout):
	'''Entity ifcstructureddimensioncallout definition.
	'''
	def __init__( self , inherited0__contents ,  ):
		ifcdraughtingcallout.__init__(self , inherited0__contents , )
	def wr31(self):
		eval_wr31_wr = (SIZEOF(None)  ==  0)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifclaborresource #
####################
class ifclaborresource(ifcconstructionresource):
	'''Entity ifclaborresource definition.

	:param skillset
	:type skillset:ifctext
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity , skillset, ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity , )
		self.skillset = skillset

	@apply
	def skillset():
		def fget( self ):
			return self._skillset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._skillset = ifctext(value)
				else:
					self._skillset = value
			else:
				self._skillset = value
		return property(**locals())

####################
 # ENTITY ifcmechanicalfastenertype #
####################
class ifcmechanicalfastenertype(ifcfastenertype):
	'''Entity ifcmechanicalfastenertype definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype ,  ):
		ifcfastenertype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )

####################
 # ENTITY ifcquantityweight #
####################
class ifcquantityweight(ifcphysicalsimplequantity):
	'''Entity ifcquantityweight definition.

	:param weightvalue
	:type weightvalue:ifcmassmeasure
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , weightvalue, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.weightvalue = weightvalue

	@apply
	def weightvalue():
		def fget( self ):
			return self._weightvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument weightvalue is mantatory and can not be set to None')
			if not check_type(value,ifcmassmeasure):
				self._weightvalue = ifcmassmeasure(value)
			else:
				self._weightvalue = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.self.ifcphysicalsimplequantity.self.unit))  or  (self.self.ifcphysicalsimplequantity.self.unit.self.unittype  ==  ifcunitenum.self.massunit))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.weightvalue  >=  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcstructuralloadgroup #
####################
class ifcstructuralloadgroup(ifcgroup):
	'''Entity ifcstructuralloadgroup definition.

	:param predefinedtype
	:type predefinedtype:ifcloadgrouptypeenum

	:param actiontype
	:type actiontype:ifcactiontypeenum

	:param actionsource
	:type actionsource:ifcactionsourcetypeenum

	:param coefficient
	:type coefficient:ifcratiomeasure

	:param purpose
	:type purpose:ifclabel

	:param sourceofresultgroup
	:type sourceofresultgroup:SET(0,1,'ifcstructuralresultgroup', scope = schema_scope)

	:param loadgroupfor
	:type loadgroupfor:SET(0,None,'ifcstructuralanalysismodel', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , predefinedtype,actiontype,actionsource,coefficient,purpose, ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.predefinedtype = predefinedtype
		self.actiontype = actiontype
		self.actionsource = actionsource
		self.coefficient = coefficient
		self.purpose = purpose

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcloadgrouptypeenum):
				self._predefinedtype = ifcloadgrouptypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def actiontype():
		def fget( self ):
			return self._actiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actiontype is mantatory and can not be set to None')
			if not check_type(value,ifcactiontypeenum):
				self._actiontype = ifcactiontypeenum(value)
			else:
				self._actiontype = value
		return property(**locals())

	@apply
	def actionsource():
		def fget( self ):
			return self._actionsource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actionsource is mantatory and can not be set to None')
			if not check_type(value,ifcactionsourcetypeenum):
				self._actionsource = ifcactionsourcetypeenum(value)
			else:
				self._actionsource = value
		return property(**locals())

	@apply
	def coefficient():
		def fget( self ):
			return self._coefficient
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcratiomeasure):
					self._coefficient = ifcratiomeasure(value)
				else:
					self._coefficient = value
			else:
				self._coefficient = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._purpose = ifclabel(value)
				else:
					self._purpose = value
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def sourceofresultgroup():
		def fget( self ):
			return self._sourceofresultgroup
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument sourceofresultgroup is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def loadgroupfor():
		def fget( self ):
			return self._loadgroupfor
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument loadgroupfor is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcwalltype #
####################
class ifcwalltype(ifcbuildingelementtype):
	'''Entity ifcwalltype definition.

	:param predefinedtype
	:type predefinedtype:ifcwalltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcwalltypeenum):
				self._predefinedtype = ifcwalltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcconstructionmaterialresource #
####################
class ifcconstructionmaterialresource(ifcconstructionresource):
	'''Entity ifcconstructionmaterialresource definition.

	:param suppliers
	:type suppliers:SET(1,None,'ifcactorselect', scope = schema_scope)

	:param usageratio
	:type usageratio:ifcratiomeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity , suppliers,usageratio, ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity , )
		self.suppliers = suppliers
		self.usageratio = usageratio

	@apply
	def suppliers():
		def fget( self ):
			return self._suppliers
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifcactorselect', scope = schema_scope)):
					self._suppliers = SET(value)
				else:
					self._suppliers = value
			else:
				self._suppliers = value
		return property(**locals())

	@apply
	def usageratio():
		def fget( self ):
			return self._usageratio
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcratiomeasure):
					self._usageratio = ifcratiomeasure(value)
				else:
					self._usageratio = value
			else:
				self._usageratio = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.ifcresource.self.resourceof)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.self.ifcresource.self.resourceof[1]))  or  (self.self.ifcresource.self.resourceof[1].self.relatedobjectstype  ==  ifcobjecttypeenum.self.product))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcradiusdimension #
####################
class ifcradiusdimension(ifcdimensioncurvedirectedcallout):
	'''Entity ifcradiusdimension definition.
	'''
	def __init__( self , inherited0__contents ,  ):
		ifcdimensioncurvedirectedcallout.__init__(self , inherited0__contents , )

####################
 # ENTITY ifcapprovalrelationship #
####################
class ifcapprovalrelationship(BaseEntityClass):
	'''Entity ifcapprovalrelationship definition.

	:param relatedapproval
	:type relatedapproval:ifcapproval

	:param relatingapproval
	:type relatingapproval:ifcapproval

	:param description
	:type description:ifctext

	:param name
	:type name:ifclabel
	'''
	def __init__( self , relatedapproval,relatingapproval,description,name, ):
		self.relatedapproval = relatedapproval
		self.relatingapproval = relatingapproval
		self.description = description
		self.name = name

	@apply
	def relatedapproval():
		def fget( self ):
			return self._relatedapproval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedapproval is mantatory and can not be set to None')
			if not check_type(value,ifcapproval):
				self._relatedapproval = ifcapproval(value)
			else:
				self._relatedapproval = value
		return property(**locals())

	@apply
	def relatingapproval():
		def fget( self ):
			return self._relatingapproval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingapproval is mantatory and can not be set to None')
			if not check_type(value,ifcapproval):
				self._relatingapproval = ifcapproval(value)
			else:
				self._relatingapproval = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifcboundingbox #
####################
class ifcboundingbox(ifcgeometricrepresentationitem):
	'''Entity ifcboundingbox definition.

	:param corner
	:type corner:ifccartesianpoint

	:param xdim
	:type xdim:ifcpositivelengthmeasure

	:param ydim
	:type ydim:ifcpositivelengthmeasure

	:param zdim
	:type zdim:ifcpositivelengthmeasure

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , corner,xdim,ydim,zdim, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.corner = corner
		self.xdim = xdim
		self.ydim = ydim
		self.zdim = zdim

	@apply
	def corner():
		def fget( self ):
			return self._corner
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument corner is mantatory and can not be set to None')
			if not check_type(value,ifccartesianpoint):
				self._corner = ifccartesianpoint(value)
			else:
				self._corner = value
		return property(**locals())

	@apply
	def xdim():
		def fget( self ):
			return self._xdim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument xdim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._xdim = ifcpositivelengthmeasure(value)
			else:
				self._xdim = value
		return property(**locals())

	@apply
	def ydim():
		def fget( self ):
			return self._ydim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ydim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._ydim = ifcpositivelengthmeasure(value)
			else:
				self._ydim = value
		return property(**locals())

	@apply
	def zdim():
		def fget( self ):
			return self._zdim
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zdim is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._zdim = ifcpositivelengthmeasure(value)
			else:
				self._zdim = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifctextstylefordefinedfont #
####################
class ifctextstylefordefinedfont(BaseEntityClass):
	'''Entity ifctextstylefordefinedfont definition.

	:param colour
	:type colour:ifccolour

	:param backgroundcolour
	:type backgroundcolour:ifccolour
	'''
	def __init__( self , colour,backgroundcolour, ):
		self.colour = colour
		self.backgroundcolour = backgroundcolour

	@apply
	def colour():
		def fget( self ):
			return self._colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument colour is mantatory and can not be set to None')
			if not check_type(value,ifccolour):
				self._colour = ifccolour(value)
			else:
				self._colour = value
		return property(**locals())

	@apply
	def backgroundcolour():
		def fget( self ):
			return self._backgroundcolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolour):
					self._backgroundcolour = ifccolour(value)
				else:
					self._backgroundcolour = value
			else:
				self._backgroundcolour = value
		return property(**locals())

####################
 # ENTITY ifcconstructionproductresource #
####################
class ifcconstructionproductresource(ifcconstructionresource):
	'''Entity ifcconstructionproductresource definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity ,  ):
		ifcconstructionresource.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__resourceidentifier , inherited6__resourcegroup , inherited7__resourceconsumption , inherited8__basequantity , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.ifcresource.self.resourceof)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.self.ifcresource.self.resourceof[1]))  or  (self.self.ifcresource.self.resourceof[1].self.relatedobjectstype  ==  ifcobjecttypeenum.self.product))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcmonetaryunit #
####################
class ifcmonetaryunit(BaseEntityClass):
	'''Entity ifcmonetaryunit definition.

	:param currency
	:type currency:ifccurrencyenum
	'''
	def __init__( self , currency, ):
		self.currency = currency

	@apply
	def currency():
		def fget( self ):
			return self._currency
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument currency is mantatory and can not be set to None')
			if not check_type(value,ifccurrencyenum):
				self._currency = ifccurrencyenum(value)
			else:
				self._currency = value
		return property(**locals())

####################
 # ENTITY ifcpropertysinglevalue #
####################
class ifcpropertysinglevalue(ifcsimpleproperty):
	'''Entity ifcpropertysinglevalue definition.

	:param nominalvalue
	:type nominalvalue:ifcvalue

	:param unit
	:type unit:ifcunit
	'''
	def __init__( self , inherited0__name , inherited1__description , nominalvalue,unit, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.nominalvalue = nominalvalue
		self.unit = unit

	@apply
	def nominalvalue():
		def fget( self ):
			return self._nominalvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcvalue):
					self._nominalvalue = ifcvalue(value)
				else:
					self._nominalvalue = value
			else:
				self._nominalvalue = value
		return property(**locals())

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._unit = ifcunit(value)
				else:
					self._unit = value
			else:
				self._unit = value
		return property(**locals())

####################
 # ENTITY ifcrelassignstoprocess #
####################
class ifcrelassignstoprocess(ifcrelassigns):
	'''Entity ifcrelassignstoprocess definition.

	:param relatingprocess
	:type relatingprocess:ifcprocess

	:param quantityinprocess
	:type quantityinprocess:ifcmeasurewithunit
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatingprocess,quantityinprocess, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatingprocess = relatingprocess
		self.quantityinprocess = quantityinprocess

	@apply
	def relatingprocess():
		def fget( self ):
			return self._relatingprocess
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingprocess is mantatory and can not be set to None')
			if not check_type(value,ifcprocess):
				self._relatingprocess = ifcprocess(value)
			else:
				self._relatingprocess = value
		return property(**locals())

	@apply
	def quantityinprocess():
		def fget( self ):
			return self._quantityinprocess
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmeasurewithunit):
					self._quantityinprocess = ifcmeasurewithunit(value)
				else:
					self._quantityinprocess = value
			else:
				self._quantityinprocess = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcsiunit #
####################
class ifcsiunit(ifcnamedunit):
	'''Entity ifcsiunit definition.

	:param prefix
	:type prefix:ifcsiprefix

	:param name
	:type name:ifcsiunitname

	:param ifcnamedunit_dimensions
	:type ifcnamedunit_dimensions:ifcdimensionalexponents
	'''
	def __init__( self , inherited0__dimensions , inherited1__unittype , prefix,name, ):
		ifcnamedunit.__init__(self , inherited0__dimensions , inherited1__unittype , )
		self.prefix = prefix
		self.name = name

	@apply
	def prefix():
		def fget( self ):
			return self._prefix
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsiprefix):
					self._prefix = ifcsiprefix(value)
				else:
					self._prefix = value
			else:
				self._prefix = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifcsiunitname):
				self._name = ifcsiunitname(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def ifcnamedunit_dimensions():
		def fget( self ):
			attribute_eval = ifcdimensionsforsiunit(self.self.name)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ifcnamedunit_dimensions is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcspaceheatertype #
####################
class ifcspaceheatertype(ifcenergyconversiondevicetype):
	'''Entity ifcspaceheatertype definition.

	:param predefinedtype
	:type predefinedtype:ifcspaceheatertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcspaceheatertypeenum):
				self._predefinedtype = ifcspaceheatertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcspaceheatertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcspaceheatertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcdistributionchamberelementtype #
####################
class ifcdistributionchamberelementtype(ifcdistributionflowelementtype):
	'''Entity ifcdistributionchamberelementtype definition.

	:param predefinedtype
	:type predefinedtype:ifcdistributionchamberelementtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributionflowelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcdistributionchamberelementtypeenum):
				self._predefinedtype = ifcdistributionchamberelementtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcstructuralcurvemember #
####################
class ifcstructuralcurvemember(ifcstructuralmember):
	'''Entity ifcstructuralcurvemember definition.

	:param predefinedtype
	:type predefinedtype:ifcstructuralcurvetypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , predefinedtype, ):
		ifcstructuralmember.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstructuralcurvetypeenum):
				self._predefinedtype = ifcstructuralcurvetypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcjunctionboxtype #
####################
class ifcjunctionboxtype(ifcflowfittingtype):
	'''Entity ifcjunctionboxtype definition.

	:param predefinedtype
	:type predefinedtype:ifcjunctionboxtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowfittingtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcjunctionboxtypeenum):
				self._predefinedtype = ifcjunctionboxtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifccontextdependentunit #
####################
class ifccontextdependentunit(ifcnamedunit):
	'''Entity ifccontextdependentunit definition.

	:param name
	:type name:ifclabel
	'''
	def __init__( self , inherited0__dimensions , inherited1__unittype , name, ):
		ifcnamedunit.__init__(self , inherited0__dimensions , inherited1__unittype , )
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY ifcsectionproperties #
####################
class ifcsectionproperties(BaseEntityClass):
	'''Entity ifcsectionproperties definition.

	:param sectiontype
	:type sectiontype:ifcsectiontypeenum

	:param startprofile
	:type startprofile:ifcprofiledef

	:param endprofile
	:type endprofile:ifcprofiledef
	'''
	def __init__( self , sectiontype,startprofile,endprofile, ):
		self.sectiontype = sectiontype
		self.startprofile = startprofile
		self.endprofile = endprofile

	@apply
	def sectiontype():
		def fget( self ):
			return self._sectiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sectiontype is mantatory and can not be set to None')
			if not check_type(value,ifcsectiontypeenum):
				self._sectiontype = ifcsectiontypeenum(value)
			else:
				self._sectiontype = value
		return property(**locals())

	@apply
	def startprofile():
		def fget( self ):
			return self._startprofile
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument startprofile is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._startprofile = ifcprofiledef(value)
			else:
				self._startprofile = value
		return property(**locals())

	@apply
	def endprofile():
		def fget( self ):
			return self._endprofile
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcprofiledef):
					self._endprofile = ifcprofiledef(value)
				else:
					self._endprofile = value
			else:
				self._endprofile = value
		return property(**locals())

####################
 # ENTITY ifcshaperepresentation #
####################
class ifcshaperepresentation(ifcshapemodel):
	'''Entity ifcshaperepresentation definition.
	'''
	def __init__( self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items ,  ):
		ifcshapemodel.__init__(self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items , )
	def wr21(self):
		eval_wr21_wr = ('IFC2X3.IFCGEOMETRICREPRESENTATIONCONTEXT'  ==  TYPEOF(self.self.ifcrepresentation.self.contextofitems))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (SIZEOF(None)  ==  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr

	def wr23(self):
		eval_wr23_wr = EXISTS(self.self.ifcrepresentation.self.representationtype)
		if not eval_wr23_wr:
			raise AssertionError('Rule wr23 violated')
		else:
			return eval_wr23_wr

	def wr24(self):
		eval_wr24_wr = ifcshaperepresentationtypes(self.self.ifcrepresentation.self.representationtype,self.self.ifcrepresentation.self.items)
		if not eval_wr24_wr:
			raise AssertionError('Rule wr24 violated')
		else:
			return eval_wr24_wr


####################
 # ENTITY ifcfiltertype #
####################
class ifcfiltertype(ifcflowtreatmentdevicetype):
	'''Entity ifcfiltertype definition.

	:param predefinedtype
	:type predefinedtype:ifcfiltertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowtreatmentdevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcfiltertypeenum):
				self._predefinedtype = ifcfiltertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcfiltertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcfiltertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcspace #
####################
class ifcspace(ifcspatialstructureelement):
	'''Entity ifcspace definition.

	:param interiororexteriorspace
	:type interiororexteriorspace:ifcinternalorexternalenum

	:param elevationwithflooring
	:type elevationwithflooring:ifclengthmeasure

	:param hascoverings
	:type hascoverings:SET(0,None,'ifcrelcoversspaces', scope = schema_scope)

	:param boundedby
	:type boundedby:SET(0,None,'ifcrelspaceboundary', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , interiororexteriorspace,elevationwithflooring, ):
		ifcspatialstructureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , )
		self.interiororexteriorspace = interiororexteriorspace
		self.elevationwithflooring = elevationwithflooring

	@apply
	def interiororexteriorspace():
		def fget( self ):
			return self._interiororexteriorspace
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument interiororexteriorspace is mantatory and can not be set to None')
			if not check_type(value,ifcinternalorexternalenum):
				self._interiororexteriorspace = ifcinternalorexternalenum(value)
			else:
				self._interiororexteriorspace = value
		return property(**locals())

	@apply
	def elevationwithflooring():
		def fget( self ):
			return self._elevationwithflooring
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._elevationwithflooring = ifclengthmeasure(value)
				else:
					self._elevationwithflooring = value
			else:
				self._elevationwithflooring = value
		return property(**locals())

	@apply
	def hascoverings():
		def fget( self ):
			return self._hascoverings
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hascoverings is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def boundedby():
		def fget( self ):
			return self._boundedby
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument boundedby is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcflowterminal #
####################
class ifcflowterminal(ifcdistributionflowelement):
	'''Entity ifcflowterminal definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcpolyloop #
####################
class ifcpolyloop(ifcloop):
	'''Entity ifcpolyloop definition.

	:param polygon
	:type polygon:LIST(3,None,'ifccartesianpoint', scope = schema_scope)
	'''
	def __init__( self , polygon, ):
		ifcloop.__init__(self , )
		self.polygon = polygon

	@apply
	def polygon():
		def fget( self ):
			return self._polygon
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument polygon is mantatory and can not be set to None')
			if not check_type(value,LIST(3,None,'ifccartesianpoint', scope = schema_scope)):
				self._polygon = LIST(value)
			else:
				self._polygon = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (SIZEOF(None)  ==  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcrelassociatesmaterial #
####################
class ifcrelassociatesmaterial(ifcrelassociates):
	'''Entity ifcrelassociatesmaterial definition.

	:param relatingmaterial
	:type relatingmaterial:ifcmaterialselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingmaterial, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingmaterial = relatingmaterial

	@apply
	def relatingmaterial():
		def fget( self ):
			return self._relatingmaterial
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingmaterial is mantatory and can not be set to None')
			if not check_type(value,ifcmaterialselect):
				self._relatingmaterial = ifcmaterialselect(value)
			else:
				self._relatingmaterial = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (SIZEOF(None)  ==  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (SIZEOF(None)  ==  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifccshapeprofiledef #
####################
class ifccshapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifccshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param width
	:type width:ifcpositivelengthmeasure

	:param wallthickness
	:type wallthickness:ifcpositivelengthmeasure

	:param girth
	:type girth:ifcpositivelengthmeasure

	:param internalfilletradius
	:type internalfilletradius:ifcpositivelengthmeasure

	:param centreofgravityinx
	:type centreofgravityinx:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , depth,width,wallthickness,girth,internalfilletradius,centreofgravityinx, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.depth = depth
		self.width = width
		self.wallthickness = wallthickness
		self.girth = girth
		self.internalfilletradius = internalfilletradius
		self.centreofgravityinx = centreofgravityinx

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def width():
		def fget( self ):
			return self._width
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument width is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._width = ifcpositivelengthmeasure(value)
			else:
				self._width = value
		return property(**locals())

	@apply
	def wallthickness():
		def fget( self ):
			return self._wallthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument wallthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._wallthickness = ifcpositivelengthmeasure(value)
			else:
				self._wallthickness = value
		return property(**locals())

	@apply
	def girth():
		def fget( self ):
			return self._girth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument girth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._girth = ifcpositivelengthmeasure(value)
			else:
				self._girth = value
		return property(**locals())

	@apply
	def internalfilletradius():
		def fget( self ):
			return self._internalfilletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._internalfilletradius = ifcpositivelengthmeasure(value)
				else:
					self._internalfilletradius = value
			else:
				self._internalfilletradius = value
		return property(**locals())

	@apply
	def centreofgravityinx():
		def fget( self ):
			return self._centreofgravityinx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._centreofgravityinx = ifcpositivelengthmeasure(value)
				else:
					self._centreofgravityinx = value
			else:
				self._centreofgravityinx = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.girth  <  (self.depth / 2))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.internalfilletradius))  or  ((self.internalfilletradius  <=  (self.width / 2))  and  (self.internalfilletradius  <=  (self.depth / 2))))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((self.wallthickness  <  (self.width / 2))  and  (self.wallthickness  <  (self.depth / 2)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcpropertytablevalue #
####################
class ifcpropertytablevalue(ifcsimpleproperty):
	'''Entity ifcpropertytablevalue definition.

	:param definingvalues
	:type definingvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param definedvalues
	:type definedvalues:LIST(1,None,'ifcvalue', scope = schema_scope)

	:param expression
	:type expression:ifctext

	:param definingunit
	:type definingunit:ifcunit

	:param definedunit
	:type definedunit:ifcunit
	'''
	def __init__( self , inherited0__name , inherited1__description , definingvalues,definedvalues,expression,definingunit,definedunit, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.definingvalues = definingvalues
		self.definedvalues = definedvalues
		self.expression = expression
		self.definingunit = definingunit
		self.definedunit = definedunit

	@apply
	def definingvalues():
		def fget( self ):
			return self._definingvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definingvalues is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
				self._definingvalues = LIST(value)
			else:
				self._definingvalues = value
		return property(**locals())

	@apply
	def definedvalues():
		def fget( self ):
			return self._definedvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definedvalues is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
				self._definedvalues = LIST(value)
			else:
				self._definedvalues = value
		return property(**locals())

	@apply
	def expression():
		def fget( self ):
			return self._expression
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._expression = ifctext(value)
				else:
					self._expression = value
			else:
				self._expression = value
		return property(**locals())

	@apply
	def definingunit():
		def fget( self ):
			return self._definingunit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._definingunit = ifcunit(value)
				else:
					self._definingunit = value
			else:
				self._definingunit = value
		return property(**locals())

	@apply
	def definedunit():
		def fget( self ):
			return self._definedunit
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcunit):
					self._definedunit = ifcunit(value)
				else:
					self._definedunit = value
			else:
				self._definedunit = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.definingvalues)  ==  SIZEOF(self.definedvalues))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcstructuralloadplanarforce #
####################
class ifcstructuralloadplanarforce(ifcstructuralloadstatic):
	'''Entity ifcstructuralloadplanarforce definition.

	:param planarforcex
	:type planarforcex:ifcplanarforcemeasure

	:param planarforcey
	:type planarforcey:ifcplanarforcemeasure

	:param planarforcez
	:type planarforcez:ifcplanarforcemeasure
	'''
	def __init__( self , inherited0__name , planarforcex,planarforcey,planarforcez, ):
		ifcstructuralloadstatic.__init__(self , inherited0__name , )
		self.planarforcex = planarforcex
		self.planarforcey = planarforcey
		self.planarforcez = planarforcez

	@apply
	def planarforcex():
		def fget( self ):
			return self._planarforcex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplanarforcemeasure):
					self._planarforcex = ifcplanarforcemeasure(value)
				else:
					self._planarforcex = value
			else:
				self._planarforcex = value
		return property(**locals())

	@apply
	def planarforcey():
		def fget( self ):
			return self._planarforcey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplanarforcemeasure):
					self._planarforcey = ifcplanarforcemeasure(value)
				else:
					self._planarforcey = value
			else:
				self._planarforcey = value
		return property(**locals())

	@apply
	def planarforcez():
		def fget( self ):
			return self._planarforcez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplanarforcemeasure):
					self._planarforcez = ifcplanarforcemeasure(value)
				else:
					self._planarforcez = value
			else:
				self._planarforcez = value
		return property(**locals())

####################
 # ENTITY ifcbooleanclippingresult #
####################
class ifcbooleanclippingresult(ifcbooleanresult):
	'''Entity ifcbooleanclippingresult definition.
	'''
	def __init__( self , inherited0__operator , inherited1__firstoperand , inherited2__secondoperand ,  ):
		ifcbooleanresult.__init__(self , inherited0__operator , inherited1__firstoperand , inherited2__secondoperand , )
	def wr1(self):
		eval_wr1_wr = (('IFC2X3.IFCSWEPTAREASOLID'  ==  TYPEOF(self.firstoperand))  or  ('IFC2X3.IFCBOOLEANCLIPPINGRESULT'  ==  TYPEOF(self.firstoperand)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('IFC2X3.IFCHALFSPACESOLID'  ==  TYPEOF(self.secondoperand))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.operator  ==  difference)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ifcbuildingstorey #
####################
class ifcbuildingstorey(ifcspatialstructureelement):
	'''Entity ifcbuildingstorey definition.

	:param elevation
	:type elevation:ifclengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , elevation, ):
		ifcspatialstructureelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__longname , inherited8__compositiontype , )
		self.elevation = elevation

	@apply
	def elevation():
		def fget( self ):
			return self._elevation
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._elevation = ifclengthmeasure(value)
				else:
					self._elevation = value
			else:
				self._elevation = value
		return property(**locals())

####################
 # ENTITY ifcsectionreinforcementproperties #
####################
class ifcsectionreinforcementproperties(BaseEntityClass):
	'''Entity ifcsectionreinforcementproperties definition.

	:param longitudinalstartposition
	:type longitudinalstartposition:ifclengthmeasure

	:param longitudinalendposition
	:type longitudinalendposition:ifclengthmeasure

	:param transverseposition
	:type transverseposition:ifclengthmeasure

	:param reinforcementrole
	:type reinforcementrole:ifcreinforcingbarroleenum

	:param sectiondefinition
	:type sectiondefinition:ifcsectionproperties

	:param crosssectionreinforcementdefinitions
	:type crosssectionreinforcementdefinitions:SET(1,None,'ifcreinforcementbarproperties', scope = schema_scope)
	'''
	def __init__( self , longitudinalstartposition,longitudinalendposition,transverseposition,reinforcementrole,sectiondefinition,crosssectionreinforcementdefinitions, ):
		self.longitudinalstartposition = longitudinalstartposition
		self.longitudinalendposition = longitudinalendposition
		self.transverseposition = transverseposition
		self.reinforcementrole = reinforcementrole
		self.sectiondefinition = sectiondefinition
		self.crosssectionreinforcementdefinitions = crosssectionreinforcementdefinitions

	@apply
	def longitudinalstartposition():
		def fget( self ):
			return self._longitudinalstartposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument longitudinalstartposition is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._longitudinalstartposition = ifclengthmeasure(value)
			else:
				self._longitudinalstartposition = value
		return property(**locals())

	@apply
	def longitudinalendposition():
		def fget( self ):
			return self._longitudinalendposition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument longitudinalendposition is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._longitudinalendposition = ifclengthmeasure(value)
			else:
				self._longitudinalendposition = value
		return property(**locals())

	@apply
	def transverseposition():
		def fget( self ):
			return self._transverseposition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._transverseposition = ifclengthmeasure(value)
				else:
					self._transverseposition = value
			else:
				self._transverseposition = value
		return property(**locals())

	@apply
	def reinforcementrole():
		def fget( self ):
			return self._reinforcementrole
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reinforcementrole is mantatory and can not be set to None')
			if not check_type(value,ifcreinforcingbarroleenum):
				self._reinforcementrole = ifcreinforcingbarroleenum(value)
			else:
				self._reinforcementrole = value
		return property(**locals())

	@apply
	def sectiondefinition():
		def fget( self ):
			return self._sectiondefinition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sectiondefinition is mantatory and can not be set to None')
			if not check_type(value,ifcsectionproperties):
				self._sectiondefinition = ifcsectionproperties(value)
			else:
				self._sectiondefinition = value
		return property(**locals())

	@apply
	def crosssectionreinforcementdefinitions():
		def fget( self ):
			return self._crosssectionreinforcementdefinitions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument crosssectionreinforcementdefinitions is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcreinforcementbarproperties', scope = schema_scope)):
				self._crosssectionreinforcementdefinitions = SET(value)
			else:
				self._crosssectionreinforcementdefinitions = value
		return property(**locals())

####################
 # ENTITY ifcrelassignstoresource #
####################
class ifcrelassignstoresource(ifcrelassigns):
	'''Entity ifcrelassignstoresource definition.

	:param relatingresource
	:type relatingresource:ifcresource
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatingresource, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatingresource = relatingresource

	@apply
	def relatingresource():
		def fget( self ):
			return self._relatingresource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingresource is mantatory and can not be set to None')
			if not check_type(value,ifcresource):
				self._relatingresource = ifcresource(value)
			else:
				self._relatingresource = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifclineardimension #
####################
class ifclineardimension(ifcdimensioncurvedirectedcallout):
	'''Entity ifclineardimension definition.
	'''
	def __init__( self , inherited0__contents ,  ):
		ifcdimensioncurvedirectedcallout.__init__(self , inherited0__contents , )

####################
 # ENTITY ifcprocedure #
####################
class ifcprocedure(ifcprocess):
	'''Entity ifcprocedure definition.

	:param procedureid
	:type procedureid:ifcidentifier

	:param proceduretype
	:type proceduretype:ifcproceduretypeenum

	:param userdefinedproceduretype
	:type userdefinedproceduretype:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , procedureid,proceduretype,userdefinedproceduretype, ):
		ifcprocess.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.procedureid = procedureid
		self.proceduretype = proceduretype
		self.userdefinedproceduretype = userdefinedproceduretype

	@apply
	def procedureid():
		def fget( self ):
			return self._procedureid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument procedureid is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._procedureid = ifcidentifier(value)
			else:
				self._procedureid = value
		return property(**locals())

	@apply
	def proceduretype():
		def fget( self ):
			return self._proceduretype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument proceduretype is mantatory and can not be set to None')
			if not check_type(value,ifcproceduretypeenum):
				self._proceduretype = ifcproceduretypeenum(value)
			else:
				self._proceduretype = value
		return property(**locals())

	@apply
	def userdefinedproceduretype():
		def fget( self ):
			return self._userdefinedproceduretype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedproceduretype = ifclabel(value)
				else:
					self._userdefinedproceduretype = value
			else:
				self._userdefinedproceduretype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.proceduretype  !=  ifcproceduretypeenum.self.userdefined)  or  ((self.proceduretype  ==  ifcproceduretypeenum.self.userdefined)  and  EXISTS(self.self.ifcprocedure.self.userdefinedproceduretype)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY ifcactionrequest #
####################
class ifcactionrequest(ifccontrol):
	'''Entity ifcactionrequest definition.

	:param requestid
	:type requestid:ifcidentifier
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , requestid, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.requestid = requestid

	@apply
	def requestid():
		def fget( self ):
			return self._requestid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument requestid is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._requestid = ifcidentifier(value)
			else:
				self._requestid = value
		return property(**locals())

####################
 # ENTITY ifcinventory #
####################
class ifcinventory(ifcgroup):
	'''Entity ifcinventory definition.

	:param inventorytype
	:type inventorytype:ifcinventorytypeenum

	:param jurisdiction
	:type jurisdiction:ifcactorselect

	:param responsiblepersons
	:type responsiblepersons:SET(1,None,'ifcperson', scope = schema_scope)

	:param lastupdatedate
	:type lastupdatedate:ifccalendardate

	:param currentvalue
	:type currentvalue:ifccostvalue

	:param originalvalue
	:type originalvalue:ifccostvalue
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inventorytype,jurisdiction,responsiblepersons,lastupdatedate,currentvalue,originalvalue, ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.inventorytype = inventorytype
		self.jurisdiction = jurisdiction
		self.responsiblepersons = responsiblepersons
		self.lastupdatedate = lastupdatedate
		self.currentvalue = currentvalue
		self.originalvalue = originalvalue

	@apply
	def inventorytype():
		def fget( self ):
			return self._inventorytype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument inventorytype is mantatory and can not be set to None')
			if not check_type(value,ifcinventorytypeenum):
				self._inventorytype = ifcinventorytypeenum(value)
			else:
				self._inventorytype = value
		return property(**locals())

	@apply
	def jurisdiction():
		def fget( self ):
			return self._jurisdiction
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument jurisdiction is mantatory and can not be set to None')
			if not check_type(value,ifcactorselect):
				self._jurisdiction = ifcactorselect(value)
			else:
				self._jurisdiction = value
		return property(**locals())

	@apply
	def responsiblepersons():
		def fget( self ):
			return self._responsiblepersons
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument responsiblepersons is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcperson', scope = schema_scope)):
				self._responsiblepersons = SET(value)
			else:
				self._responsiblepersons = value
		return property(**locals())

	@apply
	def lastupdatedate():
		def fget( self ):
			return self._lastupdatedate
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lastupdatedate is mantatory and can not be set to None')
			if not check_type(value,ifccalendardate):
				self._lastupdatedate = ifccalendardate(value)
			else:
				self._lastupdatedate = value
		return property(**locals())

	@apply
	def currentvalue():
		def fget( self ):
			return self._currentvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccostvalue):
					self._currentvalue = ifccostvalue(value)
				else:
					self._currentvalue = value
			else:
				self._currentvalue = value
		return property(**locals())

	@apply
	def originalvalue():
		def fget( self ):
			return self._originalvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccostvalue):
					self._originalvalue = ifccostvalue(value)
				else:
					self._originalvalue = value
			else:
				self._originalvalue = value
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = (SIZEOF(None)  ==  0)
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr


####################
 # ENTITY ifcclassificationitemrelationship #
####################
class ifcclassificationitemrelationship(BaseEntityClass):
	'''Entity ifcclassificationitemrelationship definition.

	:param relatingitem
	:type relatingitem:ifcclassificationitem

	:param relateditems
	:type relateditems:SET(1,None,'ifcclassificationitem', scope = schema_scope)
	'''
	def __init__( self , relatingitem,relateditems, ):
		self.relatingitem = relatingitem
		self.relateditems = relateditems

	@apply
	def relatingitem():
		def fget( self ):
			return self._relatingitem
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingitem is mantatory and can not be set to None')
			if not check_type(value,ifcclassificationitem):
				self._relatingitem = ifcclassificationitem(value)
			else:
				self._relatingitem = value
		return property(**locals())

	@apply
	def relateditems():
		def fget( self ):
			return self._relateditems
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relateditems is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcclassificationitem', scope = schema_scope)):
				self._relateditems = SET(value)
			else:
				self._relateditems = value
		return property(**locals())

####################
 # ENTITY ifcpredefinedterminatorsymbol #
####################
class ifcpredefinedterminatorsymbol(ifcpredefinedsymbol):
	'''Entity ifcpredefinedterminatorsymbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefinedsymbol.__init__(self , inherited0__name , )
	def wr31(self):
		eval_wr31_wr = (self.self.ifcpredefineditem.self.name  ==  ['blanked arrow','blanked box','blanked dot','dimension origin','filled arrow','filled box','filled dot','integral symbol','open arrow','slash','unfilled arrow'])
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcrelconnectspathelements #
####################
class ifcrelconnectspathelements(ifcrelconnectselements):
	'''Entity ifcrelconnectspathelements definition.

	:param relatingpriorities
	:type relatingpriorities:LIST(0,None,'INTEGER', scope = schema_scope)

	:param relatedpriorities
	:type relatedpriorities:LIST(0,None,'INTEGER', scope = schema_scope)

	:param relatedconnectiontype
	:type relatedconnectiontype:ifcconnectiontypeenum

	:param relatingconnectiontype
	:type relatingconnectiontype:ifcconnectiontypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__connectiongeometry , inherited5__relatingelement , inherited6__relatedelement , relatingpriorities,relatedpriorities,relatedconnectiontype,relatingconnectiontype, ):
		ifcrelconnectselements.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__connectiongeometry , inherited5__relatingelement , inherited6__relatedelement , )
		self.relatingpriorities = relatingpriorities
		self.relatedpriorities = relatedpriorities
		self.relatedconnectiontype = relatedconnectiontype
		self.relatingconnectiontype = relatingconnectiontype

	@apply
	def relatingpriorities():
		def fget( self ):
			return self._relatingpriorities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingpriorities is mantatory and can not be set to None')
			if not check_type(value,LIST(0,None,'INTEGER', scope = schema_scope)):
				self._relatingpriorities = LIST(value)
			else:
				self._relatingpriorities = value
		return property(**locals())

	@apply
	def relatedpriorities():
		def fget( self ):
			return self._relatedpriorities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedpriorities is mantatory and can not be set to None')
			if not check_type(value,LIST(0,None,'INTEGER', scope = schema_scope)):
				self._relatedpriorities = LIST(value)
			else:
				self._relatedpriorities = value
		return property(**locals())

	@apply
	def relatedconnectiontype():
		def fget( self ):
			return self._relatedconnectiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedconnectiontype is mantatory and can not be set to None')
			if not check_type(value,ifcconnectiontypeenum):
				self._relatedconnectiontype = ifcconnectiontypeenum(value)
			else:
				self._relatedconnectiontype = value
		return property(**locals())

	@apply
	def relatingconnectiontype():
		def fget( self ):
			return self._relatingconnectiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingconnectiontype is mantatory and can not be set to None')
			if not check_type(value,ifcconnectiontypeenum):
				self._relatingconnectiontype = ifcconnectiontypeenum(value)
			else:
				self._relatingconnectiontype = value
		return property(**locals())

####################
 # ENTITY ifccurtainwalltype #
####################
class ifccurtainwalltype(ifcbuildingelementtype):
	'''Entity ifccurtainwalltype definition.

	:param predefinedtype
	:type predefinedtype:ifccurtainwalltypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccurtainwalltypeenum):
				self._predefinedtype = ifccurtainwalltypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcdraughtingpredefinedcurvefont #
####################
class ifcdraughtingpredefinedcurvefont(ifcpredefinedcurvefont):
	'''Entity ifcdraughtingpredefinedcurvefont definition.
	'''
	def __init__( self , inherited0__name ,  ):
		ifcpredefinedcurvefont.__init__(self , inherited0__name , )
	def wr31(self):
		eval_wr31_wr = (self.self.ifcpredefineditem.self.name  ==  ['continuous','chain','chain double dash','dashed','dotted','by layer'])
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcrelcoversbldgelements #
####################
class ifcrelcoversbldgelements(ifcrelconnects):
	'''Entity ifcrelcoversbldgelements definition.

	:param relatingbuildingelement
	:type relatingbuildingelement:ifcelement

	:param relatedcoverings
	:type relatedcoverings:SET(1,None,'ifccovering', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingbuildingelement,relatedcoverings, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingbuildingelement = relatingbuildingelement
		self.relatedcoverings = relatedcoverings

	@apply
	def relatingbuildingelement():
		def fget( self ):
			return self._relatingbuildingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingbuildingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatingbuildingelement = ifcelement(value)
			else:
				self._relatingbuildingelement = value
		return property(**locals())

	@apply
	def relatedcoverings():
		def fget( self ):
			return self._relatedcoverings
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedcoverings is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifccovering', scope = schema_scope)):
				self._relatedcoverings = SET(value)
			else:
				self._relatedcoverings = value
		return property(**locals())

####################
 # ENTITY ifcdoorstyle #
####################
class ifcdoorstyle(ifctypeproduct):
	'''Entity ifcdoorstyle definition.

	:param operationtype
	:type operationtype:ifcdoorstyleoperationenum

	:param constructiontype
	:type constructiontype:ifcdoorstyleconstructionenum

	:param parametertakesprecedence
	:type parametertakesprecedence:BOOLEAN

	:param sizeable
	:type sizeable:BOOLEAN
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , operationtype,constructiontype,parametertakesprecedence,sizeable, ):
		ifctypeproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , )
		self.operationtype = operationtype
		self.constructiontype = constructiontype
		self.parametertakesprecedence = parametertakesprecedence
		self.sizeable = sizeable

	@apply
	def operationtype():
		def fget( self ):
			return self._operationtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operationtype is mantatory and can not be set to None')
			if not check_type(value,ifcdoorstyleoperationenum):
				self._operationtype = ifcdoorstyleoperationenum(value)
			else:
				self._operationtype = value
		return property(**locals())

	@apply
	def constructiontype():
		def fget( self ):
			return self._constructiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constructiontype is mantatory and can not be set to None')
			if not check_type(value,ifcdoorstyleconstructionenum):
				self._constructiontype = ifcdoorstyleconstructionenum(value)
			else:
				self._constructiontype = value
		return property(**locals())

	@apply
	def parametertakesprecedence():
		def fget( self ):
			return self._parametertakesprecedence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parametertakesprecedence is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._parametertakesprecedence = BOOLEAN(value)
			else:
				self._parametertakesprecedence = value
		return property(**locals())

	@apply
	def sizeable():
		def fget( self ):
			return self._sizeable
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sizeable is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._sizeable = BOOLEAN(value)
			else:
				self._sizeable = value
		return property(**locals())

####################
 # ENTITY ifcellipse #
####################
class ifcellipse(ifcconic):
	'''Entity ifcellipse definition.

	:param semiaxis1
	:type semiaxis1:ifcpositivelengthmeasure

	:param semiaxis2
	:type semiaxis2:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , semiaxis1,semiaxis2, ):
		ifcconic.__init__(self , inherited0__position , )
		self.semiaxis1 = semiaxis1
		self.semiaxis2 = semiaxis2

	@apply
	def semiaxis1():
		def fget( self ):
			return self._semiaxis1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semiaxis1 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._semiaxis1 = ifcpositivelengthmeasure(value)
			else:
				self._semiaxis1 = value
		return property(**locals())

	@apply
	def semiaxis2():
		def fget( self ):
			return self._semiaxis2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semiaxis2 is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._semiaxis2 = ifcpositivelengthmeasure(value)
			else:
				self._semiaxis2 = value
		return property(**locals())

####################
 # ENTITY ifcstairflighttype #
####################
class ifcstairflighttype(ifcbuildingelementtype):
	'''Entity ifcstairflighttype definition.

	:param predefinedtype
	:type predefinedtype:ifcstairflighttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcstairflighttypeenum):
				self._predefinedtype = ifcstairflighttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcstructuralloadtemperature #
####################
class ifcstructuralloadtemperature(ifcstructuralloadstatic):
	'''Entity ifcstructuralloadtemperature definition.

	:param deltat_constant
	:type deltat_constant:ifcthermodynamictemperaturemeasure

	:param deltat_y
	:type deltat_y:ifcthermodynamictemperaturemeasure

	:param deltat_z
	:type deltat_z:ifcthermodynamictemperaturemeasure
	'''
	def __init__( self , inherited0__name , deltat_constant,deltat_y,deltat_z, ):
		ifcstructuralloadstatic.__init__(self , inherited0__name , )
		self.deltat_constant = deltat_constant
		self.deltat_y = deltat_y
		self.deltat_z = deltat_z

	@apply
	def deltat_constant():
		def fget( self ):
			return self._deltat_constant
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermodynamictemperaturemeasure):
					self._deltat_constant = ifcthermodynamictemperaturemeasure(value)
				else:
					self._deltat_constant = value
			else:
				self._deltat_constant = value
		return property(**locals())

	@apply
	def deltat_y():
		def fget( self ):
			return self._deltat_y
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermodynamictemperaturemeasure):
					self._deltat_y = ifcthermodynamictemperaturemeasure(value)
				else:
					self._deltat_y = value
			else:
				self._deltat_y = value
		return property(**locals())

	@apply
	def deltat_z():
		def fget( self ):
			return self._deltat_z
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermodynamictemperaturemeasure):
					self._deltat_z = ifcthermodynamictemperaturemeasure(value)
				else:
					self._deltat_z = value
			else:
				self._deltat_z = value
		return property(**locals())

####################
 # ENTITY ifcapprovalactorrelationship #
####################
class ifcapprovalactorrelationship(BaseEntityClass):
	'''Entity ifcapprovalactorrelationship definition.

	:param actor
	:type actor:ifcactorselect

	:param approval
	:type approval:ifcapproval

	:param role
	:type role:ifcactorrole
	'''
	def __init__( self , actor,approval,role, ):
		self.actor = actor
		self.approval = approval
		self.role = role

	@apply
	def actor():
		def fget( self ):
			return self._actor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actor is mantatory and can not be set to None')
			if not check_type(value,ifcactorselect):
				self._actor = ifcactorselect(value)
			else:
				self._actor = value
		return property(**locals())

	@apply
	def approval():
		def fget( self ):
			return self._approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument approval is mantatory and can not be set to None')
			if not check_type(value,ifcapproval):
				self._approval = ifcapproval(value)
			else:
				self._approval = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,ifcactorrole):
				self._role = ifcactorrole(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY ifclshapeprofiledef #
####################
class ifclshapeprofiledef(ifcparameterizedprofiledef):
	'''Entity ifclshapeprofiledef definition.

	:param depth
	:type depth:ifcpositivelengthmeasure

	:param width
	:type width:ifcpositivelengthmeasure

	:param thickness
	:type thickness:ifcpositivelengthmeasure

	:param filletradius
	:type filletradius:ifcpositivelengthmeasure

	:param edgeradius
	:type edgeradius:ifcpositivelengthmeasure

	:param legslope
	:type legslope:ifcplaneanglemeasure

	:param centreofgravityinx
	:type centreofgravityinx:ifcpositivelengthmeasure

	:param centreofgravityiny
	:type centreofgravityiny:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , depth,width,thickness,filletradius,edgeradius,legslope,centreofgravityinx,centreofgravityiny, ):
		ifcparameterizedprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , )
		self.depth = depth
		self.width = width
		self.thickness = thickness
		self.filletradius = filletradius
		self.edgeradius = edgeradius
		self.legslope = legslope
		self.centreofgravityinx = centreofgravityinx
		self.centreofgravityiny = centreofgravityiny

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._depth = ifcpositivelengthmeasure(value)
			else:
				self._depth = value
		return property(**locals())

	@apply
	def width():
		def fget( self ):
			return self._width
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._width = ifcpositivelengthmeasure(value)
				else:
					self._width = value
			else:
				self._width = value
		return property(**locals())

	@apply
	def thickness():
		def fget( self ):
			return self._thickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._thickness = ifcpositivelengthmeasure(value)
			else:
				self._thickness = value
		return property(**locals())

	@apply
	def filletradius():
		def fget( self ):
			return self._filletradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._filletradius = ifcpositivelengthmeasure(value)
				else:
					self._filletradius = value
			else:
				self._filletradius = value
		return property(**locals())

	@apply
	def edgeradius():
		def fget( self ):
			return self._edgeradius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._edgeradius = ifcpositivelengthmeasure(value)
				else:
					self._edgeradius = value
			else:
				self._edgeradius = value
		return property(**locals())

	@apply
	def legslope():
		def fget( self ):
			return self._legslope
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._legslope = ifcplaneanglemeasure(value)
				else:
					self._legslope = value
			else:
				self._legslope = value
		return property(**locals())

	@apply
	def centreofgravityinx():
		def fget( self ):
			return self._centreofgravityinx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._centreofgravityinx = ifcpositivelengthmeasure(value)
				else:
					self._centreofgravityinx = value
			else:
				self._centreofgravityinx = value
		return property(**locals())

	@apply
	def centreofgravityiny():
		def fget( self ):
			return self._centreofgravityiny
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._centreofgravityiny = ifcpositivelengthmeasure(value)
				else:
					self._centreofgravityiny = value
			else:
				self._centreofgravityiny = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (self.thickness  <  self.depth)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (( not EXISTS(self.width))  or  (self.thickness  <  self.width))
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcflowinstrumenttype #
####################
class ifcflowinstrumenttype(ifcdistributioncontrolelementtype):
	'''Entity ifcflowinstrumenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcflowinstrumenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcflowinstrumenttypeenum):
				self._predefinedtype = ifcflowinstrumenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifccircle #
####################
class ifccircle(ifcconic):
	'''Entity ifccircle definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , radius, ):
		ifcconic.__init__(self , inherited0__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY ifcdistributionchamberelement #
####################
class ifcdistributionchamberelement(ifcdistributionflowelement):
	'''Entity ifcdistributionchamberelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcmotorconnectiontype #
####################
class ifcmotorconnectiontype(ifcenergyconversiondevicetype):
	'''Entity ifcmotorconnectiontype definition.

	:param predefinedtype
	:type predefinedtype:ifcmotorconnectiontypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcmotorconnectiontypeenum):
				self._predefinedtype = ifcmotorconnectiontypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcshellbasedsurfacemodel #
####################
class ifcshellbasedsurfacemodel(ifcgeometricrepresentationitem):
	'''Entity ifcshellbasedsurfacemodel definition.

	:param sbsmboundary
	:type sbsmboundary:SET(1,None,'ifcshell', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , sbsmboundary, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.sbsmboundary = sbsmboundary

	@apply
	def sbsmboundary():
		def fget( self ):
			return self._sbsmboundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sbsmboundary is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcshell', scope = schema_scope)):
				self._sbsmboundary = SET(value)
			else:
				self._sbsmboundary = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = 3
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcprojectorder #
####################
class ifcprojectorder(ifccontrol):
	'''Entity ifcprojectorder definition.

	:param id
	:type id:ifcidentifier

	:param predefinedtype
	:type predefinedtype:ifcprojectordertypeenum

	:param status
	:type status:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , id,predefinedtype,status, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.id = id
		self.predefinedtype = predefinedtype
		self.status = status

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._id = ifcidentifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcprojectordertypeenum):
				self._predefinedtype = ifcprojectordertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._status = ifclabel(value)
				else:
					self._status = value
			else:
				self._status = value
		return property(**locals())

####################
 # ENTITY ifcrampflighttype #
####################
class ifcrampflighttype(ifcbuildingelementtype):
	'''Entity ifcrampflighttype definition.

	:param predefinedtype
	:type predefinedtype:ifcrampflighttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcrampflighttypeenum):
				self._predefinedtype = ifcrampflighttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcsurfacecurvesweptareasolid #
####################
class ifcsurfacecurvesweptareasolid(ifcsweptareasolid):
	'''Entity ifcsurfacecurvesweptareasolid definition.

	:param directrix
	:type directrix:ifccurve

	:param startparam
	:type startparam:ifcparametervalue

	:param endparam
	:type endparam:ifcparametervalue

	:param referencesurface
	:type referencesurface:ifcsurface
	'''
	def __init__( self , inherited0__sweptarea , inherited1__position , directrix,startparam,endparam,referencesurface, ):
		ifcsweptareasolid.__init__(self , inherited0__sweptarea , inherited1__position , )
		self.directrix = directrix
		self.startparam = startparam
		self.endparam = endparam
		self.referencesurface = referencesurface

	@apply
	def directrix():
		def fget( self ):
			return self._directrix
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directrix is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._directrix = ifccurve(value)
			else:
				self._directrix = value
		return property(**locals())

	@apply
	def startparam():
		def fget( self ):
			return self._startparam
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument startparam is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._startparam = ifcparametervalue(value)
			else:
				self._startparam = value
		return property(**locals())

	@apply
	def endparam():
		def fget( self ):
			return self._endparam
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument endparam is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._endparam = ifcparametervalue(value)
			else:
				self._endparam = value
		return property(**locals())

	@apply
	def referencesurface():
		def fget( self ):
			return self._referencesurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument referencesurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._referencesurface = ifcsurface(value)
			else:
				self._referencesurface = value
		return property(**locals())

####################
 # ENTITY ifctextstylewithboxcharacteristics #
####################
class ifctextstylewithboxcharacteristics(BaseEntityClass):
	'''Entity ifctextstylewithboxcharacteristics definition.

	:param boxheight
	:type boxheight:ifcpositivelengthmeasure

	:param boxwidth
	:type boxwidth:ifcpositivelengthmeasure

	:param boxslantangle
	:type boxslantangle:ifcplaneanglemeasure

	:param boxrotateangle
	:type boxrotateangle:ifcplaneanglemeasure

	:param characterspacing
	:type characterspacing:ifcsizeselect
	'''
	def __init__( self , boxheight,boxwidth,boxslantangle,boxrotateangle,characterspacing, ):
		self.boxheight = boxheight
		self.boxwidth = boxwidth
		self.boxslantangle = boxslantangle
		self.boxrotateangle = boxrotateangle
		self.characterspacing = characterspacing

	@apply
	def boxheight():
		def fget( self ):
			return self._boxheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._boxheight = ifcpositivelengthmeasure(value)
				else:
					self._boxheight = value
			else:
				self._boxheight = value
		return property(**locals())

	@apply
	def boxwidth():
		def fget( self ):
			return self._boxwidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._boxwidth = ifcpositivelengthmeasure(value)
				else:
					self._boxwidth = value
			else:
				self._boxwidth = value
		return property(**locals())

	@apply
	def boxslantangle():
		def fget( self ):
			return self._boxslantangle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._boxslantangle = ifcplaneanglemeasure(value)
				else:
					self._boxslantangle = value
			else:
				self._boxslantangle = value
		return property(**locals())

	@apply
	def boxrotateangle():
		def fget( self ):
			return self._boxrotateangle
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcplaneanglemeasure):
					self._boxrotateangle = ifcplaneanglemeasure(value)
				else:
					self._boxrotateangle = value
			else:
				self._boxrotateangle = value
		return property(**locals())

	@apply
	def characterspacing():
		def fget( self ):
			return self._characterspacing
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsizeselect):
					self._characterspacing = ifcsizeselect(value)
				else:
					self._characterspacing = value
			else:
				self._characterspacing = value
		return property(**locals())

####################
 # ENTITY ifcstructuralpointaction #
####################
class ifcstructuralpointaction(ifcstructuralaction):
	'''Entity ifcstructuralpointaction definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__causedby ,  ):
		ifcstructuralaction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedload , inherited8__globalorlocal , inherited9__destabilizingload , inherited10__causedby , )
	def wr61(self):
		eval_wr61_wr = (SIZEOF(['IFC2X3.IFCSTRUCTURALLOADSINGLEFORCE','IFC2X3.IFCSTRUCTURALLOADSINGLEDISPLACEMENT']  *  TYPEOF(self.self.ifcstructuralactivity.self.appliedload))  ==  1)
		if not eval_wr61_wr:
			raise AssertionError('Rule wr61 violated')
		else:
			return eval_wr61_wr


####################
 # ENTITY ifcannotationsurface #
####################
class ifcannotationsurface(ifcgeometricrepresentationitem):
	'''Entity ifcannotationsurface definition.

	:param item
	:type item:ifcgeometricrepresentationitem

	:param texturecoordinates
	:type texturecoordinates:ifctexturecoordinate
	'''
	def __init__( self , item,texturecoordinates, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.item = item
		self.texturecoordinates = texturecoordinates

	@apply
	def item():
		def fget( self ):
			return self._item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item is mantatory and can not be set to None')
			if not check_type(value,ifcgeometricrepresentationitem):
				self._item = ifcgeometricrepresentationitem(value)
			else:
				self._item = value
		return property(**locals())

	@apply
	def texturecoordinates():
		def fget( self ):
			return self._texturecoordinates
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctexturecoordinate):
					self._texturecoordinates = ifctexturecoordinate(value)
				else:
					self._texturecoordinates = value
			else:
				self._texturecoordinates = value
		return property(**locals())
	def wr01(self):
		eval_wr01_wr = (SIZEOF(['IFC2X3.IFCSURFACE','IFC2X3.IFCSHELLBASEDSURFACEMODEL','IFC2X3.IFCFACEBASEDSURFACEMODEL','IFC2X3.IFCSOLIDMODEL','IFC2X3.IFCBOOLEANRESULT','IFC2X3.IFCCSGPRIMITIVE3D']  *  TYPEOF(self.item))  >=  1)
		if not eval_wr01_wr:
			raise AssertionError('Rule wr01 violated')
		else:
			return eval_wr01_wr


####################
 # ENTITY ifcpropertyreferencevalue #
####################
class ifcpropertyreferencevalue(ifcsimpleproperty):
	'''Entity ifcpropertyreferencevalue definition.

	:param usagename
	:type usagename:ifclabel

	:param propertyreference
	:type propertyreference:ifcobjectreferenceselect
	'''
	def __init__( self , inherited0__name , inherited1__description , usagename,propertyreference, ):
		ifcsimpleproperty.__init__(self , inherited0__name , inherited1__description , )
		self.usagename = usagename
		self.propertyreference = propertyreference

	@apply
	def usagename():
		def fget( self ):
			return self._usagename
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._usagename = ifclabel(value)
				else:
					self._usagename = value
			else:
				self._usagename = value
		return property(**locals())

	@apply
	def propertyreference():
		def fget( self ):
			return self._propertyreference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument propertyreference is mantatory and can not be set to None')
			if not check_type(value,ifcobjectreferenceselect):
				self._propertyreference = ifcobjectreferenceselect(value)
			else:
				self._propertyreference = value
		return property(**locals())

####################
 # ENTITY ifcrelassignstoactor #
####################
class ifcrelassignstoactor(ifcrelassigns):
	'''Entity ifcrelassignstoactor definition.

	:param relatingactor
	:type relatingactor:ifcactor

	:param actingrole
	:type actingrole:ifcactorrole
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , relatingactor,actingrole, ):
		ifcrelassigns.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , )
		self.relatingactor = relatingactor
		self.actingrole = actingrole

	@apply
	def relatingactor():
		def fget( self ):
			return self._relatingactor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingactor is mantatory and can not be set to None')
			if not check_type(value,ifcactor):
				self._relatingactor = ifcactor(value)
			else:
				self._relatingactor = value
		return property(**locals())

	@apply
	def actingrole():
		def fget( self ):
			return self._actingrole
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcactorrole):
					self._actingrole = ifcactorrole(value)
				else:
					self._actingrole = value
			else:
				self._actingrole = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcreloccupiesspaces #
####################
class ifcreloccupiesspaces(ifcrelassignstoactor):
	'''Entity ifcreloccupiesspaces definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , inherited6__relatingactor , inherited7__actingrole ,  ):
		ifcrelassignstoactor.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , inherited5__relatedobjectstype , inherited6__relatingactor , inherited7__actingrole , )

####################
 # ENTITY ifcpointonsurface #
####################
class ifcpointonsurface(ifcpoint):
	'''Entity ifcpointonsurface definition.

	:param basissurface
	:type basissurface:ifcsurface

	:param pointparameteru
	:type pointparameteru:ifcparametervalue

	:param pointparameterv
	:type pointparameterv:ifcparametervalue

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , basissurface,pointparameteru,pointparameterv, ):
		ifcpoint.__init__(self , )
		self.basissurface = basissurface
		self.pointparameteru = pointparameteru
		self.pointparameterv = pointparameterv

	@apply
	def basissurface():
		def fget( self ):
			return self._basissurface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basissurface is mantatory and can not be set to None')
			if not check_type(value,ifcsurface):
				self._basissurface = ifcsurface(value)
			else:
				self._basissurface = value
		return property(**locals())

	@apply
	def pointparameteru():
		def fget( self ):
			return self._pointparameteru
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pointparameteru is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._pointparameteru = ifcparametervalue(value)
			else:
				self._pointparameteru = value
		return property(**locals())

	@apply
	def pointparameterv():
		def fget( self ):
			return self._pointparameterv
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pointparameterv is mantatory and can not be set to None')
			if not check_type(value,ifcparametervalue):
				self._pointparameterv = ifcparametervalue(value)
			else:
				self._pointparameterv = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.basissurface.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcboilertype #
####################
class ifcboilertype(ifcenergyconversiondevicetype):
	'''Entity ifcboilertype definition.

	:param predefinedtype
	:type predefinedtype:ifcboilertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcboilertypeenum):
				self._predefinedtype = ifcboilertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcboilertypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcboilertypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcactor #
####################
class ifcactor(ifcobject):
	'''Entity ifcactor definition.

	:param theactor
	:type theactor:ifcactorselect

	:param isactingupon
	:type isactingupon:SET(0,None,'ifcrelassignstoactor', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , theactor, ):
		ifcobject.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.theactor = theactor

	@apply
	def theactor():
		def fget( self ):
			return self._theactor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument theactor is mantatory and can not be set to None')
			if not check_type(value,ifcactorselect):
				self._theactor = ifcactorselect(value)
			else:
				self._theactor = value
		return property(**locals())

	@apply
	def isactingupon():
		def fget( self ):
			return self._isactingupon
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument isactingupon is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcoccupant #
####################
class ifcoccupant(ifcactor):
	'''Entity ifcoccupant definition.

	:param predefinedtype
	:type predefinedtype:ifcoccupanttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__theactor , predefinedtype, ):
		ifcactor.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__theactor , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcoccupanttypeenum):
				self._predefinedtype = ifcoccupanttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (( not (self.predefinedtype  ==  ifcoccupanttypeenum.self.userdefined))  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcrelcontainedinspatialstructure #
####################
class ifcrelcontainedinspatialstructure(ifcrelconnects):
	'''Entity ifcrelcontainedinspatialstructure definition.

	:param relatedelements
	:type relatedelements:SET(1,None,'ifcproduct', scope = schema_scope)

	:param relatingstructure
	:type relatingstructure:ifcspatialstructureelement
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatedelements,relatingstructure, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatedelements = relatedelements
		self.relatingstructure = relatingstructure

	@apply
	def relatedelements():
		def fget( self ):
			return self._relatedelements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedelements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproduct', scope = schema_scope)):
				self._relatedelements = SET(value)
			else:
				self._relatedelements = value
		return property(**locals())

	@apply
	def relatingstructure():
		def fget( self ):
			return self._relatingstructure
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingstructure is mantatory and can not be set to None')
			if not check_type(value,ifcspatialstructureelement):
				self._relatingstructure = ifcspatialstructureelement(value)
			else:
				self._relatingstructure = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (SIZEOF(None)  ==  0)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcstructuralpointconnection #
####################
class ifcstructuralpointconnection(ifcstructuralconnection):
	'''Entity ifcstructuralpointconnection definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition ,  ):
		ifcstructuralconnection.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__appliedcondition , )

####################
 # ENTITY ifcflowsegment #
####################
class ifcflowsegment(ifcdistributionflowelement):
	'''Entity ifcflowsegment definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcdistributionflowelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcoffsetcurve3d #
####################
class ifcoffsetcurve3d(ifccurve):
	'''Entity ifcoffsetcurve3d definition.

	:param basiscurve
	:type basiscurve:ifccurve

	:param distance
	:type distance:ifclengthmeasure

	:param selfintersect
	:type selfintersect:LOGICAL

	:param refdirection
	:type refdirection:ifcdirection
	'''
	def __init__( self , basiscurve,distance,selfintersect,refdirection, ):
		ifccurve.__init__(self , )
		self.basiscurve = basiscurve
		self.distance = distance
		self.selfintersect = selfintersect
		self.refdirection = refdirection

	@apply
	def basiscurve():
		def fget( self ):
			return self._basiscurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basiscurve is mantatory and can not be set to None')
			if not check_type(value,ifccurve):
				self._basiscurve = ifccurve(value)
			else:
				self._basiscurve = value
		return property(**locals())

	@apply
	def distance():
		def fget( self ):
			return self._distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._distance = ifclengthmeasure(value)
			else:
				self._distance = value
		return property(**locals())

	@apply
	def selfintersect():
		def fget( self ):
			return self._selfintersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument selfintersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._selfintersect = LOGICAL(value)
			else:
				self._selfintersect = value
		return property(**locals())

	@apply
	def refdirection():
		def fget( self ):
			return self._refdirection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument refdirection is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._refdirection = ifcdirection(value)
			else:
				self._refdirection = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.basiscurve.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcvibrationisolatortype #
####################
class ifcvibrationisolatortype(ifcdiscreteaccessorytype):
	'''Entity ifcvibrationisolatortype definition.

	:param predefinedtype
	:type predefinedtype:ifcvibrationisolatortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdiscreteaccessorytype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcvibrationisolatortypeenum):
				self._predefinedtype = ifcvibrationisolatortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcvibrationisolatortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcvibrationisolatortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcconversionbasedunit #
####################
class ifcconversionbasedunit(ifcnamedunit):
	'''Entity ifcconversionbasedunit definition.

	:param name
	:type name:ifclabel

	:param conversionfactor
	:type conversionfactor:ifcmeasurewithunit
	'''
	def __init__( self , inherited0__dimensions , inherited1__unittype , name,conversionfactor, ):
		ifcnamedunit.__init__(self , inherited0__dimensions , inherited1__unittype , )
		self.name = name
		self.conversionfactor = conversionfactor

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def conversionfactor():
		def fget( self ):
			return self._conversionfactor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument conversionfactor is mantatory and can not be set to None')
			if not check_type(value,ifcmeasurewithunit):
				self._conversionfactor = ifcmeasurewithunit(value)
			else:
				self._conversionfactor = value
		return property(**locals())

####################
 # ENTITY ifctransformertype #
####################
class ifctransformertype(ifcenergyconversiondevicetype):
	'''Entity ifctransformertype definition.

	:param predefinedtype
	:type predefinedtype:ifctransformertypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctransformertypeenum):
				self._predefinedtype = ifctransformertypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcapplication #
####################
class ifcapplication(BaseEntityClass):
	'''Entity ifcapplication definition.

	:param applicationdeveloper
	:type applicationdeveloper:ifcorganization

	:param version
	:type version:ifclabel

	:param applicationfullname
	:type applicationfullname:ifclabel

	:param applicationidentifier
	:type applicationidentifier:ifcidentifier
	'''
	def __init__( self , applicationdeveloper,version,applicationfullname,applicationidentifier, ):
		self.applicationdeveloper = applicationdeveloper
		self.version = version
		self.applicationfullname = applicationfullname
		self.applicationidentifier = applicationidentifier

	@apply
	def applicationdeveloper():
		def fget( self ):
			return self._applicationdeveloper
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applicationdeveloper is mantatory and can not be set to None')
			if not check_type(value,ifcorganization):
				self._applicationdeveloper = ifcorganization(value)
			else:
				self._applicationdeveloper = value
		return property(**locals())

	@apply
	def version():
		def fget( self ):
			return self._version
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument version is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._version = ifclabel(value)
			else:
				self._version = value
		return property(**locals())

	@apply
	def applicationfullname():
		def fget( self ):
			return self._applicationfullname
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applicationfullname is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._applicationfullname = ifclabel(value)
			else:
				self._applicationfullname = value
		return property(**locals())

	@apply
	def applicationidentifier():
		def fget( self ):
			return self._applicationidentifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applicationidentifier is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._applicationidentifier = ifcidentifier(value)
			else:
				self._applicationidentifier = value
		return property(**locals())

####################
 # ENTITY ifcannotationfillareaoccurrence #
####################
class ifcannotationfillareaoccurrence(ifcannotationoccurrence):
	'''Entity ifcannotationfillareaoccurrence definition.

	:param fillstyletarget
	:type fillstyletarget:ifcpoint

	:param globalorlocal
	:type globalorlocal:ifcglobalorlocalenum
	'''
	def __init__( self , inherited0__item , inherited1__styles , inherited2__name , fillstyletarget,globalorlocal, ):
		ifcannotationoccurrence.__init__(self , inherited0__item , inherited1__styles , inherited2__name , )
		self.fillstyletarget = fillstyletarget
		self.globalorlocal = globalorlocal

	@apply
	def fillstyletarget():
		def fget( self ):
			return self._fillstyletarget
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpoint):
					self._fillstyletarget = ifcpoint(value)
				else:
					self._fillstyletarget = value
			else:
				self._fillstyletarget = value
		return property(**locals())

	@apply
	def globalorlocal():
		def fget( self ):
			return self._globalorlocal
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcglobalorlocalenum):
					self._globalorlocal = ifcglobalorlocalenum(value)
				else:
					self._globalorlocal = value
			else:
				self._globalorlocal = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (( not EXISTS(self.self.ifcstyleditem.self.item))  or  ('IFC2X3.IFCANNOTATIONFILLAREA'  ==  TYPEOF(self.self.ifcstyleditem.self.item)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifccoveringtype #
####################
class ifccoveringtype(ifcbuildingelementtype):
	'''Entity ifccoveringtype definition.

	:param predefinedtype
	:type predefinedtype:ifccoveringtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccoveringtypeenum):
				self._predefinedtype = ifccoveringtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcproductdefinitionshape #
####################
class ifcproductdefinitionshape(ifcproductrepresentation):
	'''Entity ifcproductdefinitionshape definition.

	:param shapeofproduct
	:type shapeofproduct:SET(1,1,'ifcproduct', scope = schema_scope)

	:param hasshapeaspects
	:type hasshapeaspects:SET(0,None,'ifcshapeaspect', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__representations ,  ):
		ifcproductrepresentation.__init__(self , inherited0__name , inherited1__description , inherited2__representations , )

	@apply
	def shapeofproduct():
		def fget( self ):
			return self._shapeofproduct
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument shapeofproduct is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def hasshapeaspects():
		def fget( self ):
			return self._hasshapeaspects
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasshapeaspects is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcangulardimension #
####################
class ifcangulardimension(ifcdimensioncurvedirectedcallout):
	'''Entity ifcangulardimension definition.
	'''
	def __init__( self , inherited0__contents ,  ):
		ifcdimensioncurvedirectedcallout.__init__(self , inherited0__contents , )

####################
 # ENTITY ifccirclehollowprofiledef #
####################
class ifccirclehollowprofiledef(ifccircleprofiledef):
	'''Entity ifccirclehollowprofiledef definition.

	:param wallthickness
	:type wallthickness:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__radius , wallthickness, ):
		ifccircleprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__position , inherited3__radius , )
		self.wallthickness = wallthickness

	@apply
	def wallthickness():
		def fget( self ):
			return self._wallthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument wallthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._wallthickness = ifcpositivelengthmeasure(value)
			else:
				self._wallthickness = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.wallthickness  <  self.self.ifccircleprofiledef.self.radius)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifccenterlineprofiledef #
####################
class ifccenterlineprofiledef(ifcarbitraryopenprofiledef):
	'''Entity ifccenterlineprofiledef definition.

	:param thickness
	:type thickness:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , inherited2__curve , thickness, ):
		ifcarbitraryopenprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , inherited2__curve , )
		self.thickness = thickness

	@apply
	def thickness():
		def fget( self ):
			return self._thickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._thickness = ifcpositivelengthmeasure(value)
			else:
				self._thickness = value
		return property(**locals())

####################
 # ENTITY ifcfaceouterbound #
####################
class ifcfaceouterbound(ifcfacebound):
	'''Entity ifcfaceouterbound definition.
	'''
	def __init__( self , inherited0__bound , inherited1__orientation ,  ):
		ifcfacebound.__init__(self , inherited0__bound , inherited1__orientation , )

####################
 # ENTITY ifcvector #
####################
class ifcvector(ifcgeometricrepresentationitem):
	'''Entity ifcvector definition.

	:param orientation
	:type orientation:ifcdirection

	:param magnitude
	:type magnitude:ifclengthmeasure

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , orientation,magnitude, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.orientation = orientation
		self.magnitude = magnitude

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._orientation = ifcdirection(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def magnitude():
		def fget( self ):
			return self._magnitude
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument magnitude is mantatory and can not be set to None')
			if not check_type(value,ifclengthmeasure):
				self._magnitude = ifclengthmeasure(value)
			else:
				self._magnitude = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = self.orientation.self.dim
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.magnitude  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifccurtainwall #
####################
class ifccurtainwall(ifcbuildingelement):
	'''Entity ifccurtainwall definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcexternallydefinedhatchstyle #
####################
class ifcexternallydefinedhatchstyle(ifcexternalreference):
	'''Entity ifcexternallydefinedhatchstyle definition.
	'''
	def __init__( self , inherited0__location , inherited1__itemreference , inherited2__name ,  ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__itemreference , inherited2__name , )

####################
 # ENTITY ifcmeasurewithunit #
####################
class ifcmeasurewithunit(BaseEntityClass):
	'''Entity ifcmeasurewithunit definition.

	:param valuecomponent
	:type valuecomponent:ifcvalue

	:param unitcomponent
	:type unitcomponent:ifcunit
	'''
	def __init__( self , valuecomponent,unitcomponent, ):
		self.valuecomponent = valuecomponent
		self.unitcomponent = unitcomponent

	@apply
	def valuecomponent():
		def fget( self ):
			return self._valuecomponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument valuecomponent is mantatory and can not be set to None')
			if not check_type(value,ifcvalue):
				self._valuecomponent = ifcvalue(value)
			else:
				self._valuecomponent = value
		return property(**locals())

	@apply
	def unitcomponent():
		def fget( self ):
			return self._unitcomponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unitcomponent is mantatory and can not be set to None')
			if not check_type(value,ifcunit):
				self._unitcomponent = ifcunit(value)
			else:
				self._unitcomponent = value
		return property(**locals())

####################
 # ENTITY ifcrectangularpyramid #
####################
class ifcrectangularpyramid(ifccsgprimitive3d):
	'''Entity ifcrectangularpyramid definition.

	:param xlength
	:type xlength:ifcpositivelengthmeasure

	:param ylength
	:type ylength:ifcpositivelengthmeasure

	:param height
	:type height:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , xlength,ylength,height, ):
		ifccsgprimitive3d.__init__(self , inherited0__position , )
		self.xlength = xlength
		self.ylength = ylength
		self.height = height

	@apply
	def xlength():
		def fget( self ):
			return self._xlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument xlength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._xlength = ifcpositivelengthmeasure(value)
			else:
				self._xlength = value
		return property(**locals())

	@apply
	def ylength():
		def fget( self ):
			return self._ylength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ylength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._ylength = ifcpositivelengthmeasure(value)
			else:
				self._ylength = value
		return property(**locals())

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._height = ifcpositivelengthmeasure(value)
			else:
				self._height = value
		return property(**locals())

####################
 # ENTITY ifcsurfacestyle #
####################
class ifcsurfacestyle(ifcpresentationstyle):
	'''Entity ifcsurfacestyle definition.

	:param side
	:type side:ifcsurfaceside

	:param styles
	:type styles:SET(1,5,'ifcsurfacestyleelementselect', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , side,styles, ):
		ifcpresentationstyle.__init__(self , inherited0__name , )
		self.side = side
		self.styles = styles

	@apply
	def side():
		def fget( self ):
			return self._side
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument side is mantatory and can not be set to None')
			if not check_type(value,ifcsurfaceside):
				self._side = ifcsurfaceside(value)
			else:
				self._side = value
		return property(**locals())

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,5,'ifcsurfacestyleelementselect', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  <=  1)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  <=  1)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(None)  <=  1)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = (SIZEOF(None)  <=  1)
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr

	def wr15(self):
		eval_wr15_wr = (SIZEOF(None)  <=  1)
		if not eval_wr15_wr:
			raise AssertionError('Rule wr15 violated')
		else:
			return eval_wr15_wr


####################
 # ENTITY ifcelectricmotortype #
####################
class ifcelectricmotortype(ifcenergyconversiondevicetype):
	'''Entity ifcelectricmotortype definition.

	:param predefinedtype
	:type predefinedtype:ifcelectricmotortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcelectricmotortypeenum):
				self._predefinedtype = ifcelectricmotortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcelectricalbaseproperties #
####################
class ifcelectricalbaseproperties(ifcenergyproperties):
	'''Entity ifcelectricalbaseproperties definition.

	:param electriccurrenttype
	:type electriccurrenttype:ifcelectriccurrentenum

	:param inputvoltage
	:type inputvoltage:ifcelectricvoltagemeasure

	:param inputfrequency
	:type inputfrequency:ifcfrequencymeasure

	:param fullloadcurrent
	:type fullloadcurrent:ifcelectriccurrentmeasure

	:param minimumcircuitcurrent
	:type minimumcircuitcurrent:ifcelectriccurrentmeasure

	:param maximumpowerinput
	:type maximumpowerinput:ifcpowermeasure

	:param ratedpowerinput
	:type ratedpowerinput:ifcpowermeasure

	:param inputphase
	:type inputphase:INTEGER
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__energysequence , inherited5__userdefinedenergysequence , electriccurrenttype,inputvoltage,inputfrequency,fullloadcurrent,minimumcircuitcurrent,maximumpowerinput,ratedpowerinput,inputphase, ):
		ifcenergyproperties.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__energysequence , inherited5__userdefinedenergysequence , )
		self.electriccurrenttype = electriccurrenttype
		self.inputvoltage = inputvoltage
		self.inputfrequency = inputfrequency
		self.fullloadcurrent = fullloadcurrent
		self.minimumcircuitcurrent = minimumcircuitcurrent
		self.maximumpowerinput = maximumpowerinput
		self.ratedpowerinput = ratedpowerinput
		self.inputphase = inputphase

	@apply
	def electriccurrenttype():
		def fget( self ):
			return self._electriccurrenttype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelectriccurrentenum):
					self._electriccurrenttype = ifcelectriccurrentenum(value)
				else:
					self._electriccurrenttype = value
			else:
				self._electriccurrenttype = value
		return property(**locals())

	@apply
	def inputvoltage():
		def fget( self ):
			return self._inputvoltage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument inputvoltage is mantatory and can not be set to None')
			if not check_type(value,ifcelectricvoltagemeasure):
				self._inputvoltage = ifcelectricvoltagemeasure(value)
			else:
				self._inputvoltage = value
		return property(**locals())

	@apply
	def inputfrequency():
		def fget( self ):
			return self._inputfrequency
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument inputfrequency is mantatory and can not be set to None')
			if not check_type(value,ifcfrequencymeasure):
				self._inputfrequency = ifcfrequencymeasure(value)
			else:
				self._inputfrequency = value
		return property(**locals())

	@apply
	def fullloadcurrent():
		def fget( self ):
			return self._fullloadcurrent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelectriccurrentmeasure):
					self._fullloadcurrent = ifcelectriccurrentmeasure(value)
				else:
					self._fullloadcurrent = value
			else:
				self._fullloadcurrent = value
		return property(**locals())

	@apply
	def minimumcircuitcurrent():
		def fget( self ):
			return self._minimumcircuitcurrent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcelectriccurrentmeasure):
					self._minimumcircuitcurrent = ifcelectriccurrentmeasure(value)
				else:
					self._minimumcircuitcurrent = value
			else:
				self._minimumcircuitcurrent = value
		return property(**locals())

	@apply
	def maximumpowerinput():
		def fget( self ):
			return self._maximumpowerinput
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpowermeasure):
					self._maximumpowerinput = ifcpowermeasure(value)
				else:
					self._maximumpowerinput = value
			else:
				self._maximumpowerinput = value
		return property(**locals())

	@apply
	def ratedpowerinput():
		def fget( self ):
			return self._ratedpowerinput
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpowermeasure):
					self._ratedpowerinput = ifcpowermeasure(value)
				else:
					self._ratedpowerinput = value
			else:
				self._ratedpowerinput = value
		return property(**locals())

	@apply
	def inputphase():
		def fget( self ):
			return self._inputphase
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument inputphase is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._inputphase = INTEGER(value)
			else:
				self._inputphase = value
		return property(**locals())

####################
 # ENTITY ifcirregulartimeseriesvalue #
####################
class ifcirregulartimeseriesvalue(BaseEntityClass):
	'''Entity ifcirregulartimeseriesvalue definition.

	:param timestamp
	:type timestamp:ifcdatetimeselect

	:param listvalues
	:type listvalues:LIST(1,None,'ifcvalue', scope = schema_scope)
	'''
	def __init__( self , timestamp,listvalues, ):
		self.timestamp = timestamp
		self.listvalues = listvalues

	@apply
	def timestamp():
		def fget( self ):
			return self._timestamp
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timestamp is mantatory and can not be set to None')
			if not check_type(value,ifcdatetimeselect):
				self._timestamp = ifcdatetimeselect(value)
			else:
				self._timestamp = value
		return property(**locals())

	@apply
	def listvalues():
		def fget( self ):
			return self._listvalues
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument listvalues is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcvalue', scope = schema_scope)):
				self._listvalues = LIST(value)
			else:
				self._listvalues = value
		return property(**locals())

####################
 # ENTITY ifcpresentationlayerassignment #
####################
class ifcpresentationlayerassignment(BaseEntityClass):
	'''Entity ifcpresentationlayerassignment definition.

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext

	:param assigneditems
	:type assigneditems:SET(1,None,'ifclayereditem', scope = schema_scope)

	:param identifier
	:type identifier:ifcidentifier
	'''
	def __init__( self , name,description,assigneditems,identifier, ):
		self.name = name
		self.description = description
		self.assigneditems = assigneditems
		self.identifier = identifier

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def assigneditems():
		def fget( self ):
			return self._assigneditems
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigneditems is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifclayereditem', scope = schema_scope)):
				self._assigneditems = SET(value)
			else:
				self._assigneditems = value
		return property(**locals())

	@apply
	def identifier():
		def fget( self ):
			return self._identifier
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcidentifier):
					self._identifier = ifcidentifier(value)
				else:
					self._identifier = value
			else:
				self._identifier = value
		return property(**locals())

####################
 # ENTITY ifcprojectionelement #
####################
class ifcprojectionelement(ifcfeatureelementaddition):
	'''Entity ifcprojectionelement definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcfeatureelementaddition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

####################
 # ENTITY ifcrelassociatesapproval #
####################
class ifcrelassociatesapproval(ifcrelassociates):
	'''Entity ifcrelassociatesapproval definition.

	:param relatingapproval
	:type relatingapproval:ifcapproval
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingapproval, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingapproval = relatingapproval

	@apply
	def relatingapproval():
		def fget( self ):
			return self._relatingapproval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingapproval is mantatory and can not be set to None')
			if not check_type(value,ifcapproval):
				self._relatingapproval = ifcapproval(value)
			else:
				self._relatingapproval = value
		return property(**locals())

####################
 # ENTITY ifccurvestyle #
####################
class ifccurvestyle(ifcpresentationstyle):
	'''Entity ifccurvestyle definition.

	:param curvefont
	:type curvefont:ifccurvefontorscaledcurvefontselect

	:param curvewidth
	:type curvewidth:ifcsizeselect

	:param curvecolour
	:type curvecolour:ifccolour
	'''
	def __init__( self , inherited0__name , curvefont,curvewidth,curvecolour, ):
		ifcpresentationstyle.__init__(self , inherited0__name , )
		self.curvefont = curvefont
		self.curvewidth = curvewidth
		self.curvecolour = curvecolour

	@apply
	def curvefont():
		def fget( self ):
			return self._curvefont
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccurvefontorscaledcurvefontselect):
					self._curvefont = ifccurvefontorscaledcurvefontselect(value)
				else:
					self._curvefont = value
			else:
				self._curvefont = value
		return property(**locals())

	@apply
	def curvewidth():
		def fget( self ):
			return self._curvewidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsizeselect):
					self._curvewidth = ifcsizeselect(value)
				else:
					self._curvewidth = value
			else:
				self._curvewidth = value
		return property(**locals())

	@apply
	def curvecolour():
		def fget( self ):
			return self._curvecolour
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolour):
					self._curvecolour = ifccolour(value)
				else:
					self._curvecolour = value
			else:
				self._curvecolour = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = ((( not EXISTS(self.curvewidth))  or  ('IFC2X3.IFCPOSITIVELENGTHMEASURE'  ==  TYPEOF(self.curvewidth)))  or  (('IFC2X3.IFCDESCRIPTIVEMEASURE'  ==  TYPEOF(self.curvewidth))  and  (self.curvewidth  ==  'by layer')))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifcdirection #
####################
class ifcdirection(ifcgeometricrepresentationitem):
	'''Entity ifcdirection definition.

	:param directionratios
	:type directionratios:LIST(2,3,'REAL', scope = schema_scope)

	:param dim
	:type dim:ifcdimensioncount
	'''
	def __init__( self , directionratios, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.directionratios = directionratios

	@apply
	def directionratios():
		def fget( self ):
			return self._directionratios
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directionratios is mantatory and can not be set to None')
			if not check_type(value,LIST(2,3,'REAL', scope = schema_scope)):
				self._directionratios = LIST(value)
			else:
				self._directionratios = value
		return property(**locals())

	@apply
	def dim():
		def fget( self ):
			attribute_eval = HIINDEX(self.directionratios)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcfillareastyletiles #
####################
class ifcfillareastyletiles(ifcgeometricrepresentationitem):
	'''Entity ifcfillareastyletiles definition.

	:param tilingpattern
	:type tilingpattern:ifconedirectionrepeatfactor

	:param tiles
	:type tiles:SET(1,None,'ifcfillareastyletileshapeselect', scope = schema_scope)

	:param tilingscale
	:type tilingscale:ifcpositiveratiomeasure
	'''
	def __init__( self , tilingpattern,tiles,tilingscale, ):
		ifcgeometricrepresentationitem.__init__(self , )
		self.tilingpattern = tilingpattern
		self.tiles = tiles
		self.tilingscale = tilingscale

	@apply
	def tilingpattern():
		def fget( self ):
			return self._tilingpattern
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tilingpattern is mantatory and can not be set to None')
			if not check_type(value,ifconedirectionrepeatfactor):
				self._tilingpattern = ifconedirectionrepeatfactor(value)
			else:
				self._tilingpattern = value
		return property(**locals())

	@apply
	def tiles():
		def fget( self ):
			return self._tiles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tiles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcfillareastyletileshapeselect', scope = schema_scope)):
				self._tiles = SET(value)
			else:
				self._tiles = value
		return property(**locals())

	@apply
	def tilingscale():
		def fget( self ):
			return self._tilingscale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tilingscale is mantatory and can not be set to None')
			if not check_type(value,ifcpositiveratiomeasure):
				self._tilingscale = ifcpositiveratiomeasure(value)
			else:
				self._tilingscale = value
		return property(**locals())

####################
 # ENTITY ifcbeamtype #
####################
class ifcbeamtype(ifcbuildingelementtype):
	'''Entity ifcbeamtype definition.

	:param predefinedtype
	:type predefinedtype:ifcbeamtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcbuildingelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcbeamtypeenum):
				self._predefinedtype = ifcbeamtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifclightsourcegoniometric #
####################
class ifclightsourcegoniometric(ifclightsource):
	'''Entity ifclightsourcegoniometric definition.

	:param position
	:type position:ifcaxis2placement3d

	:param colourappearance
	:type colourappearance:ifccolourrgb

	:param colourtemperature
	:type colourtemperature:ifcthermodynamictemperaturemeasure

	:param luminousflux
	:type luminousflux:ifcluminousfluxmeasure

	:param lightemissionsource
	:type lightemissionsource:ifclightemissionsourceenum

	:param lightdistributiondatasource
	:type lightdistributiondatasource:ifclightdistributiondatasourceselect
	'''
	def __init__( self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , position,colourappearance,colourtemperature,luminousflux,lightemissionsource,lightdistributiondatasource, ):
		ifclightsource.__init__(self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , )
		self.position = position
		self.colourappearance = colourappearance
		self.colourtemperature = colourtemperature
		self.luminousflux = luminousflux
		self.lightemissionsource = lightemissionsource
		self.lightdistributiondatasource = lightdistributiondatasource

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement3d):
				self._position = ifcaxis2placement3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def colourappearance():
		def fget( self ):
			return self._colourappearance
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccolourrgb):
					self._colourappearance = ifccolourrgb(value)
				else:
					self._colourappearance = value
			else:
				self._colourappearance = value
		return property(**locals())

	@apply
	def colourtemperature():
		def fget( self ):
			return self._colourtemperature
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument colourtemperature is mantatory and can not be set to None')
			if not check_type(value,ifcthermodynamictemperaturemeasure):
				self._colourtemperature = ifcthermodynamictemperaturemeasure(value)
			else:
				self._colourtemperature = value
		return property(**locals())

	@apply
	def luminousflux():
		def fget( self ):
			return self._luminousflux
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument luminousflux is mantatory and can not be set to None')
			if not check_type(value,ifcluminousfluxmeasure):
				self._luminousflux = ifcluminousfluxmeasure(value)
			else:
				self._luminousflux = value
		return property(**locals())

	@apply
	def lightemissionsource():
		def fget( self ):
			return self._lightemissionsource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lightemissionsource is mantatory and can not be set to None')
			if not check_type(value,ifclightemissionsourceenum):
				self._lightemissionsource = ifclightemissionsourceenum(value)
			else:
				self._lightemissionsource = value
		return property(**locals())

	@apply
	def lightdistributiondatasource():
		def fget( self ):
			return self._lightdistributiondatasource
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lightdistributiondatasource is mantatory and can not be set to None')
			if not check_type(value,ifclightdistributiondatasourceselect):
				self._lightdistributiondatasource = ifclightdistributiondatasourceselect(value)
			else:
				self._lightdistributiondatasource = value
		return property(**locals())

####################
 # ENTITY ifcsensortype #
####################
class ifcsensortype(ifcdistributioncontrolelementtype):
	'''Entity ifcsensortype definition.

	:param predefinedtype
	:type predefinedtype:ifcsensortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcdistributioncontrolelementtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcsensortypeenum):
				self._predefinedtype = ifcsensortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())

####################
 # ENTITY ifcstructuralsteelprofileproperties #
####################
class ifcstructuralsteelprofileproperties(ifcstructuralprofileproperties):
	'''Entity ifcstructuralsteelprofileproperties definition.

	:param shearareaz
	:type shearareaz:ifcareameasure

	:param shearareay
	:type shearareay:ifcareameasure

	:param plasticshapefactory
	:type plasticshapefactory:ifcpositiveratiomeasure

	:param plasticshapefactorz
	:type plasticshapefactorz:ifcpositiveratiomeasure
	'''
	def __init__( self , inherited0__profilename , inherited1__profiledefinition , inherited2__physicalweight , inherited3__perimeter , inherited4__minimumplatethickness , inherited5__maximumplatethickness , inherited6__crosssectionarea , inherited7__torsionalconstantx , inherited8__momentofinertiayz , inherited9__momentofinertiay , inherited10__momentofinertiaz , inherited11__warpingconstant , inherited12__shearcentrez , inherited13__shearcentrey , inherited14__sheardeformationareaz , inherited15__sheardeformationareay , inherited16__maximumsectionmodulusy , inherited17__minimumsectionmodulusy , inherited18__maximumsectionmodulusz , inherited19__minimumsectionmodulusz , inherited20__torsionalsectionmodulus , inherited21__centreofgravityinx , inherited22__centreofgravityiny , shearareaz,shearareay,plasticshapefactory,plasticshapefactorz, ):
		ifcstructuralprofileproperties.__init__(self , inherited0__profilename , inherited1__profiledefinition , inherited2__physicalweight , inherited3__perimeter , inherited4__minimumplatethickness , inherited5__maximumplatethickness , inherited6__crosssectionarea , inherited7__torsionalconstantx , inherited8__momentofinertiayz , inherited9__momentofinertiay , inherited10__momentofinertiaz , inherited11__warpingconstant , inherited12__shearcentrez , inherited13__shearcentrey , inherited14__sheardeformationareaz , inherited15__sheardeformationareay , inherited16__maximumsectionmodulusy , inherited17__minimumsectionmodulusy , inherited18__maximumsectionmodulusz , inherited19__minimumsectionmodulusz , inherited20__torsionalsectionmodulus , inherited21__centreofgravityinx , inherited22__centreofgravityiny , )
		self.shearareaz = shearareaz
		self.shearareay = shearareay
		self.plasticshapefactory = plasticshapefactory
		self.plasticshapefactorz = plasticshapefactorz

	@apply
	def shearareaz():
		def fget( self ):
			return self._shearareaz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._shearareaz = ifcareameasure(value)
				else:
					self._shearareaz = value
			else:
				self._shearareaz = value
		return property(**locals())

	@apply
	def shearareay():
		def fget( self ):
			return self._shearareay
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcareameasure):
					self._shearareay = ifcareameasure(value)
				else:
					self._shearareay = value
			else:
				self._shearareay = value
		return property(**locals())

	@apply
	def plasticshapefactory():
		def fget( self ):
			return self._plasticshapefactory
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._plasticshapefactory = ifcpositiveratiomeasure(value)
				else:
					self._plasticshapefactory = value
			else:
				self._plasticshapefactory = value
		return property(**locals())

	@apply
	def plasticshapefactorz():
		def fget( self ):
			return self._plasticshapefactorz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._plasticshapefactorz = ifcpositiveratiomeasure(value)
				else:
					self._plasticshapefactorz = value
			else:
				self._plasticshapefactorz = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = (( not EXISTS(self.shearareay))  or  (self.shearareay  >=  0))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = (( not EXISTS(self.shearareaz))  or  (self.shearareaz  >=  0))
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr


####################
 # ENTITY ifcconnectionportgeometry #
####################
class ifcconnectionportgeometry(ifcconnectiongeometry):
	'''Entity ifcconnectionportgeometry definition.

	:param locationatrelatingelement
	:type locationatrelatingelement:ifcaxis2placement

	:param locationatrelatedelement
	:type locationatrelatedelement:ifcaxis2placement

	:param profileofport
	:type profileofport:ifcprofiledef
	'''
	def __init__( self , locationatrelatingelement,locationatrelatedelement,profileofport, ):
		ifcconnectiongeometry.__init__(self , )
		self.locationatrelatingelement = locationatrelatingelement
		self.locationatrelatedelement = locationatrelatedelement
		self.profileofport = profileofport

	@apply
	def locationatrelatingelement():
		def fget( self ):
			return self._locationatrelatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument locationatrelatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._locationatrelatingelement = ifcaxis2placement(value)
			else:
				self._locationatrelatingelement = value
		return property(**locals())

	@apply
	def locationatrelatedelement():
		def fget( self ):
			return self._locationatrelatedelement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcaxis2placement):
					self._locationatrelatedelement = ifcaxis2placement(value)
				else:
					self._locationatrelatedelement = value
			else:
				self._locationatrelatedelement = value
		return property(**locals())

	@apply
	def profileofport():
		def fget( self ):
			return self._profileofport
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument profileofport is mantatory and can not be set to None')
			if not check_type(value,ifcprofiledef):
				self._profileofport = ifcprofiledef(value)
			else:
				self._profileofport = value
		return property(**locals())

####################
 # ENTITY ifcwaterproperties #
####################
class ifcwaterproperties(ifcmaterialproperties):
	'''Entity ifcwaterproperties definition.

	:param ispotable
	:type ispotable:BOOLEAN

	:param hardness
	:type hardness:ifcionconcentrationmeasure

	:param alkalinityconcentration
	:type alkalinityconcentration:ifcionconcentrationmeasure

	:param acidityconcentration
	:type acidityconcentration:ifcionconcentrationmeasure

	:param impuritiescontent
	:type impuritiescontent:ifcnormalisedratiomeasure

	:param phlevel
	:type phlevel:ifcphmeasure

	:param dissolvedsolidscontent
	:type dissolvedsolidscontent:ifcnormalisedratiomeasure
	'''
	def __init__( self , inherited0__material , ispotable,hardness,alkalinityconcentration,acidityconcentration,impuritiescontent,phlevel,dissolvedsolidscontent, ):
		ifcmaterialproperties.__init__(self , inherited0__material , )
		self.ispotable = ispotable
		self.hardness = hardness
		self.alkalinityconcentration = alkalinityconcentration
		self.acidityconcentration = acidityconcentration
		self.impuritiescontent = impuritiescontent
		self.phlevel = phlevel
		self.dissolvedsolidscontent = dissolvedsolidscontent

	@apply
	def ispotable():
		def fget( self ):
			return self._ispotable
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._ispotable = BOOLEAN(value)
				else:
					self._ispotable = value
			else:
				self._ispotable = value
		return property(**locals())

	@apply
	def hardness():
		def fget( self ):
			return self._hardness
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcionconcentrationmeasure):
					self._hardness = ifcionconcentrationmeasure(value)
				else:
					self._hardness = value
			else:
				self._hardness = value
		return property(**locals())

	@apply
	def alkalinityconcentration():
		def fget( self ):
			return self._alkalinityconcentration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcionconcentrationmeasure):
					self._alkalinityconcentration = ifcionconcentrationmeasure(value)
				else:
					self._alkalinityconcentration = value
			else:
				self._alkalinityconcentration = value
		return property(**locals())

	@apply
	def acidityconcentration():
		def fget( self ):
			return self._acidityconcentration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcionconcentrationmeasure):
					self._acidityconcentration = ifcionconcentrationmeasure(value)
				else:
					self._acidityconcentration = value
			else:
				self._acidityconcentration = value
		return property(**locals())

	@apply
	def impuritiescontent():
		def fget( self ):
			return self._impuritiescontent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._impuritiescontent = ifcnormalisedratiomeasure(value)
				else:
					self._impuritiescontent = value
			else:
				self._impuritiescontent = value
		return property(**locals())

	@apply
	def phlevel():
		def fget( self ):
			return self._phlevel
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcphmeasure):
					self._phlevel = ifcphmeasure(value)
				else:
					self._phlevel = value
			else:
				self._phlevel = value
		return property(**locals())

	@apply
	def dissolvedsolidscontent():
		def fget( self ):
			return self._dissolvedsolidscontent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcnormalisedratiomeasure):
					self._dissolvedsolidscontent = ifcnormalisedratiomeasure(value)
				else:
					self._dissolvedsolidscontent = value
			else:
				self._dissolvedsolidscontent = value
		return property(**locals())

####################
 # ENTITY ifcfuelproperties #
####################
class ifcfuelproperties(ifcmaterialproperties):
	'''Entity ifcfuelproperties definition.

	:param combustiontemperature
	:type combustiontemperature:ifcthermodynamictemperaturemeasure

	:param carboncontent
	:type carboncontent:ifcpositiveratiomeasure

	:param lowerheatingvalue
	:type lowerheatingvalue:ifcheatingvaluemeasure

	:param higherheatingvalue
	:type higherheatingvalue:ifcheatingvaluemeasure
	'''
	def __init__( self , inherited0__material , combustiontemperature,carboncontent,lowerheatingvalue,higherheatingvalue, ):
		ifcmaterialproperties.__init__(self , inherited0__material , )
		self.combustiontemperature = combustiontemperature
		self.carboncontent = carboncontent
		self.lowerheatingvalue = lowerheatingvalue
		self.higherheatingvalue = higherheatingvalue

	@apply
	def combustiontemperature():
		def fget( self ):
			return self._combustiontemperature
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcthermodynamictemperaturemeasure):
					self._combustiontemperature = ifcthermodynamictemperaturemeasure(value)
				else:
					self._combustiontemperature = value
			else:
				self._combustiontemperature = value
		return property(**locals())

	@apply
	def carboncontent():
		def fget( self ):
			return self._carboncontent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._carboncontent = ifcpositiveratiomeasure(value)
				else:
					self._carboncontent = value
			else:
				self._carboncontent = value
		return property(**locals())

	@apply
	def lowerheatingvalue():
		def fget( self ):
			return self._lowerheatingvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcheatingvaluemeasure):
					self._lowerheatingvalue = ifcheatingvaluemeasure(value)
				else:
					self._lowerheatingvalue = value
			else:
				self._lowerheatingvalue = value
		return property(**locals())

	@apply
	def higherheatingvalue():
		def fget( self ):
			return self._higherheatingvalue
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcheatingvaluemeasure):
					self._higherheatingvalue = ifcheatingvaluemeasure(value)
				else:
					self._higherheatingvalue = value
			else:
				self._higherheatingvalue = value
		return property(**locals())

####################
 # ENTITY ifclocaltime #
####################
class ifclocaltime(BaseEntityClass):
	'''Entity ifclocaltime definition.

	:param hourcomponent
	:type hourcomponent:ifchourinday

	:param minutecomponent
	:type minutecomponent:ifcminuteinhour

	:param secondcomponent
	:type secondcomponent:ifcsecondinminute

	:param zone
	:type zone:ifccoordinateduniversaltimeoffset

	:param daylightsavingoffset
	:type daylightsavingoffset:ifcdaylightsavinghour
	'''
	def __init__( self , hourcomponent,minutecomponent,secondcomponent,zone,daylightsavingoffset, ):
		self.hourcomponent = hourcomponent
		self.minutecomponent = minutecomponent
		self.secondcomponent = secondcomponent
		self.zone = zone
		self.daylightsavingoffset = daylightsavingoffset

	@apply
	def hourcomponent():
		def fget( self ):
			return self._hourcomponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hourcomponent is mantatory and can not be set to None')
			if not check_type(value,ifchourinday):
				self._hourcomponent = ifchourinday(value)
			else:
				self._hourcomponent = value
		return property(**locals())

	@apply
	def minutecomponent():
		def fget( self ):
			return self._minutecomponent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcminuteinhour):
					self._minutecomponent = ifcminuteinhour(value)
				else:
					self._minutecomponent = value
			else:
				self._minutecomponent = value
		return property(**locals())

	@apply
	def secondcomponent():
		def fget( self ):
			return self._secondcomponent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcsecondinminute):
					self._secondcomponent = ifcsecondinminute(value)
				else:
					self._secondcomponent = value
			else:
				self._secondcomponent = value
		return property(**locals())

	@apply
	def zone():
		def fget( self ):
			return self._zone
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccoordinateduniversaltimeoffset):
					self._zone = ifccoordinateduniversaltimeoffset(value)
				else:
					self._zone = value
			else:
				self._zone = value
		return property(**locals())

	@apply
	def daylightsavingoffset():
		def fget( self ):
			return self._daylightsavingoffset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdaylightsavinghour):
					self._daylightsavingoffset = ifcdaylightsavinghour(value)
				else:
					self._daylightsavingoffset = value
			else:
				self._daylightsavingoffset = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = ifcvalidtime(self)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcslippageconnectioncondition #
####################
class ifcslippageconnectioncondition(ifcstructuralconnectioncondition):
	'''Entity ifcslippageconnectioncondition definition.

	:param slippagex
	:type slippagex:ifclengthmeasure

	:param slippagey
	:type slippagey:ifclengthmeasure

	:param slippagez
	:type slippagez:ifclengthmeasure
	'''
	def __init__( self , inherited0__name , slippagex,slippagey,slippagez, ):
		ifcstructuralconnectioncondition.__init__(self , inherited0__name , )
		self.slippagex = slippagex
		self.slippagey = slippagey
		self.slippagez = slippagez

	@apply
	def slippagex():
		def fget( self ):
			return self._slippagex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._slippagex = ifclengthmeasure(value)
				else:
					self._slippagex = value
			else:
				self._slippagex = value
		return property(**locals())

	@apply
	def slippagey():
		def fget( self ):
			return self._slippagey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._slippagey = ifclengthmeasure(value)
				else:
					self._slippagey = value
			else:
				self._slippagey = value
		return property(**locals())

	@apply
	def slippagez():
		def fget( self ):
			return self._slippagez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._slippagez = ifclengthmeasure(value)
				else:
					self._slippagez = value
			else:
				self._slippagez = value
		return property(**locals())

####################
 # ENTITY ifcstructuralresultgroup #
####################
class ifcstructuralresultgroup(ifcgroup):
	'''Entity ifcstructuralresultgroup definition.

	:param theorytype
	:type theorytype:ifcanalysistheorytypeenum

	:param resultforloadgroup
	:type resultforloadgroup:ifcstructuralloadgroup

	:param islinear
	:type islinear:BOOLEAN

	:param resultgroupfor
	:type resultgroupfor:SET(0,1,'ifcstructuralanalysismodel', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , theorytype,resultforloadgroup,islinear, ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.theorytype = theorytype
		self.resultforloadgroup = resultforloadgroup
		self.islinear = islinear

	@apply
	def theorytype():
		def fget( self ):
			return self._theorytype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument theorytype is mantatory and can not be set to None')
			if not check_type(value,ifcanalysistheorytypeenum):
				self._theorytype = ifcanalysistheorytypeenum(value)
			else:
				self._theorytype = value
		return property(**locals())

	@apply
	def resultforloadgroup():
		def fget( self ):
			return self._resultforloadgroup
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcstructuralloadgroup):
					self._resultforloadgroup = ifcstructuralloadgroup(value)
				else:
					self._resultforloadgroup = value
			else:
				self._resultforloadgroup = value
		return property(**locals())

	@apply
	def islinear():
		def fget( self ):
			return self._islinear
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument islinear is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._islinear = BOOLEAN(value)
			else:
				self._islinear = value
		return property(**locals())

	@apply
	def resultgroupfor():
		def fget( self ):
			return self._resultgroupfor
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument resultgroupfor is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifctopologyrepresentation #
####################
class ifctopologyrepresentation(ifcshapemodel):
	'''Entity ifctopologyrepresentation definition.
	'''
	def __init__( self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items ,  ):
		ifcshapemodel.__init__(self , inherited0__contextofitems , inherited1__representationidentifier , inherited2__representationtype , inherited3__items , )
	def wr21(self):
		eval_wr21_wr = (SIZEOF(None)  ==  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = EXISTS(self.self.ifcrepresentation.self.representationtype)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr

	def wr23(self):
		eval_wr23_wr = ifctopologyrepresentationtypes(self.self.ifcrepresentation.self.representationtype,self.self.ifcrepresentation.self.items)
		if not eval_wr23_wr:
			raise AssertionError('Rule wr23 violated')
		else:
			return eval_wr23_wr


####################
 # ENTITY ifcblock #
####################
class ifcblock(ifccsgprimitive3d):
	'''Entity ifcblock definition.

	:param xlength
	:type xlength:ifcpositivelengthmeasure

	:param ylength
	:type ylength:ifcpositivelengthmeasure

	:param zlength
	:type zlength:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , xlength,ylength,zlength, ):
		ifccsgprimitive3d.__init__(self , inherited0__position , )
		self.xlength = xlength
		self.ylength = ylength
		self.zlength = zlength

	@apply
	def xlength():
		def fget( self ):
			return self._xlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument xlength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._xlength = ifcpositivelengthmeasure(value)
			else:
				self._xlength = value
		return property(**locals())

	@apply
	def ylength():
		def fget( self ):
			return self._ylength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ylength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._ylength = ifcpositivelengthmeasure(value)
			else:
				self._ylength = value
		return property(**locals())

	@apply
	def zlength():
		def fget( self ):
			return self._zlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zlength is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._zlength = ifcpositivelengthmeasure(value)
			else:
				self._zlength = value
		return property(**locals())

####################
 # ENTITY ifcconnectionpointgeometry #
####################
class ifcconnectionpointgeometry(ifcconnectiongeometry):
	'''Entity ifcconnectionpointgeometry definition.

	:param pointonrelatingelement
	:type pointonrelatingelement:ifcpointorvertexpoint

	:param pointonrelatedelement
	:type pointonrelatedelement:ifcpointorvertexpoint
	'''
	def __init__( self , pointonrelatingelement,pointonrelatedelement, ):
		ifcconnectiongeometry.__init__(self , )
		self.pointonrelatingelement = pointonrelatingelement
		self.pointonrelatedelement = pointonrelatedelement

	@apply
	def pointonrelatingelement():
		def fget( self ):
			return self._pointonrelatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pointonrelatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcpointorvertexpoint):
				self._pointonrelatingelement = ifcpointorvertexpoint(value)
			else:
				self._pointonrelatingelement = value
		return property(**locals())

	@apply
	def pointonrelatedelement():
		def fget( self ):
			return self._pointonrelatedelement
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpointorvertexpoint):
					self._pointonrelatedelement = ifcpointorvertexpoint(value)
				else:
					self._pointonrelatedelement = value
			else:
				self._pointonrelatedelement = value
		return property(**locals())

####################
 # ENTITY ifcconnectionpointeccentricity #
####################
class ifcconnectionpointeccentricity(ifcconnectionpointgeometry):
	'''Entity ifcconnectionpointeccentricity definition.

	:param eccentricityinx
	:type eccentricityinx:ifclengthmeasure

	:param eccentricityiny
	:type eccentricityiny:ifclengthmeasure

	:param eccentricityinz
	:type eccentricityinz:ifclengthmeasure
	'''
	def __init__( self , inherited0__pointonrelatingelement , inherited1__pointonrelatedelement , eccentricityinx,eccentricityiny,eccentricityinz, ):
		ifcconnectionpointgeometry.__init__(self , inherited0__pointonrelatingelement , inherited1__pointonrelatedelement , )
		self.eccentricityinx = eccentricityinx
		self.eccentricityiny = eccentricityiny
		self.eccentricityinz = eccentricityinz

	@apply
	def eccentricityinx():
		def fget( self ):
			return self._eccentricityinx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._eccentricityinx = ifclengthmeasure(value)
				else:
					self._eccentricityinx = value
			else:
				self._eccentricityinx = value
		return property(**locals())

	@apply
	def eccentricityiny():
		def fget( self ):
			return self._eccentricityiny
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._eccentricityiny = ifclengthmeasure(value)
				else:
					self._eccentricityiny = value
			else:
				self._eccentricityiny = value
		return property(**locals())

	@apply
	def eccentricityinz():
		def fget( self ):
			return self._eccentricityinz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclengthmeasure):
					self._eccentricityinz = ifclengthmeasure(value)
				else:
					self._eccentricityinz = value
			else:
				self._eccentricityinz = value
		return property(**locals())

####################
 # ENTITY ifcedgeloop #
####################
class ifcedgeloop(ifcloop):
	'''Entity ifcedgeloop definition.

	:param edgelist
	:type edgelist:LIST(1,None,'ifcorientededge', scope = schema_scope)

	:param ne
	:type ne:INTEGER
	'''
	def __init__( self , edgelist, ):
		ifcloop.__init__(self , )
		self.edgelist = edgelist

	@apply
	def edgelist():
		def fget( self ):
			return self._edgelist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edgelist is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcorientededge', scope = schema_scope)):
				self._edgelist = LIST(value)
			else:
				self._edgelist = value
		return property(**locals())

	@apply
	def ne():
		def fget( self ):
			attribute_eval = SIZEOF(self.edgelist)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ne is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.edgelist[1].self.edgestart  ==  self.edgelist[self.ne].self.edgeend)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ifcloopheadtotail(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcrelservicesbuildings #
####################
class ifcrelservicesbuildings(ifcrelconnects):
	'''Entity ifcrelservicesbuildings definition.

	:param relatingsystem
	:type relatingsystem:ifcsystem

	:param relatedbuildings
	:type relatedbuildings:SET(1,None,'ifcspatialstructureelement', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingsystem,relatedbuildings, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingsystem = relatingsystem
		self.relatedbuildings = relatedbuildings

	@apply
	def relatingsystem():
		def fget( self ):
			return self._relatingsystem
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingsystem is mantatory and can not be set to None')
			if not check_type(value,ifcsystem):
				self._relatingsystem = ifcsystem(value)
			else:
				self._relatingsystem = value
		return property(**locals())

	@apply
	def relatedbuildings():
		def fget( self ):
			return self._relatedbuildings
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedbuildings is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcspatialstructureelement', scope = schema_scope)):
				self._relatedbuildings = SET(value)
			else:
				self._relatedbuildings = value
		return property(**locals())

####################
 # ENTITY ifctexturecoordinategenerator #
####################
class ifctexturecoordinategenerator(ifctexturecoordinate):
	'''Entity ifctexturecoordinategenerator definition.

	:param mode
	:type mode:ifclabel

	:param parameter
	:type parameter:LIST(1,None,'ifcsimplevalue', scope = schema_scope)
	'''
	def __init__( self , mode,parameter, ):
		ifctexturecoordinate.__init__(self , )
		self.mode = mode
		self.parameter = parameter

	@apply
	def mode():
		def fget( self ):
			return self._mode
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mode is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._mode = ifclabel(value)
			else:
				self._mode = value
		return property(**locals())

	@apply
	def parameter():
		def fget( self ):
			return self._parameter
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parameter is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcsimplevalue', scope = schema_scope)):
				self._parameter = LIST(value)
			else:
				self._parameter = value
		return property(**locals())

####################
 # ENTITY ifccablecarrierfittingtype #
####################
class ifccablecarrierfittingtype(ifcflowfittingtype):
	'''Entity ifccablecarrierfittingtype definition.

	:param predefinedtype
	:type predefinedtype:ifccablecarrierfittingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowfittingtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccablecarrierfittingtypeenum):
				self._predefinedtype = ifccablecarrierfittingtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifccablecarrierfittingtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccablecarrierfittingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcappliedvaluerelationship #
####################
class ifcappliedvaluerelationship(BaseEntityClass):
	'''Entity ifcappliedvaluerelationship definition.

	:param componentoftotal
	:type componentoftotal:ifcappliedvalue

	:param components
	:type components:SET(1,None,'ifcappliedvalue', scope = schema_scope)

	:param arithmeticoperator
	:type arithmeticoperator:ifcarithmeticoperatorenum

	:param name
	:type name:ifclabel

	:param description
	:type description:ifctext
	'''
	def __init__( self , componentoftotal,components,arithmeticoperator,name,description, ):
		self.componentoftotal = componentoftotal
		self.components = components
		self.arithmeticoperator = arithmeticoperator
		self.name = name
		self.description = description

	@apply
	def componentoftotal():
		def fget( self ):
			return self._componentoftotal
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument componentoftotal is mantatory and can not be set to None')
			if not check_type(value,ifcappliedvalue):
				self._componentoftotal = ifcappliedvalue(value)
			else:
				self._componentoftotal = value
		return property(**locals())

	@apply
	def components():
		def fget( self ):
			return self._components
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument components is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcappliedvalue', scope = schema_scope)):
				self._components = SET(value)
			else:
				self._components = value
		return property(**locals())

	@apply
	def arithmeticoperator():
		def fget( self ):
			return self._arithmeticoperator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument arithmeticoperator is mantatory and can not be set to None')
			if not check_type(value,ifcarithmeticoperatorenum):
				self._arithmeticoperator = ifcarithmeticoperatorenum(value)
			else:
				self._arithmeticoperator = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctext):
					self._description = ifctext(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY ifcclassificationnotationfacet #
####################
class ifcclassificationnotationfacet(BaseEntityClass):
	'''Entity ifcclassificationnotationfacet definition.

	:param notationvalue
	:type notationvalue:ifclabel
	'''
	def __init__( self , notationvalue, ):
		self.notationvalue = notationvalue

	@apply
	def notationvalue():
		def fget( self ):
			return self._notationvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument notationvalue is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._notationvalue = ifclabel(value)
			else:
				self._notationvalue = value
		return property(**locals())

####################
 # ENTITY ifcdimensioncurveterminator #
####################
class ifcdimensioncurveterminator(ifcterminatorsymbol):
	'''Entity ifcdimensioncurveterminator definition.

	:param role
	:type role:ifcdimensionextentusage
	'''
	def __init__( self , inherited0__item , inherited1__styles , inherited2__name , inherited3__annotatedcurve , role, ):
		ifcterminatorsymbol.__init__(self , inherited0__item , inherited1__styles , inherited2__name , inherited3__annotatedcurve , )
		self.role = role

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,ifcdimensionextentusage):
				self._role = ifcdimensionextentusage(value)
			else:
				self._role = value
		return property(**locals())
	def wr61(self):
		eval_wr61_wr = ('IFC2X3.IFCDIMENSIONCURVE'  ==  TYPEOF(self.self.ifcterminatorsymbol.self.annotatedcurve))
		if not eval_wr61_wr:
			raise AssertionError('Rule wr61 violated')
		else:
			return eval_wr61_wr


####################
 # ENTITY ifcductfittingtype #
####################
class ifcductfittingtype(ifcflowfittingtype):
	'''Entity ifcductfittingtype definition.

	:param predefinedtype
	:type predefinedtype:ifcductfittingtypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowfittingtype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcductfittingtypeenum):
				self._predefinedtype = ifcductfittingtypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr2(self):
		eval_wr2_wr = ((self.predefinedtype  !=  ifcductfittingtypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcductfittingtypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifclocalplacement #
####################
class ifclocalplacement(ifcobjectplacement):
	'''Entity ifclocalplacement definition.

	:param placementrelto
	:type placementrelto:ifcobjectplacement

	:param relativeplacement
	:type relativeplacement:ifcaxis2placement
	'''
	def __init__( self , placementrelto,relativeplacement, ):
		ifcobjectplacement.__init__(self , )
		self.placementrelto = placementrelto
		self.relativeplacement = relativeplacement

	@apply
	def placementrelto():
		def fget( self ):
			return self._placementrelto
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcobjectplacement):
					self._placementrelto = ifcobjectplacement(value)
				else:
					self._placementrelto = value
			else:
				self._placementrelto = value
		return property(**locals())

	@apply
	def relativeplacement():
		def fget( self ):
			return self._relativeplacement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relativeplacement is mantatory and can not be set to None')
			if not check_type(value,ifcaxis2placement):
				self._relativeplacement = ifcaxis2placement(value)
			else:
				self._relativeplacement = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = ifccorrectlocalplacement(self.relativeplacement,self.placementrelto)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcpropertyset #
####################
class ifcpropertyset(ifcpropertysetdefinition):
	'''Entity ifcpropertyset definition.

	:param hasproperties
	:type hasproperties:SET(1,None,'ifcproperty', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , hasproperties, ):
		ifcpropertysetdefinition.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.hasproperties = hasproperties

	@apply
	def hasproperties():
		def fget( self ):
			return self._hasproperties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hasproperties is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcproperty', scope = schema_scope)):
				self._hasproperties = SET(value)
			else:
				self._hasproperties = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr

	def wr32(self):
		eval_wr32_wr = ifcuniquepropertyname(self.hasproperties)
		if not eval_wr32_wr:
			raise AssertionError('Rule wr32 violated')
		else:
			return eval_wr32_wr


####################
 # ENTITY ifcstructuralcurvemembervarying #
####################
class ifcstructuralcurvemembervarying(ifcstructuralcurvemember):
	'''Entity ifcstructuralcurvemembervarying definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__predefinedtype ,  ):
		ifcstructuralcurvemember.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__predefinedtype , )

####################
 # ENTITY ifcunitaryequipmenttype #
####################
class ifcunitaryequipmenttype(ifcenergyconversiondevicetype):
	'''Entity ifcunitaryequipmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcunitaryequipmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcenergyconversiondevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcunitaryequipmenttypeenum):
				self._predefinedtype = ifcunitaryequipmenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcunitaryequipmenttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcunitaryequipmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifczone #
####################
class ifczone(ifcgroup):
	'''Entity ifczone definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype ,  ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcrelprojectselement #
####################
class ifcrelprojectselement(ifcrelconnects):
	'''Entity ifcrelprojectselement definition.

	:param relatingelement
	:type relatingelement:ifcelement

	:param relatedfeatureelement
	:type relatedfeatureelement:ifcfeatureelementaddition
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , relatingelement,relatedfeatureelement, ):
		ifcrelconnects.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , )
		self.relatingelement = relatingelement
		self.relatedfeatureelement = relatedfeatureelement

	@apply
	def relatingelement():
		def fget( self ):
			return self._relatingelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingelement is mantatory and can not be set to None')
			if not check_type(value,ifcelement):
				self._relatingelement = ifcelement(value)
			else:
				self._relatingelement = value
		return property(**locals())

	@apply
	def relatedfeatureelement():
		def fget( self ):
			return self._relatedfeatureelement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatedfeatureelement is mantatory and can not be set to None')
			if not check_type(value,ifcfeatureelementaddition):
				self._relatedfeatureelement = ifcfeatureelementaddition(value)
			else:
				self._relatedfeatureelement = value
		return property(**locals())

####################
 # ENTITY ifctanktype #
####################
class ifctanktype(ifcflowstoragedevicetype):
	'''Entity ifctanktype definition.

	:param predefinedtype
	:type predefinedtype:ifctanktypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowstoragedevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifctanktypeenum):
				self._predefinedtype = ifctanktypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifctanktypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifctanktypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcdocumentelectronicformat #
####################
class ifcdocumentelectronicformat(BaseEntityClass):
	'''Entity ifcdocumentelectronicformat definition.

	:param fileextension
	:type fileextension:ifclabel

	:param mimecontenttype
	:type mimecontenttype:ifclabel

	:param mimesubtype
	:type mimesubtype:ifclabel
	'''
	def __init__( self , fileextension,mimecontenttype,mimesubtype, ):
		self.fileextension = fileextension
		self.mimecontenttype = mimecontenttype
		self.mimesubtype = mimesubtype

	@apply
	def fileextension():
		def fget( self ):
			return self._fileextension
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._fileextension = ifclabel(value)
				else:
					self._fileextension = value
			else:
				self._fileextension = value
		return property(**locals())

	@apply
	def mimecontenttype():
		def fget( self ):
			return self._mimecontenttype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._mimecontenttype = ifclabel(value)
				else:
					self._mimecontenttype = value
			else:
				self._mimecontenttype = value
		return property(**locals())

	@apply
	def mimesubtype():
		def fget( self ):
			return self._mimesubtype
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._mimesubtype = ifclabel(value)
				else:
					self._mimesubtype = value
			else:
				self._mimesubtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.fileextension)  or  EXISTS(self.mimecontenttype))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcwindowstyle #
####################
class ifcwindowstyle(ifctypeproduct):
	'''Entity ifcwindowstyle definition.

	:param constructiontype
	:type constructiontype:ifcwindowstyleconstructionenum

	:param operationtype
	:type operationtype:ifcwindowstyleoperationenum

	:param parametertakesprecedence
	:type parametertakesprecedence:BOOLEAN

	:param sizeable
	:type sizeable:BOOLEAN
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , constructiontype,operationtype,parametertakesprecedence,sizeable, ):
		ifctypeproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , )
		self.constructiontype = constructiontype
		self.operationtype = operationtype
		self.parametertakesprecedence = parametertakesprecedence
		self.sizeable = sizeable

	@apply
	def constructiontype():
		def fget( self ):
			return self._constructiontype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constructiontype is mantatory and can not be set to None')
			if not check_type(value,ifcwindowstyleconstructionenum):
				self._constructiontype = ifcwindowstyleconstructionenum(value)
			else:
				self._constructiontype = value
		return property(**locals())

	@apply
	def operationtype():
		def fget( self ):
			return self._operationtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operationtype is mantatory and can not be set to None')
			if not check_type(value,ifcwindowstyleoperationenum):
				self._operationtype = ifcwindowstyleoperationenum(value)
			else:
				self._operationtype = value
		return property(**locals())

	@apply
	def parametertakesprecedence():
		def fget( self ):
			return self._parametertakesprecedence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parametertakesprecedence is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._parametertakesprecedence = BOOLEAN(value)
			else:
				self._parametertakesprecedence = value
		return property(**locals())

	@apply
	def sizeable():
		def fget( self ):
			return self._sizeable
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sizeable is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._sizeable = BOOLEAN(value)
			else:
				self._sizeable = value
		return property(**locals())

####################
 # ENTITY ifcworkschedule #
####################
class ifcworkschedule(ifcworkcontrol):
	'''Entity ifcworkschedule definition.
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identifier , inherited6__creationdate , inherited7__creators , inherited8__purpose , inherited9__duration , inherited10__totalfloat , inherited11__starttime , inherited12__finishtime , inherited13__workcontroltype , inherited14__userdefinedcontroltype ,  ):
		ifcworkcontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__identifier , inherited6__creationdate , inherited7__creators , inherited8__purpose , inherited9__duration , inherited10__totalfloat , inherited11__starttime , inherited12__finishtime , inherited13__workcontroltype , inherited14__userdefinedcontroltype , )

####################
 # ENTITY ifcboundaryfacecondition #
####################
class ifcboundaryfacecondition(ifcboundarycondition):
	'''Entity ifcboundaryfacecondition definition.

	:param linearstiffnessbyareax
	:type linearstiffnessbyareax:ifcmodulusofsubgradereactionmeasure

	:param linearstiffnessbyareay
	:type linearstiffnessbyareay:ifcmodulusofsubgradereactionmeasure

	:param linearstiffnessbyareaz
	:type linearstiffnessbyareaz:ifcmodulusofsubgradereactionmeasure
	'''
	def __init__( self , inherited0__name , linearstiffnessbyareax,linearstiffnessbyareay,linearstiffnessbyareaz, ):
		ifcboundarycondition.__init__(self , inherited0__name , )
		self.linearstiffnessbyareax = linearstiffnessbyareax
		self.linearstiffnessbyareay = linearstiffnessbyareay
		self.linearstiffnessbyareaz = linearstiffnessbyareaz

	@apply
	def linearstiffnessbyareax():
		def fget( self ):
			return self._linearstiffnessbyareax
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofsubgradereactionmeasure):
					self._linearstiffnessbyareax = ifcmodulusofsubgradereactionmeasure(value)
				else:
					self._linearstiffnessbyareax = value
			else:
				self._linearstiffnessbyareax = value
		return property(**locals())

	@apply
	def linearstiffnessbyareay():
		def fget( self ):
			return self._linearstiffnessbyareay
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofsubgradereactionmeasure):
					self._linearstiffnessbyareay = ifcmodulusofsubgradereactionmeasure(value)
				else:
					self._linearstiffnessbyareay = value
			else:
				self._linearstiffnessbyareay = value
		return property(**locals())

	@apply
	def linearstiffnessbyareaz():
		def fget( self ):
			return self._linearstiffnessbyareaz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmodulusofsubgradereactionmeasure):
					self._linearstiffnessbyareaz = ifcmodulusofsubgradereactionmeasure(value)
				else:
					self._linearstiffnessbyareaz = value
			else:
				self._linearstiffnessbyareaz = value
		return property(**locals())

####################
 # ENTITY ifccompositeprofiledef #
####################
class ifccompositeprofiledef(ifcprofiledef):
	'''Entity ifccompositeprofiledef definition.

	:param profiles
	:type profiles:SET(2,None,'ifcprofiledef', scope = schema_scope)

	:param label
	:type label:ifclabel
	'''
	def __init__( self , inherited0__profiletype , inherited1__profilename , profiles,label, ):
		ifcprofiledef.__init__(self , inherited0__profiletype , inherited1__profilename , )
		self.profiles = profiles
		self.label = label

	@apply
	def profiles():
		def fget( self ):
			return self._profiles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument profiles is mantatory and can not be set to None')
			if not check_type(value,SET(2,None,'ifcprofiledef', scope = schema_scope)):
				self._profiles = SET(value)
			else:
				self._profiles = value
		return property(**locals())

	@apply
	def label():
		def fget( self ):
			return self._label
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._label = ifclabel(value)
				else:
					self._label = value
			else:
				self._label = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcasset #
####################
class ifcasset(ifcgroup):
	'''Entity ifcasset definition.

	:param assetid
	:type assetid:ifcidentifier

	:param originalvalue
	:type originalvalue:ifccostvalue

	:param currentvalue
	:type currentvalue:ifccostvalue

	:param totalreplacementcost
	:type totalreplacementcost:ifccostvalue

	:param owner
	:type owner:ifcactorselect

	:param user
	:type user:ifcactorselect

	:param responsibleperson
	:type responsibleperson:ifcperson

	:param incorporationdate
	:type incorporationdate:ifccalendardate

	:param depreciatedvalue
	:type depreciatedvalue:ifccostvalue
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , assetid,originalvalue,currentvalue,totalreplacementcost,owner,user,responsibleperson,incorporationdate,depreciatedvalue, ):
		ifcgroup.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.assetid = assetid
		self.originalvalue = originalvalue
		self.currentvalue = currentvalue
		self.totalreplacementcost = totalreplacementcost
		self.owner = owner
		self.user = user
		self.responsibleperson = responsibleperson
		self.incorporationdate = incorporationdate
		self.depreciatedvalue = depreciatedvalue

	@apply
	def assetid():
		def fget( self ):
			return self._assetid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assetid is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._assetid = ifcidentifier(value)
			else:
				self._assetid = value
		return property(**locals())

	@apply
	def originalvalue():
		def fget( self ):
			return self._originalvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument originalvalue is mantatory and can not be set to None')
			if not check_type(value,ifccostvalue):
				self._originalvalue = ifccostvalue(value)
			else:
				self._originalvalue = value
		return property(**locals())

	@apply
	def currentvalue():
		def fget( self ):
			return self._currentvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument currentvalue is mantatory and can not be set to None')
			if not check_type(value,ifccostvalue):
				self._currentvalue = ifccostvalue(value)
			else:
				self._currentvalue = value
		return property(**locals())

	@apply
	def totalreplacementcost():
		def fget( self ):
			return self._totalreplacementcost
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument totalreplacementcost is mantatory and can not be set to None')
			if not check_type(value,ifccostvalue):
				self._totalreplacementcost = ifccostvalue(value)
			else:
				self._totalreplacementcost = value
		return property(**locals())

	@apply
	def owner():
		def fget( self ):
			return self._owner
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument owner is mantatory and can not be set to None')
			if not check_type(value,ifcactorselect):
				self._owner = ifcactorselect(value)
			else:
				self._owner = value
		return property(**locals())

	@apply
	def user():
		def fget( self ):
			return self._user
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument user is mantatory and can not be set to None')
			if not check_type(value,ifcactorselect):
				self._user = ifcactorselect(value)
			else:
				self._user = value
		return property(**locals())

	@apply
	def responsibleperson():
		def fget( self ):
			return self._responsibleperson
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument responsibleperson is mantatory and can not be set to None')
			if not check_type(value,ifcperson):
				self._responsibleperson = ifcperson(value)
			else:
				self._responsibleperson = value
		return property(**locals())

	@apply
	def incorporationdate():
		def fget( self ):
			return self._incorporationdate
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument incorporationdate is mantatory and can not be set to None')
			if not check_type(value,ifccalendardate):
				self._incorporationdate = ifccalendardate(value)
			else:
				self._incorporationdate = value
		return property(**locals())

	@apply
	def depreciatedvalue():
		def fget( self ):
			return self._depreciatedvalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depreciatedvalue is mantatory and can not be set to None')
			if not check_type(value,ifccostvalue):
				self._depreciatedvalue = ifccostvalue(value)
			else:
				self._depreciatedvalue = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcirregulartimeseries #
####################
class ifcirregulartimeseries(ifctimeseries):
	'''Entity ifcirregulartimeseries definition.

	:param values
	:type values:LIST(1,None,'ifcirregulartimeseriesvalue', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__starttime , inherited3__endtime , inherited4__timeseriesdatatype , inherited5__dataorigin , inherited6__userdefineddataorigin , inherited7__unit , values, ):
		ifctimeseries.__init__(self , inherited0__name , inherited1__description , inherited2__starttime , inherited3__endtime , inherited4__timeseriesdatatype , inherited5__dataorigin , inherited6__userdefineddataorigin , inherited7__unit , )
		self.values = values

	@apply
	def values():
		def fget( self ):
			return self._values
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument values is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcirregulartimeseriesvalue', scope = schema_scope)):
				self._values = LIST(value)
			else:
				self._values = value
		return property(**locals())

####################
 # ENTITY ifcblobtexture #
####################
class ifcblobtexture(ifcsurfacetexture):
	'''Entity ifcblobtexture definition.

	:param rasterformat
	:type rasterformat:ifcidentifier

	:param rastercode
	:type rastercode:BOOLEAN
	'''
	def __init__( self , inherited0__repeats , inherited1__repeatt , inherited2__texturetype , inherited3__texturetransform , rasterformat,rastercode, ):
		ifcsurfacetexture.__init__(self , inherited0__repeats , inherited1__repeatt , inherited2__texturetype , inherited3__texturetransform , )
		self.rasterformat = rasterformat
		self.rastercode = rastercode

	@apply
	def rasterformat():
		def fget( self ):
			return self._rasterformat
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rasterformat is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._rasterformat = ifcidentifier(value)
			else:
				self._rasterformat = value
		return property(**locals())

	@apply
	def rastercode():
		def fget( self ):
			return self._rastercode
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rastercode is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._rastercode = BOOLEAN(value)
			else:
				self._rastercode = value
		return property(**locals())
	def wr11(self):
		eval_wr11_wr = (self.self.rasterformat  ==  ['BMP','JPG','GIF','PNG'])
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY ifclightintensitydistribution #
####################
class ifclightintensitydistribution(BaseEntityClass):
	'''Entity ifclightintensitydistribution definition.

	:param lightdistributioncurve
	:type lightdistributioncurve:ifclightdistributioncurveenum

	:param distributiondata
	:type distributiondata:LIST(1,None,'ifclightdistributiondata', scope = schema_scope)
	'''
	def __init__( self , lightdistributioncurve,distributiondata, ):
		self.lightdistributioncurve = lightdistributioncurve
		self.distributiondata = distributiondata

	@apply
	def lightdistributioncurve():
		def fget( self ):
			return self._lightdistributioncurve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lightdistributioncurve is mantatory and can not be set to None')
			if not check_type(value,ifclightdistributioncurveenum):
				self._lightdistributioncurve = ifclightdistributioncurveenum(value)
			else:
				self._lightdistributioncurve = value
		return property(**locals())

	@apply
	def distributiondata():
		def fget( self ):
			return self._distributiondata
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distributiondata is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifclightdistributiondata', scope = schema_scope)):
				self._distributiondata = LIST(value)
			else:
				self._distributiondata = value
		return property(**locals())

####################
 # ENTITY ifcorderaction #
####################
class ifcorderaction(ifctask):
	'''Entity ifcorderaction definition.

	:param actionid
	:type actionid:ifcidentifier
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__taskid , inherited6__status , inherited7__workmethod , inherited8__ismilestone , inherited9__priority , actionid, ):
		ifctask.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__taskid , inherited6__status , inherited7__workmethod , inherited8__ismilestone , inherited9__priority , )
		self.actionid = actionid

	@apply
	def actionid():
		def fget( self ):
			return self._actionid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument actionid is mantatory and can not be set to None')
			if not check_type(value,ifcidentifier):
				self._actionid = ifcidentifier(value)
			else:
				self._actionid = value
		return property(**locals())

####################
 # ENTITY ifcgrid #
####################
class ifcgrid(ifcproduct):
	'''Entity ifcgrid definition.

	:param uaxes
	:type uaxes:LIST(1,None,'ifcgridaxis', scope = schema_scope)

	:param vaxes
	:type vaxes:LIST(1,None,'ifcgridaxis', scope = schema_scope)

	:param waxes
	:type waxes:LIST(1,None,'ifcgridaxis', scope = schema_scope)

	:param containedinstructure
	:type containedinstructure:SET(0,1,'ifcrelcontainedinspatialstructure', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , uaxes,vaxes,waxes, ):
		ifcproduct.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , )
		self.uaxes = uaxes
		self.vaxes = vaxes
		self.waxes = waxes

	@apply
	def uaxes():
		def fget( self ):
			return self._uaxes
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uaxes is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcgridaxis', scope = schema_scope)):
				self._uaxes = LIST(value)
			else:
				self._uaxes = value
		return property(**locals())

	@apply
	def vaxes():
		def fget( self ):
			return self._vaxes
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vaxes is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifcgridaxis', scope = schema_scope)):
				self._vaxes = LIST(value)
			else:
				self._vaxes = value
		return property(**locals())

	@apply
	def waxes():
		def fget( self ):
			return self._waxes
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcgridaxis', scope = schema_scope)):
					self._waxes = LIST(value)
				else:
					self._waxes = value
			else:
				self._waxes = value
		return property(**locals())

	@apply
	def containedinstructure():
		def fget( self ):
			return self._containedinstructure
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument containedinstructure is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = EXISTS(self.self.ifcproduct.self.objectplacement)
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr


####################
 # ENTITY ifcmechanicalfastener #
####################
class ifcmechanicalfastener(ifcfastener):
	'''Entity ifcmechanicalfastener definition.

	:param nominaldiameter
	:type nominaldiameter:ifcpositivelengthmeasure

	:param nominallength
	:type nominallength:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , nominaldiameter,nominallength, ):
		ifcfastener.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.nominaldiameter = nominaldiameter
		self.nominallength = nominallength

	@apply
	def nominaldiameter():
		def fget( self ):
			return self._nominaldiameter
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominaldiameter = ifcpositivelengthmeasure(value)
				else:
					self._nominaldiameter = value
			else:
				self._nominaldiameter = value
		return property(**locals())

	@apply
	def nominallength():
		def fget( self ):
			return self._nominallength
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._nominallength = ifcpositivelengthmeasure(value)
				else:
					self._nominallength = value
			else:
				self._nominallength = value
		return property(**locals())

####################
 # ENTITY ifcphysicalcomplexquantity #
####################
class ifcphysicalcomplexquantity(ifcphysicalquantity):
	'''Entity ifcphysicalcomplexquantity definition.

	:param hasquantities
	:type hasquantities:SET(1,None,'ifcphysicalquantity', scope = schema_scope)

	:param discrimination
	:type discrimination:ifclabel

	:param quality
	:type quality:ifclabel

	:param usage
	:type usage:ifclabel
	'''
	def __init__( self , inherited0__name , inherited1__description , hasquantities,discrimination,quality,usage, ):
		ifcphysicalquantity.__init__(self , inherited0__name , inherited1__description , )
		self.hasquantities = hasquantities
		self.discrimination = discrimination
		self.quality = quality
		self.usage = usage

	@apply
	def hasquantities():
		def fget( self ):
			return self._hasquantities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hasquantities is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ifcphysicalquantity', scope = schema_scope)):
				self._hasquantities = SET(value)
			else:
				self._hasquantities = value
		return property(**locals())

	@apply
	def discrimination():
		def fget( self ):
			return self._discrimination
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument discrimination is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._discrimination = ifclabel(value)
			else:
				self._discrimination = value
		return property(**locals())

	@apply
	def quality():
		def fget( self ):
			return self._quality
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._quality = ifclabel(value)
				else:
					self._quality = value
			else:
				self._quality = value
		return property(**locals())

	@apply
	def usage():
		def fget( self ):
			return self._usage
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._usage = ifclabel(value)
				else:
					self._usage = value
			else:
				self._usage = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (SIZEOF(None)  ==  0)
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr


####################
 # ENTITY ifcpresentationlayerwithstyle #
####################
class ifcpresentationlayerwithstyle(ifcpresentationlayerassignment):
	'''Entity ifcpresentationlayerwithstyle definition.

	:param layeron
	:type layeron:LOGICAL

	:param layerfrozen
	:type layerfrozen:LOGICAL

	:param layerblocked
	:type layerblocked:LOGICAL

	:param layerstyles
	:type layerstyles:SET(0,None,'ifcpresentationstyleselect', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__assigneditems , inherited3__identifier , layeron,layerfrozen,layerblocked,layerstyles, ):
		ifcpresentationlayerassignment.__init__(self , inherited0__name , inherited1__description , inherited2__assigneditems , inherited3__identifier , )
		self.layeron = layeron
		self.layerfrozen = layerfrozen
		self.layerblocked = layerblocked
		self.layerstyles = layerstyles

	@apply
	def layeron():
		def fget( self ):
			return self._layeron
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layeron is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._layeron = LOGICAL(value)
			else:
				self._layeron = value
		return property(**locals())

	@apply
	def layerfrozen():
		def fget( self ):
			return self._layerfrozen
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layerfrozen is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._layerfrozen = LOGICAL(value)
			else:
				self._layerfrozen = value
		return property(**locals())

	@apply
	def layerblocked():
		def fget( self ):
			return self._layerblocked
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layerblocked is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._layerblocked = LOGICAL(value)
			else:
				self._layerblocked = value
		return property(**locals())

	@apply
	def layerstyles():
		def fget( self ):
			return self._layerstyles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layerstyles is mantatory and can not be set to None')
			if not check_type(value,SET(0,None,'ifcpresentationstyleselect', scope = schema_scope)):
				self._layerstyles = SET(value)
			else:
				self._layerstyles = value
		return property(**locals())

####################
 # ENTITY ifccompressortype #
####################
class ifccompressortype(ifcflowmovingdevicetype):
	'''Entity ifccompressortype definition.

	:param predefinedtype
	:type predefinedtype:ifccompressortypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowmovingdevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifccompressortypeenum):
				self._predefinedtype = ifccompressortypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifccompressortypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifccompressortypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifclightdistributiondata #
####################
class ifclightdistributiondata(BaseEntityClass):
	'''Entity ifclightdistributiondata definition.

	:param mainplaneangle
	:type mainplaneangle:ifcplaneanglemeasure

	:param secondaryplaneangle
	:type secondaryplaneangle:LIST(1,None,'REAL', scope = schema_scope)

	:param luminousintensity
	:type luminousintensity:LIST(1,None,'REAL', scope = schema_scope)
	'''
	def __init__( self , mainplaneangle,secondaryplaneangle,luminousintensity, ):
		self.mainplaneangle = mainplaneangle
		self.secondaryplaneangle = secondaryplaneangle
		self.luminousintensity = luminousintensity

	@apply
	def mainplaneangle():
		def fget( self ):
			return self._mainplaneangle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mainplaneangle is mantatory and can not be set to None')
			if not check_type(value,ifcplaneanglemeasure):
				self._mainplaneangle = ifcplaneanglemeasure(value)
			else:
				self._mainplaneangle = value
		return property(**locals())

	@apply
	def secondaryplaneangle():
		def fget( self ):
			return self._secondaryplaneangle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument secondaryplaneangle is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'REAL', scope = schema_scope)):
				self._secondaryplaneangle = LIST(value)
			else:
				self._secondaryplaneangle = value
		return property(**locals())

	@apply
	def luminousintensity():
		def fget( self ):
			return self._luminousintensity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument luminousintensity is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'REAL', scope = schema_scope)):
				self._luminousintensity = LIST(value)
			else:
				self._luminousintensity = value
		return property(**locals())

####################
 # ENTITY ifcpipesegmenttype #
####################
class ifcpipesegmenttype(ifcflowsegmenttype):
	'''Entity ifcpipesegmenttype definition.

	:param predefinedtype
	:type predefinedtype:ifcpipesegmenttypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowsegmenttype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcpipesegmenttypeenum):
				self._predefinedtype = ifcpipesegmenttypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcpipesegmenttypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcpipesegmenttypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcquantityvolume #
####################
class ifcquantityvolume(ifcphysicalsimplequantity):
	'''Entity ifcquantityvolume definition.

	:param volumevalue
	:type volumevalue:ifcvolumemeasure
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__unit , volumevalue, ):
		ifcphysicalsimplequantity.__init__(self , inherited0__name , inherited1__description , inherited2__unit , )
		self.volumevalue = volumevalue

	@apply
	def volumevalue():
		def fget( self ):
			return self._volumevalue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument volumevalue is mantatory and can not be set to None')
			if not check_type(value,ifcvolumemeasure):
				self._volumevalue = ifcvolumemeasure(value)
			else:
				self._volumevalue = value
		return property(**locals())
	def wr21(self):
		eval_wr21_wr = (( not EXISTS(self.self.ifcphysicalsimplequantity.self.unit))  or  (self.self.ifcphysicalsimplequantity.self.unit.self.unittype  ==  ifcunitenum.self.volumeunit))
		if not eval_wr21_wr:
			raise AssertionError('Rule wr21 violated')
		else:
			return eval_wr21_wr

	def wr22(self):
		eval_wr22_wr = (self.volumevalue  >=  0)
		if not eval_wr22_wr:
			raise AssertionError('Rule wr22 violated')
		else:
			return eval_wr22_wr


####################
 # ENTITY ifcaxis2placement2d #
####################
class ifcaxis2placement2d(ifcplacement):
	'''Entity ifcaxis2placement2d definition.

	:param refdirection
	:type refdirection:ifcdirection

	:param p
	:type p:LIST(2,2,'ifcdirection', scope = schema_scope)
	'''
	def __init__( self , inherited0__location , refdirection, ):
		ifcplacement.__init__(self , inherited0__location , )
		self.refdirection = refdirection

	@apply
	def refdirection():
		def fget( self ):
			return self._refdirection
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdirection):
					self._refdirection = ifcdirection(value)
				else:
					self._refdirection = value
			else:
				self._refdirection = value
		return property(**locals())

	@apply
	def p():
		def fget( self ):
			attribute_eval = ifcbuild2axes(self.refdirection)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not EXISTS(self.refdirection))  or  (self.refdirection.self.dim  ==  2))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.ifcplacement.self.location.self.dim  ==  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcchamferedgefeature #
####################
class ifcchamferedgefeature(ifcedgefeature):
	'''Entity ifcchamferedgefeature definition.

	:param width
	:type width:ifcpositivelengthmeasure

	:param height
	:type height:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__featurelength , width,height, ):
		ifcedgefeature.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , inherited8__featurelength , )
		self.width = width
		self.height = height

	@apply
	def width():
		def fget( self ):
			return self._width
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._width = ifcpositivelengthmeasure(value)
				else:
					self._width = value
			else:
				self._width = value
		return property(**locals())

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._height = ifcpositivelengthmeasure(value)
				else:
					self._height = value
			else:
				self._height = value
		return property(**locals())

####################
 # ENTITY ifcmateriallayer #
####################
class ifcmateriallayer(BaseEntityClass):
	'''Entity ifcmateriallayer definition.

	:param material
	:type material:ifcmaterial

	:param layerthickness
	:type layerthickness:ifcpositivelengthmeasure

	:param isventilated
	:type isventilated:ifclogical

	:param tomateriallayerset
	:type tomateriallayerset:ifcmateriallayerset
	'''
	def __init__( self , material,layerthickness,isventilated, ):
		self.material = material
		self.layerthickness = layerthickness
		self.isventilated = isventilated

	@apply
	def material():
		def fget( self ):
			return self._material
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcmaterial):
					self._material = ifcmaterial(value)
				else:
					self._material = value
			else:
				self._material = value
		return property(**locals())

	@apply
	def layerthickness():
		def fget( self ):
			return self._layerthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument layerthickness is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._layerthickness = ifcpositivelengthmeasure(value)
			else:
				self._layerthickness = value
		return property(**locals())

	@apply
	def isventilated():
		def fget( self ):
			return self._isventilated
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclogical):
					self._isventilated = ifclogical(value)
				else:
					self._isventilated = value
			else:
				self._isventilated = value
		return property(**locals())

	@apply
	def tomateriallayerset():
		def fget( self ):
			return self._tomateriallayerset
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument tomateriallayerset is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifcrightcircularcone #
####################
class ifcrightcircularcone(ifccsgprimitive3d):
	'''Entity ifcrightcircularcone definition.

	:param height
	:type height:ifcpositivelengthmeasure

	:param bottomradius
	:type bottomradius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , height,bottomradius, ):
		ifccsgprimitive3d.__init__(self , inherited0__position , )
		self.height = height
		self.bottomradius = bottomradius

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._height = ifcpositivelengthmeasure(value)
			else:
				self._height = value
		return property(**locals())

	@apply
	def bottomradius():
		def fget( self ):
			return self._bottomradius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bottomradius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._bottomradius = ifcpositivelengthmeasure(value)
			else:
				self._bottomradius = value
		return property(**locals())

####################
 # ENTITY ifcstructuralloadlinearforce #
####################
class ifcstructuralloadlinearforce(ifcstructuralloadstatic):
	'''Entity ifcstructuralloadlinearforce definition.

	:param linearforcex
	:type linearforcex:ifclinearforcemeasure

	:param linearforcey
	:type linearforcey:ifclinearforcemeasure

	:param linearforcez
	:type linearforcez:ifclinearforcemeasure

	:param linearmomentx
	:type linearmomentx:ifclinearmomentmeasure

	:param linearmomenty
	:type linearmomenty:ifclinearmomentmeasure

	:param linearmomentz
	:type linearmomentz:ifclinearmomentmeasure
	'''
	def __init__( self , inherited0__name , linearforcex,linearforcey,linearforcez,linearmomentx,linearmomenty,linearmomentz, ):
		ifcstructuralloadstatic.__init__(self , inherited0__name , )
		self.linearforcex = linearforcex
		self.linearforcey = linearforcey
		self.linearforcez = linearforcez
		self.linearmomentx = linearmomentx
		self.linearmomenty = linearmomenty
		self.linearmomentz = linearmomentz

	@apply
	def linearforcex():
		def fget( self ):
			return self._linearforcex
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearforcemeasure):
					self._linearforcex = ifclinearforcemeasure(value)
				else:
					self._linearforcex = value
			else:
				self._linearforcex = value
		return property(**locals())

	@apply
	def linearforcey():
		def fget( self ):
			return self._linearforcey
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearforcemeasure):
					self._linearforcey = ifclinearforcemeasure(value)
				else:
					self._linearforcey = value
			else:
				self._linearforcey = value
		return property(**locals())

	@apply
	def linearforcez():
		def fget( self ):
			return self._linearforcez
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearforcemeasure):
					self._linearforcez = ifclinearforcemeasure(value)
				else:
					self._linearforcez = value
			else:
				self._linearforcez = value
		return property(**locals())

	@apply
	def linearmomentx():
		def fget( self ):
			return self._linearmomentx
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearmomentmeasure):
					self._linearmomentx = ifclinearmomentmeasure(value)
				else:
					self._linearmomentx = value
			else:
				self._linearmomentx = value
		return property(**locals())

	@apply
	def linearmomenty():
		def fget( self ):
			return self._linearmomenty
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearmomentmeasure):
					self._linearmomenty = ifclinearmomentmeasure(value)
				else:
					self._linearmomenty = value
			else:
				self._linearmomenty = value
		return property(**locals())

	@apply
	def linearmomentz():
		def fget( self ):
			return self._linearmomentz
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclinearmomentmeasure):
					self._linearmomentz = ifclinearmomentmeasure(value)
				else:
					self._linearmomentz = value
			else:
				self._linearmomentz = value
		return property(**locals())

####################
 # ENTITY ifcopenshell #
####################
class ifcopenshell(ifcconnectedfaceset):
	'''Entity ifcopenshell definition.
	'''
	def __init__( self , inherited0__cfsfaces ,  ):
		ifcconnectedfaceset.__init__(self , inherited0__cfsfaces , )

####################
 # ENTITY ifcwindow #
####################
class ifcwindow(ifcbuildingelement):
	'''Entity ifcwindow definition.

	:param overallheight
	:type overallheight:ifcpositivelengthmeasure

	:param overallwidth
	:type overallwidth:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , overallheight,overallwidth, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.overallheight = overallheight
		self.overallwidth = overallwidth

	@apply
	def overallheight():
		def fget( self ):
			return self._overallheight
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._overallheight = ifcpositivelengthmeasure(value)
				else:
					self._overallheight = value
			else:
				self._overallheight = value
		return property(**locals())

	@apply
	def overallwidth():
		def fget( self ):
			return self._overallwidth
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositivelengthmeasure):
					self._overallwidth = ifcpositivelengthmeasure(value)
				else:
					self._overallwidth = value
			else:
				self._overallwidth = value
		return property(**locals())

####################
 # ENTITY ifclibraryinformation #
####################
class ifclibraryinformation(BaseEntityClass):
	'''Entity ifclibraryinformation definition.

	:param name
	:type name:ifclabel

	:param version
	:type version:ifclabel

	:param publisher
	:type publisher:ifcorganization

	:param versiondate
	:type versiondate:ifccalendardate

	:param libraryreference
	:type libraryreference:SET(1,None,'ifclibraryreference', scope = schema_scope)
	'''
	def __init__( self , name,version,publisher,versiondate,libraryreference, ):
		self.name = name
		self.version = version
		self.publisher = publisher
		self.versiondate = versiondate
		self.libraryreference = libraryreference

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,ifclabel):
				self._name = ifclabel(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def version():
		def fget( self ):
			return self._version
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._version = ifclabel(value)
				else:
					self._version = value
			else:
				self._version = value
		return property(**locals())

	@apply
	def publisher():
		def fget( self ):
			return self._publisher
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcorganization):
					self._publisher = ifcorganization(value)
				else:
					self._publisher = value
			else:
				self._publisher = value
		return property(**locals())

	@apply
	def versiondate():
		def fget( self ):
			return self._versiondate
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifccalendardate):
					self._versiondate = ifccalendardate(value)
				else:
					self._versiondate = value
			else:
				self._versiondate = value
		return property(**locals())

	@apply
	def libraryreference():
		def fget( self ):
			return self._libraryreference
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'ifclibraryreference', scope = schema_scope)):
					self._libraryreference = SET(value)
				else:
					self._libraryreference = value
			else:
				self._libraryreference = value
		return property(**locals())

####################
 # ENTITY ifclightsourcespot #
####################
class ifclightsourcespot(ifclightsourcepositional):
	'''Entity ifclightsourcespot definition.

	:param orientation
	:type orientation:ifcdirection

	:param concentrationexponent
	:type concentrationexponent:ifcreal

	:param spreadangle
	:type spreadangle:ifcpositiveplaneanglemeasure

	:param beamwidthangle
	:type beamwidthangle:ifcpositiveplaneanglemeasure
	'''
	def __init__( self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , inherited4__position , inherited5__radius , inherited6__constantattenuation , inherited7__distanceattenuation , inherited8__quadricattenuation , orientation,concentrationexponent,spreadangle,beamwidthangle, ):
		ifclightsourcepositional.__init__(self , inherited0__name , inherited1__lightcolour , inherited2__ambientintensity , inherited3__intensity , inherited4__position , inherited5__radius , inherited6__constantattenuation , inherited7__distanceattenuation , inherited8__quadricattenuation , )
		self.orientation = orientation
		self.concentrationexponent = concentrationexponent
		self.spreadangle = spreadangle
		self.beamwidthangle = beamwidthangle

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,ifcdirection):
				self._orientation = ifcdirection(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def concentrationexponent():
		def fget( self ):
			return self._concentrationexponent
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcreal):
					self._concentrationexponent = ifcreal(value)
				else:
					self._concentrationexponent = value
			else:
				self._concentrationexponent = value
		return property(**locals())

	@apply
	def spreadangle():
		def fget( self ):
			return self._spreadangle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument spreadangle is mantatory and can not be set to None')
			if not check_type(value,ifcpositiveplaneanglemeasure):
				self._spreadangle = ifcpositiveplaneanglemeasure(value)
			else:
				self._spreadangle = value
		return property(**locals())

	@apply
	def beamwidthangle():
		def fget( self ):
			return self._beamwidthangle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument beamwidthangle is mantatory and can not be set to None')
			if not check_type(value,ifcpositiveplaneanglemeasure):
				self._beamwidthangle = ifcpositiveplaneanglemeasure(value)
			else:
				self._beamwidthangle = value
		return property(**locals())

####################
 # ENTITY ifcstructuralsurfacemembervarying #
####################
class ifcstructuralsurfacemembervarying(ifcstructuralsurfacemember):
	'''Entity ifcstructuralsurfacemembervarying definition.

	:param subsequentthickness
	:type subsequentthickness:LIST(2,None,'REAL', scope = schema_scope)

	:param varyingthicknesslocation
	:type varyingthicknesslocation:ifcshapeaspect

	:param varyingthickness
	:type varyingthickness:LIST(3,None,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__predefinedtype , inherited8__thickness , subsequentthickness,varyingthicknesslocation, ):
		ifcstructuralsurfacemember.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__predefinedtype , inherited8__thickness , )
		self.subsequentthickness = subsequentthickness
		self.varyingthicknesslocation = varyingthicknesslocation

	@apply
	def subsequentthickness():
		def fget( self ):
			return self._subsequentthickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument subsequentthickness is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._subsequentthickness = LIST(value)
			else:
				self._subsequentthickness = value
		return property(**locals())

	@apply
	def varyingthicknesslocation():
		def fget( self ):
			return self._varyingthicknesslocation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument varyingthicknesslocation is mantatory and can not be set to None')
			if not check_type(value,ifcshapeaspect):
				self._varyingthicknesslocation = ifcshapeaspect(value)
			else:
				self._varyingthicknesslocation = value
		return property(**locals())

	@apply
	def varyingthickness():
		def fget( self ):
			attribute_eval = ifcaddtobeginoflist(self.self.ifcstructuralsurfacemember.self.thickness,self.subsequentthickness)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument varyingthickness is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr61(self):
		eval_wr61_wr = EXISTS(self.self.ifcstructuralsurfacemember.self.thickness)
		if not eval_wr61_wr:
			raise AssertionError('Rule wr61 violated')
		else:
			return eval_wr61_wr

	def wr62(self):
		eval_wr62_wr = (SIZEOF(None)  ==  0)
		if not eval_wr62_wr:
			raise AssertionError('Rule wr62 violated')
		else:
			return eval_wr62_wr

	def wr63(self):
		eval_wr63_wr = (SIZEOF(None)  ==  0)
		if not eval_wr63_wr:
			raise AssertionError('Rule wr63 violated')
		else:
			return eval_wr63_wr


####################
 # ENTITY ifcrelassociatesdocument #
####################
class ifcrelassociatesdocument(ifcrelassociates):
	'''Entity ifcrelassociatesdocument definition.

	:param relatingdocument
	:type relatingdocument:ifcdocumentselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , relatingdocument, ):
		ifcrelassociates.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__relatedobjects , )
		self.relatingdocument = relatingdocument

	@apply
	def relatingdocument():
		def fget( self ):
			return self._relatingdocument
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relatingdocument is mantatory and can not be set to None')
			if not check_type(value,ifcdocumentselect):
				self._relatingdocument = ifcdocumentselect(value)
			else:
				self._relatingdocument = value
		return property(**locals())

####################
 # ENTITY ifctimeseriesschedule #
####################
class ifctimeseriesschedule(ifccontrol):
	'''Entity ifctimeseriesschedule definition.

	:param applicabledates
	:type applicabledates:LIST(1,None,'ifcdatetimeselect', scope = schema_scope)

	:param timeseriesscheduletype
	:type timeseriesscheduletype:ifctimeseriesscheduletypeenum

	:param timeseries
	:type timeseries:ifctimeseries
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , applicabledates,timeseriesscheduletype,timeseries, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.applicabledates = applicabledates
		self.timeseriesscheduletype = timeseriesscheduletype
		self.timeseries = timeseries

	@apply
	def applicabledates():
		def fget( self ):
			return self._applicabledates
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'ifcdatetimeselect', scope = schema_scope)):
					self._applicabledates = LIST(value)
				else:
					self._applicabledates = value
			else:
				self._applicabledates = value
		return property(**locals())

	@apply
	def timeseriesscheduletype():
		def fget( self ):
			return self._timeseriesscheduletype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timeseriesscheduletype is mantatory and can not be set to None')
			if not check_type(value,ifctimeseriesscheduletypeenum):
				self._timeseriesscheduletype = ifctimeseriesscheduletypeenum(value)
			else:
				self._timeseriesscheduletype = value
		return property(**locals())

	@apply
	def timeseries():
		def fget( self ):
			return self._timeseries
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument timeseries is mantatory and can not be set to None')
			if not check_type(value,ifctimeseries):
				self._timeseries = ifctimeseries(value)
			else:
				self._timeseries = value
		return property(**locals())
	def wr41(self):
		eval_wr41_wr = (( not (self.timeseriesscheduletype  ==  ifctimeseriesscheduletypeenum.self.userdefined))  or  EXISTS(self.self.ifcobject.self.objecttype))
		if not eval_wr41_wr:
			raise AssertionError('Rule wr41 violated')
		else:
			return eval_wr41_wr


####################
 # ENTITY ifcconditioncriterion #
####################
class ifcconditioncriterion(ifccontrol):
	'''Entity ifcconditioncriterion definition.

	:param criterion
	:type criterion:ifcconditioncriterionselect

	:param criteriondatetime
	:type criteriondatetime:ifcdatetimeselect
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , criterion,criteriondatetime, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.criterion = criterion
		self.criteriondatetime = criteriondatetime

	@apply
	def criterion():
		def fget( self ):
			return self._criterion
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument criterion is mantatory and can not be set to None')
			if not check_type(value,ifcconditioncriterionselect):
				self._criterion = ifcconditioncriterionselect(value)
			else:
				self._criterion = value
		return property(**locals())

	@apply
	def criteriondatetime():
		def fget( self ):
			return self._criteriondatetime
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument criteriondatetime is mantatory and can not be set to None')
			if not check_type(value,ifcdatetimeselect):
				self._criteriondatetime = ifcdatetimeselect(value)
			else:
				self._criteriondatetime = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = EXISTS(self.self.ifcroot.self.name)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcelectricdistributionpoint #
####################
class ifcelectricdistributionpoint(ifcflowcontroller):
	'''Entity ifcelectricdistributionpoint definition.

	:param distributionpointfunction
	:type distributionpointfunction:ifcelectricdistributionpointfunctionenum

	:param userdefinedfunction
	:type userdefinedfunction:ifclabel
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , distributionpointfunction,userdefinedfunction, ):
		ifcflowcontroller.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.distributionpointfunction = distributionpointfunction
		self.userdefinedfunction = userdefinedfunction

	@apply
	def distributionpointfunction():
		def fget( self ):
			return self._distributionpointfunction
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distributionpointfunction is mantatory and can not be set to None')
			if not check_type(value,ifcelectricdistributionpointfunctionenum):
				self._distributionpointfunction = ifcelectricdistributionpointfunctionenum(value)
			else:
				self._distributionpointfunction = value
		return property(**locals())

	@apply
	def userdefinedfunction():
		def fget( self ):
			return self._userdefinedfunction
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._userdefinedfunction = ifclabel(value)
				else:
					self._userdefinedfunction = value
			else:
				self._userdefinedfunction = value
		return property(**locals())
	def wr31(self):
		eval_wr31_wr = ((self.distributionpointfunction  !=  ifcelectricdistributionpointfunctionenum.self.userdefined)  or  ((self.distributionpointfunction  ==  ifcelectricdistributionpointfunctionenum.self.userdefined)  and  EXISTS(self.self.ifcelectricdistributionpoint.self.userdefinedfunction)))
		if not eval_wr31_wr:
			raise AssertionError('Rule wr31 violated')
		else:
			return eval_wr31_wr


####################
 # ENTITY ifcpumptype #
####################
class ifcpumptype(ifcflowmovingdevicetype):
	'''Entity ifcpumptype definition.

	:param predefinedtype
	:type predefinedtype:ifcpumptypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , predefinedtype, ):
		ifcflowmovingdevicetype.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__applicableoccurrence , inherited5__haspropertysets , inherited6__representationmaps , inherited7__tag , inherited8__elementtype , )
		self.predefinedtype = predefinedtype

	@apply
	def predefinedtype():
		def fget( self ):
			return self._predefinedtype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predefinedtype is mantatory and can not be set to None')
			if not check_type(value,ifcpumptypeenum):
				self._predefinedtype = ifcpumptypeenum(value)
			else:
				self._predefinedtype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.predefinedtype  !=  ifcpumptypeenum.self.userdefined)  or  ((self.predefinedtype  ==  ifcpumptypeenum.self.userdefined)  and  EXISTS(self.self.ifcelementtype.self.elementtype)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcsphere #
####################
class ifcsphere(ifccsgprimitive3d):
	'''Entity ifcsphere definition.

	:param radius
	:type radius:ifcpositivelengthmeasure
	'''
	def __init__( self , inherited0__position , radius, ):
		ifccsgprimitive3d.__init__(self , inherited0__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,ifcpositivelengthmeasure):
				self._radius = ifcpositivelengthmeasure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY ifccurvestylefont #
####################
class ifccurvestylefont(BaseEntityClass):
	'''Entity ifccurvestylefont definition.

	:param name
	:type name:ifclabel

	:param patternlist
	:type patternlist:LIST(1,None,'ifccurvestylefontpattern', scope = schema_scope)
	'''
	def __init__( self , name,patternlist, ):
		self.name = name
		self.patternlist = patternlist

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifclabel):
					self._name = ifclabel(value)
				else:
					self._name = value
			else:
				self._name = value
		return property(**locals())

	@apply
	def patternlist():
		def fget( self ):
			return self._patternlist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument patternlist is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'ifccurvestylefontpattern', scope = schema_scope)):
				self._patternlist = LIST(value)
			else:
				self._patternlist = value
		return property(**locals())

####################
 # ENTITY ifcexternallydefinedsymbol #
####################
class ifcexternallydefinedsymbol(ifcexternalreference):
	'''Entity ifcexternallydefinedsymbol definition.
	'''
	def __init__( self , inherited0__location , inherited1__itemreference , inherited2__name ,  ):
		ifcexternalreference.__init__(self , inherited0__location , inherited1__itemreference , inherited2__name , )

####################
 # ENTITY ifcramp #
####################
class ifcramp(ifcbuildingelement):
	'''Entity ifcramp definition.

	:param shapetype
	:type shapetype:ifcramptypeenum
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , shapetype, ):
		ifcbuildingelement.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )
		self.shapetype = shapetype

	@apply
	def shapetype():
		def fget( self ):
			return self._shapetype
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument shapetype is mantatory and can not be set to None')
			if not check_type(value,ifcramptypeenum):
				self._shapetype = ifcramptypeenum(value)
			else:
				self._shapetype = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  0)  or  ((HIINDEX(self.self.ifcobjectdefinition.self.isdecomposedby)  ==  1)  and  ( not EXISTS(self.self.ifcproduct.self.representation))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ifcopeningelement #
####################
class ifcopeningelement(ifcfeatureelementsubtraction):
	'''Entity ifcopeningelement definition.

	:param hasfillings
	:type hasfillings:SET(0,None,'ifcrelfillselement', scope = schema_scope)
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag ,  ):
		ifcfeatureelementsubtraction.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , inherited5__objectplacement , inherited6__representation , inherited7__tag , )

	@apply
	def hasfillings():
		def fget( self ):
			return self._hasfillings
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument hasfillings is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY ifccartesiantransformationoperator3dnonuniform #
####################
class ifccartesiantransformationoperator3dnonuniform(ifccartesiantransformationoperator3d):
	'''Entity ifccartesiantransformationoperator3dnonuniform definition.

	:param scale2
	:type scale2:REAL

	:param scale3
	:type scale3:REAL

	:param scl2
	:type scl2:REAL

	:param scl3
	:type scl3:REAL
	'''
	def __init__( self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , inherited4__axis3 , scale2,scale3, ):
		ifccartesiantransformationoperator3d.__init__(self , inherited0__axis1 , inherited1__axis2 , inherited2__localorigin , inherited3__scale , inherited4__axis3 , )
		self.scale2 = scale2
		self.scale3 = scale3

	@apply
	def scale2():
		def fget( self ):
			return self._scale2
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._scale2 = REAL(value)
				else:
					self._scale2 = value
			else:
				self._scale2 = value
		return property(**locals())

	@apply
	def scale3():
		def fget( self ):
			return self._scale3
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._scale3 = REAL(value)
				else:
					self._scale3 = value
			else:
				self._scale3 = value
		return property(**locals())

	@apply
	def scl2():
		def fget( self ):
			attribute_eval = NVL(self.scale2,self.self.ifccartesiantransformationoperator.self.scl)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scl2 is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def scl3():
		def fget( self ):
			attribute_eval = NVL(self.scale3,self.self.ifccartesiantransformationoperator.self.scl)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scl3 is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.scl2  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.scl3  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ifcscheduletimecontrol #
####################
class ifcscheduletimecontrol(ifccontrol):
	'''Entity ifcscheduletimecontrol definition.

	:param actualstart
	:type actualstart:ifcdatetimeselect

	:param earlystart
	:type earlystart:ifcdatetimeselect

	:param latestart
	:type latestart:ifcdatetimeselect

	:param schedulestart
	:type schedulestart:ifcdatetimeselect

	:param actualfinish
	:type actualfinish:ifcdatetimeselect

	:param earlyfinish
	:type earlyfinish:ifcdatetimeselect

	:param latefinish
	:type latefinish:ifcdatetimeselect

	:param schedulefinish
	:type schedulefinish:ifcdatetimeselect

	:param scheduleduration
	:type scheduleduration:ifctimemeasure

	:param actualduration
	:type actualduration:ifctimemeasure

	:param remainingtime
	:type remainingtime:ifctimemeasure

	:param freefloat
	:type freefloat:ifctimemeasure

	:param totalfloat
	:type totalfloat:ifctimemeasure

	:param iscritical
	:type iscritical:BOOLEAN

	:param statustime
	:type statustime:ifcdatetimeselect

	:param startfloat
	:type startfloat:ifctimemeasure

	:param finishfloat
	:type finishfloat:ifctimemeasure

	:param completion
	:type completion:ifcpositiveratiomeasure

	:param scheduletimecontrolassigned
	:type scheduletimecontrolassigned:ifcrelassignstasks
	'''
	def __init__( self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , actualstart,earlystart,latestart,schedulestart,actualfinish,earlyfinish,latefinish,schedulefinish,scheduleduration,actualduration,remainingtime,freefloat,totalfloat,iscritical,statustime,startfloat,finishfloat,completion, ):
		ifccontrol.__init__(self , inherited0__globalid , inherited1__ownerhistory , inherited2__name , inherited3__description , inherited4__objecttype , )
		self.actualstart = actualstart
		self.earlystart = earlystart
		self.latestart = latestart
		self.schedulestart = schedulestart
		self.actualfinish = actualfinish
		self.earlyfinish = earlyfinish
		self.latefinish = latefinish
		self.schedulefinish = schedulefinish
		self.scheduleduration = scheduleduration
		self.actualduration = actualduration
		self.remainingtime = remainingtime
		self.freefloat = freefloat
		self.totalfloat = totalfloat
		self.iscritical = iscritical
		self.statustime = statustime
		self.startfloat = startfloat
		self.finishfloat = finishfloat
		self.completion = completion

	@apply
	def actualstart():
		def fget( self ):
			return self._actualstart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._actualstart = ifcdatetimeselect(value)
				else:
					self._actualstart = value
			else:
				self._actualstart = value
		return property(**locals())

	@apply
	def earlystart():
		def fget( self ):
			return self._earlystart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._earlystart = ifcdatetimeselect(value)
				else:
					self._earlystart = value
			else:
				self._earlystart = value
		return property(**locals())

	@apply
	def latestart():
		def fget( self ):
			return self._latestart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._latestart = ifcdatetimeselect(value)
				else:
					self._latestart = value
			else:
				self._latestart = value
		return property(**locals())

	@apply
	def schedulestart():
		def fget( self ):
			return self._schedulestart
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._schedulestart = ifcdatetimeselect(value)
				else:
					self._schedulestart = value
			else:
				self._schedulestart = value
		return property(**locals())

	@apply
	def actualfinish():
		def fget( self ):
			return self._actualfinish
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._actualfinish = ifcdatetimeselect(value)
				else:
					self._actualfinish = value
			else:
				self._actualfinish = value
		return property(**locals())

	@apply
	def earlyfinish():
		def fget( self ):
			return self._earlyfinish
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._earlyfinish = ifcdatetimeselect(value)
				else:
					self._earlyfinish = value
			else:
				self._earlyfinish = value
		return property(**locals())

	@apply
	def latefinish():
		def fget( self ):
			return self._latefinish
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._latefinish = ifcdatetimeselect(value)
				else:
					self._latefinish = value
			else:
				self._latefinish = value
		return property(**locals())

	@apply
	def schedulefinish():
		def fget( self ):
			return self._schedulefinish
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._schedulefinish = ifcdatetimeselect(value)
				else:
					self._schedulefinish = value
			else:
				self._schedulefinish = value
		return property(**locals())

	@apply
	def scheduleduration():
		def fget( self ):
			return self._scheduleduration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimemeasure):
					self._scheduleduration = ifctimemeasure(value)
				else:
					self._scheduleduration = value
			else:
				self._scheduleduration = value
		return property(**locals())

	@apply
	def actualduration():
		def fget( self ):
			return self._actualduration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimemeasure):
					self._actualduration = ifctimemeasure(value)
				else:
					self._actualduration = value
			else:
				self._actualduration = value
		return property(**locals())

	@apply
	def remainingtime():
		def fget( self ):
			return self._remainingtime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimemeasure):
					self._remainingtime = ifctimemeasure(value)
				else:
					self._remainingtime = value
			else:
				self._remainingtime = value
		return property(**locals())

	@apply
	def freefloat():
		def fget( self ):
			return self._freefloat
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimemeasure):
					self._freefloat = ifctimemeasure(value)
				else:
					self._freefloat = value
			else:
				self._freefloat = value
		return property(**locals())

	@apply
	def totalfloat():
		def fget( self ):
			return self._totalfloat
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimemeasure):
					self._totalfloat = ifctimemeasure(value)
				else:
					self._totalfloat = value
			else:
				self._totalfloat = value
		return property(**locals())

	@apply
	def iscritical():
		def fget( self ):
			return self._iscritical
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,BOOLEAN):
					self._iscritical = BOOLEAN(value)
				else:
					self._iscritical = value
			else:
				self._iscritical = value
		return property(**locals())

	@apply
	def statustime():
		def fget( self ):
			return self._statustime
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcdatetimeselect):
					self._statustime = ifcdatetimeselect(value)
				else:
					self._statustime = value
			else:
				self._statustime = value
		return property(**locals())

	@apply
	def startfloat():
		def fget( self ):
			return self._startfloat
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimemeasure):
					self._startfloat = ifctimemeasure(value)
				else:
					self._startfloat = value
			else:
				self._startfloat = value
		return property(**locals())

	@apply
	def finishfloat():
		def fget( self ):
			return self._finishfloat
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifctimemeasure):
					self._finishfloat = ifctimemeasure(value)
				else:
					self._finishfloat = value
			else:
				self._finishfloat = value
		return property(**locals())

	@apply
	def completion():
		def fget( self ):
			return self._completion
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,ifcpositiveratiomeasure):
					self._completion = ifcpositiveratiomeasure(value)
				else:
					self._completion = value
			else:
				self._completion = value
		return property(**locals())

	@apply
	def scheduletimecontrolassigned():
		def fget( self ):
			return self._scheduletimecontrolassigned
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument scheduletimecontrolassigned is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # FUNCTION ifcnormalise #
####################
def ifcnormalise(arg,):
	'''
	:param arg
	:type arg:ifcvectorordirection
	'''
	if ( not EXISTS(arg)):
		return  None 
	else:
		ndim = arg.dim
		if ('IFC2X3.IFCVECTOR'  ==  TYPEOF(arg)):
			# begin/end block
			v.directionratios = arg.ifcvector.orientation.directionratios
			vec.magnitude = arg.ifcvector.magnitude
			vec.orientation = v
			if (arg.magnitude  ==  0):
				return  None 
			else:
				vec.magnitude = 1
		else:
			v.directionratios = arg.directionratios
		mag = 0
		for  i in range(1,ndim,1):
			mag = mag  +  (v.directionratios[i]  *  v.directionratios[i])
		if (mag  >  0):
			mag = SQRT(mag)
			for  i in range(1,ndim,1):
				v.directionratios[i] = v.directionratios[i] / mag
			if ('IFC2X3.IFCVECTOR'  ==  TYPEOF(arg)):
				vec.orientation = v
				result = vec
			else:
				result = v
		else:
			return  None 
	return result

####################
 # FUNCTION ifcsamevalue #
####################
def ifcsamevalue(value1,value2,epsilon,):
	'''
	:param value1
	:type value1:REAL
	:param value2
	:type value2:REAL
	:param epsilon
	:type epsilon:REAL
	'''
	valideps = NVL(epsilon,defaulteps)
	return ((value1  +  valideps)  >  value2)  and  (value1  <  (value2  +  valideps))

####################
 # FUNCTION ifcsamevalidprecision #
####################
def ifcsamevalidprecision(epsilon1,epsilon2,):
	'''
	:param epsilon1
	:type epsilon1:REAL
	:param epsilon2
	:type epsilon2:REAL
	'''
	valideps1 = NVL(epsilon1,defaulteps)
	valideps2 = NVL(epsilon2,defaulteps)
	return (((0  <  valideps1)  and  (valideps1  <=  (derivationofeps  *  valideps2)))  and  (valideps2  <=  (derivationofeps  *  valideps1)))  and  (valideps2  <  uppereps)

####################
 # FUNCTION ifcbuildaxes #
####################
def ifcbuildaxes(axis,refdirection,):
	'''
	:param axis
	:type axis:ifcdirection
	:param refdirection
	:type refdirection:ifcdirection
	'''
	d1 = NVL(ifcnormalise(axis),(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,0,1]))
	d2 = ifcfirstprojaxis(d1,refdirection)
	return [d2,ifcnormalise(ifccrossproduct(d1,d2)).ifcvector.orientation,d1]

####################
 # FUNCTION ifcvectorsum #
####################
def ifcvectorsum(arg1,arg2,):
	'''
	:param arg1
	:type arg1:ifcvectorordirection
	:param arg2
	:type arg2:ifcvectorordirection
	'''
	if ((( not EXISTS(arg1))  or  ( not EXISTS(arg2)))  or  (arg1.dim  !=  arg2.dim)):
		return  None 
	else:
		# begin/end block
		if ('IFC2X3.IFCVECTOR'  ==  TYPEOF(arg1)):
			mag1 = arg1.ifcvector.magnitude
			vec1 = arg1.ifcvector.orientation
		else:
			mag1 = 1
			vec1 = arg1
		if ('IFC2X3.IFCVECTOR'  ==  TYPEOF(arg2)):
			mag2 = arg2.ifcvector.magnitude
			vec2 = arg2.ifcvector.orientation
		else:
			mag2 = 1
			vec2 = arg2
		vec1 = ifcnormalise(vec1)
		vec2 = ifcnormalise(vec2)
		ndim = SIZEOF(vec1.directionratios)
		mag = 0
		res = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,ndim])
		for  i in range(1,ndim,1):
			res.directionratios[i] = (mag1  *  vec1.directionratios[i])  +  (mag2  *  vec2.directionratios[i])
			mag = mag  +  (res.directionratios[i]  *  res.directionratios[i])
		if (mag  >  0):
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(res,SQRT(mag))
		else:
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(vec1,0)
	return result

####################
 # FUNCTION ifcvectordifference #
####################
def ifcvectordifference(arg1,arg2,):
	'''
	:param arg1
	:type arg1:ifcvectorordirection
	:param arg2
	:type arg2:ifcvectorordirection
	'''
	if ((( not EXISTS(arg1))  or  ( not EXISTS(arg2)))  or  (arg1.dim  !=  arg2.dim)):
		return  None 
	else:
		# begin/end block
		if ('IFC2X3.IFCVECTOR'  ==  TYPEOF(arg1)):
			mag1 = arg1.ifcvector.magnitude
			vec1 = arg1.ifcvector.orientation
		else:
			mag1 = 1
			vec1 = arg1
		if ('IFC2X3.IFCVECTOR'  ==  TYPEOF(arg2)):
			mag2 = arg2.ifcvector.magnitude
			vec2 = arg2.ifcvector.orientation
		else:
			mag2 = 1
			vec2 = arg2
		vec1 = ifcnormalise(vec1)
		vec2 = ifcnormalise(vec2)
		ndim = SIZEOF(vec1.directionratios)
		mag = 0
		res = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,ndim])
		for  i in range(1,ndim,1):
			res.directionratios[i] = (mag1  *  vec1.directionratios[i]) - (mag2  *  vec2.directionratios[i])
			mag = mag  +  (res.directionratios[i]  *  res.directionratios[i])
		if (mag  >  0):
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(res,SQRT(mag))
		else:
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(vec1,0)
	return result

####################
 # FUNCTION ifccorrectlocalplacement #
####################
def ifccorrectlocalplacement(axisplacement,relplacement,):
	'''
	:param axisplacement
	:type axisplacement:ifcaxis2placement
	:param relplacement
	:type relplacement:ifcobjectplacement
	'''
	if (EXISTS(relplacement)):
		if ('IFC2X3.IFCGRIDPLACEMENT'  ==  TYPEOF(relplacement)):
			return  None 
		if ('IFC2X3.IFCLOCALPLACEMENT'  ==  TYPEOF(relplacement)):
			if ('IFC2X3.IFCAXIS2PLACEMENT2D'  ==  TYPEOF(axisplacement)):
				return TRUE
			if ('IFC2X3.IFCAXIS2PLACEMENT3D'  ==  TYPEOF(axisplacement)):
				if (relplacement.relativeplacement.dim  ==  3):
					return TRUE
				else:
					return FALSE
	else:
		return TRUE
	return  None 

####################
 # FUNCTION ifccorrectfillareastyle #
####################
def ifccorrectfillareastyle(styles,):
	'''
	:param styles
	:type styles:(null)
	'''
	external = SIZEOF(None)
	hatching = SIZEOF(None)
	tiles = SIZEOF(None)
	colour = SIZEOF(None)
	if (external  >  1):
		return FALSE
	if ((external  ==  1)  and  (((hatching  >  0)  or  (tiles  >  0))  or  (colour  >  0))):
		return FALSE
	if (colour  >  1):
		return FALSE
	if ((hatching  >  0)  and  (tiles  >  0)):
		return FALSE
	return TRUE

####################
 # FUNCTION ifcuniquepropertyname #
####################
def ifcuniquepropertyname(properties,):
	'''
	:param properties
	:type properties:(null)
	'''
	for  i in range(1,HIINDEX(properties),1):
		names = names  +  properties[i].name
	return SIZEOF(names)  ==  SIZEOF(properties)

####################
 # FUNCTION ifccurvedim #
####################
def ifccurvedim(curve,):
	'''
	:param curve
	:type curve:ifccurve
	'''
	if ('IFC2X3.IFCLINE'  ==  TYPEOF(curve)):
		return curve.ifcline.pnt.dim
	if ('IFC2X3.IFCCONIC'  ==  TYPEOF(curve)):
		return curve.ifcconic.position.dim
	if ('IFC2X3.IFCPOLYLINE'  ==  TYPEOF(curve)):
		return curve.ifcpolyline.points[1].dim
	if ('IFC2X3.IFCTRIMMEDCURVE'  ==  TYPEOF(curve)):
		return ifccurvedim(curve.ifctrimmedcurve.basiscurve)
	if ('IFC2X3.IFCCOMPOSITECURVE'  ==  TYPEOF(curve)):
		return curve.ifccompositecurve.segments[1].dim
	if ('IFC2X3.IFCBSPLINECURVE'  ==  TYPEOF(curve)):
		return curve.ifcbsplinecurve.controlpointslist[1].dim
	if ('IFC2X3.IFCOFFSETCURVE2D'  ==  TYPEOF(curve)):
		return 2
	if ('IFC2X3.IFCOFFSETCURVE3D'  ==  TYPEOF(curve)):
		return 3
	return  None 

####################
 # FUNCTION ifcsamedirection #
####################
def ifcsamedirection(dir1,dir2,epsilon,):
	'''
	:param dir1
	:type dir1:ifcdirection
	:param dir2
	:type dir2:ifcdirection
	:param epsilon
	:type epsilon:REAL
	'''
	if (SIZEOF(dir1.directionratios)  >  2):
		dir1z = dir1.directionratios[3]
	if (SIZEOF(dir2.directionratios)  >  2):
		dir2z = dir2.directionratios[3]
	return (ifcsamevalue(dir1x,dir2x,epsilon)  and  ifcsamevalue(dir1y,dir2y,epsilon))  and  ifcsamevalue(dir1z,dir2z,epsilon)

####################
 # FUNCTION ifclisttoarray #
####################
def ifclisttoarray(lis,low,u,):
	'''
	:param lis
	:type lis:(null)
	:param low
	:type low:INTEGER
	:param u
	:type u:INTEGER
	'''
	n = SIZEOF(lis)
	if (n  !=  ((u - low)  +  1)):
		return  None 
	else:
		res = [lis[1],n]
		for  i in range(2,n,1):
			res[(low  +  i) - 1] = lis[i]
		return res

####################
 # FUNCTION ifcvalidtime #
####################
def ifcvalidtime(time,):
	'''
	:param time
	:type time:ifclocaltime
	'''
	if (EXISTS(time.secondcomponent)):
		return EXISTS(time.minutecomponent)
	else:
		return TRUE

####################
 # FUNCTION ifctopologyrepresentationtypes #
####################
def ifctopologyrepresentationtypes(reptype,items,):
	'''
	:param reptype
	:type reptype:STRING
	:param items
	:type items:(null)
	'''
	case_selector = reptype
	if  case_selector == 'Vertex':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Edge':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Path':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Face':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Shell':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Undefined':
		return TRUE
	else:
		return  None 
	return count  ==  SIZEOF(items)

####################
 # FUNCTION ifccorrectunitassignment #
####################
def ifccorrectunitassignment(units,):
	'''
	:param units
	:type units:(null)
	'''
	namedunitnumber = SIZEOF(None)
	derivedunitnumber = SIZEOF(None)
	monetaryunitnumber = SIZEOF(None)
	for  i in range(1,SIZEOF(units),1):
		if (('IFC2X3.IFCNAMEDUNIT'  ==  TYPEOF(units[i]))  and  ( not (units[i].ifcnamedunit.unittype  ==  ifcunitenum.userdefined))):
			namedunitnames = namedunitnames  +  units[i].ifcnamedunit.unittype
		if (('IFC2X3.IFCDERIVEDUNIT'  ==  TYPEOF(units[i]))  and  ( not (units[i].ifcderivedunit.unittype  ==  ifcderivedunitenum.userdefined))):
			derivedunitnames = derivedunitnames  +  units[i].ifcderivedunit.unittype
	return ((SIZEOF(namedunitnames)  ==  namedunitnumber)  and  (SIZEOF(derivedunitnames)  ==  derivedunitnumber))  and  (monetaryunitnumber  <=  1)

####################
 # FUNCTION ifcdotproduct #
####################
def ifcdotproduct(arg1,arg2,):
	'''
	:param arg1
	:type arg1:ifcdirection
	:param arg2
	:type arg2:ifcdirection
	'''
	if (( not EXISTS(arg1))  or  ( not EXISTS(arg2))):
		scalar =  None 
	else:
		if (arg1.dim  !=  arg2.dim):
			scalar =  None 
		else:
			# begin/end block
			vec1 = ifcnormalise(arg1)
			vec2 = ifcnormalise(arg2)
			ndim = arg1.dim
			scalar = 0
			for  i in range(1,ndim,1):
				scalar = scalar  +  (vec1.directionratios[i]  *  vec2.directionratios[i])
	return scalar

####################
 # FUNCTION ifcaddtobeginoflist #
####################
def ifcaddtobeginoflist(ascalar,alist,):
	'''
	:param ascalar
	:type ascalar:(null)
	:param alist
	:type alist:(null)
	'''
	if ( not EXISTS(ascalar)):
		result = alist
	else:
		result = result  +  ascalar
		if (HIINDEX(alist)  >=  1):
			for  i in range(1,HIINDEX(alist),1):
				result[i  +  1] = alist[i]
	return result

####################
 # FUNCTION ifcfirstprojaxis #
####################
def ifcfirstprojaxis(zaxis,arg,):
	'''
	:param zaxis
	:type zaxis:ifcdirection
	:param arg
	:type arg:ifcdirection
	'''
	if ( not EXISTS(zaxis)):
		return  None 
	else:
		z = ifcnormalise(zaxis)
		if ( not EXISTS(arg)):
			if (z.directionratios  !=  [1,0,0]):
				v = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([1,0,0])
			else:
				v = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,1,0])
		else:
			if (arg.dim  !=  3):
				return  None 
			if (ifccrossproduct(arg,z).magnitude  ==  0):
				return  None 
			else:
				v = ifcnormalise(arg)
		xvec = ifcscalartimesvector(ifcdotproduct(v,z),z)
		xaxis = ifcvectordifference(v,xvec).orientation
		xaxis = ifcnormalise(xaxis)
	return xaxis

####################
 # FUNCTION ifcshaperepresentationtypes #
####################
def ifcshaperepresentationtypes(reptype,items,):
	'''
	:param reptype
	:type reptype:STRING
	:param items
	:type items:(null)
	'''
	case_selector = reptype
	if  case_selector == 'Curve2D':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Annotation2D':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'GeometricSet':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'GeometricCurveSet':
		# begin/end block
		count = SIZEOF(None)
		for  i in range(1,HIINDEX(items),1):
			if ('IFC2X3.IFCGEOMETRICSET'  ==  TYPEOF(items[i])):
				if (SIZEOF(None)  >  0):
					count = count - 1
	elif case_selector == 'SurfaceModel':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'SolidModel':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'SweptSolid':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'CSG':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Clipping':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'AdvancedSweptSolid':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'Brep':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'BoundingBox':
		# begin/end block
		count = SIZEOF(None)
		if (SIZEOF(items)  >  1):
			count = 0
	elif case_selector == 'SectionedSpine':
		# begin/end block
		count = SIZEOF(None)
	elif case_selector == 'MappedRepresentation':
		# begin/end block
		count = SIZEOF(None)
	else:
		return  None 
	return count  ==  SIZEOF(items)

####################
 # FUNCTION ifcpathheadtotail #
####################
def ifcpathheadtotail(apath,):
	'''
	:param apath
	:type apath:ifcpath
	'''
	n = SIZEOF(apath.edgelist)
	for  i in range(2,n,1):
		p = p  and  (apath.edgelist[i - 1].edgeend  ==  apath.edgelist[i].edgestart)
	return p

####################
 # FUNCTION ifcsecondprojaxis #
####################
def ifcsecondprojaxis(zaxis,xaxis,arg,):
	'''
	:param zaxis
	:type zaxis:ifcdirection
	:param xaxis
	:type xaxis:ifcdirection
	:param arg
	:type arg:ifcdirection
	'''
	if ( not EXISTS(arg)):
		v = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,1,0])
	else:
		v = arg
	temp = ifcscalartimesvector(ifcdotproduct(v,zaxis),zaxis)
	yaxis = ifcvectordifference(v,temp)
	temp = ifcscalartimesvector(ifcdotproduct(v,xaxis),xaxis)
	yaxis = ifcvectordifference(yaxis,temp)
	yaxis = ifcnormalise(yaxis)
	return yaxis.orientation

####################
 # FUNCTION ifcderivedimensionalexponents #
####################
def ifcderivedimensionalexponents(unitelements,):
	'''
	:param unitelements
	:type unitelements:(null)
	'''
	for  i in range(LOINDEX(unitelements),HIINDEX(unitelements),1):
		result.lengthexponent = result.lengthexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.lengthexponent)
		result.massexponent = result.massexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.massexponent)
		result.timeexponent = result.timeexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.timeexponent)
		result.electriccurrentexponent = result.electriccurrentexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.electriccurrentexponent)
		result.thermodynamictemperatureexponent = result.thermodynamictemperatureexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.thermodynamictemperatureexponent)
		result.amountofsubstanceexponent = result.amountofsubstanceexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.amountofsubstanceexponent)
		result.luminousintensityexponent = result.luminousintensityexponent  +  (unitelements[i].exponent  *  unitelements[i].unit.dimensions.luminousintensityexponent)
	return result

####################
 # FUNCTION ifcbooleanchoose #
####################
def ifcbooleanchoose(b,choice1,choice2,):
	'''
	:param b
	:type b:BOOLEAN
	:param choice1
	:type choice1:(null)
	:param choice2
	:type choice2:(null)
	'''
	if (b):
		return choice1
	else:
		return choice2

####################
 # FUNCTION ifcscalartimesvector #
####################
def ifcscalartimesvector(scalar,vec,):
	'''
	:param scalar
	:type scalar:REAL
	:param vec
	:type vec:ifcvectorordirection
	'''
	if (( not EXISTS(scalar))  or  ( not EXISTS(vec))):
		return  None 
	else:
		if ('IFC2X3.IFCVECTOR'  ==  TYPEOF(vec)):
			v = vec.ifcvector.orientation
			mag = scalar  *  vec.ifcvector.magnitude
		else:
			v = vec
			mag = scalar
		if (mag  <  0):
			for  i in range(1,SIZEOF(v.directionratios),1):
				v.directionratios[i] = -v.directionratios[i]
			mag = -mag
		result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(ifcnormalise(v),mag)
	return result

####################
 # FUNCTION ifcleapyear #
####################
def ifcleapyear(year,):
	'''
	:param year
	:type year:INTEGER
	'''
	if ((((year  %  4)  ==  0)  and  ((year  %  100)  !=  0))  or  ((year  %  400)  ==  0)):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION ifcbaseaxis #
####################
def ifcbaseaxis(dim,axis1,axis2,axis3,):
	'''
	:param dim
	:type dim:INTEGER
	:param axis1
	:type axis1:ifcdirection
	:param axis2
	:type axis2:ifcdirection
	:param axis3
	:type axis3:ifcdirection
	'''
	if (dim  ==  3):
		d1 = NVL(ifcnormalise(axis3),(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,0,1]))
		d2 = ifcfirstprojaxis(d1,axis1)
		u = [d2,ifcsecondprojaxis(d1,d2,axis2),d1]
	else:
		if (EXISTS(axis1)):
			d1 = ifcnormalise(axis1)
			u = [d1,ifcorthogonalcomplement(d1)]
			if (EXISTS(axis2)):
				factor = ifcdotproduct(axis2,u[2])
				if (factor  <  0):
					u[2].directionratios[1] = -u[2].directionratios[1]
					u[2].directionratios[2] = -u[2].directionratios[2]
		else:
			if (EXISTS(axis2)):
				d1 = ifcnormalise(axis2)
				u = [ifcorthogonalcomplement(d1),d1]
				u[1].directionratios[1] = -u[1].directionratios[1]
				u[1].directionratios[2] = -u[1].directionratios[2]
			else:
				u = [(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([1,0]),(ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([0,1])]
	return u

####################
 # FUNCTION ifcorthogonalcomplement #
####################
def ifcorthogonalcomplement(vec,):
	'''
	:param vec
	:type vec:ifcdirection
	'''
	if (( not EXISTS(vec))  or  (vec.dim  !=  2)):
		return  None 
	else:
		result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([-vec.directionratios[2],vec.directionratios[1]])
		return result

####################
 # FUNCTION ifcloopheadtotail #
####################
def ifcloopheadtotail(aloop,):
	'''
	:param aloop
	:type aloop:ifcedgeloop
	'''
	n = SIZEOF(aloop.edgelist)
	for  i in range(2,n,1):
		p = p  and  (aloop.edgelist[i - 1].edgeend  ==  aloop.edgelist[i].edgestart)
	return p

####################
 # FUNCTION ifccorrectdimensions #
####################
def ifccorrectdimensions(m,dim,):
	'''
	:param m
	:type m:ifcunitenum
	:param dim
	:type dim:ifcdimensionalexponents
	'''
	case_selector = m
	if  case_selector == lengthunit:
		if (dim  ==  ifcdimensionalexponents(1,0,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == massunit:
		if (dim  ==  ifcdimensionalexponents(0,1,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == timeunit:
		if (dim  ==  ifcdimensionalexponents(0,0,1,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electriccurrentunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,1,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == thermodynamictemperatureunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,1,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == amountofsubstanceunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,0,1,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == luminousintensityunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,0,0,1)):
			return TRUE
		else:
			return FALSE
	elif case_selector == planeangleunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == solidangleunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == areaunit:
		if (dim  ==  ifcdimensionalexponents(2,0,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == volumeunit:
		if (dim  ==  ifcdimensionalexponents(3,0,0,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == absorbeddoseunit:
		if (dim  ==  ifcdimensionalexponents(2,0,-2,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == radioactivityunit:
		if (dim  ==  ifcdimensionalexponents(0,0,-1,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electriccapacitanceunit:
		if (dim  ==  ifcdimensionalexponents(-2,1,4,1,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == doseequivalentunit:
		if (dim  ==  ifcdimensionalexponents(2,0,-2,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electricchargeunit:
		if (dim  ==  ifcdimensionalexponents(0,0,1,1,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electricconductanceunit:
		if (dim  ==  ifcdimensionalexponents(-2,-1,3,2,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electricvoltageunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-3,-1,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == electricresistanceunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-3,-2,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == energyunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-2,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == forceunit:
		if (dim  ==  ifcdimensionalexponents(1,1,-2,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == frequencyunit:
		if (dim  ==  ifcdimensionalexponents(0,0,-1,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == inductanceunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-2,-2,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == illuminanceunit:
		if (dim  ==  ifcdimensionalexponents(-2,0,0,0,0,0,1)):
			return TRUE
		else:
			return FALSE
	elif case_selector == luminousfluxunit:
		if (dim  ==  ifcdimensionalexponents(0,0,0,0,0,0,1)):
			return TRUE
		else:
			return FALSE
	elif case_selector == magneticfluxunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-2,-1,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == magneticfluxdensityunit:
		if (dim  ==  ifcdimensionalexponents(0,1,-2,-1,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == powerunit:
		if (dim  ==  ifcdimensionalexponents(2,1,-3,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	elif case_selector == pressureunit:
		if (dim  ==  ifcdimensionalexponents(-1,1,-2,0,0,0,0)):
			return TRUE
		else:
			return FALSE
	else:
		return UNKNOWN

####################
 # FUNCTION ifcdimensionsforsiunit #
####################
def ifcdimensionsforsiunit(n,):
	'''
	:param n
	:type n:ifcsiunitname
	'''
	case_selector = n
	if  case_selector == metre:
		return ifcdimensionalexponents(1,0,0,0,0,0,0)
	elif case_selector == square_metre:
		return ifcdimensionalexponents(2,0,0,0,0,0,0)
	elif case_selector == cubic_metre:
		return ifcdimensionalexponents(3,0,0,0,0,0,0)
	elif case_selector == gram:
		return ifcdimensionalexponents(0,1,0,0,0,0,0)
	elif case_selector == second:
		return ifcdimensionalexponents(0,0,1,0,0,0,0)
	elif case_selector == ampere:
		return ifcdimensionalexponents(0,0,0,1,0,0,0)
	elif case_selector == kelvin:
		return ifcdimensionalexponents(0,0,0,0,1,0,0)
	elif case_selector == mole:
		return ifcdimensionalexponents(0,0,0,0,0,1,0)
	elif case_selector == candela:
		return ifcdimensionalexponents(0,0,0,0,0,0,1)
	elif case_selector == radian:
		return ifcdimensionalexponents(0,0,0,0,0,0,0)
	elif case_selector == steradian:
		return ifcdimensionalexponents(0,0,0,0,0,0,0)
	elif case_selector == hertz:
		return ifcdimensionalexponents(0,0,-1,0,0,0,0)
	elif case_selector == newton:
		return ifcdimensionalexponents(1,1,-2,0,0,0,0)
	elif case_selector == pascal:
		return ifcdimensionalexponents(-1,1,-2,0,0,0,0)
	elif case_selector == joule:
		return ifcdimensionalexponents(2,1,-2,0,0,0,0)
	elif case_selector == watt:
		return ifcdimensionalexponents(2,1,-3,0,0,0,0)
	elif case_selector == coulomb:
		return ifcdimensionalexponents(0,0,1,1,0,0,0)
	elif case_selector == volt:
		return ifcdimensionalexponents(2,1,-3,-1,0,0,0)
	elif case_selector == farad:
		return ifcdimensionalexponents(-2,-1,4,1,0,0,0)
	elif case_selector == ohm:
		return ifcdimensionalexponents(2,1,-3,-2,0,0,0)
	elif case_selector == siemens:
		return ifcdimensionalexponents(-2,-1,3,2,0,0,0)
	elif case_selector == weber:
		return ifcdimensionalexponents(2,1,-2,-1,0,0,0)
	elif case_selector == tesla:
		return ifcdimensionalexponents(0,1,-2,-1,0,0,0)
	elif case_selector == henry:
		return ifcdimensionalexponents(2,1,-2,-2,0,0,0)
	elif case_selector == degree_celsius:
		return ifcdimensionalexponents(0,0,0,0,1,0,0)
	elif case_selector == lumen:
		return ifcdimensionalexponents(0,0,0,0,0,0,1)
	elif case_selector == lux:
		return ifcdimensionalexponents(-2,0,0,0,0,0,1)
	elif case_selector == becquerel:
		return ifcdimensionalexponents(0,0,-1,0,0,0,0)
	elif case_selector == gray:
		return ifcdimensionalexponents(2,0,-2,0,0,0,0)
	elif case_selector == sievert:
		return ifcdimensionalexponents(2,0,-2,0,0,0,0)
	else:
		return ifcdimensionalexponents(0,0,0,0,0,0,0)

####################
 # FUNCTION ifcmlstotalthickness #
####################
def ifcmlstotalthickness(layerset,):
	'''
	:param layerset
	:type layerset:ifcmateriallayerset
	'''
	if (SIZEOF(layerset.materiallayers)  >  1):
		for  i in range(2,HIINDEX(layerset.materiallayers),1):
			max = max  +  layerset.materiallayers[i].layerthickness
	return max

####################
 # FUNCTION ifccorrectobjectassignment #
####################
def ifccorrectobjectassignment(constraint,objects,):
	'''
	:param constraint
	:type constraint:ifcobjecttypeenum
	:param objects
	:type objects:(null)
	'''
	if ( not EXISTS(constraint)):
		return TRUE
	case_selector = constraint
	if  case_selector == ifcobjecttypeenum.notdefined:
		return TRUE
	elif case_selector == ifcobjecttypeenum.product:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.process:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.control:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.resource:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.actor:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.group:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	elif case_selector == ifcobjecttypeenum.project:
		# begin/end block
		count = SIZEOF(None)
		return count  ==  0
	else:
		return  None 

####################
 # FUNCTION ifcvalidcalendardate #
####################
def ifcvalidcalendardate(date,):
	'''
	:param date
	:type date:ifccalendardate
	'''
	if ( not ((1  <=  date.daycomponent)  and  (date.daycomponent  <=  31))):
		return FALSE
	case_selector = date.monthcomponent
	if  case_selector == 4:
		return (1  <=  date.daycomponent)  and  (date.daycomponent  <=  30)
	elif case_selector == 6:
		return (1  <=  date.daycomponent)  and  (date.daycomponent  <=  30)
	elif case_selector == 9:
		return (1  <=  date.daycomponent)  and  (date.daycomponent  <=  30)
	elif case_selector == 11:
		return (1  <=  date.daycomponent)  and  (date.daycomponent  <=  30)
	elif case_selector == 2:
		# begin/end block
		if (ifcleapyear(date.yearcomponent)):
			return (1  <=  date.daycomponent)  and  (date.daycomponent  <=  29)
		else:
			return (1  <=  date.daycomponent)  and  (date.daycomponent  <=  28)
	else:
		return TRUE

####################
 # FUNCTION ifccurveweightspositive #
####################
def ifccurveweightspositive(b,):
	'''
	:param b
	:type b:ifcrationalbeziercurve
	'''
	for  i in range(0,b.upperindexoncontrolpoints,1):
		if (b.weights[i]  <=  0):
			result = FALSE
			return result
	return result

####################
 # FUNCTION ifcsameaxis2placement #
####################
def ifcsameaxis2placement(ap1,ap2,epsilon,):
	'''
	:param ap1
	:type ap1:ifcaxis2placement
	:param ap2
	:type ap2:ifcaxis2placement
	:param epsilon
	:type epsilon:REAL
	'''
	return (ifcsamedirection(ap1.p[1],ap2.p[1],epsilon)  and  ifcsamedirection(ap1.p[2],ap2.p[2],epsilon))  and  ifcsamecartesianpoint(ap1.location,ap1.location,epsilon)

####################
 # FUNCTION ifcbuild2axes #
####################
def ifcbuild2axes(refdirection,):
	'''
	:param refdirection
	:type refdirection:ifcdirection
	'''
	return [d,ifcorthogonalcomplement(d)]

####################
 # FUNCTION ifccrossproduct #
####################
def ifccrossproduct(arg1,arg2,):
	'''
	:param arg1
	:type arg1:ifcdirection
	:param arg2
	:type arg2:ifcdirection
	'''
	if ((( not EXISTS(arg1))  or  (arg1.dim  ==  2))  or  (( not EXISTS(arg2))  or  (arg2.dim  ==  2))):
		return  None 
	else:
		# begin/end block
		v1 = ifcnormalise(arg1).directionratios
		v2 = ifcnormalise(arg2).directionratios
		res = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcdirection([(v1[2]  *  v2[3]) - (v1[3]  *  v2[2]),(v1[3]  *  v2[1]) - (v1[1]  *  v2[3]),(v1[1]  *  v2[2]) - (v1[2]  *  v2[1])])
		mag = 0
		for  i in range(1,3,1):
			mag = mag  +  (res.directionratios[i]  *  res.directionratios[i])
		if (mag  >  0):
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(res,SQRT(mag))
		else:
			result = (ifcrepresentationitem()  ==  ifcgeometricrepresentationitem())  ==  ifcvector(arg1,0)
		return result

####################
 # FUNCTION ifcsamecartesianpoint #
####################
def ifcsamecartesianpoint(cp1,cp2,epsilon,):
	'''
	:param cp1
	:type cp1:ifccartesianpoint
	:param cp2
	:type cp2:ifccartesianpoint
	:param epsilon
	:type epsilon:REAL
	'''
	if (SIZEOF(cp1.coordinates)  >  2):
		cp1z = cp1.coordinates[3]
	if (SIZEOF(cp2.coordinates)  >  2):
		cp2z = cp2.coordinates[3]
	return (ifcsamevalue(cp1x,cp2x,epsilon)  and  ifcsamevalue(cp1y,cp2y,epsilon))  and  ifcsamevalue(cp1z,cp2z,epsilon)

####################
 # RULE ifcsingleprojectinstance #
####################
ifcsingleprojectinstance = Rule()

####################
 # RULE ifcrepresentationcontextsamewcs #
####################
ifcrepresentationcontextsamewcs = Rule()
