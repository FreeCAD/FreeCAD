# This file was generated by fedex_python.  You probably don't want to edit
# it since your modifications will be lost if fedex_plus is used to
# regenerate it.
import sys

from SCL.SCLBase import *
from SCL.SimpleDataTypes import *
from SCL.ConstructedDataTypes import *
from SCL.AggregationDataTypes import *
from SCL.TypeChecker import check_type
from SCL.Builtin import *
from SCL.Rules import *

schema_name = 'ap203_configuration_controlled_3d_design_of_mechanical_parts_and_assemblies_mim_lf'

schema_scope = sys.modules[__name__]

# SELECT TYPE characterized_definition
characterized_definition = SELECT(
	'characterized_object',
	'characterized_product_definition',
	'shape_definition',
	scope = schema_scope)
# Defined datatype capacitance_measure
class capacitance_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE geometric_item_specific_usage_select
geometric_item_specific_usage_select = SELECT(
	'shape_aspect',
	'shape_aspect_relationship',
	scope = schema_scope)
# Defined datatype parameter_value
class parameter_value(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype frequency_measure
class frequency_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype plane_angle_measure
class plane_angle_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype box_rotate_angle
class box_rotate_angle(plane_angle_measure):
	def __init__(self,*kargs):
		pass

# SELECT TYPE attribute_language_item
attribute_language_item = SELECT(
	'alternate_product_relationship',
	'application_context',
	'applied_certification_assignment',
	'applied_document_reference',
	'applied_document_usage_constraint_assignment',
	'applied_external_identification_assignment',
	'applied_identification_assignment',
	'applied_organizational_project_assignment',
	'applied_security_classification_assignment',
	'approval',
	'approval_relationship',
	'approval_status',
	'assembly_component_usage_substitute',
	'attribute_value_assignment',
	'certification',
	'certification_type',
	'configuration_design',
	'configuration_item',
	'contract',
	'date_role',
	'date_time_role',
	'descriptive_representation_item',
	'document_relationship',
	'document_usage_role',
	'effectivity',
	'effectivity_relationship',
	'event_occurrence',
	'external_source',
	'general_property',
	'general_property_relationship',
	'geometric_representation_item',
	'geometric_tolerance',
	'identification_role',
	'information_right',
	'information_usage_right',
	'make_from_usage_option',
	'mapped_item',
	'multi_language_attribute_assignment',
	'object_role',
	'organization_relationship',
	'organization_role',
	'organizational_project',
	'organizational_project_relationship',
	'organizational_project_role',
	'person_and_organization',
	'person_and_organization_role',
	'product',
	'product_concept',
	'product_concept_relationship',
	'product_definition',
	'product_definition_context',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_shape',
	'product_related_product_category',
	'property_definition',
	'representation',
	'security_classification',
	'security_classification_assignment',
	'shape_aspect',
	'shape_aspect_relationship',
	'shape_representation',
	'time_interval_role',
	'topological_representation_item',
	'uncertainty_measure_with_unit',
	'uncertainty_qualifier',
	'usage_association',
	scope = schema_scope)
# SELECT TYPE change_request_item
change_request_item = SELECT(
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE configured_effectivity_context_item
configured_effectivity_context_item = SELECT(
	'product_concept_feature_association',
	scope = schema_scope)
# SELECT TYPE font_select
font_select = SELECT(
	'pre_defined_text_font',
	'externally_defined_text_font',
	'text_font',
	scope = schema_scope)
# Defined datatype text
class text(STRING):
	def __init__(self,*kargs):
		pass

# SELECT TYPE action_request_item
action_request_item = SELECT(
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'property_definition',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE blend_end_condition_select
blend_end_condition_select = SELECT(
	'point_on_curve',
	'edge_curve',
	'vertex',
	scope = schema_scope)
# SELECT TYPE draughting_callout_element
draughting_callout_element = SELECT(
	'annotation_text_occurrence',
	'annotation_symbol_occurrence',
	'annotation_curve_occurrence',
	scope = schema_scope)
# SELECT TYPE name_item
name_item = SELECT(
	'assembly_component_usage',
	'external_class_library',
	'group',
	'group_relationship',
	'product',
	'product_definition',
	scope = schema_scope)
# Defined datatype blend_radius_variation_type
class blend_radius_variation_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE classification_item
classification_item = SELECT(
	'action',
	'action_directive',
	'action_method',
	'action_property',
	'action_relationship',
	'action_request_solution',
	'action_request_status',
	'address',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_action_request_assignment',
	'applied_approval_assignment',
	'applied_certification_assignment',
	'applied_contract_assignment',
	'applied_date_and_time_assignment',
	'applied_date_assignment',
	'applied_document_reference',
	'applied_document_usage_constraint_assignment',
	'applied_effectivity_assignment',
	'applied_event_occurrence_assignment',
	'applied_external_identification_assignment',
	'applied_identification_assignment',
	'applied_organization_assignment',
	'applied_organizational_project_assignment',
	'applied_person_and_organization_assignment',
	'applied_security_classification_assignment',
	'approval',
	'approval_person_organization',
	'approval_relationship',
	'approval_status',
	'assembly_component_usage_substitute',
	'calendar_date',
	'certification',
	'characterized_class',
	'characterized_object',
	'class_',
	'classified_item',
	'configuration_item',
	'context_dependent_unit',
	'contract',
	'conversion_based_unit',
	'date_and_time',
	'date_and_time_assignment',
	'date_assignment',
	'derived_unit',
	'descriptive_representation_item',
	'directed_action',
	'document_file',
	'document_relationship',
	'effectivity',
	'event_occurrence',
	'executed_action',
	'general_property',
	'general_property_relationship',
	'group',
	'identification_assignment',
	'information_right',
	'information_usage_right',
	'language',
	'measure_representation_item',
	'measure_with_unit',
	'multi_language_attribute_assignment',
	'named_unit',
	'organization',
	'organization_relationship',
	'organizational_address',
	'organizational_project',
	'organizational_project_relationship',
	'person',
	'person_and_organization_address',
	'product',
	'product_concept',
	'product_definition',
	'product_definition_context',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'property_definition',
	'property_definition_representation',
	'representation',
	'representation_context',
	'representation_item',
	'security_classification',
	'uncertainty_measure_with_unit',
	'usage_association',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE curve_font_or_scaled_curve_font_select
curve_font_or_scaled_curve_font_select = SELECT(
	'curve_style_font_select',
	'curve_style_font_and_scaling',
	scope = schema_scope)
# Defined datatype year_number
class year_number(INTEGER):
	def __init__(self,*kargs):
		pass

# SELECT TYPE characterized_product_definition
characterized_product_definition = SELECT(
	'product_definition',
	'product_definition_relationship',
	scope = schema_scope)
# SELECT TYPE reversible_topology_item
reversible_topology_item = SELECT(
	'edge',
	'path',
	'face',
	'face_bound',
	'closed_shell',
	'open_shell',
	scope = schema_scope)
# SELECT TYPE size_select
size_select = SELECT(
	'positive_length_measure',
	'measure_with_unit',
	'descriptive_measure',
	scope = schema_scope)
# SELECT TYPE axis2_placement
axis2_placement = SELECT(
	'axis2_placement_2d',
	'axis2_placement_3d',
	scope = schema_scope)
# SELECT TYPE symbol_style_select
symbol_style_select = SELECT(
	'symbol_colour',
	scope = schema_scope)
# SELECT TYPE presentation_style_select
presentation_style_select = SELECT(
	'point_style',
	'curve_style',
	'surface_style_usage',
	'symbol_style',
	'fill_area_style',
	'text_style',
	'null_style',
	scope = schema_scope)
set_of_reversible_topology_item = SET(0,None,'reversible_topology_item', scope = schema_scope)
# Defined datatype central_or_parallel
class central_or_parallel(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype message
class message(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype week_in_year_number
class week_in_year_number(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((1  <=  self)  and  (self  <=  53))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype limit_condition
class limit_condition(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype knot_type
class knot_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype thermodynamic_temperature_measure
class thermodynamic_temperature_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE presented_item_select
presented_item_select = SELECT(
	'action',
	'action_method',
	'action_relationship',
	'product_concept',
	'product_concept_feature',
	'product_concept_feature_category',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	scope = schema_scope)
# SELECT TYPE angle_direction_reference_with_a2p3d_select
angle_direction_reference_with_a2p3d_select = SELECT(
	'angle_direction_reference_select',
	'axis2_placement_3d',
	scope = schema_scope)
set_representation_item = SET(1,None,'representation_item', scope = schema_scope)
# SELECT TYPE angle_direction_reference_select
angle_direction_reference_select = SELECT(
	'direction',
	'curve',
	'point_path',
	scope = schema_scope)
# SELECT TYPE presentation_representation_select
presentation_representation_select = SELECT(
	'presentation_representation',
	'presentation_set',
	scope = schema_scope)
# SELECT TYPE text_or_character
text_or_character = SELECT(
	'annotation_text',
	'annotation_text_character',
	'composite_text',
	'text_literal',
	scope = schema_scope)
# Defined datatype minute_in_hour
class minute_in_hour(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <=  59))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype transition_code
class transition_code(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE character_style_select
character_style_select = SELECT(
	'character_glyph_style_stroke',
	'character_glyph_style_outline',
	'text_style_for_defined_font',
	scope = schema_scope)
# SELECT TYPE picture_representation_item_select
picture_representation_item_select = SELECT(
	'styled_item',
	'planar_box',
	'axis2_placement_2d',
	scope = schema_scope)
# SELECT TYPE annotation_symbol_occurrence_item
annotation_symbol_occurrence_item = SELECT(
	'annotation_symbol',
	'defined_symbol',
	scope = schema_scope)
# SELECT TYPE invisibility_context
invisibility_context = SELECT(
	'draughting_model',
	'presentation_representation',
	'presentation_set',
	scope = schema_scope)
# SELECT TYPE external_identification_item
external_identification_item = SELECT(
	'action_relationship',
	'action_request_status',
	'applied_organization_assignment',
	'applied_person_and_organization_assignment',
	'approval',
	'approval_status',
	'date_and_time_assignment',
	'date_assignment',
	'document_file',
	'external_source',
	'externally_defined_class',
	'externally_defined_context_dependent_unit',
	'externally_defined_conversion_based_unit',
	'externally_defined_general_property',
	'externally_defined_picture_representation_item',
	'externally_defined_representation_item',
	'organizational_address',
	'product_definition',
	'security_classification',
	'trimmed_curve',
	'versioned_action_request',
	scope = schema_scope)
# Defined datatype identifier
class identifier(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype magnetic_flux_measure
class magnetic_flux_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE compound_item_definition
compound_item_definition = SELECT(
	'list_representation_item',
	'set_representation_item',
	scope = schema_scope)
# SELECT TYPE product_definition_or_breakdown_element_usage
product_definition_or_breakdown_element_usage = SELECT(
	'product_definition',
	'product_definition_usage',
	scope = schema_scope)
# SELECT TYPE draughting_model_item_association_select
draughting_model_item_association_select = SELECT(
	'annotation_occurrence',
	'draughting_callout',
	scope = schema_scope)
# Defined datatype non_negative_length_measure
class non_negative_length_measure(length_measure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE represented_definition
represented_definition = SELECT(
	'general_property',
	'property_definition',
	'property_definition_relationship',
	'shape_aspect',
	'shape_aspect_relationship',
	scope = schema_scope)
# SELECT TYPE text_string_representation_item
text_string_representation_item = SELECT(
	'text_literal',
	'annotation_text',
	'annotation_text_character',
	'composite_text',
	'axis2_placement',
	scope = schema_scope)
# SELECT TYPE event_occurrence_item
event_occurrence_item = SELECT(
	'organizational_project',
	scope = schema_scope)
# SELECT TYPE measure_value
measure_value = SELECT(
	'absorbed_dose_measure',
	'dose_equivalent_measure',
	'radioactivity_measure',
	'acceleration_measure',
	'amount_of_substance_measure',
	'area_measure',
	'celsius_temperature_measure',
	'context_dependent_measure',
	'count_measure',
	'descriptive_measure',
	'capacitance_measure',
	'electric_charge_measure',
	'conductance_measure',
	'electric_current_measure',
	'electric_potential_measure',
	'energy_measure',
	'magnetic_flux_density_measure',
	'force_measure',
	'frequency_measure',
	'illuminance_measure',
	'inductance_measure',
	'length_measure',
	'luminous_flux_measure',
	'luminous_intensity_measure',
	'magnetic_flux_measure',
	'mass_measure',
	'numeric_measure',
	'non_negative_length_measure',
	'parameter_value',
	'plane_angle_measure',
	'positive_length_measure',
	'positive_plane_angle_measure',
	'positive_ratio_measure',
	'power_measure',
	'pressure_measure',
	'ratio_measure',
	'resistance_measure',
	'solid_angle_measure',
	'thermodynamic_temperature_measure',
	'time_measure',
	'velocity_measure',
	'volume_measure',
	scope = schema_scope)
# SELECT TYPE person_organization_select
person_organization_select = SELECT(
	'person',
	'organization',
	'person_and_organization',
	scope = schema_scope)
# SELECT TYPE presentation_size_assignment_select
presentation_size_assignment_select = SELECT(
	'presentation_view',
	'presentation_area',
	'area_in_set',
	scope = schema_scope)
# SELECT TYPE date_and_time_item
date_and_time_item = SELECT(
	'action',
	'action_directive',
	'applied_action_assignment',
	'applied_organization_assignment',
	'applied_person_and_organization_assignment',
	'applied_security_classification_assignment',
	'approval_person_organization',
	'certification',
	'contract',
	'directed_action',
	'document',
	'document_file',
	'event_occurrence',
	'executed_action',
	'information_usage_right',
	'organizational_project',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	'rule_action',
	'security_classification',
	'versioned_action_request',
	scope = schema_scope)
# Defined datatype preferred_surface_curve_representation
class preferred_surface_curve_representation(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE rendering_properties_select
rendering_properties_select = SELECT(
	'surface_style_reflectance_ambient',
	'surface_style_transparent',
	scope = schema_scope)
# Defined datatype velocity_measure
class velocity_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype magnetic_flux_density_measure
class magnetic_flux_density_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype u_direction_count
class u_direction_count(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype dimension_count
class dimension_count(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE cc_specified_item
cc_specified_item = SELECT(
	'product_definition',
	'shape_aspect',
	scope = schema_scope)
list_representation_item = LIST(1,None,'representation_item', scope = schema_scope)
# SELECT TYPE sketch_basis_select
sketch_basis_select = SELECT(
	'curve_bounded_surface',
	'face_surface',
	scope = schema_scope)
# SELECT TYPE document_identifier_assigned_item
document_identifier_assigned_item = SELECT(
	'document',
	scope = schema_scope)
# Defined datatype energy_measure
class energy_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype radioactivity_measure
class radioactivity_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE csg_select
csg_select = SELECT(
	'boolean_result',
	'csg_primitive',
	scope = schema_scope)
# SELECT TYPE annotation_representation_select
annotation_representation_select = SELECT(
	'presentation_area',
	'presentation_view',
	'symbol_representation',
	scope = schema_scope)
# SELECT TYPE layered_item
layered_item = SELECT(
	'presentation_representation',
	'representation_item',
	scope = schema_scope)
# SELECT TYPE pcurve_or_surface
pcurve_or_surface = SELECT(
	'pcurve',
	'surface',
	scope = schema_scope)
# SELECT TYPE orientation_basis_select
orientation_basis_select = SELECT(
	'axis2_placement_3d',
	'min_and_major_ply_orientation_basis',
	scope = schema_scope)
# Defined datatype positive_length_measure
class positive_length_measure(non_negative_length_measure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype dimension_extent_usage
class dimension_extent_usage(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE attribute_type
attribute_type = SELECT(
	'label',
	'text',
	scope = schema_scope)
# Defined datatype box_width
class box_width(positive_ratio_measure):
	def __init__(self,*kargs):
		pass

# SELECT TYPE cc_person_organization_item
cc_person_organization_item = SELECT(
	'change',
	'change_request',
	'configuration_item',
	'contract',
	'product',
	'product_definition',
	'product_definition_formation',
	'security_classification',
	'start_request',
	'start_work',
	scope = schema_scope)
# Defined datatype trim_intent
class trim_intent(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE id_attribute_select
id_attribute_select = SELECT(
	'action',
	'address',
	'product_category',
	'property_definition',
	'shape_aspect',
	'shape_aspect_relationship',
	'application_context',
	'group',
	'organizational_project',
	'representation',
	scope = schema_scope)
# Defined datatype nonnegative_integer
class nonnegative_integer(INTEGER):
	def __init__(self,*kargs):
		pass
		self.nonnegativity()

	def nonnegativity(self):
		eval_nonnegativity_wr = (self  >=  0)
		if not eval_nonnegativity_wr:
			raise AssertionError('Rule nonnegativity violated')
		else:
			return eval_nonnegativity_wr

# SELECT TYPE invisible_item
invisible_item = SELECT(
	'draughting_callout',
	'presentation_layer_assignment',
	'representation',
	'styled_item',
	scope = schema_scope)
# SELECT TYPE generalized_surface_select
generalized_surface_select = SELECT(
	'surface',
	'face_surface',
	'surfaced_open_shell',
	scope = schema_scope)
# Defined datatype numeric_measure
class numeric_measure(NUMBER):
	def __init__(self,*kargs):
		pass

# Defined datatype box_slant_angle
class box_slant_angle(plane_angle_measure):
	def __init__(self,*kargs):
		pass

# Defined datatype b_spline_curve_form
class b_spline_curve_form(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE characterized_product_composition_value
characterized_product_composition_value = SELECT(
	'measure_with_unit',
	scope = schema_scope)
# SELECT TYPE effectivity_item
effectivity_item = SELECT(
	'assembly_component_usage_substitute',
	'product',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	'product_definition_substitute',
	scope = schema_scope)
# SELECT TYPE multi_language_attribute_item
multi_language_attribute_item = SELECT(
	'alternate_product_relationship',
	'application_context',
	'applied_certification_assignment',
	'applied_document_reference',
	'applied_document_usage_constraint_assignment',
	'applied_external_identification_assignment',
	'applied_identification_assignment',
	'applied_organizational_project_assignment',
	'approval',
	'approval_relationship',
	'approval_status',
	'assembly_component_usage_substitute',
	'attribute_value_assignment',
	'certification',
	'certification_type',
	'colour',
	'configuration_design',
	'configuration_item',
	'contract',
	'date_role',
	'date_time_role',
	'descriptive_representation_item',
	'document_relationship',
	'document_usage_role',
	'effectivity',
	'effectivity_relationship',
	'event_occurrence',
	'external_source',
	'general_property',
	'general_property_relationship',
	'geometric_representation_item',
	'geometric_tolerance',
	'identification_role',
	'information_right',
	'information_usage_right',
	'make_from_usage_option',
	'mapped_item',
	'object_role',
	'organization_relationship',
	'organization_role',
	'organizational_project',
	'organizational_project_relationship',
	'organizational_project_role',
	'person_and_organization',
	'person_and_organization_role',
	'product',
	'product_concept',
	'product_concept_relationship',
	'product_definition',
	'product_definition_context',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'product_definition_shape',
	'product_related_product_category',
	'property_definition',
	'representation',
	'representation_relationship',
	'security_classification',
	'security_classification_assignment',
	'shape_aspect',
	'shape_aspect_relationship',
	'shape_representation',
	'time_interval_role',
	'topological_representation_item',
	'uncertainty_measure_with_unit',
	'usage_association',
	scope = schema_scope)
# SELECT TYPE draughting_titled_item
draughting_titled_item = SELECT(
	'drawing_revision',
	'drawing_sheet_revision',
	scope = schema_scope)
# Defined datatype hour_in_day
class hour_in_day(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <  24))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE surface_style_element_select
surface_style_element_select = SELECT(
	'surface_style_fill_area',
	'surface_style_boundary',
	'surface_style_silhouette',
	'surface_style_segmentation_curve',
	'surface_style_control_grid',
	'surface_style_parameter_line',
	'surface_style_rendering',
	scope = schema_scope)
# Defined datatype v_direction_count
class v_direction_count(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype inductance_measure
class inductance_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE security_classification_item
security_classification_item = SELECT(
	'assembly_component_usage',
	'document',
	'document_file',
	'make_from_usage_option',
	'product',
	'product_definition',
	'product_definition_formation',
	'product_definition_usage',
	scope = schema_scope)
# SELECT TYPE action_items
action_items = SELECT(
	'action_directive',
	'certification_item',
	'characterized_object',
	'classification_item',
	'configuration_effectivity',
	'document_reference_item',
	'identification_item',
	'organization',
	'person_and_organization',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'requirement_assigned_item',
	scope = schema_scope)
# SELECT TYPE dimensional_characteristic
dimensional_characteristic = SELECT(
	'dimensional_location',
	'dimensional_size',
	scope = schema_scope)
# Defined datatype ratio_measure
class ratio_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE document_reference_item
document_reference_item = SELECT(
	'action_method',
	'applied_external_identification_assignment',
	'assembly_component_usage',
	'characterized_class',
	'characterized_object',
	'configuration_item',
	'descriptive_representation_item',
	'dimensional_size',
	'executed_action',
	'externally_defined_dimension_definition',
	'externally_defined_item',
	'group',
	'group_relationship',
	'information_right',
	'information_usage_right',
	'material_designation',
	'measure_representation_item',
	'product',
	'product_category',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'property_definition',
	'representation',
	'representation_item',
	'rule_set',
	'shape_aspect',
	'shape_aspect_relationship',
	'usage_association',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE requirement_source_item
requirement_source_item = SELECT(
	'characterized_object',
	'group',
	'group_relationship',
	'product',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	'shape_aspect',
	scope = schema_scope)
# SELECT TYPE classified_item
classified_item = SELECT(
	'product',
	'product_definition',
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE mechanical_design_geometric_presentation_representation_items
mechanical_design_geometric_presentation_representation_items = SELECT(
	'axis2_placement',
	'camera_model_d3',
	'mapped_item',
	'styled_item',
	scope = schema_scope)
# Defined datatype si_unit_name
class si_unit_name(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype acceleration_measure
class acceleration_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype amount_of_substance_measure
class amount_of_substance_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype day_in_month_number
class day_in_month_number(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((1  <=  self)  and  (self  <=  31))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE area_or_view
area_or_view = SELECT(
	'presentation_area',
	'presentation_view',
	scope = schema_scope)
# Defined datatype electric_current_measure
class electric_current_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE founded_item_select
founded_item_select = SELECT(
	'founded_item',
	'representation_item',
	scope = schema_scope)
# SELECT TYPE style_context_select
style_context_select = SELECT(
	'group',
	'presentation_layer_assignment',
	'presentation_set',
	'representation',
	'representation_item',
	'representation_relationship',
	scope = schema_scope)
# SELECT TYPE rule_superseded_item
rule_superseded_item = SELECT(
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE camera_model_d3_multi_clipping_union_select
camera_model_d3_multi_clipping_union_select = SELECT(
	'camera_model_d3_multi_clipping_intersection',
	'plane',
	scope = schema_scope)
# SELECT TYPE product_definition_or_assembly_relationship
product_definition_or_assembly_relationship = SELECT(
	'assembly_component_usage',
	'product_definition',
	scope = schema_scope)
# Defined datatype positive_integer
class positive_integer(nonnegative_integer):
	def __init__(self,*kargs):
		pass
		self.positivity()

	def positivity(self):
		eval_positivity_wr = (self  >  0)
		if not eval_positivity_wr:
			raise AssertionError('Rule positivity violated')
		else:
			return eval_positivity_wr

# SELECT TYPE source_item
source_item = SELECT(
	'identifier',
	'message',
	scope = schema_scope)
# Defined datatype trimming_preference
class trimming_preference(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype resistance_measure
class resistance_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE trim_condition_select
trim_condition_select = SELECT(
	'length_measure',
	'plane_angle_measure',
	'generalized_surface_select',
	'solid_model',
	scope = schema_scope)
# SELECT TYPE contract_item
contract_item = SELECT(
	'action_directive',
	'alternate_product_relationship',
	'directed_action',
	'executed_action',
	'information_usage_right',
	'organization',
	'person_and_organization',
	'product',
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE configured_effectivity_item
configured_effectivity_item = SELECT(
	'product_definition',
	scope = schema_scope)
# SELECT TYPE date_time_or_event_occurrence
date_time_or_event_occurrence = SELECT(
	'date_time_select',
	'event_occurrence',
	scope = schema_scope)
# SELECT TYPE derived_property_select
derived_property_select = SELECT(
	'property_definition',
	'action_property',
	scope = schema_scope)
# SELECT TYPE fill_area_style_tile_shape_select
fill_area_style_tile_shape_select = SELECT(
	'fill_area_style_tile_curve_with_style',
	'fill_area_style_tile_coloured_region',
	'fill_area_style_tile_symbol_with_style',
	'pre_defined_tile',
	'externally_defined_tile',
	scope = schema_scope)
# Defined datatype shading_surface_method
class shading_surface_method(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE vector_or_direction
vector_or_direction = SELECT(
	'vector',
	'direction',
	scope = schema_scope)
# SELECT TYPE requirement_assigned_item
requirement_assigned_item = SELECT(
	'configuration_item',
	'descriptive_representation_item',
	'product',
	'product_class',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	'representation',
	'shape_aspect',
	scope = schema_scope)
# SELECT TYPE approval_item
approval_item = SELECT(
	'action',
	'action_directive',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_usage_right',
	'assembly_component_usage_substitute',
	'certification',
	'configuration_effectivity',
	'configuration_item',
	'contract',
	'date',
	'directed_action',
	'document',
	'document_file',
	'effectivity',
	'executed_action',
	'general_property_relationship',
	'group',
	'group_relationship',
	'information_usage_right',
	'product',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'representation',
	'requirement_assignment',
	'security_classification',
	'shape_aspect_relationship',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE cc_classified_item
cc_classified_item = SELECT(
	'assembly_component_usage',
	'product_definition_formation',
	scope = schema_scope)
# Defined datatype volume_measure
class volume_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE geometric_set_select
geometric_set_select = SELECT(
	'point',
	'curve',
	'surface',
	scope = schema_scope)
# Defined datatype positive_plane_angle_measure
class positive_plane_angle_measure(plane_angle_measure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE start_request_item
start_request_item = SELECT(
	'product_definition_formation',
	scope = schema_scope)
# Defined datatype text_delineation
class text_delineation(label):
	def __init__(self,*kargs):
		pass

# SELECT TYPE category_usage_item
category_usage_item = SELECT(
	'product_class',
	scope = schema_scope)
# SELECT TYPE base_solid_select
base_solid_select = SELECT(
	'solid_model',
	'csg_primitive',
	'boolean_result',
	scope = schema_scope)
# SELECT TYPE defined_symbol_select
defined_symbol_select = SELECT(
	'pre_defined_symbol',
	'externally_defined_symbol',
	scope = schema_scope)
# Defined datatype force_measure
class force_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype b_spline_surface_form
class b_spline_surface_form(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype null_style
class null_style(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE date_time_item
date_time_item = SELECT(
	'approval_person_organization',
	'certification',
	'change',
	'change_request',
	'contract',
	'product_definition',
	'security_classification',
	'start_request',
	'start_work',
	scope = schema_scope)
# Defined datatype marker_type
class marker_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE shell
shell = SELECT(
	'vertex_shell',
	'wire_shell',
	'open_shell',
	'closed_shell',
	scope = schema_scope)
# Defined datatype luminous_flux_measure
class luminous_flux_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE transformation
transformation = SELECT(
	'item_defined_transformation',
	'functionally_defined_transformation',
	scope = schema_scope)
# Defined datatype day_in_week_number
class day_in_week_number(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((1  <=  self)  and  (self  <=  7))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE boolean_operand
boolean_operand = SELECT(
	'solid_model',
	'half_space_solid',
	'csg_primitive',
	'boolean_result',
	scope = schema_scope)
# SELECT TYPE certified_item
certified_item = SELECT(
	'supplied_part_relationship',
	scope = schema_scope)
# Defined datatype text_path
class text_path(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE curve_or_annotation_curve_occurrence
curve_or_annotation_curve_occurrence = SELECT(
	'curve',
	'annotation_curve_occurrence',
	scope = schema_scope)
# SELECT TYPE date_time_select
date_time_select = SELECT(
	'date',
	'date_and_time',
	'local_time',
	scope = schema_scope)
# Defined datatype solid_angle_measure
class solid_angle_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE groupable_item
groupable_item = SELECT(
	'geometric_representation_item',
	'group_relationship',
	'mapped_item',
	'package_product_concept_feature',
	'product_concept_feature',
	'product_definition',
	'product_definition_formation',
	'property_definition_representation',
	'representation',
	'representation_item',
	'representation_relationship_with_transformation',
	'shape_aspect',
	'shape_aspect_relationship',
	'shape_representation_relationship',
	'styled_item',
	'topological_representation_item',
	scope = schema_scope)
# SELECT TYPE csg_primitive
csg_primitive = SELECT(
	'sphere',
	'block',
	'right_angular_wedge',
	'torus',
	'right_circular_cone',
	'right_circular_cylinder',
	scope = schema_scope)
# Defined datatype electric_charge_measure
class electric_charge_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE marker_select
marker_select = SELECT(
	'marker_type',
	'pre_defined_marker',
	scope = schema_scope)
# SELECT TYPE camera_model_d3_multi_clipping_interection_select
camera_model_d3_multi_clipping_interection_select = SELECT(
	'camera_model_d3_multi_clipping_union',
	'plane',
	scope = schema_scope)
# SELECT TYPE constructive_geometry_representation_or_shape_represenation
constructive_geometry_representation_or_shape_represenation = SELECT(
	'constructive_geometry_representation',
	'shape_representation',
	scope = schema_scope)
# Defined datatype surface_side
class surface_side(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype luminous_intensity_measure
class luminous_intensity_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE organization_item
organization_item = SELECT(
	'action',
	'action_directive',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_classification_assignment',
	'applied_identification_assignment',
	'applied_security_classification_assignment',
	'approval',
	'assembly_component_usage_substitute',
	'certification',
	'class_',
	'configuration_item',
	'contract',
	'document_file',
	'executed_action',
	'general_property',
	'information_usage_right',
	'organizational_project',
	'product',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'property_definition',
	'rule_action',
	'security_classification',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# Defined datatype presentable_text
class presentable_text(STRING):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = control_characters_free(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE product_or_formation_or_definition
product_or_formation_or_definition = SELECT(
	'product',
	'product_definition_formation',
	'product_definition',
	scope = schema_scope)
# Defined datatype time_measure
class time_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE curve_on_surface
curve_on_surface = SELECT(
	'pcurve',
	'surface_curve',
	'composite_curve_on_surface',
	scope = schema_scope)
# Defined datatype power_measure
class power_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE attribute_classification_item
attribute_classification_item = SELECT(
	'action_directive',
	'action_method',
	'action_property',
	'action_property_representation',
	'action_relationship',
	'action_request_solution',
	'action_request_status',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_action_request_assignment',
	'applied_approval_assignment',
	'applied_certification_assignment',
	'applied_document_reference',
	'applied_document_usage_constraint_assignment',
	'applied_effectivity_assignment',
	'applied_event_occurrence_assignment',
	'applied_external_identification_assignment',
	'applied_identification_assignment',
	'applied_organization_assignment',
	'applied_organizational_project_assignment',
	'applied_person_and_organization_assignment',
	'approval',
	'approval_person_organization',
	'approval_relationship',
	'approval_status',
	'certification',
	'context_dependent_unit',
	'contract',
	'date_and_time_assignment',
	'date_assignment',
	'derived_unit',
	'descriptive_representation_item',
	'document_file',
	'document_relationship',
	'effectivity',
	'event_occurrence_relationship',
	'executed_action',
	'general_property',
	'general_property_relationship',
	'group',
	'group_relationship',
	'information_right',
	'information_usage_right',
	'language',
	'measure_representation_item',
	'measure_with_unit',
	'named_unit',
	'organization_relationship',
	'organizational_address',
	'organizational_project_relationship',
	'person_and_organization',
	'person_and_organization_address',
	'product',
	'product_category',
	'product_concept',
	'product_concept_context',
	'product_definition',
	'product_definition_context',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'property_definition',
	'property_definition_relationship',
	'property_definition_representation',
	'representation',
	'representation_context',
	'representation_item',
	'security_classification',
	'time_interval_relationship',
	'uncertainty_measure_with_unit',
	'usage_association',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE string_representation_item_select
string_representation_item_select = SELECT(
	'descriptive_representation_item',
	'included_text_block',
	'structured_text_composition',
	scope = schema_scope)
# SELECT TYPE trimming_select
trimming_select = SELECT(
	'cartesian_point',
	'parameter_value',
	scope = schema_scope)
# SELECT TYPE curve_style_font_select
curve_style_font_select = SELECT(
	'curve_style_font',
	'pre_defined_curve_font',
	'externally_defined_curve_font',
	scope = schema_scope)
point_path_members = LIST(1,None,'point_and_vector', scope = schema_scope)
# SELECT TYPE role_select
role_select = SELECT(
	'action_assignment',
	'action_request_assignment',
	'approval_assignment',
	'approval_date_time',
	'certification_assignment',
	'contract_assignment',
	'document_reference',
	'effectivity_assignment',
	'group_assignment',
	'name_assignment',
	'security_classification_assignment',
	scope = schema_scope)
# Defined datatype ahead_or_behind
class ahead_or_behind(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE contracted_item
contracted_item = SELECT(
	'product_definition_formation',
	scope = schema_scope)
# Defined datatype day_in_year_number
class day_in_year_number(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((1  <=  self)  and  (self  <=  366))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype mass_measure
class mass_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype angle_relator
class angle_relator(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE characterized_action_definition
characterized_action_definition = SELECT(
	'action',
	'action_method',
	'action_method_relationship',
	'action_relationship',
	scope = schema_scope)
# SELECT TYPE tolerance_method_definition
tolerance_method_definition = SELECT(
	'tolerance_value',
	'limits_and_fits',
	scope = schema_scope)
# SELECT TYPE plane_or_planar_box
plane_or_planar_box = SELECT(
	'plane',
	'planar_box',
	scope = schema_scope)
# Defined datatype positive_ratio_measure
class positive_ratio_measure(ratio_measure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE time_interval_item
time_interval_item = SELECT(
	'action',
	'time_interval_based_effectivity',
	scope = schema_scope)
# SELECT TYPE character_spacing_select
character_spacing_select = SELECT(
	'length_measure',
	'ratio_measure',
	'measure_with_unit',
	'descriptive_measure',
	scope = schema_scope)
# Defined datatype dose_equivalent_measure
class dose_equivalent_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE requirement_satisfaction_item
requirement_satisfaction_item = SELECT(
	'requirement_assigned_item',
	scope = schema_scope)
# Defined datatype shading_curve_method
class shading_curve_method(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE description_attribute_select
description_attribute_select = SELECT(
	'action_request_solution',
	'application_context',
	'approval_role',
	'configuration_design',
	'date_role',
	'date_time_role',
	'context_dependent_shape_representation',
	'effectivity',
	'external_source',
	'organization_role',
	'person_and_organization_role',
	'person_and_organization',
	'property_definition_representation',
	'representation',
	scope = schema_scope)
# SELECT TYPE mechanical_design_and_draughting_relationship_select
mechanical_design_and_draughting_relationship_select = SELECT(
	'draughting_model',
	'mechanical_design_geometric_presentation_representation',
	'mechanical_design_presentation_representation_with_draughting',
	'mechanical_design_shaded_presentation_representation',
	'shape_representation',
	scope = schema_scope)
# Defined datatype descriptive_measure
class descriptive_measure(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype area_measure
class area_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype text_alignment
class text_alignment(label):
	def __init__(self,*kargs):
		pass

# Defined datatype month_in_year_number
class month_in_year_number(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((1  <=  self)  and  (self  <=  12))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype box_height
class box_height(positive_ratio_measure):
	def __init__(self,*kargs):
		pass

# SELECT TYPE curve_or_render
curve_or_render = SELECT(
	'curve_style',
	'curve_style_rendering',
	scope = schema_scope)
# Defined datatype illuminance_measure
class illuminance_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype source
class source(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE name_attribute_select
name_attribute_select = SELECT(
	'action_request_solution',
	'address',
	'configuration_design',
	'context_dependent_shape_representation',
	'derived_unit',
	'effectivity',
	'person_and_organization',
	'product_definition',
	'product_definition_substitute',
	'property_definition_representation',
	scope = schema_scope)
# SELECT TYPE unit
unit = SELECT(
	'derived_unit',
	'named_unit',
	scope = schema_scope)
# SELECT TYPE characterized_material_property
characterized_material_property = SELECT(
	'material_property_representation',
	'product_material_composition_relationship',
	scope = schema_scope)
# SELECT TYPE date_item
date_item = SELECT(
	'action',
	'action_directive',
	'applied_action_assignment',
	'applied_organization_assignment',
	'applied_person_and_organization_assignment',
	'applied_security_classification_assignment',
	'approval_person_organization',
	'certification',
	'contract',
	'directed_action',
	'document',
	'document_file',
	'event_occurrence',
	'executed_action',
	'information_usage_right',
	'organizational_project',
	'product_definition',
	'product_definition_formation',
	'product_definition_relationship',
	'security_classification',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE reversible_topology
reversible_topology = SELECT(
	'reversible_topology_item',
	'list_of_reversible_topology_item',
	'set_of_reversible_topology_item',
	scope = schema_scope)
# SELECT TYPE work_item
work_item = SELECT(
	'product_definition_formation',
	scope = schema_scope)
point_and_vector_members = LIST(2,3,'point_and_vector_member', scope = schema_scope)
# SELECT TYPE shape_definition
shape_definition = SELECT(
	'product_definition_shape',
	'shape_aspect',
	'shape_aspect_relationship',
	scope = schema_scope)
# Defined datatype celsius_temperature_measure
class celsius_temperature_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype second_in_minute
class second_in_minute(REAL):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <=  60))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE annotation_text_occurrence_item
annotation_text_occurrence_item = SELECT(
	'text_literal',
	'annotation_text',
	'annotation_text_character',
	'composite_text',
	scope = schema_scope)
# Defined datatype label
class label(STRING):
	def __init__(self,*kargs):
		pass

# SELECT TYPE mechanical_design_geometric_presentation_area_items
mechanical_design_geometric_presentation_area_items = SELECT(
	'axis2_placement',
	'mapped_item',
	scope = schema_scope)
# Defined datatype context_dependent_measure
class context_dependent_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE point_and_vector_member
point_and_vector_member = SELECT(
	'point',
	'direction',
	scope = schema_scope)
# SELECT TYPE instance_usage_context_select
instance_usage_context_select = SELECT(
	'product_definition_relationship',
	'product_definition_usage',
	scope = schema_scope)
# SELECT TYPE project_item
project_item = SELECT(
	'executed_action',
	'product_concept',
	scope = schema_scope)
# Defined datatype boolean_operator
class boolean_operator(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype electric_potential_measure
class electric_potential_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE person_and_organization_item
person_and_organization_item = SELECT(
	'action',
	'action_directive',
	'alternate_product_relationship',
	'applied_action_assignment',
	'applied_classification_assignment',
	'applied_identification_assignment',
	'applied_security_classification_assignment',
	'approval',
	'assembly_component_usage_substitute',
	'certification',
	'configuration_item',
	'contract',
	'document_file',
	'executed_action',
	'general_property',
	'information_usage_right',
	'organizational_project',
	'person_and_organization',
	'product',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'property_definition',
	'rule_action',
	'security_classification',
	'shape_representation',
	'versioned_action_request',
	scope = schema_scope)
# SELECT TYPE box_characteristic_select
box_characteristic_select = SELECT(
	'box_height',
	'box_width',
	'box_slant_angle',
	'box_rotate_angle',
	scope = schema_scope)
# Defined datatype si_prefix
class si_prefix(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE certification_item
certification_item = SELECT(
	'alternate_product_relationship',
	'make_from_usage_option',
	'product_definition_formation',
	'product_definition_formation_relationship',
	scope = schema_scope)
# Defined datatype conductance_measure
class conductance_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE action_method_items
action_method_items = SELECT(
	'product',
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE fill_style_select
fill_style_select = SELECT(
	'fill_area_style_colour',
	'externally_defined_tile_style',
	'fill_area_style_tiles',
	'externally_defined_hatch_style',
	'fill_area_style_hatching',
	scope = schema_scope)
# Defined datatype pressure_measure
class pressure_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE draughting_model_item_select
draughting_model_item_select = SELECT(
	'mapped_item',
	'styled_item',
	'axis2_placement',
	'camera_model',
	'draughting_callout',
	scope = schema_scope)
# SELECT TYPE value_qualifier
value_qualifier = SELECT(
	'precision_qualifier',
	'type_qualifier',
	'uncertainty_qualifier',
	scope = schema_scope)
# SELECT TYPE ir_usage_item
ir_usage_item = SELECT(
	'action_directive',
	'certification_item',
	'characterized_object',
	'classification_item',
	'configuration_effectivity',
	'document_reference_item',
	'identification_item',
	'organization',
	'person_and_organization',
	'product_definition',
	'product_definition_formation',
	'product_definition_formation_relationship',
	'product_definition_relationship',
	'requirement_assigned_item',
	scope = schema_scope)
# SELECT TYPE product_definition_or_product_definition_relationship
product_definition_or_product_definition_relationship = SELECT(
	'product_definition',
	'product_definition_usage',
	scope = schema_scope)
# Defined datatype length_measure
class length_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype absorbed_dose_measure
class absorbed_dose_measure(REAL):
	def __init__(self,*kargs):
		pass

# SELECT TYPE approved_item
approved_item = SELECT(
	'certification',
	'change',
	'change_request',
	'configuration_effectivity',
	'configuration_item',
	'contract',
	'product',
	'security_classification',
	'start_request',
	'start_work',
	scope = schema_scope)
# Defined datatype count_measure
class count_measure(NUMBER):
	def __init__(self,*kargs):
		pass

# SELECT TYPE annotation_plane_element
annotation_plane_element = SELECT(
	'draughting_callout',
	'styled_item',
	scope = schema_scope)
# SELECT TYPE identification_item
identification_item = SELECT(
	'approval_status',
	'characterized_class',
	'class_',
	'configuration_item',
	'contract',
	'dimensional_size',
	'document_file',
	'general_property',
	'group',
	'group_relationship',
	'information_right',
	'information_usage_right',
	'material_designation',
	'organization',
	'person_and_organization',
	'product',
	'product_category',
	'product_class',
	'product_concept',
	'product_concept_feature',
	'product_definition',
	'product_definition_formation',
	'product_identification',
	'representation',
	'rule_set',
	'security_classification',
	'security_classification_level',
	'shape_aspect_relationship',
	'shape_representation',
	'usage_association',
	scope = schema_scope)
# SELECT TYPE direction_count_select
direction_count_select = SELECT(
	'u_direction_count',
	'v_direction_count',
	scope = schema_scope)
list_of_reversible_topology_item = LIST(0,None,'reversible_topology_item', scope = schema_scope)
# SELECT TYPE configuration_design_item
configuration_design_item = SELECT(
	'product_definition',
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE class_usage_effectivity_context_item
class_usage_effectivity_context_item = SELECT(
	'product_definition',
	scope = schema_scope)
# SELECT TYPE surface_side_style_select
surface_side_style_select = SELECT(
	'surface_side_style',
	'pre_defined_surface_side_style',
	scope = schema_scope)

####################
 # ENTITY founded_item #
####################
class founded_item(BaseEntityClass):
	'''Entity founded_item definition.

	:param users
	:type users:SET(0,None,'founded_item_select', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def users():
		def fget( self ):
			attribute_eval = using_items(self,[])
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument users is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.users)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not (self  ==  self.users))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY curve_style #
####################
class curve_style(founded_item):
	'''Entity curve_style definition.

	:param name
	:type name:label

	:param curve_font
	:type curve_font:curve_font_or_scaled_curve_font_select

	:param curve_width
	:type curve_width:size_select

	:param curve_colour
	:type curve_colour:colour
	'''
	def __init__( self , name,curve_font,curve_width,curve_colour, ):
		founded_item.__init__(self , )
		self.name = name
		self.curve_font = curve_font
		self.curve_width = curve_width
		self.curve_colour = curve_colour

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def curve_font():
		def fget( self ):
			return self._curve_font
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_font is mantatory and can not be set to None')
			if not check_type(value,curve_font_or_scaled_curve_font_select):
				self._curve_font = curve_font_or_scaled_curve_font_select(value)
			else:
				self._curve_font = value
		return property(**locals())

	@apply
	def curve_width():
		def fget( self ):
			return self._curve_width
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_width is mantatory and can not be set to None')
			if not check_type(value,size_select):
				self._curve_width = size_select(value)
			else:
				self._curve_width = value
		return property(**locals())

	@apply
	def curve_colour():
		def fget( self ):
			return self._curve_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._curve_colour = colour(value)
			else:
				self._curve_colour = value
		return property(**locals())

####################
 # ENTITY externally_defined_item #
####################
class externally_defined_item(BaseEntityClass):
	'''Entity externally_defined_item definition.

	:param item_id
	:type item_id:source_item

	:param source
	:type source:external_source
	'''
	def __init__( self , item_id,source, ):
		self.item_id = item_id
		self.source = source

	@apply
	def item_id():
		def fget( self ):
			return self._item_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_id is mantatory and can not be set to None')
			if not check_type(value,source_item):
				self._item_id = source_item(value)
			else:
				self._item_id = value
		return property(**locals())

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source is mantatory and can not be set to None')
			if not check_type(value,external_source):
				self._source = external_source(value)
			else:
				self._source = value
		return property(**locals())

####################
 # ENTITY externally_defined_tile #
####################
class externally_defined_tile(externally_defined_item):
	'''Entity externally_defined_tile definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )

####################
 # ENTITY document_usage_constraint_assignment #
####################
class document_usage_constraint_assignment(BaseEntityClass):
	'''Entity document_usage_constraint_assignment definition.

	:param assigned_document_usage
	:type assigned_document_usage:document_usage_constraint

	:param role
	:type role:document_usage_role
	'''
	def __init__( self , assigned_document_usage,role, ):
		self.assigned_document_usage = assigned_document_usage
		self.role = role

	@apply
	def assigned_document_usage():
		def fget( self ):
			return self._assigned_document_usage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_document_usage is mantatory and can not be set to None')
			if not check_type(value,document_usage_constraint):
				self._assigned_document_usage = document_usage_constraint(value)
			else:
				self._assigned_document_usage = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,document_usage_role):
				self._role = document_usage_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_document_usage_constraint_assignment #
####################
class applied_document_usage_constraint_assignment(document_usage_constraint_assignment):
	'''Entity applied_document_usage_constraint_assignment definition.

	:param items
	:type items:SET(1,None,'document_reference_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_document_usage , inherited1__role , items, ):
		document_usage_constraint_assignment.__init__(self , inherited0__assigned_document_usage , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'document_reference_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY characterized_object #
####################
class characterized_object(BaseEntityClass):
	'''Entity characterized_object definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY partial_document_with_structured_text_representation_assignment #
####################
class partial_document_with_structured_text_representation_assignment(applied_document_usage_constraint_assignment,characterized_object):
	'''Entity partial_document_with_structured_text_representation_assignment definition.
	'''
	def __init__( self , inherited0__assigned_document_usage , inherited1__role , inherited2__items , inherited3__name , inherited4__description ,  ):
		applied_document_usage_constraint_assignment.__init__(self , inherited0__assigned_document_usage , inherited1__role , inherited2__items , )
		characterized_object.__init__(self , inherited3__name , inherited4__description , )

####################
 # ENTITY generic_expression #
####################
class generic_expression(BaseEntityClass):
	'''Entity generic_expression definition.
	'''
	# This class does not define any attribute.
	pass
	def wr1(self):
		eval_wr1_wr = is_acyclic(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY expression #
####################
class expression(generic_expression):
	'''Entity expression definition.
	'''
	def __init__( self ,  ):
		generic_expression.__init__(self , )

####################
 # ENTITY numeric_expression #
####################
class numeric_expression(expression):
	'''Entity numeric_expression definition.

	:param is_int
	:type is_int:LOGICAL

	:param sql_mappable
	:type sql_mappable:LOGICAL
	'''
	def __init__( self ,  ):
		expression.__init__(self , )

	@apply
	def is_int():
		def fget( self ):
			attribute_eval = is_int_expr(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument is_int is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def sql_mappable():
		def fget( self ):
			attribute_eval = is_sql_mappable(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument sql_mappable is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY simple_generic_expression #
####################
class simple_generic_expression(generic_expression):
	'''Entity simple_generic_expression definition.
	'''
	def __init__( self ,  ):
		generic_expression.__init__(self , )

####################
 # ENTITY simple_numeric_expression #
####################
class simple_numeric_expression(numeric_expression,simple_generic_expression):
	'''Entity simple_numeric_expression definition.
	'''
	def __init__( self ,  ):
		numeric_expression.__init__(self , )
		simple_generic_expression.__init__(self , )

####################
 # ENTITY generic_literal #
####################
class generic_literal(simple_generic_expression):
	'''Entity generic_literal definition.
	'''
	def __init__( self ,  ):
		simple_generic_expression.__init__(self , )

####################
 # ENTITY literal_number #
####################
class literal_number(simple_numeric_expression,generic_literal):
	'''Entity literal_number definition.

	:param the_value
	:type the_value:(null)
	'''
	def __init__( self , the_value, ):
		simple_numeric_expression.__init__(self , )
		generic_literal.__init__(self , )
		self.the_value = the_value

	@apply
	def the_value():
		def fget( self ):
			return self._the_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument the_value is mantatory and can not be set to None')
			if not check_type(value,(null)):
				self._the_value = (null)(value)
			else:
				self._the_value = value
		return property(**locals())

####################
 # ENTITY real_literal #
####################
class real_literal(literal_number):
	'''Entity real_literal definition.

	:param literal_number_the_value
	:type literal_number_the_value:REAL
	'''
	def __init__( self , inherited0__the_value , literal_number_the_value, ):
		literal_number.__init__(self , inherited0__the_value , )
		self.literal_number_the_value = literal_number_the_value

	@apply
	def literal_number_the_value():
		def fget( self ):
			return self._literal_number_the_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument literal_number_the_value is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._literal_number_the_value = REAL(value)
			else:
				self._literal_number_the_value = value
		return property(**locals())

####################
 # ENTITY representation_item #
####################
class representation_item(BaseEntityClass):
	'''Entity representation_item definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(using_representations(self))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY styled_item #
####################
class styled_item(representation_item):
	'''Entity styled_item definition.

	:param styles
	:type styles:SET(1,None,'presentation_style_assignment', scope = schema_scope)

	:param item
	:type item:representation_item
	'''
	def __init__( self , inherited0__name , styles,item, ):
		representation_item.__init__(self , inherited0__name , )
		self.styles = styles
		self.item = item

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'presentation_style_assignment', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())

	@apply
	def item():
		def fget( self ):
			return self._item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._item = representation_item(value)
			else:
				self._item = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.self.styles)  ==  1) XOR (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY annotation_occurrence #
####################
class annotation_occurrence(styled_item):
	'''Entity annotation_occurrence definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item ,  ):
		styled_item.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM'  ==  TYPEOF(self))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY annotation_fill_area_occurrence #
####################
class annotation_fill_area_occurrence(annotation_occurrence):
	'''Entity annotation_fill_area_occurrence definition.

	:param fill_style_target
	:type fill_style_target:point

	:param styled_item_item
	:type styled_item_item:annotation_fill_area
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , fill_style_target,styled_item_item, ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		self.fill_style_target = fill_style_target
		self.styled_item_item = styled_item_item

	@apply
	def fill_style_target():
		def fget( self ):
			return self._fill_style_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fill_style_target is mantatory and can not be set to None')
			if not check_type(value,point):
				self._fill_style_target = point(value)
			else:
				self._fill_style_target = value
		return property(**locals())

	@apply
	def styled_item_item():
		def fget( self ):
			return self._styled_item_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_item_item is mantatory and can not be set to None')
			if not check_type(value,annotation_fill_area):
				self._styled_item_item = annotation_fill_area(value)
			else:
				self._styled_item_item = value
		return property(**locals())

####################
 # ENTITY action_assignment #
####################
class action_assignment(BaseEntityClass):
	'''Entity action_assignment definition.

	:param assigned_action
	:type assigned_action:action

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_action, ):
		self.assigned_action = assigned_action

	@apply
	def assigned_action():
		def fget( self ):
			return self._assigned_action
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_action is mantatory and can not be set to None')
			if not check_type(value,action):
				self._assigned_action = action(value)
			else:
				self._assigned_action = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_action_assignment #
####################
class applied_action_assignment(action_assignment):
	'''Entity applied_action_assignment definition.

	:param items
	:type items:SET(1,None,'action_items', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action , items, ):
		action_assignment.__init__(self , inherited0__assigned_action , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'action_items', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY applied_usage_right #
####################
class applied_usage_right(applied_action_assignment):
	'''Entity applied_usage_right definition.

	:param applied_action_assignment_items
	:type applied_action_assignment_items:SET(1,None,'ir_usage_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action , inherited1__items , applied_action_assignment_items, ):
		applied_action_assignment.__init__(self , inherited0__assigned_action , inherited1__items , )
		self.applied_action_assignment_items = applied_action_assignment_items

	@apply
	def applied_action_assignment_items():
		def fget( self ):
			return self._applied_action_assignment_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applied_action_assignment_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'ir_usage_item', scope = schema_scope)):
				self._applied_action_assignment_items = SET(value)
			else:
				self._applied_action_assignment_items = value
		return property(**locals())

####################
 # ENTITY material_designation #
####################
class material_designation(BaseEntityClass):
	'''Entity material_designation definition.

	:param name
	:type name:label

	:param definitions
	:type definitions:SET(1,None,'characterized_definition', scope = schema_scope)
	'''
	def __init__( self , name,definitions, ):
		self.name = name
		self.definitions = definitions

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def definitions():
		def fget( self ):
			return self._definitions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definitions is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'characterized_definition', scope = schema_scope)):
				self._definitions = SET(value)
			else:
				self._definitions = value
		return property(**locals())

####################
 # ENTITY composite_material_designation #
####################
class composite_material_designation(material_designation):
	'''Entity composite_material_designation definition.
	'''
	def __init__( self , inherited0__name , inherited1__definitions ,  ):
		material_designation.__init__(self , inherited0__name , inherited1__definitions , )

####################
 # ENTITY representation_item_relationship #
####################
class representation_item_relationship(BaseEntityClass):
	'''Entity representation_item_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_representation_item
	:type relating_representation_item:representation_item

	:param related_representation_item
	:type related_representation_item:representation_item
	'''
	def __init__( self , name,description,relating_representation_item,related_representation_item, ):
		self.name = name
		self.description = description
		self.relating_representation_item = relating_representation_item
		self.related_representation_item = related_representation_item

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_representation_item():
		def fget( self ):
			return self._relating_representation_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_representation_item is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._relating_representation_item = representation_item(value)
			else:
				self._relating_representation_item = value
		return property(**locals())

	@apply
	def related_representation_item():
		def fget( self ):
			return self._related_representation_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_representation_item is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._related_representation_item = representation_item(value)
			else:
				self._related_representation_item = value
		return property(**locals())

####################
 # ENTITY explicit_procedural_representation_item_relationship #
####################
class explicit_procedural_representation_item_relationship(representation_item_relationship):
	'''Entity explicit_procedural_representation_item_relationship definition.

	:param representation_item_relationship_relating_representation_item
	:type representation_item_relationship_relating_representation_item:procedural_representation_sequence
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_representation_item , inherited3__related_representation_item , representation_item_relationship_relating_representation_item, ):
		representation_item_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_representation_item , inherited3__related_representation_item , )
		self.representation_item_relationship_relating_representation_item = representation_item_relationship_relating_representation_item

	@apply
	def representation_item_relationship_relating_representation_item():
		def fget( self ):
			return self._representation_item_relationship_relating_representation_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_item_relationship_relating_representation_item is mantatory and can not be set to None')
			if not check_type(value,procedural_representation_sequence):
				self._representation_item_relationship_relating_representation_item = procedural_representation_sequence(value)
			else:
				self._representation_item_relationship_relating_representation_item = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PROCEDURAL_REPRESENTATION_SEQUENCE'  ==  TYPEOF(self.self.representation_item_relationship.self.related_representation_item)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY explicit_procedural_geometric_representation_item_relationship #
####################
class explicit_procedural_geometric_representation_item_relationship(explicit_procedural_representation_item_relationship):
	'''Entity explicit_procedural_geometric_representation_item_relationship definition.

	:param representation_item_relationship_related_representation_item
	:type representation_item_relationship_related_representation_item:geometric_representation_item

	:param representation_item_relationship_relating_representation_item
	:type representation_item_relationship_relating_representation_item:procedural_shape_representation_sequence
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_representation_item , inherited3__related_representation_item , inherited4__representation_item_relationship_relating_representation_item , representation_item_relationship_related_representation_item,representation_item_relationship_relating_representation_item, ):
		explicit_procedural_representation_item_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_representation_item , inherited3__related_representation_item , inherited4__representation_item_relationship_relating_representation_item , )
		self.representation_item_relationship_related_representation_item = representation_item_relationship_related_representation_item
		self.representation_item_relationship_relating_representation_item = representation_item_relationship_relating_representation_item

	@apply
	def representation_item_relationship_related_representation_item():
		def fget( self ):
			return self._representation_item_relationship_related_representation_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_item_relationship_related_representation_item is mantatory and can not be set to None')
			if not check_type(value,geometric_representation_item):
				self._representation_item_relationship_related_representation_item = geometric_representation_item(value)
			else:
				self._representation_item_relationship_related_representation_item = value
		return property(**locals())

	@apply
	def representation_item_relationship_relating_representation_item():
		def fget( self ):
			return self._representation_item_relationship_relating_representation_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_item_relationship_relating_representation_item is mantatory and can not be set to None')
			if not check_type(value,procedural_shape_representation_sequence):
				self._representation_item_relationship_relating_representation_item = procedural_shape_representation_sequence(value)
			else:
				self._representation_item_relationship_relating_representation_item = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PROCEDURAL_SHAPE_REPRESENTATION_SEQUENCE'  ==  TYPEOF(self.self.representation_item_relationship.self.related_representation_item)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY identification_role #
####################
class identification_role(BaseEntityClass):
	'''Entity identification_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY certification_assignment #
####################
class certification_assignment(BaseEntityClass):
	'''Entity certification_assignment definition.

	:param assigned_certification
	:type assigned_certification:certification

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_certification, ):
		self.assigned_certification = assigned_certification

	@apply
	def assigned_certification():
		def fget( self ):
			return self._assigned_certification
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_certification is mantatory and can not be set to None')
			if not check_type(value,certification):
				self._assigned_certification = certification(value)
			else:
				self._assigned_certification = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_certification_assignment #
####################
class applied_certification_assignment(certification_assignment):
	'''Entity applied_certification_assignment definition.

	:param items
	:type items:SET(1,None,'certification_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_certification , items, ):
		certification_assignment.__init__(self , inherited0__assigned_certification , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'certification_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY geometric_representation_item #
####################
class geometric_representation_item(representation_item):
	'''Entity geometric_representation_item definition.

	:param dim
	:type dim:dimension_count
	'''
	def __init__( self , inherited0__name ,  ):
		representation_item.__init__(self , inherited0__name , )

	@apply
	def dim():
		def fget( self ):
			attribute_eval = dimension_of(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY functionally_defined_transformation #
####################
class functionally_defined_transformation(BaseEntityClass):
	'''Entity functionally_defined_transformation definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY cartesian_transformation_operator #
####################
class cartesian_transformation_operator(geometric_representation_item,functionally_defined_transformation):
	'''Entity cartesian_transformation_operator definition.

	:param axis1
	:type axis1:direction

	:param axis2
	:type axis2:direction

	:param local_origin
	:type local_origin:cartesian_point

	:param scale
	:type scale:REAL

	:param scl
	:type scl:REAL
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__description , axis1,axis2,local_origin,scale, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		functionally_defined_transformation.__init__(self , inherited1__name , inherited2__description , )
		self.axis1 = axis1
		self.axis2 = axis2
		self.local_origin = local_origin
		self.scale = scale

	@apply
	def axis1():
		def fget( self ):
			return self._axis1
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._axis1 = direction(value)
				else:
					self._axis1 = value
			else:
				self._axis1 = value
		return property(**locals())

	@apply
	def axis2():
		def fget( self ):
			return self._axis2
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._axis2 = direction(value)
				else:
					self._axis2 = value
			else:
				self._axis2 = value
		return property(**locals())

	@apply
	def local_origin():
		def fget( self ):
			return self._local_origin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument local_origin is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._local_origin = cartesian_point(value)
			else:
				self._local_origin = value
		return property(**locals())

	@apply
	def scale():
		def fget( self ):
			return self._scale
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,REAL):
					self._scale = REAL(value)
				else:
					self._scale = value
			else:
				self._scale = value
		return property(**locals())

	@apply
	def scl():
		def fget( self ):
			attribute_eval = NVL(self.scale,1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scl is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.scl  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY cartesian_transformation_operator_3d #
####################
class cartesian_transformation_operator_3d(cartesian_transformation_operator):
	'''Entity cartesian_transformation_operator_3d definition.

	:param axis3
	:type axis3:direction

	:param u
	:type u:LIST(3,3,'direction', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__description , inherited3__axis1 , inherited4__axis2 , inherited5__local_origin , inherited6__scale , axis3, ):
		cartesian_transformation_operator.__init__(self , inherited0__name , inherited1__name , inherited2__description , inherited3__axis1 , inherited4__axis2 , inherited5__local_origin , inherited6__scale , )
		self.axis3 = axis3

	@apply
	def axis3():
		def fget( self ):
			return self._axis3
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._axis3 = direction(value)
				else:
					self._axis3 = value
			else:
				self._axis3 = value
		return property(**locals())

	@apply
	def u():
		def fget( self ):
			attribute_eval = base_axis(3,self.self.cartesian_transformation_operator.self.axis1,self.self.cartesian_transformation_operator.self.axis2,self.axis3)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument u is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY solid_model #
####################
class solid_model(geometric_representation_item):
	'''Entity solid_model definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY modified_solid #
####################
class modified_solid(solid_model):
	'''Entity modified_solid definition.

	:param rationale
	:type rationale:text

	:param base_solid
	:type base_solid:base_solid_select
	'''
	def __init__( self , inherited0__name , rationale,base_solid, ):
		solid_model.__init__(self , inherited0__name , )
		self.rationale = rationale
		self.base_solid = base_solid

	@apply
	def rationale():
		def fget( self ):
			return self._rationale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rationale is mantatory and can not be set to None')
			if not check_type(value,text):
				self._rationale = text(value)
			else:
				self._rationale = value
		return property(**locals())

	@apply
	def base_solid():
		def fget( self ):
			return self._base_solid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base_solid is mantatory and can not be set to None')
			if not check_type(value,base_solid_select):
				self._base_solid = base_solid_select(value)
			else:
				self._base_solid = value
		return property(**locals())

####################
 # ENTITY modified_solid_with_placed_configuration #
####################
class modified_solid_with_placed_configuration(modified_solid):
	'''Entity modified_solid_with_placed_configuration definition.

	:param placing
	:type placing:axis2_placement_3d
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , placing, ):
		modified_solid.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , )
		self.placing = placing

	@apply
	def placing():
		def fget( self ):
			return self._placing
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placing is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._placing = axis2_placement_3d(value)
			else:
				self._placing = value
		return property(**locals())

####################
 # ENTITY solid_with_protrusion #
####################
class solid_with_protrusion(modified_solid_with_placed_configuration):
	'''Entity solid_with_protrusion definition.

	:param protrusion_height
	:type protrusion_height:positive_length_measure

	:param protrusion_draft_angle
	:type protrusion_draft_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , protrusion_height,protrusion_draft_angle, ):
		modified_solid_with_placed_configuration.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , )
		self.protrusion_height = protrusion_height
		self.protrusion_draft_angle = protrusion_draft_angle

	@apply
	def protrusion_height():
		def fget( self ):
			return self._protrusion_height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument protrusion_height is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._protrusion_height = positive_length_measure(value)
			else:
				self._protrusion_height = value
		return property(**locals())

	@apply
	def protrusion_draft_angle():
		def fget( self ):
			return self._protrusion_draft_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument protrusion_draft_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._protrusion_draft_angle = plane_angle_measure(value)
			else:
				self._protrusion_draft_angle = value
		return property(**locals())

####################
 # ENTITY solid_with_circular_protrusion #
####################
class solid_with_circular_protrusion(solid_with_protrusion):
	'''Entity solid_with_circular_protrusion definition.

	:param protrusion_radius
	:type protrusion_radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__protrusion_height , inherited5__protrusion_draft_angle , protrusion_radius, ):
		solid_with_protrusion.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__protrusion_height , inherited5__protrusion_draft_angle , )
		self.protrusion_radius = protrusion_radius

	@apply
	def protrusion_radius():
		def fget( self ):
			return self._protrusion_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument protrusion_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._protrusion_radius = positive_length_measure(value)
			else:
				self._protrusion_radius = value
		return property(**locals())

####################
 # ENTITY versioned_action_request #
####################
class versioned_action_request(BaseEntityClass):
	'''Entity versioned_action_request definition.

	:param id
	:type id:identifier

	:param version
	:type version:label

	:param purpose
	:type purpose:text

	:param description
	:type description:text
	'''
	def __init__( self , id,version,purpose,description, ):
		self.id = id
		self.version = version
		self.purpose = purpose
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def version():
		def fget( self ):
			return self._version
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument version is mantatory and can not be set to None')
			if not check_type(value,label):
				self._version = label(value)
			else:
				self._version = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument purpose is mantatory and can not be set to None')
			if not check_type(value,text):
				self._purpose = text(value)
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY derived_unit #
####################
class derived_unit(BaseEntityClass):
	'''Entity derived_unit definition.

	:param elements
	:type elements:SET(1,None,'derived_unit_element', scope = schema_scope)

	:param name
	:type name:label
	'''
	def __init__( self , elements, ):
		self.elements = elements

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument elements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'derived_unit_element', scope = schema_scope)):
				self._elements = SET(value)
			else:
				self._elements = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.elements)  >  1)  or  ((SIZEOF(self.elements)  ==  1)  and  (self.elements[1].self.exponent  !=  1)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY magnetic_flux_density_unit #
####################
class magnetic_flux_density_unit(derived_unit):
	'''Entity magnetic_flux_density_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.tesla))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY named_unit #
####################
class named_unit(BaseEntityClass):
	'''Entity named_unit definition.

	:param dimensions
	:type dimensions:dimensional_exponents
	'''
	def __init__( self , dimensions, ):
		self.dimensions = dimensions

	@apply
	def dimensions():
		def fget( self ):
			return self._dimensions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dimensions is mantatory and can not be set to None')
			if not check_type(value,dimensional_exponents):
				self._dimensions = dimensional_exponents(value)
			else:
				self._dimensions = value
		return property(**locals())

####################
 # ENTITY si_unit #
####################
class si_unit(named_unit):
	'''Entity si_unit definition.

	:param prefix
	:type prefix:si_prefix

	:param name
	:type name:si_unit_name

	:param named_unit_dimensions
	:type named_unit_dimensions:dimensional_exponents
	'''
	def __init__( self , inherited0__dimensions , prefix,name, ):
		named_unit.__init__(self , inherited0__dimensions , )
		self.prefix = prefix
		self.name = name

	@apply
	def prefix():
		def fget( self ):
			return self._prefix
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,si_prefix):
					self._prefix = si_prefix(value)
				else:
					self._prefix = value
			else:
				self._prefix = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,si_unit_name):
				self._name = si_unit_name(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def named_unit_dimensions():
		def fget( self ):
			attribute_eval = dimensions_for_si_unit(self.name)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument named_unit_dimensions is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MASS_UNIT'  ==  TYPEOF(self))  and  (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DERIVED_UNIT_ELEMENT.UNIT'))  >  0)))  or  (self.prefix  ==  si_prefix.self.kilo))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_magnetic_flux_density_unit #
####################
class si_magnetic_flux_density_unit(magnetic_flux_density_unit,si_unit):
	'''Entity si_magnetic_flux_density_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		magnetic_flux_density_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.tesla)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY solid_with_shape_element_pattern #
####################
class solid_with_shape_element_pattern(modified_solid_with_placed_configuration):
	'''Entity solid_with_shape_element_pattern definition.

	:param replicated_element
	:type replicated_element:modified_solid_with_placed_configuration
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , replicated_element, ):
		modified_solid_with_placed_configuration.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , )
		self.replicated_element = replicated_element

	@apply
	def replicated_element():
		def fget( self ):
			return self._replicated_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument replicated_element is mantatory and can not be set to None')
			if not check_type(value,modified_solid_with_placed_configuration):
				self._replicated_element = modified_solid_with_placed_configuration(value)
			else:
				self._replicated_element = value
		return property(**locals())

####################
 # ENTITY solid_with_circular_pattern #
####################
class solid_with_circular_pattern(solid_with_shape_element_pattern):
	'''Entity solid_with_circular_pattern definition.

	:param replicate_count
	:type replicate_count:positive_integer

	:param angular_spacing
	:type angular_spacing:plane_angle_measure

	:param radial_alignment
	:type radial_alignment:BOOLEAN

	:param reference_point
	:type reference_point:point
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__replicated_element , replicate_count,angular_spacing,radial_alignment,reference_point, ):
		solid_with_shape_element_pattern.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__replicated_element , )
		self.replicate_count = replicate_count
		self.angular_spacing = angular_spacing
		self.radial_alignment = radial_alignment
		self.reference_point = reference_point

	@apply
	def replicate_count():
		def fget( self ):
			return self._replicate_count
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument replicate_count is mantatory and can not be set to None')
			if not check_type(value,positive_integer):
				self._replicate_count = positive_integer(value)
			else:
				self._replicate_count = value
		return property(**locals())

	@apply
	def angular_spacing():
		def fget( self ):
			return self._angular_spacing
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angular_spacing is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._angular_spacing = plane_angle_measure(value)
			else:
				self._angular_spacing = value
		return property(**locals())

	@apply
	def radial_alignment():
		def fget( self ):
			return self._radial_alignment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radial_alignment is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._radial_alignment = BOOLEAN(value)
			else:
				self._radial_alignment = value
		return property(**locals())

	@apply
	def reference_point():
		def fget( self ):
			return self._reference_point
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reference_point is mantatory and can not be set to None')
			if not check_type(value,point):
				self._reference_point = point(value)
			else:
				self._reference_point = value
		return property(**locals())

####################
 # ENTITY solid_with_incomplete_circular_pattern #
####################
class solid_with_incomplete_circular_pattern(solid_with_circular_pattern):
	'''Entity solid_with_incomplete_circular_pattern definition.

	:param omitted_instances
	:type omitted_instances:SET(1,None,'INTEGER', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__replicated_element , inherited5__replicate_count , inherited6__angular_spacing , inherited7__radial_alignment , inherited8__reference_point , omitted_instances, ):
		solid_with_circular_pattern.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__replicated_element , inherited5__replicate_count , inherited6__angular_spacing , inherited7__radial_alignment , inherited8__reference_point , )
		self.omitted_instances = omitted_instances

	@apply
	def omitted_instances():
		def fget( self ):
			return self._omitted_instances
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument omitted_instances is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'INTEGER', scope = schema_scope)):
				self._omitted_instances = SET(value)
			else:
				self._omitted_instances = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.omitted_instances)  <  self.self.solid_with_circular_pattern.self.replicate_count)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY geometric_tolerance #
####################
class geometric_tolerance(BaseEntityClass):
	'''Entity geometric_tolerance definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param magnitude
	:type magnitude:measure_with_unit

	:param toleranced_shape_aspect
	:type toleranced_shape_aspect:shape_aspect
	'''
	def __init__( self , name,description,magnitude,toleranced_shape_aspect, ):
		self.name = name
		self.description = description
		self.magnitude = magnitude
		self.toleranced_shape_aspect = toleranced_shape_aspect

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def magnitude():
		def fget( self ):
			return self._magnitude
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument magnitude is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._magnitude = measure_with_unit(value)
			else:
				self._magnitude = value
		return property(**locals())

	@apply
	def toleranced_shape_aspect():
		def fget( self ):
			return self._toleranced_shape_aspect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument toleranced_shape_aspect is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._toleranced_shape_aspect = shape_aspect(value)
			else:
				self._toleranced_shape_aspect = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('NUMBER'  ==  TYPEOF(self.magnitude.self.measure_with_unit.self.value_component))  and  (self.magnitude.self.measure_with_unit.self.value_component  >=  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY cylindricity_tolerance #
####################
class cylindricity_tolerance(geometric_tolerance):
	'''Entity cylindricity_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY representation #
####################
class representation(BaseEntityClass):
	'''Entity representation definition.

	:param name
	:type name:label

	:param items
	:type items:SET(1,None,'representation_item', scope = schema_scope)

	:param context_of_items
	:type context_of_items:representation_context

	:param description
	:type description:text

	:param id
	:type id:identifier
	'''
	def __init__( self , name,items,context_of_items, ):
		self.name = name
		self.items = items
		self.context_of_items = context_of_items

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'representation_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def context_of_items():
		def fget( self ):
			return self._context_of_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument context_of_items is mantatory and can not be set to None')
			if not check_type(value,representation_context):
				self._context_of_items = representation_context(value)
			else:
				self._context_of_items = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY shape_representation #
####################
class shape_representation(representation):
	'''Entity shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )

####################
 # ENTITY manifold_surface_shape_representation #
####################
class manifold_surface_shape_representation(shape_representation):
	'''Entity manifold_surface_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(None)  ==  0)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = (SIZEOF(None)  ==  0)
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr


####################
 # ENTITY certification #
####################
class certification(BaseEntityClass):
	'''Entity certification definition.

	:param name
	:type name:label

	:param purpose
	:type purpose:text

	:param kind
	:type kind:certification_type
	'''
	def __init__( self , name,purpose,kind, ):
		self.name = name
		self.purpose = purpose
		self.kind = kind

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument purpose is mantatory and can not be set to None')
			if not check_type(value,text):
				self._purpose = text(value)
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def kind():
		def fget( self ):
			return self._kind
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument kind is mantatory and can not be set to None')
			if not check_type(value,certification_type):
				self._kind = certification_type(value)
			else:
				self._kind = value
		return property(**locals())

####################
 # ENTITY mechanical_design_geometric_presentation_representation #
####################
class mechanical_design_geometric_presentation_representation(representation):
	'''Entity mechanical_design_geometric_presentation_representation definition.

	:param representation_items
	:type representation_items:SET(1,None,'mechanical_design_geometric_presentation_representation_items', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_items = representation_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'mechanical_design_geometric_presentation_representation_items', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(None)  ==  0)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr


####################
 # ENTITY camera_model #
####################
class camera_model(geometric_representation_item):
	'''Entity camera_model definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(USEDIN(self,('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ITEM_DEFINED_TRANSFORMATION.')  +  'TRANSFORM_ITEM_1'))  +  SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'REPRESENTATION_MAP.MAPPING_ORIGIN')))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'STYLED_ITEM.ITEM'))  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY general_property #
####################
class general_property(BaseEntityClass):
	'''Entity general_property definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY characteristic_data_table_header #
####################
class characteristic_data_table_header(general_property):
	'''Entity characteristic_data_table_header definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description ,  ):
		general_property.__init__(self , inherited0__id , inherited1__name , inherited2__description , )

####################
 # ENTITY representation_relationship #
####################
class representation_relationship(BaseEntityClass):
	'''Entity representation_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param rep_1
	:type rep_1:representation

	:param rep_2
	:type rep_2:representation
	'''
	def __init__( self , name,description,rep_1,rep_2, ):
		self.name = name
		self.description = description
		self.rep_1 = rep_1
		self.rep_2 = rep_2

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def rep_1():
		def fget( self ):
			return self._rep_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rep_1 is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._rep_1 = representation(value)
			else:
				self._rep_1 = value
		return property(**locals())

	@apply
	def rep_2():
		def fget( self ):
			return self._rep_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rep_2 is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._rep_2 = representation(value)
			else:
				self._rep_2 = value
		return property(**locals())

####################
 # ENTITY evaluated_characteristic #
####################
class evaluated_characteristic(representation,representation_relationship):
	'''Entity evaluated_characteristic definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__name , inherited4__description , inherited5__rep_1 , inherited6__rep_2 ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		representation_relationship.__init__(self , inherited3__name , inherited4__description , inherited5__rep_1 , inherited6__rep_2 , )
	def wr1(self):
		eval_wr1_wr = (self.self.representation_relationship.self.rep_1  !=  self.self.representation_relationship.self.rep_2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition_relationship #
####################
class product_definition_relationship(BaseEntityClass):
	'''Entity product_definition_relationship definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_product_definition
	:type relating_product_definition:product_definition

	:param related_product_definition
	:type related_product_definition:product_definition
	'''
	def __init__( self , id,name,description,relating_product_definition,related_product_definition, ):
		self.id = id
		self.name = name
		self.description = description
		self.relating_product_definition = relating_product_definition
		self.related_product_definition = related_product_definition

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_product_definition():
		def fget( self ):
			return self._relating_product_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_product_definition is mantatory and can not be set to None')
			if not check_type(value,product_definition):
				self._relating_product_definition = product_definition(value)
			else:
				self._relating_product_definition = value
		return property(**locals())

	@apply
	def related_product_definition():
		def fget( self ):
			return self._related_product_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_product_definition is mantatory and can not be set to None')
			if not check_type(value,product_definition):
				self._related_product_definition = product_definition(value)
			else:
				self._related_product_definition = value
		return property(**locals())

####################
 # ENTITY product_definition_usage #
####################
class product_definition_usage(product_definition_relationship):
	'''Entity product_definition_usage definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )
	def wr1(self):
		eval_wr1_wr = acyclic_product_definition_relationship(self,[self.self.product_definition_relationship.self.related_product_definition],'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRODUCT_DEFINITION_USAGE')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY assembly_component_usage #
####################
class assembly_component_usage(product_definition_usage):
	'''Entity assembly_component_usage definition.

	:param reference_designator
	:type reference_designator:identifier
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , reference_designator, ):
		product_definition_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )
		self.reference_designator = reference_designator

	@apply
	def reference_designator():
		def fget( self ):
			return self._reference_designator
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,identifier):
					self._reference_designator = identifier(value)
				else:
					self._reference_designator = value
			else:
				self._reference_designator = value
		return property(**locals())

####################
 # ENTITY quantified_assembly_component_usage #
####################
class quantified_assembly_component_usage(assembly_component_usage):
	'''Entity quantified_assembly_component_usage definition.

	:param quantity
	:type quantity:measure_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , quantity, ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )
		self.quantity = quantity

	@apply
	def quantity():
		def fget( self ):
			return self._quantity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument quantity is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._quantity = measure_with_unit(value)
			else:
				self._quantity = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not ('NUMBER'  ==  TYPEOF(self.quantity.self.value_component)))  or  (self.quantity.self.value_component  >  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY draughting_model #
####################
class draughting_model(representation):
	'''Entity draughting_model definition.

	:param representation_items
	:type representation_items:SET(1,None,'draughting_model_item_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_items = representation_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'draughting_model_item_select', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY externally_defined_hatch_style #
####################
class externally_defined_hatch_style(externally_defined_item,geometric_representation_item):
	'''Entity externally_defined_hatch_style definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source , inherited2__name ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )
		geometric_representation_item.__init__(self , inherited2__name , )

####################
 # ENTITY manifold_solid_brep #
####################
class manifold_solid_brep(solid_model):
	'''Entity manifold_solid_brep definition.

	:param outer
	:type outer:closed_shell
	'''
	def __init__( self , inherited0__name , outer, ):
		solid_model.__init__(self , inherited0__name , )
		self.outer = outer

	@apply
	def outer():
		def fget( self ):
			return self._outer
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outer is mantatory and can not be set to None')
			if not check_type(value,closed_shell):
				self._outer = closed_shell(value)
			else:
				self._outer = value
		return property(**locals())

####################
 # ENTITY faceted_brep #
####################
class faceted_brep(manifold_solid_brep):
	'''Entity faceted_brep definition.
	'''
	def __init__( self , inherited0__name , inherited1__outer ,  ):
		manifold_solid_brep.__init__(self , inherited0__name , inherited1__outer , )

####################
 # ENTITY time_interval #
####################
class time_interval(BaseEntityClass):
	'''Entity time_interval definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY time_interval_with_bounds #
####################
class time_interval_with_bounds(time_interval):
	'''Entity time_interval_with_bounds definition.

	:param primary_bound
	:type primary_bound:date_time_or_event_occurrence

	:param secondary_bound
	:type secondary_bound:date_time_or_event_occurrence

	:param duration
	:type duration:time_measure_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , primary_bound,secondary_bound,duration, ):
		time_interval.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
		self.primary_bound = primary_bound
		self.secondary_bound = secondary_bound
		self.duration = duration

	@apply
	def primary_bound():
		def fget( self ):
			return self._primary_bound
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,date_time_or_event_occurrence):
					self._primary_bound = date_time_or_event_occurrence(value)
				else:
					self._primary_bound = value
			else:
				self._primary_bound = value
		return property(**locals())

	@apply
	def secondary_bound():
		def fget( self ):
			return self._secondary_bound
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,date_time_or_event_occurrence):
					self._secondary_bound = date_time_or_event_occurrence(value)
				else:
					self._secondary_bound = value
			else:
				self._secondary_bound = value
		return property(**locals())

	@apply
	def duration():
		def fget( self ):
			return self._duration
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,time_measure_with_unit):
					self._duration = time_measure_with_unit(value)
				else:
					self._duration = value
			else:
				self._duration = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not (EXISTS(self.secondary_bound)  and  EXISTS(self.duration)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (EXISTS(self.primary_bound)  or  EXISTS(self.secondary_bound))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY action_directive #
####################
class action_directive(BaseEntityClass):
	'''Entity action_directive definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param analysis
	:type analysis:text

	:param comment
	:type comment:text

	:param requests
	:type requests:SET(1,None,'versioned_action_request', scope = schema_scope)
	'''
	def __init__( self , name,description,analysis,comment,requests, ):
		self.name = name
		self.description = description
		self.analysis = analysis
		self.comment = comment
		self.requests = requests

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def analysis():
		def fget( self ):
			return self._analysis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument analysis is mantatory and can not be set to None')
			if not check_type(value,text):
				self._analysis = text(value)
			else:
				self._analysis = value
		return property(**locals())

	@apply
	def comment():
		def fget( self ):
			return self._comment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument comment is mantatory and can not be set to None')
			if not check_type(value,text):
				self._comment = text(value)
			else:
				self._comment = value
		return property(**locals())

	@apply
	def requests():
		def fget( self ):
			return self._requests
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument requests is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'versioned_action_request', scope = schema_scope)):
				self._requests = SET(value)
			else:
				self._requests = value
		return property(**locals())

####################
 # ENTITY plane_angle_unit #
####################
class plane_angle_unit(named_unit):
	'''Entity plane_angle_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY compound_representation_item #
####################
class compound_representation_item(representation_item):
	'''Entity compound_representation_item definition.

	:param item_element
	:type item_element:compound_item_definition
	'''
	def __init__( self , inherited0__name , item_element, ):
		representation_item.__init__(self , inherited0__name , )
		self.item_element = item_element

	@apply
	def item_element():
		def fget( self ):
			return self._item_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_element is mantatory and can not be set to None')
			if not check_type(value,compound_item_definition):
				self._item_element = compound_item_definition(value)
			else:
				self._item_element = value
		return property(**locals())

####################
 # ENTITY row_value #
####################
class row_value(compound_representation_item):
	'''Entity row_value definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY annotation_symbol_occurrence #
####################
class annotation_symbol_occurrence(annotation_occurrence):
	'''Entity annotation_symbol_occurrence definition.

	:param styled_item_item
	:type styled_item_item:annotation_symbol_occurrence_item
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , styled_item_item, ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		self.styled_item_item = styled_item_item

	@apply
	def styled_item_item():
		def fget( self ):
			return self._styled_item_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_item_item is mantatory and can not be set to None')
			if not check_type(value,annotation_symbol_occurrence_item):
				self._styled_item_item = annotation_symbol_occurrence_item(value)
			else:
				self._styled_item_item = value
		return property(**locals())

####################
 # ENTITY terminator_symbol #
####################
class terminator_symbol(annotation_symbol_occurrence):
	'''Entity terminator_symbol definition.

	:param annotated_curve
	:type annotated_curve:annotation_curve_occurrence
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , annotated_curve, ):
		annotation_symbol_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , )
		self.annotated_curve = annotated_curve

	@apply
	def annotated_curve():
		def fget( self ):
			return self._annotated_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument annotated_curve is mantatory and can not be set to None')
			if not check_type(value,annotation_curve_occurrence):
				self._annotated_curve = annotation_curve_occurrence(value)
			else:
				self._annotated_curve = value
		return property(**locals())

####################
 # ENTITY leader_terminator #
####################
class leader_terminator(terminator_symbol):
	'''Entity leader_terminator definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , inherited4__annotated_curve ,  ):
		terminator_symbol.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , inherited4__annotated_curve , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LEADER_CURVE'  ==  TYPEOF(self.self.terminator_symbol.self.annotated_curve))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY row_representation_item #
####################
class row_representation_item(compound_representation_item):
	'''Entity row_representation_item definition.

	:param compound_representation_item_item_element
	:type compound_representation_item_item_element:LIST(1,None,'representation_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__item_element , compound_representation_item_item_element, ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )
		self.compound_representation_item_item_element = compound_representation_item_item_element

	@apply
	def compound_representation_item_item_element():
		def fget( self ):
			return self._compound_representation_item_item_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument compound_representation_item_item_element is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'representation_item', scope = schema_scope)):
				self._compound_representation_item_item_element = LIST(value)
			else:
				self._compound_representation_item_item_element = value
		return property(**locals())

####################
 # ENTITY organization_assignment #
####################
class organization_assignment(BaseEntityClass):
	'''Entity organization_assignment definition.

	:param assigned_organization
	:type assigned_organization:organization

	:param role
	:type role:organization_role
	'''
	def __init__( self , assigned_organization,role, ):
		self.assigned_organization = assigned_organization
		self.role = role

	@apply
	def assigned_organization():
		def fget( self ):
			return self._assigned_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_organization is mantatory and can not be set to None')
			if not check_type(value,organization):
				self._assigned_organization = organization(value)
			else:
				self._assigned_organization = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,organization_role):
				self._role = organization_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_organization_assignment #
####################
class applied_organization_assignment(organization_assignment):
	'''Entity applied_organization_assignment definition.

	:param items
	:type items:SET(1,None,'organization_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_organization , inherited1__role , items, ):
		organization_assignment.__init__(self , inherited0__assigned_organization , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'organization_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY measure_with_unit #
####################
class measure_with_unit(BaseEntityClass):
	'''Entity measure_with_unit definition.

	:param value_component
	:type value_component:measure_value

	:param unit_component
	:type unit_component:unit
	'''
	def __init__( self , value_component,unit_component, ):
		self.value_component = value_component
		self.unit_component = unit_component

	@apply
	def value_component():
		def fget( self ):
			return self._value_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument value_component is mantatory and can not be set to None')
			if not check_type(value,measure_value):
				self._value_component = measure_value(value)
			else:
				self._value_component = value
		return property(**locals())

	@apply
	def unit_component():
		def fget( self ):
			return self._unit_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unit_component is mantatory and can not be set to None')
			if not check_type(value,unit):
				self._unit_component = unit(value)
			else:
				self._unit_component = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = valid_units(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY area_measure_with_unit #
####################
class area_measure_with_unit(measure_with_unit):
	'''Entity area_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.AREA_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY colour #
####################
class colour(BaseEntityClass):
	'''Entity colour definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY concept_feature_operator #
####################
class concept_feature_operator(BaseEntityClass):
	'''Entity concept_feature_operator definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY configuration_item_relationship #
####################
class configuration_item_relationship(BaseEntityClass):
	'''Entity configuration_item_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_configuration_item
	:type relating_configuration_item:configuration_item

	:param related_configuration_item
	:type related_configuration_item:configuration_item
	'''
	def __init__( self , name,description,relating_configuration_item,related_configuration_item, ):
		self.name = name
		self.description = description
		self.relating_configuration_item = relating_configuration_item
		self.related_configuration_item = related_configuration_item

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_configuration_item():
		def fget( self ):
			return self._relating_configuration_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_configuration_item is mantatory and can not be set to None')
			if not check_type(value,configuration_item):
				self._relating_configuration_item = configuration_item(value)
			else:
				self._relating_configuration_item = value
		return property(**locals())

	@apply
	def related_configuration_item():
		def fget( self ):
			return self._related_configuration_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_configuration_item is mantatory and can not be set to None')
			if not check_type(value,configuration_item):
				self._related_configuration_item = configuration_item(value)
			else:
				self._related_configuration_item = value
		return property(**locals())

####################
 # ENTITY default_tolerance_table #
####################
class default_tolerance_table(representation):
	'''Entity default_tolerance_table definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (((SIZEOF(None)  ==  0)  and  (SIZEOF(None)  ==  0))  and  (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'REPRESENTATION_RELATIONSHIP.REP_2'))  ==  0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY force_unit #
####################
class force_unit(derived_unit):
	'''Entity force_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.newton))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_method_assignment #
####################
class action_method_assignment(BaseEntityClass):
	'''Entity action_method_assignment definition.

	:param assigned_action_method
	:type assigned_action_method:action_method

	:param role
	:type role:action_method_role
	'''
	def __init__( self , assigned_action_method,role, ):
		self.assigned_action_method = assigned_action_method
		self.role = role

	@apply
	def assigned_action_method():
		def fget( self ):
			return self._assigned_action_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_action_method is mantatory and can not be set to None')
			if not check_type(value,action_method):
				self._assigned_action_method = action_method(value)
			else:
				self._assigned_action_method = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,action_method_role):
				self._role = action_method_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_action_method_assignment #
####################
class applied_action_method_assignment(action_method_assignment):
	'''Entity applied_action_method_assignment definition.

	:param items
	:type items:SET(1,None,'action_method_items', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action_method , inherited1__role , items, ):
		action_method_assignment.__init__(self , inherited0__assigned_action_method , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'action_method_items', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY descriptive_representation_item #
####################
class descriptive_representation_item(representation_item):
	'''Entity descriptive_representation_item definition.

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__name , description, ):
		representation_item.__init__(self , inherited0__name , )
		self.description = description

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY enum_reference_prefix #
####################
class enum_reference_prefix(descriptive_representation_item):
	'''Entity enum_reference_prefix definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		descriptive_representation_item.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY fill_area_style_tile_symbol_with_style #
####################
class fill_area_style_tile_symbol_with_style(geometric_representation_item):
	'''Entity fill_area_style_tile_symbol_with_style definition.

	:param symbol
	:type symbol:annotation_symbol_occurrence
	'''
	def __init__( self , inherited0__name , symbol, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.symbol = symbol

	@apply
	def symbol():
		def fget( self ):
			return self._symbol
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument symbol is mantatory and can not be set to None')
			if not check_type(value,annotation_symbol_occurrence):
				self._symbol = annotation_symbol_occurrence(value)
			else:
				self._symbol = value
		return property(**locals())

####################
 # ENTITY draughting_callout #
####################
class draughting_callout(geometric_representation_item):
	'''Entity draughting_callout definition.

	:param contents
	:type contents:SET(1,None,'draughting_callout_element', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , contents, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.contents = contents

	@apply
	def contents():
		def fget( self ):
			return self._contents
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument contents is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'draughting_callout_element', scope = schema_scope)):
				self._contents = SET(value)
			else:
				self._contents = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((((SIZEOF(None)  ==  0)  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LEADER_DIRECTED_CALLOUT'  ==  TYPEOF(self))  and  (SIZEOF(None)  ==  0)))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PROJECTION_DIRECTED_CALLOUT'  ==  TYPEOF(self))  and  (SIZEOF(None)  ==  0)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT'  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY leader_directed_callout #
####################
class leader_directed_callout(draughting_callout):
	'''Entity leader_directed_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.draughting_callout.self.contents)  >=  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY leader_directed_dimension #
####################
class leader_directed_dimension(leader_directed_callout):
	'''Entity leader_directed_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		leader_directed_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY presentation_representation #
####################
class presentation_representation(representation):
	'''Entity presentation_representation definition.

	:param representation_context_of_items
	:type representation_context_of_items:geometric_representation_context
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_context_of_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_context_of_items = representation_context_of_items

	@apply
	def representation_context_of_items():
		def fget( self ):
			return self._representation_context_of_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_context_of_items is mantatory and can not be set to None')
			if not check_type(value,geometric_representation_context):
				self._representation_context_of_items = geometric_representation_context(value)
			else:
				self._representation_context_of_items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.representation.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRESENTATION_AREA'  ==  TYPEOF(self))  or  (SIZEOF(None)  >  0))  or  (SIZEOF(None)  >  0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY presentation_area #
####################
class presentation_area(presentation_representation):
	'''Entity presentation_area definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items ,  ):
		presentation_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(None)  >  0)  or  (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PRESENTATION_SIZE.UNIT'))  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY mechanical_design_geometric_presentation_area #
####################
class mechanical_design_geometric_presentation_area(presentation_area):
	'''Entity mechanical_design_geometric_presentation_area definition.

	:param representation_items
	:type representation_items:SET(1,None,'mechanical_design_geometric_presentation_area_items', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , representation_items, ):
		presentation_area.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , )
		self.representation_items = representation_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'mechanical_design_geometric_presentation_area_items', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((SIZEOF(None)  ==  0)  and  (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  0))  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY name_attribute #
####################
class name_attribute(BaseEntityClass):
	'''Entity name_attribute definition.

	:param attribute_value
	:type attribute_value:label

	:param named_item
	:type named_item:name_attribute_select
	'''
	def __init__( self , attribute_value,named_item, ):
		self.attribute_value = attribute_value
		self.named_item = named_item

	@apply
	def attribute_value():
		def fget( self ):
			return self._attribute_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_value is mantatory and can not be set to None')
			if not check_type(value,label):
				self._attribute_value = label(value)
			else:
				self._attribute_value = value
		return property(**locals())

	@apply
	def named_item():
		def fget( self ):
			return self._named_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument named_item is mantatory and can not be set to None')
			if not check_type(value,name_attribute_select):
				self._named_item = name_attribute_select(value)
			else:
				self._named_item = value
		return property(**locals())

####################
 # ENTITY boolean_expression #
####################
class boolean_expression(expression):
	'''Entity boolean_expression definition.
	'''
	def __init__( self ,  ):
		expression.__init__(self , )

####################
 # ENTITY drawing_revision_sequence #
####################
class drawing_revision_sequence(BaseEntityClass):
	'''Entity drawing_revision_sequence definition.

	:param predecessor
	:type predecessor:drawing_revision

	:param successor
	:type successor:drawing_revision
	'''
	def __init__( self , predecessor,successor, ):
		self.predecessor = predecessor
		self.successor = successor

	@apply
	def predecessor():
		def fget( self ):
			return self._predecessor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument predecessor is mantatory and can not be set to None')
			if not check_type(value,drawing_revision):
				self._predecessor = drawing_revision(value)
			else:
				self._predecessor = value
		return property(**locals())

	@apply
	def successor():
		def fget( self ):
			return self._successor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument successor is mantatory and can not be set to None')
			if not check_type(value,drawing_revision):
				self._successor = drawing_revision(value)
			else:
				self._successor = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.predecessor  !=  self.successor)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY effectivity #
####################
class effectivity(BaseEntityClass):
	'''Entity effectivity definition.

	:param id
	:type id:identifier

	:param description
	:type description:text

	:param name
	:type name:label
	'''
	def __init__( self , id, ):
		self.id = id

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY serial_numbered_effectivity #
####################
class serial_numbered_effectivity(effectivity):
	'''Entity serial_numbered_effectivity definition.

	:param effectivity_start_id
	:type effectivity_start_id:identifier

	:param effectivity_end_id
	:type effectivity_end_id:identifier
	'''
	def __init__( self , inherited0__id , effectivity_start_id,effectivity_end_id, ):
		effectivity.__init__(self , inherited0__id , )
		self.effectivity_start_id = effectivity_start_id
		self.effectivity_end_id = effectivity_end_id

	@apply
	def effectivity_start_id():
		def fget( self ):
			return self._effectivity_start_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument effectivity_start_id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._effectivity_start_id = identifier(value)
			else:
				self._effectivity_start_id = value
		return property(**locals())

	@apply
	def effectivity_end_id():
		def fget( self ):
			return self._effectivity_end_id
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,identifier):
					self._effectivity_end_id = identifier(value)
				else:
					self._effectivity_end_id = value
			else:
				self._effectivity_end_id = value
		return property(**locals())

####################
 # ENTITY thermal_resistance_unit #
####################
class thermal_resistance_unit(derived_unit):
	'''Entity thermal_resistance_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensional_exponents(-1,-1,-3,0,1,0,0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY energy_unit #
####################
class energy_unit(derived_unit):
	'''Entity energy_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.joule))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_concept_feature_association #
####################
class product_concept_feature_association(BaseEntityClass):
	'''Entity product_concept_feature_association definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param concept
	:type concept:product_concept

	:param feature
	:type feature:product_concept_feature
	'''
	def __init__( self , name,description,concept,feature, ):
		self.name = name
		self.description = description
		self.concept = concept
		self.feature = feature

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def concept():
		def fget( self ):
			return self._concept
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument concept is mantatory and can not be set to None')
			if not check_type(value,product_concept):
				self._concept = product_concept(value)
			else:
				self._concept = value
		return property(**locals())

	@apply
	def feature():
		def fget( self ):
			return self._feature
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument feature is mantatory and can not be set to None')
			if not check_type(value,product_concept_feature):
				self._feature = product_concept_feature(value)
			else:
				self._feature = value
		return property(**locals())

####################
 # ENTITY table_representation_item #
####################
class table_representation_item(compound_representation_item):
	'''Entity table_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY date_and_time_assignment #
####################
class date_and_time_assignment(BaseEntityClass):
	'''Entity date_and_time_assignment definition.

	:param assigned_date_and_time
	:type assigned_date_and_time:date_and_time

	:param role
	:type role:date_time_role
	'''
	def __init__( self , assigned_date_and_time,role, ):
		self.assigned_date_and_time = assigned_date_and_time
		self.role = role

	@apply
	def assigned_date_and_time():
		def fget( self ):
			return self._assigned_date_and_time
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_date_and_time is mantatory and can not be set to None')
			if not check_type(value,date_and_time):
				self._assigned_date_and_time = date_and_time(value)
			else:
				self._assigned_date_and_time = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,date_time_role):
				self._role = date_time_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_date_and_time_assignment #
####################
class applied_date_and_time_assignment(date_and_time_assignment):
	'''Entity applied_date_and_time_assignment definition.

	:param items
	:type items:SET(1,None,'date_and_time_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_date_and_time , inherited1__role , items, ):
		date_and_time_assignment.__init__(self , inherited0__assigned_date_and_time , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'date_and_time_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY logical_literal #
####################
class logical_literal(generic_literal):
	'''Entity logical_literal definition.

	:param lit_value
	:type lit_value:LOGICAL
	'''
	def __init__( self , lit_value, ):
		generic_literal.__init__(self , )
		self.lit_value = lit_value

	@apply
	def lit_value():
		def fget( self ):
			return self._lit_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lit_value is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._lit_value = LOGICAL(value)
			else:
				self._lit_value = value
		return property(**locals())

####################
 # ENTITY logical_representation_item #
####################
class logical_representation_item(representation_item,logical_literal):
	'''Entity logical_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__lit_value ,  ):
		representation_item.__init__(self , inherited0__name , )
		logical_literal.__init__(self , inherited1__lit_value , )

####################
 # ENTITY multiple_arity_generic_expression #
####################
class multiple_arity_generic_expression(generic_expression):
	'''Entity multiple_arity_generic_expression definition.

	:param operands
	:type operands:LIST(2,None,'generic_expression', scope = schema_scope)
	'''
	def __init__( self , operands, ):
		generic_expression.__init__(self , )
		self.operands = operands

	@apply
	def operands():
		def fget( self ):
			return self._operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'generic_expression', scope = schema_scope)):
				self._operands = LIST(value)
			else:
				self._operands = value
		return property(**locals())

####################
 # ENTITY multiple_arity_numeric_expression #
####################
class multiple_arity_numeric_expression(numeric_expression,multiple_arity_generic_expression):
	'''Entity multiple_arity_numeric_expression definition.

	:param multiple_arity_generic_expression_operands
	:type multiple_arity_generic_expression_operands:LIST(2,None,'numeric_expression', scope = schema_scope)
	'''
	def __init__( self , inherited0__operands , multiple_arity_generic_expression_operands, ):
		numeric_expression.__init__(self , )
		multiple_arity_generic_expression.__init__(self , inherited0__operands , )
		self.multiple_arity_generic_expression_operands = multiple_arity_generic_expression_operands

	@apply
	def multiple_arity_generic_expression_operands():
		def fget( self ):
			return self._multiple_arity_generic_expression_operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument multiple_arity_generic_expression_operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'numeric_expression', scope = schema_scope)):
				self._multiple_arity_generic_expression_operands = LIST(value)
			else:
				self._multiple_arity_generic_expression_operands = value
		return property(**locals())

####################
 # ENTITY binary_representation_item #
####################
class binary_representation_item(representation_item):
	'''Entity binary_representation_item definition.

	:param binary_value
	:type binary_value:(null)
	'''
	def __init__( self , inherited0__name , binary_value, ):
		representation_item.__init__(self , inherited0__name , )
		self.binary_value = binary_value

	@apply
	def binary_value():
		def fget( self ):
			return self._binary_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument binary_value is mantatory and can not be set to None')
			if not check_type(value,(null)):
				self._binary_value = (null)(value)
			else:
				self._binary_value = value
		return property(**locals())

####################
 # ENTITY bytes_representation_item #
####################
class bytes_representation_item(binary_representation_item):
	'''Entity bytes_representation_item definition.

	:param no_of_bytes
	:type no_of_bytes:INTEGER
	'''
	def __init__( self , inherited0__name , inherited1__binary_value ,  ):
		binary_representation_item.__init__(self , inherited0__name , inherited1__binary_value , )

	@apply
	def no_of_bytes():
		def fget( self ):
			attribute_eval = (BLENGTH(self.self.binary_representation_item.self.binary_value) / 8)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument no_of_bytes is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((BLENGTH(self.self.binary_representation_item.self.binary_value)  %  8)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY picture_representation_item #
####################
class picture_representation_item(bytes_representation_item):
	'''Entity picture_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__binary_value ,  ):
		bytes_representation_item.__init__(self , inherited0__name , inherited1__binary_value , )

####################
 # ENTITY mapped_item #
####################
class mapped_item(representation_item):
	'''Entity mapped_item definition.

	:param mapping_source
	:type mapping_source:representation_map

	:param mapping_target
	:type mapping_target:representation_item
	'''
	def __init__( self , inherited0__name , mapping_source,mapping_target, ):
		representation_item.__init__(self , inherited0__name , )
		self.mapping_source = mapping_source
		self.mapping_target = mapping_target

	@apply
	def mapping_source():
		def fget( self ):
			return self._mapping_source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapping_source is mantatory and can not be set to None')
			if not check_type(value,representation_map):
				self._mapping_source = representation_map(value)
			else:
				self._mapping_source = value
		return property(**locals())

	@apply
	def mapping_target():
		def fget( self ):
			return self._mapping_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapping_target is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._mapping_target = representation_item(value)
			else:
				self._mapping_target = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = acyclic_mapped_representation(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY annotation_text_character #
####################
class annotation_text_character(mapped_item):
	'''Entity annotation_text_character definition.

	:param alignment
	:type alignment:text_alignment

	:param mapped_item_mapping_target
	:type mapped_item_mapping_target:axis2_placement
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , alignment,mapped_item_mapping_target, ):
		mapped_item.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , )
		self.alignment = alignment
		self.mapped_item_mapping_target = mapped_item_mapping_target

	@apply
	def alignment():
		def fget( self ):
			return self._alignment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument alignment is mantatory and can not be set to None')
			if not check_type(value,text_alignment):
				self._alignment = text_alignment(value)
			else:
				self._alignment = value
		return property(**locals())

	@apply
	def mapped_item_mapping_target():
		def fget( self ):
			return self._mapped_item_mapping_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_target is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._mapped_item_mapping_target = axis2_placement(value)
			else:
				self._mapped_item_mapping_target = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CHARACTER_GLYPH_SYMBOL'  ==  TYPEOF(self.self.mapped_item.self.mapping_source.self.mapped_representation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM'  ==  TYPEOF(self))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY context_dependent_unit #
####################
class context_dependent_unit(named_unit):
	'''Entity context_dependent_unit definition.

	:param name
	:type name:label
	'''
	def __init__( self , inherited0__dimensions , name, ):
		named_unit.__init__(self , inherited0__dimensions , )
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY externally_defined_context_dependent_unit #
####################
class externally_defined_context_dependent_unit(context_dependent_unit,externally_defined_item):
	'''Entity externally_defined_context_dependent_unit definition.
	'''
	def __init__( self , inherited0__dimensions , inherited1__name , inherited2__item_id , inherited3__source ,  ):
		context_dependent_unit.__init__(self , inherited0__dimensions , inherited1__name , )
		externally_defined_item.__init__(self , inherited2__item_id , inherited3__source , )

####################
 # ENTITY surface #
####################
class surface(geometric_representation_item):
	'''Entity surface definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY oriented_surface #
####################
class oriented_surface(surface):
	'''Entity oriented_surface definition.

	:param orientation
	:type orientation:BOOLEAN
	'''
	def __init__( self , inherited0__name , orientation, ):
		surface.__init__(self , inherited0__name , )
		self.orientation = orientation

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY group #
####################
class group(BaseEntityClass):
	'''Entity group definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY requirement_assignment #
####################
class requirement_assignment(characterized_object,group):
	'''Entity requirement_assignment definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__name , inherited3__description ,  ):
		characterized_object.__init__(self , inherited0__name , inherited1__description , )
		group.__init__(self , inherited2__name , inherited3__description , )

####################
 # ENTITY product_definition #
####################
class product_definition(BaseEntityClass):
	'''Entity product_definition definition.

	:param id
	:type id:identifier

	:param description
	:type description:text

	:param formation
	:type formation:product_definition_formation

	:param frame_of_reference
	:type frame_of_reference:product_definition_context

	:param name
	:type name:label
	'''
	def __init__( self , id,description,formation,frame_of_reference, ):
		self.id = id
		self.description = description
		self.formation = formation
		self.frame_of_reference = frame_of_reference

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def formation():
		def fget( self ):
			return self._formation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument formation is mantatory and can not be set to None')
			if not check_type(value,product_definition_formation):
				self._formation = product_definition_formation(value)
			else:
				self._formation = value
		return property(**locals())

	@apply
	def frame_of_reference():
		def fget( self ):
			return self._frame_of_reference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument frame_of_reference is mantatory and can not be set to None')
			if not check_type(value,product_definition_context):
				self._frame_of_reference = product_definition_context(value)
			else:
				self._frame_of_reference = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY laminate_table #
####################
class laminate_table(product_definition):
	'''Entity laminate_table definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY zone_structural_makeup #
####################
class zone_structural_makeup(laminate_table):
	'''Entity zone_structural_makeup definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		laminate_table.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY smeared_material_definition #
####################
class smeared_material_definition(zone_structural_makeup):
	'''Entity smeared_material_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		zone_structural_makeup.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY simple_boolean_expression #
####################
class simple_boolean_expression(boolean_expression,simple_generic_expression):
	'''Entity simple_boolean_expression definition.
	'''
	def __init__( self ,  ):
		boolean_expression.__init__(self , )
		simple_generic_expression.__init__(self , )

####################
 # ENTITY boolean_literal #
####################
class boolean_literal(simple_boolean_expression,generic_literal):
	'''Entity boolean_literal definition.

	:param the_value
	:type the_value:BOOLEAN
	'''
	def __init__( self , the_value, ):
		simple_boolean_expression.__init__(self , )
		generic_literal.__init__(self , )
		self.the_value = the_value

	@apply
	def the_value():
		def fget( self ):
			return self._the_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument the_value is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._the_value = BOOLEAN(value)
			else:
				self._the_value = value
		return property(**locals())

####################
 # ENTITY boolean_representation_item #
####################
class boolean_representation_item(representation_item,boolean_literal):
	'''Entity boolean_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__the_value ,  ):
		representation_item.__init__(self , inherited0__name , )
		boolean_literal.__init__(self , inherited1__the_value , )

####################
 # ENTITY currency #
####################
class currency(context_dependent_unit):
	'''Entity currency definition.
	'''
	def __init__( self , inherited0__dimensions , inherited1__name ,  ):
		context_dependent_unit.__init__(self , inherited0__dimensions , inherited1__name , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY iso4217_currency #
####################
class iso4217_currency(currency):
	'''Entity iso4217_currency definition.
	'''
	def __init__( self , inherited0__dimensions , inherited1__name ,  ):
		currency.__init__(self , inherited0__dimensions , inherited1__name , )

####################
 # ENTITY offset_surface #
####################
class offset_surface(surface):
	'''Entity offset_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param distance
	:type distance:length_measure

	:param self_intersect
	:type self_intersect:LOGICAL
	'''
	def __init__( self , inherited0__name , basis_surface,distance,self_intersect, ):
		surface.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.distance = distance
		self.self_intersect = self_intersect

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def distance():
		def fget( self ):
			return self._distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._distance = length_measure(value)
			else:
				self._distance = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())

####################
 # ENTITY placement #
####################
class placement(geometric_representation_item):
	'''Entity placement definition.

	:param location
	:type location:cartesian_point
	'''
	def __init__( self , inherited0__name , location, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.location = location

	@apply
	def location():
		def fget( self ):
			return self._location
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument location is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._location = cartesian_point(value)
			else:
				self._location = value
		return property(**locals())

####################
 # ENTITY axis2_placement_2d #
####################
class axis2_placement_2d(placement):
	'''Entity axis2_placement_2d definition.

	:param ref_direction
	:type ref_direction:direction

	:param p
	:type p:LIST(2,2,'direction', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__location , ref_direction, ):
		placement.__init__(self , inherited0__name , inherited1__location , )
		self.ref_direction = ref_direction

	@apply
	def ref_direction():
		def fget( self ):
			return self._ref_direction
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._ref_direction = direction(value)
				else:
					self._ref_direction = value
			else:
				self._ref_direction = value
		return property(**locals())

	@apply
	def p():
		def fget( self ):
			attribute_eval = build_2axes(self.ref_direction)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY shape_aspect #
####################
class shape_aspect(BaseEntityClass):
	'''Entity shape_aspect definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param of_shape
	:type of_shape:product_definition_shape

	:param product_definitional
	:type product_definitional:LOGICAL

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description,of_shape,product_definitional, ):
		self.name = name
		self.description = description
		self.of_shape = of_shape
		self.product_definitional = product_definitional

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def of_shape():
		def fget( self ):
			return self._of_shape
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument of_shape is mantatory and can not be set to None')
			if not check_type(value,product_definition_shape):
				self._of_shape = product_definition_shape(value)
			else:
				self._of_shape = value
		return property(**locals())

	@apply
	def product_definitional():
		def fget( self ):
			return self._product_definitional
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument product_definitional is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._product_definitional = LOGICAL(value)
			else:
				self._product_definitional = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY composite_shape_aspect #
####################
class composite_shape_aspect(shape_aspect):
	'''Entity composite_shape_aspect definition.

	:param component_relationships
	:type component_relationships:SET(2,None,'shape_aspect_relationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )

	@apply
	def component_relationships():
		def fget( self ):
			return self._component_relationships
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument component_relationships is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY general_material_property #
####################
class general_material_property(general_property):
	'''Entity general_material_property definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description ,  ):
		general_property.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_category #
####################
class product_category(BaseEntityClass):
	'''Entity product_category definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_related_product_category #
####################
class product_related_product_category(product_category):
	'''Entity product_related_product_category definition.

	:param products
	:type products:SET(1,None,'product', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , products, ):
		product_category.__init__(self , inherited0__name , inherited1__description , )
		self.products = products

	@apply
	def products():
		def fget( self ):
			return self._products
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument products is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'product', scope = schema_scope)):
				self._products = SET(value)
			else:
				self._products = value
		return property(**locals())

####################
 # ENTITY shape_representation_with_parameters #
####################
class shape_representation_with_parameters(shape_representation):
	'''Entity shape_representation_with_parameters definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  SIZEOF(self.self.items))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY camera_model_d3 #
####################
class camera_model_d3(camera_model):
	'''Entity camera_model_d3 definition.

	:param view_reference_system
	:type view_reference_system:axis2_placement_3d

	:param perspective_of_volume
	:type perspective_of_volume:view_volume
	'''
	def __init__( self , inherited0__name , view_reference_system,perspective_of_volume, ):
		camera_model.__init__(self , inherited0__name , )
		self.view_reference_system = view_reference_system
		self.perspective_of_volume = perspective_of_volume

	@apply
	def view_reference_system():
		def fget( self ):
			return self._view_reference_system
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument view_reference_system is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._view_reference_system = axis2_placement_3d(value)
			else:
				self._view_reference_system = value
		return property(**locals())

	@apply
	def perspective_of_volume():
		def fget( self ):
			return self._perspective_of_volume
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument perspective_of_volume is mantatory and can not be set to None')
			if not check_type(value,view_volume):
				self._perspective_of_volume = view_volume(value)
			else:
				self._perspective_of_volume = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((dot_product(self.self.view_reference_system.self.p[3],self.self.perspective_of_volume.self.view_window.self.placement.self.p[3])  ==  1)  and  (self.self.view_reference_system.self.location.self.coordinates[3]  ==  self.self.perspective_of_volume.self.view_window.self.placement.self.location.self.coordinates[3]))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY camera_model_d3_multi_clipping #
####################
class camera_model_d3_multi_clipping(camera_model_d3):
	'''Entity camera_model_d3_multi_clipping definition.

	:param shape_clipping
	:type shape_clipping:SET(1,None,'camera_model_d3_multi_clipping_interection_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__view_reference_system , inherited2__perspective_of_volume , shape_clipping, ):
		camera_model_d3.__init__(self , inherited0__name , inherited1__view_reference_system , inherited2__perspective_of_volume , )
		self.shape_clipping = shape_clipping

	@apply
	def shape_clipping():
		def fget( self ):
			return self._shape_clipping
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument shape_clipping is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'camera_model_d3_multi_clipping_interection_select', scope = schema_scope)):
				self._shape_clipping = SET(value)
			else:
				self._shape_clipping = value
		return property(**locals())

####################
 # ENTITY curve #
####################
class curve(geometric_representation_item):
	'''Entity curve definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY conic #
####################
class conic(curve):
	'''Entity conic definition.

	:param position
	:type position:axis2_placement
	'''
	def __init__( self , inherited0__name , position, ):
		curve.__init__(self , inherited0__name , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._position = axis2_placement(value)
			else:
				self._position = value
		return property(**locals())

####################
 # ENTITY hyperbola #
####################
class hyperbola(conic):
	'''Entity hyperbola definition.

	:param semi_axis
	:type semi_axis:positive_length_measure

	:param semi_imag_axis
	:type semi_imag_axis:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , semi_axis,semi_imag_axis, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self.semi_axis = semi_axis
		self.semi_imag_axis = semi_imag_axis

	@apply
	def semi_axis():
		def fget( self ):
			return self._semi_axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_axis is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._semi_axis = positive_length_measure(value)
			else:
				self._semi_axis = value
		return property(**locals())

	@apply
	def semi_imag_axis():
		def fget( self ):
			return self._semi_imag_axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_imag_axis is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._semi_imag_axis = positive_length_measure(value)
			else:
				self._semi_imag_axis = value
		return property(**locals())

####################
 # ENTITY shape_aspect_relationship #
####################
class shape_aspect_relationship(BaseEntityClass):
	'''Entity shape_aspect_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_shape_aspect
	:type relating_shape_aspect:shape_aspect

	:param related_shape_aspect
	:type related_shape_aspect:shape_aspect

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description,relating_shape_aspect,related_shape_aspect, ):
		self.name = name
		self.description = description
		self.relating_shape_aspect = relating_shape_aspect
		self.related_shape_aspect = related_shape_aspect

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_shape_aspect():
		def fget( self ):
			return self._relating_shape_aspect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_shape_aspect is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._relating_shape_aspect = shape_aspect(value)
			else:
				self._relating_shape_aspect = value
		return property(**locals())

	@apply
	def related_shape_aspect():
		def fget( self ):
			return self._related_shape_aspect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_shape_aspect is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._related_shape_aspect = shape_aspect(value)
			else:
				self._related_shape_aspect = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY shape_aspect_deriving_relationship #
####################
class shape_aspect_deriving_relationship(shape_aspect_relationship):
	'''Entity shape_aspect_deriving_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		shape_aspect_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DERIVED_SHAPE_ASPECT'  ==  TYPEOF(self.self.shape_aspect_relationship.self.relating_shape_aspect))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY tolerance_zone_form #
####################
class tolerance_zone_form(BaseEntityClass):
	'''Entity tolerance_zone_form definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY uncertainty_qualifier #
####################
class uncertainty_qualifier(BaseEntityClass):
	'''Entity uncertainty_qualifier definition.

	:param measure_name
	:type measure_name:label

	:param description
	:type description:text
	'''
	def __init__( self , measure_name,description, ):
		self.measure_name = measure_name
		self.description = description

	@apply
	def measure_name():
		def fget( self ):
			return self._measure_name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument measure_name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._measure_name = label(value)
			else:
				self._measure_name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY attribute_classification_assignment #
####################
class attribute_classification_assignment(BaseEntityClass):
	'''Entity attribute_classification_assignment definition.

	:param assigned_class
	:type assigned_class:group

	:param attribute_name
	:type attribute_name:label

	:param role
	:type role:classification_role
	'''
	def __init__( self , assigned_class,attribute_name,role, ):
		self.assigned_class = assigned_class
		self.attribute_name = attribute_name
		self.role = role

	@apply
	def assigned_class():
		def fget( self ):
			return self._assigned_class
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_class is mantatory and can not be set to None')
			if not check_type(value,group):
				self._assigned_class = group(value)
			else:
				self._assigned_class = value
		return property(**locals())

	@apply
	def attribute_name():
		def fget( self ):
			return self._attribute_name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._attribute_name = label(value)
			else:
				self._attribute_name = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,classification_role):
				self._role = classification_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_attribute_classification_assignment #
####################
class applied_attribute_classification_assignment(attribute_classification_assignment):
	'''Entity applied_attribute_classification_assignment definition.

	:param items
	:type items:SET(1,None,'attribute_classification_item', scope = schema_scope)

	:param attribute_classification_assignment_assigned_class
	:type attribute_classification_assignment_assigned_class:class
	'''
	def __init__( self , inherited0__assigned_class , inherited1__attribute_name , inherited2__role , items,attribute_classification_assignment_assigned_class, ):
		attribute_classification_assignment.__init__(self , inherited0__assigned_class , inherited1__attribute_name , inherited2__role , )
		self.items = items
		self.attribute_classification_assignment_assigned_class = attribute_classification_assignment_assigned_class

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'attribute_classification_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def attribute_classification_assignment_assigned_class():
		def fget( self ):
			return self._attribute_classification_assignment_assigned_class
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_classification_assignment_assigned_class is mantatory and can not be set to None')
			if not check_type(value,class):
				self._attribute_classification_assignment_assigned_class = class(value)
			else:
				self._attribute_classification_assignment_assigned_class = value
		return property(**locals())

####################
 # ENTITY group_assignment #
####################
class group_assignment(BaseEntityClass):
	'''Entity group_assignment definition.

	:param assigned_group
	:type assigned_group:group

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_group, ):
		self.assigned_group = assigned_group

	@apply
	def assigned_group():
		def fget( self ):
			return self._assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_group is mantatory and can not be set to None')
			if not check_type(value,group):
				self._assigned_group = group(value)
			else:
				self._assigned_group = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY assigned_requirement #
####################
class assigned_requirement(group_assignment):
	'''Entity assigned_requirement definition.

	:param items
	:type items:SET(1,1,'product_definition', scope = schema_scope)

	:param group_assignment_assigned_group
	:type group_assignment_assigned_group:requirement_assignment
	'''
	def __init__( self , inherited0__assigned_group , items,group_assignment_assigned_group, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items
		self.group_assignment_assigned_group = group_assignment_assigned_group

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,1,'product_definition', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def group_assignment_assigned_group():
		def fget( self ):
			return self._group_assignment_assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument group_assignment_assigned_group is mantatory and can not be set to None')
			if not check_type(value,requirement_assignment):
				self._group_assignment_assigned_group = requirement_assignment(value)
			else:
				self._group_assignment_assigned_group = value
		return property(**locals())

####################
 # ENTITY capacitance_measure_with_unit #
####################
class capacitance_measure_with_unit(measure_with_unit):
	'''Entity capacitance_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CAPACITANCE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY symbol_representation #
####################
class symbol_representation(representation):
	'''Entity symbol_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )

####################
 # ENTITY generic_character_glyph_symbol #
####################
class generic_character_glyph_symbol(symbol_representation):
	'''Entity generic_character_glyph_symbol definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		symbol_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )

####################
 # ENTITY character_glyph_symbol #
####################
class character_glyph_symbol(generic_character_glyph_symbol):
	'''Entity character_glyph_symbol definition.

	:param character_box
	:type character_box:planar_extent

	:param baseline_ratio
	:type baseline_ratio:ratio_measure

	:param box_height
	:type box_height:length_measure
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , character_box,baseline_ratio, ):
		generic_character_glyph_symbol.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.character_box = character_box
		self.baseline_ratio = baseline_ratio

	@apply
	def character_box():
		def fget( self ):
			return self._character_box
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument character_box is mantatory and can not be set to None')
			if not check_type(value,planar_extent):
				self._character_box = planar_extent(value)
			else:
				self._character_box = value
		return property(**locals())

	@apply
	def baseline_ratio():
		def fget( self ):
			return self._baseline_ratio
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument baseline_ratio is mantatory and can not be set to None')
			if not check_type(value,ratio_measure):
				self._baseline_ratio = ratio_measure(value)
			else:
				self._baseline_ratio = value
		return property(**locals())

	@apply
	def box_height():
		def fget( self ):
			attribute_eval = self.character_box.self.size_in_y
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument box_height is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((0  <=  self.baseline_ratio)  and  (self.baseline_ratio  <=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = item_in_context(self.self.character_box,self.self.representation.self.context_of_items)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POSITIVE_LENGTH_MEASURE'  ==  TYPEOF(self.self.box_height))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY character_glyph_symbol_stroke #
####################
class character_glyph_symbol_stroke(character_glyph_symbol):
	'''Entity character_glyph_symbol_stroke definition.

	:param strokes
	:type strokes:SET(1,None,'curve', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__character_box , inherited4__baseline_ratio , strokes, ):
		character_glyph_symbol.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__character_box , inherited4__baseline_ratio , )
		self.strokes = strokes

	@apply
	def strokes():
		def fget( self ):
			return self._strokes
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument strokes is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'curve', scope = schema_scope)):
				self._strokes = SET(value)
			else:
				self._strokes = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.strokes  <=  self.self.representation.self.items)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY composite_text #
####################
class composite_text(geometric_representation_item):
	'''Entity composite_text definition.

	:param collected_text
	:type collected_text:SET(2,None,'text_or_character', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , collected_text, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.collected_text = collected_text

	@apply
	def collected_text():
		def fget( self ):
			return self._collected_text
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument collected_text is mantatory and can not be set to None')
			if not check_type(value,SET(2,None,'text_or_character', scope = schema_scope)):
				self._collected_text = SET(value)
			else:
				self._collected_text = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = acyclic_composite_text(self,self.self.collected_text)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY composite_text_with_extent #
####################
class composite_text_with_extent(composite_text):
	'''Entity composite_text_with_extent definition.

	:param extent
	:type extent:planar_extent
	'''
	def __init__( self , inherited0__name , inherited1__collected_text , extent, ):
		composite_text.__init__(self , inherited0__name , inherited1__collected_text , )
		self.extent = extent

	@apply
	def extent():
		def fget( self ):
			return self._extent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extent is mantatory and can not be set to None')
			if not check_type(value,planar_extent):
				self._extent = planar_extent(value)
			else:
				self._extent = value
		return property(**locals())

####################
 # ENTITY address #
####################
class address(BaseEntityClass):
	'''Entity address definition.

	:param internal_location
	:type internal_location:label

	:param street_number
	:type street_number:label

	:param street
	:type street:label

	:param postal_box
	:type postal_box:label

	:param town
	:type town:label

	:param region
	:type region:label

	:param postal_code
	:type postal_code:label

	:param country
	:type country:label

	:param facsimile_number
	:type facsimile_number:label

	:param telephone_number
	:type telephone_number:label

	:param electronic_mail_address
	:type electronic_mail_address:label

	:param telex_number
	:type telex_number:label

	:param name
	:type name:label

	:param url
	:type url:identifier
	'''
	def __init__( self , internal_location,street_number,street,postal_box,town,region,postal_code,country,facsimile_number,telephone_number,electronic_mail_address,telex_number, ):
		self.internal_location = internal_location
		self.street_number = street_number
		self.street = street
		self.postal_box = postal_box
		self.town = town
		self.region = region
		self.postal_code = postal_code
		self.country = country
		self.facsimile_number = facsimile_number
		self.telephone_number = telephone_number
		self.electronic_mail_address = electronic_mail_address
		self.telex_number = telex_number

	@apply
	def internal_location():
		def fget( self ):
			return self._internal_location
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._internal_location = label(value)
				else:
					self._internal_location = value
			else:
				self._internal_location = value
		return property(**locals())

	@apply
	def street_number():
		def fget( self ):
			return self._street_number
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._street_number = label(value)
				else:
					self._street_number = value
			else:
				self._street_number = value
		return property(**locals())

	@apply
	def street():
		def fget( self ):
			return self._street
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._street = label(value)
				else:
					self._street = value
			else:
				self._street = value
		return property(**locals())

	@apply
	def postal_box():
		def fget( self ):
			return self._postal_box
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._postal_box = label(value)
				else:
					self._postal_box = value
			else:
				self._postal_box = value
		return property(**locals())

	@apply
	def town():
		def fget( self ):
			return self._town
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._town = label(value)
				else:
					self._town = value
			else:
				self._town = value
		return property(**locals())

	@apply
	def region():
		def fget( self ):
			return self._region
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._region = label(value)
				else:
					self._region = value
			else:
				self._region = value
		return property(**locals())

	@apply
	def postal_code():
		def fget( self ):
			return self._postal_code
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._postal_code = label(value)
				else:
					self._postal_code = value
			else:
				self._postal_code = value
		return property(**locals())

	@apply
	def country():
		def fget( self ):
			return self._country
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._country = label(value)
				else:
					self._country = value
			else:
				self._country = value
		return property(**locals())

	@apply
	def facsimile_number():
		def fget( self ):
			return self._facsimile_number
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._facsimile_number = label(value)
				else:
					self._facsimile_number = value
			else:
				self._facsimile_number = value
		return property(**locals())

	@apply
	def telephone_number():
		def fget( self ):
			return self._telephone_number
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._telephone_number = label(value)
				else:
					self._telephone_number = value
			else:
				self._telephone_number = value
		return property(**locals())

	@apply
	def electronic_mail_address():
		def fget( self ):
			return self._electronic_mail_address
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._electronic_mail_address = label(value)
				else:
					self._electronic_mail_address = value
			else:
				self._electronic_mail_address = value
		return property(**locals())

	@apply
	def telex_number():
		def fget( self ):
			return self._telex_number
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._telex_number = label(value)
				else:
					self._telex_number = value
			else:
				self._telex_number = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def url():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument url is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((((((((((EXISTS(self.internal_location)  or  EXISTS(self.street_number))  or  EXISTS(self.street))  or  EXISTS(self.postal_box))  or  EXISTS(self.town))  or  EXISTS(self.region))  or  EXISTS(self.postal_code))  or  EXISTS(self.country))  or  EXISTS(self.facsimile_number))  or  EXISTS(self.telephone_number))  or  EXISTS(self.electronic_mail_address))  or  EXISTS(self.telex_number))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY organizational_address #
####################
class organizational_address(address):
	'''Entity organizational_address definition.

	:param organizations
	:type organizations:SET(1,None,'organization', scope = schema_scope)

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , organizations,description, ):
		address.__init__(self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , )
		self.organizations = organizations
		self.description = description

	@apply
	def organizations():
		def fget( self ):
			return self._organizations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument organizations is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'organization', scope = schema_scope)):
				self._organizations = SET(value)
			else:
				self._organizations = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY unary_generic_expression #
####################
class unary_generic_expression(generic_expression):
	'''Entity unary_generic_expression definition.

	:param operand
	:type operand:generic_expression
	'''
	def __init__( self , operand, ):
		generic_expression.__init__(self , )
		self.operand = operand

	@apply
	def operand():
		def fget( self ):
			return self._operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operand is mantatory and can not be set to None')
			if not check_type(value,generic_expression):
				self._operand = generic_expression(value)
			else:
				self._operand = value
		return property(**locals())

####################
 # ENTITY unary_numeric_expression #
####################
class unary_numeric_expression(numeric_expression,unary_generic_expression):
	'''Entity unary_numeric_expression definition.

	:param unary_generic_expression_operand
	:type unary_generic_expression_operand:numeric_expression
	'''
	def __init__( self , inherited0__operand , unary_generic_expression_operand, ):
		numeric_expression.__init__(self , )
		unary_generic_expression.__init__(self , inherited0__operand , )
		self.unary_generic_expression_operand = unary_generic_expression_operand

	@apply
	def unary_generic_expression_operand():
		def fget( self ):
			return self._unary_generic_expression_operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unary_generic_expression_operand is mantatory and can not be set to None')
			if not check_type(value,numeric_expression):
				self._unary_generic_expression_operand = numeric_expression(value)
			else:
				self._unary_generic_expression_operand = value
		return property(**locals())

####################
 # ENTITY bounded_surface #
####################
class bounded_surface(surface):
	'''Entity bounded_surface definition.
	'''
	def __init__( self , inherited0__name ,  ):
		surface.__init__(self , inherited0__name , )

####################
 # ENTITY b_spline_surface #
####################
class b_spline_surface(bounded_surface):
	'''Entity b_spline_surface definition.

	:param u_degree
	:type u_degree:INTEGER

	:param v_degree
	:type v_degree:INTEGER

	:param control_points_list
	:type control_points_list:LIST(2,None,LIST(2,None,'cartesian_point', scope = schema_scope))

	:param surface_form
	:type surface_form:b_spline_surface_form

	:param u_closed
	:type u_closed:LOGICAL

	:param v_closed
	:type v_closed:LOGICAL

	:param self_intersect
	:type self_intersect:LOGICAL

	:param control_points
	:type control_points:ARRAY(0,u_upper,ARRAY(0,v_upper,'cartesian_point', scope = schema_scope))

	:param u_upper
	:type u_upper:INTEGER

	:param v_upper
	:type v_upper:INTEGER
	'''
	def __init__( self , inherited0__name , u_degree,v_degree,control_points_list,surface_form,u_closed,v_closed,self_intersect, ):
		bounded_surface.__init__(self , inherited0__name , )
		self.u_degree = u_degree
		self.v_degree = v_degree
		self.control_points_list = control_points_list
		self.surface_form = surface_form
		self.u_closed = u_closed
		self.v_closed = v_closed
		self.self_intersect = self_intersect

	@apply
	def u_degree():
		def fget( self ):
			return self._u_degree
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_degree is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._u_degree = INTEGER(value)
			else:
				self._u_degree = value
		return property(**locals())

	@apply
	def v_degree():
		def fget( self ):
			return self._v_degree
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_degree is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._v_degree = INTEGER(value)
			else:
				self._v_degree = value
		return property(**locals())

	@apply
	def control_points_list():
		def fget( self ):
			return self._control_points_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument control_points_list is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,LIST(2,None,'cartesian_point', scope = schema_scope))):
				self._control_points_list = LIST(value)
			else:
				self._control_points_list = value
		return property(**locals())

	@apply
	def surface_form():
		def fget( self ):
			return self._surface_form
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument surface_form is mantatory and can not be set to None')
			if not check_type(value,b_spline_surface_form):
				self._surface_form = b_spline_surface_form(value)
			else:
				self._surface_form = value
		return property(**locals())

	@apply
	def u_closed():
		def fget( self ):
			return self._u_closed
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_closed is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._u_closed = LOGICAL(value)
			else:
				self._u_closed = value
		return property(**locals())

	@apply
	def v_closed():
		def fget( self ):
			return self._v_closed
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_closed is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._v_closed = LOGICAL(value)
			else:
				self._v_closed = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())

	@apply
	def control_points():
		def fget( self ):
			attribute_eval = make_array_of_array(self.control_points_list,0,self.u_upper,0,self.v_upper)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument control_points is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def u_upper():
		def fget( self ):
			attribute_eval = (SIZEOF(self.control_points_list) - 1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument u_upper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def v_upper():
		def fget( self ):
			attribute_eval = (SIZEOF(self.control_points_list[1]) - 1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument v_upper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.UNIFORM_SURFACE'  ==  TYPEOF(self))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.QUASI_UNIFORM_SURFACE'  ==  TYPEOF(self)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BEZIER_SURFACE'  ==  TYPEOF(self)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS'  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY uniform_surface #
####################
class uniform_surface(b_spline_surface):
	'''Entity uniform_surface definition.
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect ,  ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )

####################
 # ENTITY externally_defined_symbol #
####################
class externally_defined_symbol(externally_defined_item):
	'''Entity externally_defined_symbol definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )

####################
 # ENTITY pre_defined_item #
####################
class pre_defined_item(BaseEntityClass):
	'''Entity pre_defined_item definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY pre_defined_marker #
####################
class pre_defined_marker(pre_defined_item):
	'''Entity pre_defined_marker definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )

####################
 # ENTITY externally_defined_marker #
####################
class externally_defined_marker(externally_defined_symbol,pre_defined_marker):
	'''Entity externally_defined_marker definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source , inherited2__name ,  ):
		externally_defined_symbol.__init__(self , inherited0__item_id , inherited1__source , )
		pre_defined_marker.__init__(self , inherited2__name , )

####################
 # ENTITY geometrically_bounded_surface_shape_representation #
####################
class geometrically_bounded_surface_shape_representation(shape_representation):
	'''Entity geometrically_bounded_surface_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  >  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY line_profile_tolerance #
####################
class line_profile_tolerance(geometric_tolerance):
	'''Entity line_profile_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))  or  (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY text_style #
####################
class text_style(founded_item):
	'''Entity text_style definition.

	:param name
	:type name:label

	:param character_appearance
	:type character_appearance:character_style_select
	'''
	def __init__( self , name,character_appearance, ):
		founded_item.__init__(self , )
		self.name = name
		self.character_appearance = character_appearance

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def character_appearance():
		def fget( self ):
			return self._character_appearance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument character_appearance is mantatory and can not be set to None')
			if not check_type(value,character_style_select):
				self._character_appearance = character_style_select(value)
			else:
				self._character_appearance = value
		return property(**locals())

####################
 # ENTITY axis1_placement #
####################
class axis1_placement(placement):
	'''Entity axis1_placement definition.

	:param axis
	:type axis:direction

	:param z
	:type z:direction
	'''
	def __init__( self , inherited0__name , inherited1__location , axis, ):
		placement.__init__(self , inherited0__name , inherited1__location , )
		self.axis = axis

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._axis = direction(value)
				else:
					self._axis = value
			else:
				self._axis = value
		return property(**locals())

	@apply
	def z():
		def fget( self ):
			attribute_eval = NVL(normalise(self.axis),self.dummy_gri  ==  direction([0,0,1]))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument z is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY dose_equivalent_measure_with_unit #
####################
class dose_equivalent_measure_with_unit(measure_with_unit):
	'''Entity dose_equivalent_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DOSE_EQUIVALENT_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY beveled_sheet_representation #
####################
class beveled_sheet_representation(shape_representation):
	'''Entity beveled_sheet_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )

####################
 # ENTITY identification_assignment #
####################
class identification_assignment(BaseEntityClass):
	'''Entity identification_assignment definition.

	:param assigned_id
	:type assigned_id:identifier

	:param role
	:type role:identification_role
	'''
	def __init__( self , assigned_id,role, ):
		self.assigned_id = assigned_id
		self.role = role

	@apply
	def assigned_id():
		def fget( self ):
			return self._assigned_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._assigned_id = identifier(value)
			else:
				self._assigned_id = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,identification_role):
				self._role = identification_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY external_identification_assignment #
####################
class external_identification_assignment(identification_assignment):
	'''Entity external_identification_assignment definition.

	:param source
	:type source:external_source
	'''
	def __init__( self , inherited0__assigned_id , inherited1__role , source, ):
		identification_assignment.__init__(self , inherited0__assigned_id , inherited1__role , )
		self.source = source

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source is mantatory and can not be set to None')
			if not check_type(value,external_source):
				self._source = external_source(value)
			else:
				self._source = value
		return property(**locals())

####################
 # ENTITY applied_external_identification_assignment #
####################
class applied_external_identification_assignment(external_identification_assignment):
	'''Entity applied_external_identification_assignment definition.

	:param items
	:type items:SET(1,None,'external_identification_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_id , inherited1__role , inherited2__source , items, ):
		external_identification_assignment.__init__(self , inherited0__assigned_id , inherited1__role , inherited2__source , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'external_identification_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY composite_assembly_definition #
####################
class composite_assembly_definition(product_definition):
	'''Entity composite_assembly_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY csg_shape_representation #
####################
class csg_shape_representation(shape_representation):
	'''Entity csg_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  >  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY explicit_procedural_representation_relationship #
####################
class explicit_procedural_representation_relationship(representation_relationship):
	'''Entity explicit_procedural_representation_relationship definition.

	:param representation_relationship_rep_1
	:type representation_relationship_rep_1:procedural_representation
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , representation_relationship_rep_1, ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
		self.representation_relationship_rep_1 = representation_relationship_rep_1

	@apply
	def representation_relationship_rep_1():
		def fget( self ):
			return self._representation_relationship_rep_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_rep_1 is mantatory and can not be set to None')
			if not check_type(value,procedural_representation):
				self._representation_relationship_rep_1 = procedural_representation(value)
			else:
				self._representation_relationship_rep_1 = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PROCEDURAL_REPRESENTATION'  ==  TYPEOF(self.self.representation_relationship.self.rep_2)))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VARIATIONAL_REPRESENTATION'  ==  TYPEOF(self.self.representation_relationship.self.rep_2))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.representation_relationship.self.rep_1.self.context_of_items  ==  self.self.representation_relationship.self.rep_2.self.context_of_items)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY explicit_procedural_shape_representation_relationship #
####################
class explicit_procedural_shape_representation_relationship(explicit_procedural_representation_relationship):
	'''Entity explicit_procedural_shape_representation_relationship definition.

	:param representation_relationship_rep_1
	:type representation_relationship_rep_1:procedural_shape_representation

	:param representation_relationship_rep_2
	:type representation_relationship_rep_2:shape_representation
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , inherited4__representation_relationship_rep_1 , representation_relationship_rep_1,representation_relationship_rep_2, ):
		explicit_procedural_representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , inherited4__representation_relationship_rep_1 , )
		self.representation_relationship_rep_1 = representation_relationship_rep_1
		self.representation_relationship_rep_2 = representation_relationship_rep_2

	@apply
	def representation_relationship_rep_1():
		def fget( self ):
			return self._representation_relationship_rep_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_rep_1 is mantatory and can not be set to None')
			if not check_type(value,procedural_shape_representation):
				self._representation_relationship_rep_1 = procedural_shape_representation(value)
			else:
				self._representation_relationship_rep_1 = value
		return property(**locals())

	@apply
	def representation_relationship_rep_2():
		def fget( self ):
			return self._representation_relationship_rep_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_rep_2 is mantatory and can not be set to None')
			if not check_type(value,shape_representation):
				self._representation_relationship_rep_2 = shape_representation(value)
			else:
				self._representation_relationship_rep_2 = value
		return property(**locals())

####################
 # ENTITY null_representation_item #
####################
class null_representation_item(representation_item):
	'''Entity null_representation_item definition.
	'''
	def __init__( self , inherited0__name ,  ):
		representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY pre_defined_symbol #
####################
class pre_defined_symbol(pre_defined_item):
	'''Entity pre_defined_symbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )

####################
 # ENTITY pre_defined_dimension_symbol #
####################
class pre_defined_dimension_symbol(pre_defined_symbol):
	'''Entity pre_defined_dimension_symbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_symbol.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['arc length','conical taper','counterbore','countersink','depth','diameter','plus minus','radius','slope','spherical diameter','spherical radius','square'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY bounded_curve #
####################
class bounded_curve(curve):
	'''Entity bounded_curve definition.
	'''
	def __init__( self , inherited0__name ,  ):
		curve.__init__(self , inherited0__name , )

####################
 # ENTITY b_spline_curve #
####################
class b_spline_curve(bounded_curve):
	'''Entity b_spline_curve definition.

	:param degree
	:type degree:INTEGER

	:param control_points_list
	:type control_points_list:LIST(2,None,'cartesian_point', scope = schema_scope)

	:param curve_form
	:type curve_form:b_spline_curve_form

	:param closed_curve
	:type closed_curve:LOGICAL

	:param self_intersect
	:type self_intersect:LOGICAL

	:param control_points
	:type control_points:ARRAY(0,upper_index_on_control_points,'cartesian_point', scope = schema_scope)

	:param upper_index_on_control_points
	:type upper_index_on_control_points:INTEGER
	'''
	def __init__( self , inherited0__name , degree,control_points_list,curve_form,closed_curve,self_intersect, ):
		bounded_curve.__init__(self , inherited0__name , )
		self.degree = degree
		self.control_points_list = control_points_list
		self.curve_form = curve_form
		self.closed_curve = closed_curve
		self.self_intersect = self_intersect

	@apply
	def degree():
		def fget( self ):
			return self._degree
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument degree is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._degree = INTEGER(value)
			else:
				self._degree = value
		return property(**locals())

	@apply
	def control_points_list():
		def fget( self ):
			return self._control_points_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument control_points_list is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'cartesian_point', scope = schema_scope)):
				self._control_points_list = LIST(value)
			else:
				self._control_points_list = value
		return property(**locals())

	@apply
	def curve_form():
		def fget( self ):
			return self._curve_form
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_form is mantatory and can not be set to None')
			if not check_type(value,b_spline_curve_form):
				self._curve_form = b_spline_curve_form(value)
			else:
				self._curve_form = value
		return property(**locals())

	@apply
	def closed_curve():
		def fget( self ):
			return self._closed_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument closed_curve is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._closed_curve = LOGICAL(value)
			else:
				self._closed_curve = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())

	@apply
	def control_points():
		def fget( self ):
			attribute_eval = list_to_array(self.control_points_list,0,self.upper_index_on_control_points)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument control_points is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def upper_index_on_control_points():
		def fget( self ):
			attribute_eval = (SIZEOF(self.control_points_list) - 1)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument upper_index_on_control_points is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.UNIFORM_CURVE'  ==  TYPEOF(self))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.QUASI_UNIFORM_CURVE'  ==  TYPEOF(self)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BEZIER_CURVE'  ==  TYPEOF(self)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS'  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rational_b_spline_curve #
####################
class rational_b_spline_curve(b_spline_curve):
	'''Entity rational_b_spline_curve definition.

	:param weights_data
	:type weights_data:LIST(2,None,'REAL', scope = schema_scope)

	:param weights
	:type weights:ARRAY(0,upper_index_on_control_points,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , weights_data, ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )
		self.weights_data = weights_data

	@apply
	def weights_data():
		def fget( self ):
			return self._weights_data
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument weights_data is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._weights_data = LIST(value)
			else:
				self._weights_data = value
		return property(**locals())

	@apply
	def weights():
		def fget( self ):
			attribute_eval = list_to_array(self.weights_data,0,self.upper_index_on_control_points)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument weights is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.weights_data)  ==  SIZEOF(self.self.b_spline_curve.self.control_points_list))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = curve_weights_positive(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY topological_representation_item #
####################
class topological_representation_item(representation_item):
	'''Entity topological_representation_item definition.
	'''
	def __init__( self , inherited0__name ,  ):
		representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY edge #
####################
class edge(topological_representation_item):
	'''Entity edge definition.

	:param edge_start
	:type edge_start:vertex

	:param edge_end
	:type edge_end:vertex
	'''
	def __init__( self , inherited0__name , edge_start,edge_end, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.edge_start = edge_start
		self.edge_end = edge_end

	@apply
	def edge_start():
		def fget( self ):
			return self._edge_start
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edge_start is mantatory and can not be set to None')
			if not check_type(value,vertex):
				self._edge_start = vertex(value)
			else:
				self._edge_start = value
		return property(**locals())

	@apply
	def edge_end():
		def fget( self ):
			return self._edge_end
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edge_end is mantatory and can not be set to None')
			if not check_type(value,vertex):
				self._edge_end = vertex(value)
			else:
				self._edge_end = value
		return property(**locals())

####################
 # ENTITY subedge #
####################
class subedge(edge):
	'''Entity subedge definition.

	:param parent_edge
	:type parent_edge:edge
	'''
	def __init__( self , inherited0__name , inherited1__edge_start , inherited2__edge_end , parent_edge, ):
		edge.__init__(self , inherited0__name , inherited1__edge_start , inherited2__edge_end , )
		self.parent_edge = parent_edge

	@apply
	def parent_edge():
		def fget( self ):
			return self._parent_edge
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_edge is mantatory and can not be set to None')
			if not check_type(value,edge):
				self._parent_edge = edge(value)
			else:
				self._parent_edge = value
		return property(**locals())

####################
 # ENTITY solid_with_depression #
####################
class solid_with_depression(modified_solid_with_placed_configuration):
	'''Entity solid_with_depression definition.

	:param depth
	:type depth:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , depth, ):
		modified_solid_with_placed_configuration.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , )
		self.depth = depth

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._depth = positive_length_measure(value)
			else:
				self._depth = value
		return property(**locals())

####################
 # ENTITY solid_with_hole #
####################
class solid_with_hole(solid_with_depression):
	'''Entity solid_with_hole definition.
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth ,  ):
		solid_with_depression.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , )

####################
 # ENTITY solid_with_stepped_round_hole #
####################
class solid_with_stepped_round_hole(solid_with_hole):
	'''Entity solid_with_stepped_round_hole definition.

	:param segments
	:type segments:positive_integer

	:param segment_radii
	:type segment_radii:LIST(1,segments,'REAL', scope = schema_scope)

	:param segment_depths
	:type segment_depths:LIST(1,segments,'REAL', scope = schema_scope)

	:param solid_with_depression_depth
	:type solid_with_depression_depth:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , segments,segment_radii,segment_depths, ):
		solid_with_hole.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , )
		self.segments = segments
		self.segment_radii = segment_radii
		self.segment_depths = segment_depths

	@apply
	def segments():
		def fget( self ):
			return self._segments
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument segments is mantatory and can not be set to None')
			if not check_type(value,positive_integer):
				self._segments = positive_integer(value)
			else:
				self._segments = value
		return property(**locals())

	@apply
	def segment_radii():
		def fget( self ):
			return self._segment_radii
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument segment_radii is mantatory and can not be set to None')
			if not check_type(value,LIST(1,segments,'REAL', scope = schema_scope)):
				self._segment_radii = LIST(value)
			else:
				self._segment_radii = value
		return property(**locals())

	@apply
	def segment_depths():
		def fget( self ):
			return self._segment_depths
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument segment_depths is mantatory and can not be set to None')
			if not check_type(value,LIST(1,segments,'REAL', scope = schema_scope)):
				self._segment_depths = LIST(value)
			else:
				self._segment_depths = value
		return property(**locals())

	@apply
	def solid_with_depression_depth():
		def fget( self ):
			attribute_eval = compute_total_depth(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument solid_with_depression_depth is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION'  ==  TYPEOF(self))  and  (SIZEOF(TYPEOF(self)  *  ['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_FLAT_BOTTOM_ROUND_HOLE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_SPHERICAL_BOTTOM_ROUND_HOLE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_FLAT_BOTTOM_ROUND_HOLE'])  !=  0)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY solid_with_conical_bottom_round_hole #
####################
class solid_with_conical_bottom_round_hole(solid_with_stepped_round_hole):
	'''Entity solid_with_conical_bottom_round_hole definition.

	:param semi_apex_angle
	:type semi_apex_angle:positive_plane_angle_measure

	:param tip_radius
	:type tip_radius:non_negative_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__segments , inherited6__segment_radii , inherited7__segment_depths , semi_apex_angle,tip_radius, ):
		solid_with_stepped_round_hole.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__segments , inherited6__segment_radii , inherited7__segment_depths , )
		self.semi_apex_angle = semi_apex_angle
		self.tip_radius = tip_radius

	@apply
	def semi_apex_angle():
		def fget( self ):
			return self._semi_apex_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_apex_angle is mantatory and can not be set to None')
			if not check_type(value,positive_plane_angle_measure):
				self._semi_apex_angle = positive_plane_angle_measure(value)
			else:
				self._semi_apex_angle = value
		return property(**locals())

	@apply
	def tip_radius():
		def fget( self ):
			return self._tip_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tip_radius is mantatory and can not be set to None')
			if not check_type(value,non_negative_length_measure):
				self._tip_radius = non_negative_length_measure(value)
			else:
				self._tip_radius = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.tip_radius  <  self.self.solid_with_stepped_round_hole.self.segment_radii[self.segments])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY geometric_tolerance_with_datum_reference #
####################
class geometric_tolerance_with_datum_reference(geometric_tolerance):
	'''Entity geometric_tolerance_with_datum_reference definition.

	:param datum_system
	:type datum_system:SET(1,None,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , datum_system, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
		self.datum_system = datum_system

	@apply
	def datum_system():
		def fget( self ):
			return self._datum_system
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument datum_system is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'datum_reference', scope = schema_scope)):
				self._datum_system = SET(value)
			else:
				self._datum_system = value
		return property(**locals())

####################
 # ENTITY symmetry_tolerance #
####################
class symmetry_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity symmetry_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_request_assignment #
####################
class action_request_assignment(BaseEntityClass):
	'''Entity action_request_assignment definition.

	:param assigned_action_request
	:type assigned_action_request:versioned_action_request

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_action_request, ):
		self.assigned_action_request = assigned_action_request

	@apply
	def assigned_action_request():
		def fget( self ):
			return self._assigned_action_request
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_action_request is mantatory and can not be set to None')
			if not check_type(value,versioned_action_request):
				self._assigned_action_request = versioned_action_request(value)
			else:
				self._assigned_action_request = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY dimensional_location #
####################
class dimensional_location(shape_aspect_relationship):
	'''Entity dimensional_location definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		shape_aspect_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )

####################
 # ENTITY directed_dimensional_location #
####################
class directed_dimensional_location(dimensional_location):
	'''Entity directed_dimensional_location definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		dimensional_location.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )

####################
 # ENTITY variable_semantics #
####################
class variable_semantics(BaseEntityClass):
	'''Entity variable_semantics definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY expression_conversion_based_unit #
####################
class expression_conversion_based_unit(context_dependent_unit,variable_semantics):
	'''Entity expression_conversion_based_unit definition.

	:param associated_variable_environment
	:type associated_variable_environment:environment
	'''
	def __init__( self , inherited0__dimensions , inherited1__name ,  ):
		context_dependent_unit.__init__(self , inherited0__dimensions , inherited1__name , )
		variable_semantics.__init__(self , )

	@apply
	def associated_variable_environment():
		def fget( self ):
			return self._associated_variable_environment
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument associated_variable_environment is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY colour_specification #
####################
class colour_specification(colour):
	'''Entity colour_specification definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		colour.__init__(self , )
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY externally_defined_colour #
####################
class externally_defined_colour(colour_specification,externally_defined_item):
	'''Entity externally_defined_colour definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_id , inherited2__source ,  ):
		colour_specification.__init__(self , inherited0__name , )
		externally_defined_item.__init__(self , inherited1__item_id , inherited2__source , )

####################
 # ENTITY face_bound #
####################
class face_bound(topological_representation_item):
	'''Entity face_bound definition.

	:param bound
	:type bound:loop

	:param orientation
	:type orientation:BOOLEAN
	'''
	def __init__( self , inherited0__name , bound,orientation, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.bound = bound
		self.orientation = orientation

	@apply
	def bound():
		def fget( self ):
			return self._bound
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bound is mantatory and can not be set to None')
			if not check_type(value,loop):
				self._bound = loop(value)
			else:
				self._bound = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY length_measure_with_unit #
####################
class length_measure_with_unit(measure_with_unit):
	'''Entity length_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY text_string_representation #
####################
class text_string_representation(representation):
	'''Entity text_string_representation definition.

	:param representation_items
	:type representation_items:SET(1,None,'text_string_representation_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_items = representation_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'text_string_representation_item', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY annotation_subfigure_occurrence #
####################
class annotation_subfigure_occurrence(annotation_symbol_occurrence):
	'''Entity annotation_subfigure_occurrence definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item ,  ):
		annotation_symbol_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_SYMBOL'  ==  TYPEOF(self.self.item))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DRAUGHTING_SUBFIGURE_REPRESENTATION'  ==  TYPEOF(self.self.item.self.mapped_item.self.mapping_source.self.mapped_representation))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY data_environment #
####################
class data_environment(BaseEntityClass):
	'''Entity data_environment definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param elements
	:type elements:SET(1,None,'property_definition_representation', scope = schema_scope)
	'''
	def __init__( self , name,description,elements, ):
		self.name = name
		self.description = description
		self.elements = elements

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument elements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'property_definition_representation', scope = schema_scope)):
				self._elements = SET(value)
			else:
				self._elements = value
		return property(**locals())

####################
 # ENTITY solid_with_rectangular_protrusion #
####################
class solid_with_rectangular_protrusion(solid_with_protrusion):
	'''Entity solid_with_rectangular_protrusion definition.

	:param protrusion_length
	:type protrusion_length:positive_length_measure

	:param protrusion_width
	:type protrusion_width:positive_length_measure

	:param protrusion_corner_radius
	:type protrusion_corner_radius:non_negative_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__protrusion_height , inherited5__protrusion_draft_angle , protrusion_length,protrusion_width,protrusion_corner_radius, ):
		solid_with_protrusion.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__protrusion_height , inherited5__protrusion_draft_angle , )
		self.protrusion_length = protrusion_length
		self.protrusion_width = protrusion_width
		self.protrusion_corner_radius = protrusion_corner_radius

	@apply
	def protrusion_length():
		def fget( self ):
			return self._protrusion_length
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument protrusion_length is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._protrusion_length = positive_length_measure(value)
			else:
				self._protrusion_length = value
		return property(**locals())

	@apply
	def protrusion_width():
		def fget( self ):
			return self._protrusion_width
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument protrusion_width is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._protrusion_width = positive_length_measure(value)
			else:
				self._protrusion_width = value
		return property(**locals())

	@apply
	def protrusion_corner_radius():
		def fget( self ):
			return self._protrusion_corner_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument protrusion_corner_radius is mantatory and can not be set to None')
			if not check_type(value,non_negative_length_measure):
				self._protrusion_corner_radius = non_negative_length_measure(value)
			else:
				self._protrusion_corner_radius = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.protrusion_corner_radius  <=  (self.protrusion_width / 2))  and  (self.protrusion_corner_radius  <=  (self.protrusion_length / 2)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY visual_appearance_representation #
####################
class visual_appearance_representation(representation):
	'''Entity visual_appearance_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (((3  <=  SIZEOF(self.self.items))  and  (SIZEOF(self.self.items)  <=  9))  and  (((SIZEOF(None)  +  SIZEOF(None))  +  SIZEOF(None))  ==  SIZEOF(self.self.items)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  <=  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  <=  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  <=  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  <=  1)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  <=  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  <=  1)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  <=  1)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = ((SIZEOF(USEDIN(self,('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PROPERTY_DEFINITION_REPRESENTATION.')  +  'USED_REPRESENTATION'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr


####################
 # ENTITY dated_effectivity #
####################
class dated_effectivity(effectivity):
	'''Entity dated_effectivity definition.

	:param effectivity_end_date
	:type effectivity_end_date:date_time_or_event_occurrence

	:param effectivity_start_date
	:type effectivity_start_date:date_time_or_event_occurrence
	'''
	def __init__( self , inherited0__id , effectivity_end_date,effectivity_start_date, ):
		effectivity.__init__(self , inherited0__id , )
		self.effectivity_end_date = effectivity_end_date
		self.effectivity_start_date = effectivity_start_date

	@apply
	def effectivity_end_date():
		def fget( self ):
			return self._effectivity_end_date
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,date_time_or_event_occurrence):
					self._effectivity_end_date = date_time_or_event_occurrence(value)
				else:
					self._effectivity_end_date = value
			else:
				self._effectivity_end_date = value
		return property(**locals())

	@apply
	def effectivity_start_date():
		def fget( self ):
			return self._effectivity_start_date
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument effectivity_start_date is mantatory and can not be set to None')
			if not check_type(value,date_time_or_event_occurrence):
				self._effectivity_start_date = date_time_or_event_occurrence(value)
			else:
				self._effectivity_start_date = value
		return property(**locals())

####################
 # ENTITY direction #
####################
class direction(geometric_representation_item):
	'''Entity direction definition.

	:param direction_ratios
	:type direction_ratios:LIST(2,3,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , direction_ratios, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.direction_ratios = direction_ratios

	@apply
	def direction_ratios():
		def fget( self ):
			return self._direction_ratios
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument direction_ratios is mantatory and can not be set to None')
			if not check_type(value,LIST(2,3,'REAL', scope = schema_scope)):
				self._direction_ratios = LIST(value)
			else:
				self._direction_ratios = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_concept #
####################
class product_concept(BaseEntityClass):
	'''Entity product_concept definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param market_context
	:type market_context:product_concept_context
	'''
	def __init__( self , id,name,description,market_context, ):
		self.id = id
		self.name = name
		self.description = description
		self.market_context = market_context

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def market_context():
		def fget( self ):
			return self._market_context
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument market_context is mantatory and can not be set to None')
			if not check_type(value,product_concept_context):
				self._market_context = product_concept_context(value)
			else:
				self._market_context = value
		return property(**locals())

####################
 # ENTITY product_class #
####################
class product_class(product_concept,characterized_object):
	'''Entity product_class definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__market_context , inherited4__name , inherited5__description ,  ):
		product_concept.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__market_context , )
		characterized_object.__init__(self , inherited4__name , inherited5__description , )

####################
 # ENTITY text_style_for_defined_font #
####################
class text_style_for_defined_font(BaseEntityClass):
	'''Entity text_style_for_defined_font definition.

	:param text_colour
	:type text_colour:colour
	'''
	def __init__( self , text_colour, ):
		self.text_colour = text_colour

	@apply
	def text_colour():
		def fget( self ):
			return self._text_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument text_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._text_colour = colour(value)
			else:
				self._text_colour = value
		return property(**locals())

####################
 # ENTITY general_property_relationship #
####################
class general_property_relationship(BaseEntityClass):
	'''Entity general_property_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_property
	:type relating_property:general_property

	:param related_property
	:type related_property:general_property
	'''
	def __init__( self , name,description,relating_property,related_property, ):
		self.name = name
		self.description = description
		self.relating_property = relating_property
		self.related_property = related_property

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_property():
		def fget( self ):
			return self._relating_property
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_property is mantatory and can not be set to None')
			if not check_type(value,general_property):
				self._relating_property = general_property(value)
			else:
				self._relating_property = value
		return property(**locals())

	@apply
	def related_property():
		def fget( self ):
			return self._related_property
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_property is mantatory and can not be set to None')
			if not check_type(value,general_property):
				self._related_property = general_property(value)
			else:
				self._related_property = value
		return property(**locals())

####################
 # ENTITY characteristic_data_table_header_decomposition #
####################
class characteristic_data_table_header_decomposition(general_property_relationship):
	'''Entity characteristic_data_table_header_decomposition definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_property , inherited3__related_property ,  ):
		general_property_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_property , inherited3__related_property , )

####################
 # ENTITY light_source #
####################
class light_source(geometric_representation_item):
	'''Entity light_source definition.

	:param light_colour
	:type light_colour:colour
	'''
	def __init__( self , inherited0__name , light_colour, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.light_colour = light_colour

	@apply
	def light_colour():
		def fget( self ):
			return self._light_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument light_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._light_colour = colour(value)
			else:
				self._light_colour = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'STYLED_ITEM.ITEM'))  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY light_source_positional #
####################
class light_source_positional(light_source):
	'''Entity light_source_positional definition.

	:param position
	:type position:cartesian_point

	:param constant_attenuation
	:type constant_attenuation:REAL

	:param distance_attenuation
	:type distance_attenuation:REAL
	'''
	def __init__( self , inherited0__name , inherited1__light_colour , position,constant_attenuation,distance_attenuation, ):
		light_source.__init__(self , inherited0__name , inherited1__light_colour , )
		self.position = position
		self.constant_attenuation = constant_attenuation
		self.distance_attenuation = distance_attenuation

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._position = cartesian_point(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def constant_attenuation():
		def fget( self ):
			return self._constant_attenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constant_attenuation is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._constant_attenuation = REAL(value)
			else:
				self._constant_attenuation = value
		return property(**locals())

	@apply
	def distance_attenuation():
		def fget( self ):
			return self._distance_attenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance_attenuation is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._distance_attenuation = REAL(value)
			else:
				self._distance_attenuation = value
		return property(**locals())

####################
 # ENTITY boolean_result #
####################
class boolean_result(geometric_representation_item):
	'''Entity boolean_result definition.

	:param operator
	:type operator:boolean_operator

	:param first_operand
	:type first_operand:boolean_operand

	:param second_operand
	:type second_operand:boolean_operand
	'''
	def __init__( self , inherited0__name , operator,first_operand,second_operand, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.operator = operator
		self.first_operand = first_operand
		self.second_operand = second_operand

	@apply
	def operator():
		def fget( self ):
			return self._operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operator is mantatory and can not be set to None')
			if not check_type(value,boolean_operator):
				self._operator = boolean_operator(value)
			else:
				self._operator = value
		return property(**locals())

	@apply
	def first_operand():
		def fget( self ):
			return self._first_operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument first_operand is mantatory and can not be set to None')
			if not check_type(value,boolean_operand):
				self._first_operand = boolean_operand(value)
			else:
				self._first_operand = value
		return property(**locals())

	@apply
	def second_operand():
		def fget( self ):
			return self._second_operand
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument second_operand is mantatory and can not be set to None')
			if not check_type(value,boolean_operand):
				self._second_operand = boolean_operand(value)
			else:
				self._second_operand = value
		return property(**locals())

####################
 # ENTITY curve_style_font_and_scaling #
####################
class curve_style_font_and_scaling(founded_item):
	'''Entity curve_style_font_and_scaling definition.

	:param name
	:type name:label

	:param curve_font
	:type curve_font:curve_style_font_select

	:param curve_font_scaling
	:type curve_font_scaling:REAL
	'''
	def __init__( self , name,curve_font,curve_font_scaling, ):
		founded_item.__init__(self , )
		self.name = name
		self.curve_font = curve_font
		self.curve_font_scaling = curve_font_scaling

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def curve_font():
		def fget( self ):
			return self._curve_font
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_font is mantatory and can not be set to None')
			if not check_type(value,curve_style_font_select):
				self._curve_font = curve_style_font_select(value)
			else:
				self._curve_font = value
		return property(**locals())

	@apply
	def curve_font_scaling():
		def fget( self ):
			return self._curve_font_scaling
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_font_scaling is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._curve_font_scaling = REAL(value)
			else:
				self._curve_font_scaling = value
		return property(**locals())

####################
 # ENTITY group_relationship #
####################
class group_relationship(BaseEntityClass):
	'''Entity group_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_group
	:type relating_group:group

	:param related_group
	:type related_group:group
	'''
	def __init__( self , name,description,relating_group,related_group, ):
		self.name = name
		self.description = description
		self.relating_group = relating_group
		self.related_group = related_group

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_group():
		def fget( self ):
			return self._relating_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_group is mantatory and can not be set to None')
			if not check_type(value,group):
				self._relating_group = group(value)
			else:
				self._relating_group = value
		return property(**locals())

	@apply
	def related_group():
		def fget( self ):
			return self._related_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_group is mantatory and can not be set to None')
			if not check_type(value,group):
				self._related_group = group(value)
			else:
				self._related_group = value
		return property(**locals())

####################
 # ENTITY item_identified_representation_usage #
####################
class item_identified_representation_usage(BaseEntityClass):
	'''Entity item_identified_representation_usage definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param definition
	:type definition:represented_definition

	:param used_representation
	:type used_representation:representation

	:param identified_item
	:type identified_item:representation_item
	'''
	def __init__( self , name,description,definition,used_representation,identified_item, ):
		self.name = name
		self.description = description
		self.definition = definition
		self.used_representation = used_representation
		self.identified_item = identified_item

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,represented_definition):
				self._definition = represented_definition(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def used_representation():
		def fget( self ):
			return self._used_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument used_representation is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._used_representation = representation(value)
			else:
				self._used_representation = value
		return property(**locals())

	@apply
	def identified_item():
		def fget( self ):
			return self._identified_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument identified_item is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._identified_item = representation_item(value)
			else:
				self._identified_item = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.used_representation  ==  using_representations(self.self.identified_item))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition_formation_relationship #
####################
class product_definition_formation_relationship(BaseEntityClass):
	'''Entity product_definition_formation_relationship definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_product_definition_formation
	:type relating_product_definition_formation:product_definition_formation

	:param related_product_definition_formation
	:type related_product_definition_formation:product_definition_formation
	'''
	def __init__( self , id,name,description,relating_product_definition_formation,related_product_definition_formation, ):
		self.id = id
		self.name = name
		self.description = description
		self.relating_product_definition_formation = relating_product_definition_formation
		self.related_product_definition_formation = related_product_definition_formation

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_product_definition_formation():
		def fget( self ):
			return self._relating_product_definition_formation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_product_definition_formation is mantatory and can not be set to None')
			if not check_type(value,product_definition_formation):
				self._relating_product_definition_formation = product_definition_formation(value)
			else:
				self._relating_product_definition_formation = value
		return property(**locals())

	@apply
	def related_product_definition_formation():
		def fget( self ):
			return self._related_product_definition_formation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_product_definition_formation is mantatory and can not be set to None')
			if not check_type(value,product_definition_formation):
				self._related_product_definition_formation = product_definition_formation(value)
			else:
				self._related_product_definition_formation = value
		return property(**locals())

####################
 # ENTITY event_occurrence_assignment #
####################
class event_occurrence_assignment(BaseEntityClass):
	'''Entity event_occurrence_assignment definition.

	:param assigned_event_occurrence
	:type assigned_event_occurrence:event_occurrence

	:param role
	:type role:event_occurrence_role
	'''
	def __init__( self , assigned_event_occurrence,role, ):
		self.assigned_event_occurrence = assigned_event_occurrence
		self.role = role

	@apply
	def assigned_event_occurrence():
		def fget( self ):
			return self._assigned_event_occurrence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_event_occurrence is mantatory and can not be set to None')
			if not check_type(value,event_occurrence):
				self._assigned_event_occurrence = event_occurrence(value)
			else:
				self._assigned_event_occurrence = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,event_occurrence_role):
				self._role = event_occurrence_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_event_occurrence_assignment #
####################
class applied_event_occurrence_assignment(event_occurrence_assignment):
	'''Entity applied_event_occurrence_assignment definition.

	:param items
	:type items:SET(1,None,'event_occurrence_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_event_occurrence , inherited1__role , items, ):
		event_occurrence_assignment.__init__(self , inherited0__assigned_event_occurrence , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'event_occurrence_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY next_assembly_usage_occurrence #
####################
class next_assembly_usage_occurrence(assembly_component_usage):
	'''Entity next_assembly_usage_occurrence definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator ,  ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )

####################
 # ENTITY procedural_representation #
####################
class procedural_representation(representation):
	'''Entity procedural_representation definition.

	:param representation_items
	:type representation_items:SET(1,None,'procedural_representation_sequence', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_items = representation_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'procedural_representation_sequence', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())

####################
 # ENTITY procedural_shape_representation #
####################
class procedural_shape_representation(procedural_representation,shape_representation):
	'''Entity procedural_shape_representation definition.

	:param representation_items
	:type representation_items:SET(1,None,'procedural_shape_representation_sequence', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_items , inherited4__name , inherited5__items , inherited6__context_of_items , representation_items, ):
		procedural_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_items , )
		shape_representation.__init__(self , inherited4__name , inherited5__items , inherited6__context_of_items , )
		self.representation_items = representation_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'procedural_shape_representation_sequence', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())

####################
 # ENTITY time_unit #
####################
class time_unit(named_unit):
	'''Entity time_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  1))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY interval_expression #
####################
class interval_expression(boolean_expression,multiple_arity_generic_expression):
	'''Entity interval_expression definition.

	:param interval_high
	:type interval_high:generic_expression

	:param interval_item
	:type interval_item:generic_expression

	:param interval_low
	:type interval_low:generic_expression
	'''
	def __init__( self , inherited0__operands ,  ):
		boolean_expression.__init__(self , )
		multiple_arity_generic_expression.__init__(self , inherited0__operands , )

	@apply
	def interval_high():
		def fget( self ):
			attribute_eval = self.self.multiple_arity_generic_expression.self.operands[3]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument interval_high is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def interval_item():
		def fget( self ):
			attribute_eval = self.self.multiple_arity_generic_expression.self.operands[2]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument interval_item is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def interval_low():
		def fget( self ):
			attribute_eval = self.self.multiple_arity_generic_expression.self.operands[1]
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument interval_low is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.EXPRESSION'  ==  TYPEOF(self.interval_low))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.EXPRESSION'  ==  TYPEOF(self.interval_item)))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.EXPRESSION'  ==  TYPEOF(self.interval_high)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.STRING_EXPRESSION'  ==  TYPEOF(self.self.interval_low))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.STRING_EXPRESSION'  ==  TYPEOF(self.self.interval_high)))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.STRING_EXPRESSION'  ==  TYPEOF(self.self.interval_item)))  or  ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.STRING_EXPRESSION'  ==  TYPEOF(self.self.interval_low))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.NUMERIC_EXPRESSION'  ==  TYPEOF(self.self.interval_item)))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.NUMERIC_EXPRESSION'  ==  TYPEOF(self.self.interval_high))))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY item_defined_transformation #
####################
class item_defined_transformation(BaseEntityClass):
	'''Entity item_defined_transformation definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param transform_item_1
	:type transform_item_1:representation_item

	:param transform_item_2
	:type transform_item_2:representation_item
	'''
	def __init__( self , name,description,transform_item_1,transform_item_2, ):
		self.name = name
		self.description = description
		self.transform_item_1 = transform_item_1
		self.transform_item_2 = transform_item_2

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def transform_item_1():
		def fget( self ):
			return self._transform_item_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transform_item_1 is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._transform_item_1 = representation_item(value)
			else:
				self._transform_item_1 = value
		return property(**locals())

	@apply
	def transform_item_2():
		def fget( self ):
			return self._transform_item_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transform_item_2 is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._transform_item_2 = representation_item(value)
			else:
				self._transform_item_2 = value
		return property(**locals())

####################
 # ENTITY transformation_with_derived_angle #
####################
class transformation_with_derived_angle(item_defined_transformation):
	'''Entity transformation_with_derived_angle definition.

	:param item_defined_transformation_transform_item_1
	:type item_defined_transformation_transform_item_1:angle_direction_reference_with_a2p3d_select

	:param item_defined_transformation_transform_item_2
	:type item_defined_transformation_transform_item_2:axis2_placement_3d

	:param orientation_angle
	:type orientation_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , item_defined_transformation_transform_item_1,item_defined_transformation_transform_item_2, ):
		item_defined_transformation.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , )
		self.item_defined_transformation_transform_item_1 = item_defined_transformation_transform_item_1
		self.item_defined_transformation_transform_item_2 = item_defined_transformation_transform_item_2

	@apply
	def item_defined_transformation_transform_item_1():
		def fget( self ):
			return self._item_defined_transformation_transform_item_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_defined_transformation_transform_item_1 is mantatory and can not be set to None')
			if not check_type(value,angle_direction_reference_with_a2p3d_select):
				self._item_defined_transformation_transform_item_1 = angle_direction_reference_with_a2p3d_select(value)
			else:
				self._item_defined_transformation_transform_item_1 = value
		return property(**locals())

	@apply
	def item_defined_transformation_transform_item_2():
		def fget( self ):
			return self._item_defined_transformation_transform_item_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_defined_transformation_transform_item_2 is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._item_defined_transformation_transform_item_2 = axis2_placement_3d(value)
			else:
				self._item_defined_transformation_transform_item_2 = value
		return property(**locals())

	@apply
	def orientation_angle():
		def fget( self ):
			attribute_eval = derive_angle(self.self.item_defined_transformation.self.transform_item_1,self.self.item_defined_transformation.self.transform_item_2)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument orientation_angle is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((self.self.item_defined_transformation.self.transform_item_1.self.axis2_placement_3d.self.p[3].self.direction_ratios[1]  ==  self.self.item_defined_transformation.self.transform_item_2.self.axis2_placement_3d.self.p[3].self.direction_ratios[1])  and  (self.self.item_defined_transformation.self.transform_item_1.self.axis2_placement_3d.self.p[3].self.direction_ratios[2]  ==  self.self.item_defined_transformation.self.transform_item_2.self.axis2_placement_3d.self.p[3].self.direction_ratios[2]))  and  (self.self.item_defined_transformation.self.transform_item_1.self.axis2_placement_3d.self.p[3].self.direction_ratios[3]  ==  self.self.item_defined_transformation.self.transform_item_2.self.axis2_placement_3d.self.p[3].self.direction_ratios[3]))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY draped_defined_transformation #
####################
class draped_defined_transformation(transformation_with_derived_angle):
	'''Entity draped_defined_transformation definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__item_defined_transformation_transform_item_1 , inherited5__item_defined_transformation_transform_item_2 ,  ):
		transformation_with_derived_angle.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__item_defined_transformation_transform_item_1 , inherited5__item_defined_transformation_transform_item_2 , )

####################
 # ENTITY externally_defined_picture_representation_item #
####################
class externally_defined_picture_representation_item(picture_representation_item):
	'''Entity externally_defined_picture_representation_item definition.

	:param source
	:type source:applied_external_identification_assignment
	'''
	def __init__( self , inherited0__name , inherited1__binary_value ,  ):
		picture_representation_item.__init__(self , inherited0__name , inherited1__binary_value , )

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument source is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not (self.self.representation_item.self.name  ==  self.pre_defined_picture_representation_types))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY mechanical_design_shaded_presentation_representation #
####################
class mechanical_design_shaded_presentation_representation(representation):
	'''Entity mechanical_design_shaded_presentation_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(None)  ==  0)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = (SIZEOF(None)  ==  0)
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr

	def wr15(self):
		eval_wr15_wr = (SIZEOF(None)  ==  0)
		if not eval_wr15_wr:
			raise AssertionError('Rule wr15 violated')
		else:
			return eval_wr15_wr

	def wr16(self):
		eval_wr16_wr = (SIZEOF(None)  ==  0)
		if not eval_wr16_wr:
			raise AssertionError('Rule wr16 violated')
		else:
			return eval_wr16_wr


####################
 # ENTITY oriented_edge #
####################
class oriented_edge(edge):
	'''Entity oriented_edge definition.

	:param edge_element
	:type edge_element:edge

	:param orientation
	:type orientation:BOOLEAN

	:param edge_edge_end
	:type edge_edge_end:vertex

	:param edge_edge_start
	:type edge_edge_start:vertex
	'''
	def __init__( self , inherited0__name , inherited1__edge_start , inherited2__edge_end , edge_element,orientation, ):
		edge.__init__(self , inherited0__name , inherited1__edge_start , inherited2__edge_end , )
		self.edge_element = edge_element
		self.orientation = orientation

	@apply
	def edge_element():
		def fget( self ):
			return self._edge_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edge_element is mantatory and can not be set to None')
			if not check_type(value,edge):
				self._edge_element = edge(value)
			else:
				self._edge_element = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def edge_edge_end():
		def fget( self ):
			attribute_eval = boolean_choose(self.self.orientation,self.self.edge_element.self.edge_end,self.self.edge_element.self.edge_start)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument edge_edge_end is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def edge_edge_start():
		def fget( self ):
			attribute_eval = boolean_choose(self.self.orientation,self.self.edge_element.self.edge_start,self.self.edge_element.self.edge_end)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument edge_edge_start is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORIENTED_EDGE'  ==  TYPEOF(self.self.edge_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY person #
####################
class person(BaseEntityClass):
	'''Entity person definition.

	:param id
	:type id:identifier

	:param last_name
	:type last_name:label

	:param first_name
	:type first_name:label

	:param middle_names
	:type middle_names:LIST(1,None,'STRING', scope = schema_scope)

	:param prefix_titles
	:type prefix_titles:LIST(1,None,'STRING', scope = schema_scope)

	:param suffix_titles
	:type suffix_titles:LIST(1,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , id,last_name,first_name,middle_names,prefix_titles,suffix_titles, ):
		self.id = id
		self.last_name = last_name
		self.first_name = first_name
		self.middle_names = middle_names
		self.prefix_titles = prefix_titles
		self.suffix_titles = suffix_titles

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def last_name():
		def fget( self ):
			return self._last_name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._last_name = label(value)
				else:
					self._last_name = value
			else:
				self._last_name = value
		return property(**locals())

	@apply
	def first_name():
		def fget( self ):
			return self._first_name
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._first_name = label(value)
				else:
					self._first_name = value
			else:
				self._first_name = value
		return property(**locals())

	@apply
	def middle_names():
		def fget( self ):
			return self._middle_names
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._middle_names = LIST(value)
				else:
					self._middle_names = value
			else:
				self._middle_names = value
		return property(**locals())

	@apply
	def prefix_titles():
		def fget( self ):
			return self._prefix_titles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._prefix_titles = LIST(value)
				else:
					self._prefix_titles = value
			else:
				self._prefix_titles = value
		return property(**locals())

	@apply
	def suffix_titles():
		def fget( self ):
			return self._suffix_titles
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
					self._suffix_titles = LIST(value)
				else:
					self._suffix_titles = value
			else:
				self._suffix_titles = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.last_name)  or  EXISTS(self.first_name))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY camera_image #
####################
class camera_image(mapped_item):
	'''Entity camera_image definition.

	:param mapped_item_mapping_source
	:type mapped_item_mapping_source:camera_usage

	:param mapped_item_mapping_target
	:type mapped_item_mapping_target:planar_box
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , mapped_item_mapping_source,mapped_item_mapping_target, ):
		mapped_item.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , )
		self.mapped_item_mapping_source = mapped_item_mapping_source
		self.mapped_item_mapping_target = mapped_item_mapping_target

	@apply
	def mapped_item_mapping_source():
		def fget( self ):
			return self._mapped_item_mapping_source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_source is mantatory and can not be set to None')
			if not check_type(value,camera_usage):
				self._mapped_item_mapping_source = camera_usage(value)
			else:
				self._mapped_item_mapping_source = value
		return property(**locals())

	@apply
	def mapped_item_mapping_target():
		def fget( self ):
			return self._mapped_item_mapping_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_target is mantatory and can not be set to None')
			if not check_type(value,planar_box):
				self._mapped_item_mapping_target = planar_box(value)
			else:
				self._mapped_item_mapping_target = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM'  ==  TYPEOF(self))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY camera_image_3d_with_scale #
####################
class camera_image_3d_with_scale(camera_image):
	'''Entity camera_image_3d_with_scale definition.

	:param scale
	:type scale:positive_ratio_measure
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , inherited3__mapped_item_mapping_source , inherited4__mapped_item_mapping_target ,  ):
		camera_image.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , inherited3__mapped_item_mapping_source , inherited4__mapped_item_mapping_target , )

	@apply
	def scale():
		def fget( self ):
			attribute_eval = (self.self.mapped_item.self.mapping_target.self.planar_extent.self.size_in_x / self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.view_window.self.size_in_x)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument scale is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CAMERA_MODEL_D3'  ==  TYPEOF(self.self.mapped_item.self.mapping_source.self.mapping_origin))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (aspect_ratio(self.self.mapped_item.self.mapping_target)  ==  aspect_ratio(self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.view_window))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.front_plane_clipping  and  self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.view_volume_sides_clipping)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.mapped_item.self.mapping_target.self.planar_extent.self.size_in_x  >  0)  and  (self.self.mapped_item.self.mapping_target.self.planar_extent.self.size_in_y  >  0))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.view_window.self.size_in_x  >  0)  and  (self.self.mapped_item.self.mapping_source.self.mapping_origin.self.camera_model_d3.self.perspective_of_volume.self.view_window.self.size_in_y  >  0))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'AXIS2_PLACEMENT_2D')  ==  TYPEOF(self.self.mapped_item.self.mapping_target.self.planar_box.self.placement))  and  ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'AXIS2_PLACEMENT_3D')  ==  TYPEOF(self.self.mapped_item.self.mapping_target.self.planar_box.self.placement))))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY effectivity_assignment #
####################
class effectivity_assignment(BaseEntityClass):
	'''Entity effectivity_assignment definition.

	:param assigned_effectivity
	:type assigned_effectivity:effectivity

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_effectivity, ):
		self.assigned_effectivity = assigned_effectivity

	@apply
	def assigned_effectivity():
		def fget( self ):
			return self._assigned_effectivity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_effectivity is mantatory and can not be set to None')
			if not check_type(value,effectivity):
				self._assigned_effectivity = effectivity(value)
			else:
				self._assigned_effectivity = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY configured_effectivity_assignment #
####################
class configured_effectivity_assignment(effectivity_assignment):
	'''Entity configured_effectivity_assignment definition.

	:param items
	:type items:SET(1,None,'configured_effectivity_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_effectivity , items, ):
		effectivity_assignment.__init__(self , inherited0__assigned_effectivity , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'configured_effectivity_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.EFFECTIVITY']  *  TYPEOF(self.self.assigned_effectivity))  ==  1)  and  (self.self.assigned_effectivity.self.id  ==  'configuration validity'))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.items)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (self.self.role.self.name  ==  ['design','usage'])
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.role.self.name  !=  'design')  or  (SIZEOF(None)  ==  0))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.role.self.name  !=  'usage')  or  (SIZEOF(None)  ==  0))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (self.self.role.self.description  ==  ['exception','inherited','local'])
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  1)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr


####################
 # ENTITY swept_area_solid #
####################
class swept_area_solid(solid_model):
	'''Entity swept_area_solid definition.

	:param swept_area
	:type swept_area:curve_bounded_surface
	'''
	def __init__( self , inherited0__name , swept_area, ):
		solid_model.__init__(self , inherited0__name , )
		self.swept_area = swept_area

	@apply
	def swept_area():
		def fget( self ):
			return self._swept_area
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument swept_area is mantatory and can not be set to None')
			if not check_type(value,curve_bounded_surface):
				self._swept_area = curve_bounded_surface(value)
			else:
				self._swept_area = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLANE'  ==  TYPEOF(self.swept_area.self.basis_surface))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY revolved_area_solid #
####################
class revolved_area_solid(swept_area_solid):
	'''Entity revolved_area_solid definition.

	:param axis
	:type axis:axis1_placement

	:param angle
	:type angle:plane_angle_measure

	:param axis_line
	:type axis_line:line
	'''
	def __init__( self , inherited0__name , inherited1__swept_area , axis,angle, ):
		swept_area_solid.__init__(self , inherited0__name , inherited1__swept_area , )
		self.axis = axis
		self.angle = angle

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axis is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._axis = axis1_placement(value)
			else:
				self._axis = value
		return property(**locals())

	@apply
	def angle():
		def fget( self ):
			return self._angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._angle = plane_angle_measure(value)
			else:
				self._angle = value
		return property(**locals())

	@apply
	def axis_line():
		def fget( self ):
			attribute_eval = (((representation_item('')  ==  geometric_representation_item())  ==  curve())  ==  line(self.axis.self.location,(representation_item('')  ==  geometric_representation_item())  ==  vector(self.axis.self.z,1)))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument axis_line is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY edge_blended_solid #
####################
class edge_blended_solid(modified_solid):
	'''Entity edge_blended_solid definition.

	:param blended_edges
	:type blended_edges:LIST(1,None,'edge_curve', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , blended_edges, ):
		modified_solid.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , )
		self.blended_edges = blended_edges

	@apply
	def blended_edges():
		def fget( self ):
			return self._blended_edges
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument blended_edges is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'edge_curve', scope = schema_scope)):
				self._blended_edges = LIST(value)
			else:
				self._blended_edges = value
		return property(**locals())

####################
 # ENTITY solid_with_chamfered_edges #
####################
class solid_with_chamfered_edges(edge_blended_solid):
	'''Entity solid_with_chamfered_edges definition.
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges ,  ):
		edge_blended_solid.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , )

####################
 # ENTITY solid_with_single_offset_chamfer #
####################
class solid_with_single_offset_chamfer(solid_with_chamfered_edges):
	'''Entity solid_with_single_offset_chamfer definition.

	:param offset_distance
	:type offset_distance:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , offset_distance, ):
		solid_with_chamfered_edges.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , )
		self.offset_distance = offset_distance

	@apply
	def offset_distance():
		def fget( self ):
			return self._offset_distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offset_distance is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._offset_distance = positive_length_measure(value)
			else:
				self._offset_distance = value
		return property(**locals())

####################
 # ENTITY representation_context #
####################
class representation_context(BaseEntityClass):
	'''Entity representation_context definition.

	:param context_identifier
	:type context_identifier:identifier

	:param context_type
	:type context_type:text

	:param representations_in_context
	:type representations_in_context:SET(1,None,'representation', scope = schema_scope)
	'''
	def __init__( self , context_identifier,context_type, ):
		self.context_identifier = context_identifier
		self.context_type = context_type

	@apply
	def context_identifier():
		def fget( self ):
			return self._context_identifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument context_identifier is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._context_identifier = identifier(value)
			else:
				self._context_identifier = value
		return property(**locals())

	@apply
	def context_type():
		def fget( self ):
			return self._context_type
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument context_type is mantatory and can not be set to None')
			if not check_type(value,text):
				self._context_type = text(value)
			else:
				self._context_type = value
		return property(**locals())

	@apply
	def representations_in_context():
		def fget( self ):
			return self._representations_in_context
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument representations_in_context is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY tagged_text_format #
####################
class tagged_text_format(representation_context):
	'''Entity tagged_text_format definition.
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type ,  ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )

####################
 # ENTITY conversion_based_unit #
####################
class conversion_based_unit(named_unit):
	'''Entity conversion_based_unit definition.

	:param name
	:type name:label

	:param conversion_factor
	:type conversion_factor:measure_with_unit
	'''
	def __init__( self , inherited0__dimensions , name,conversion_factor, ):
		named_unit.__init__(self , inherited0__dimensions , )
		self.name = name
		self.conversion_factor = conversion_factor

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def conversion_factor():
		def fget( self ):
			return self._conversion_factor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument conversion_factor is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._conversion_factor = measure_with_unit(value)
			else:
				self._conversion_factor = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.named_unit.self.dimensions  ==  derive_dimensional_exponents(self.conversion_factor.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY definitional_representation_relationship #
####################
class definitional_representation_relationship(representation_relationship):
	'''Entity definitional_representation_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 ,  ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
	def wr1(self):
		eval_wr1_wr = acyclic_representation_relationship(self,[self.self.representation_relationship.self.rep_2],'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'REPRESENTATION')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY point #
####################
class point(geometric_representation_item):
	'''Entity point definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY point_on_surface #
####################
class point_on_surface(point):
	'''Entity point_on_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param point_parameter_u
	:type point_parameter_u:parameter_value

	:param point_parameter_v
	:type point_parameter_v:parameter_value
	'''
	def __init__( self , inherited0__name , basis_surface,point_parameter_u,point_parameter_v, ):
		point.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.point_parameter_u = point_parameter_u
		self.point_parameter_v = point_parameter_v

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def point_parameter_u():
		def fget( self ):
			return self._point_parameter_u
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument point_parameter_u is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._point_parameter_u = parameter_value(value)
			else:
				self._point_parameter_u = value
		return property(**locals())

	@apply
	def point_parameter_v():
		def fget( self ):
			return self._point_parameter_v
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument point_parameter_v is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._point_parameter_v = parameter_value(value)
			else:
				self._point_parameter_v = value
		return property(**locals())

####################
 # ENTITY product_definition_formation #
####################
class product_definition_formation(BaseEntityClass):
	'''Entity product_definition_formation definition.

	:param id
	:type id:identifier

	:param description
	:type description:text

	:param of_product
	:type of_product:product
	'''
	def __init__( self , id,description,of_product, ):
		self.id = id
		self.description = description
		self.of_product = of_product

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def of_product():
		def fget( self ):
			return self._of_product
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument of_product is mantatory and can not be set to None')
			if not check_type(value,product):
				self._of_product = product(value)
			else:
				self._of_product = value
		return property(**locals())

####################
 # ENTITY surface_curve_swept_area_solid #
####################
class surface_curve_swept_area_solid(swept_area_solid):
	'''Entity surface_curve_swept_area_solid definition.

	:param directrix
	:type directrix:curve

	:param start_param
	:type start_param:REAL

	:param end_param
	:type end_param:REAL

	:param reference_surface
	:type reference_surface:surface
	'''
	def __init__( self , inherited0__name , inherited1__swept_area , directrix,start_param,end_param,reference_surface, ):
		swept_area_solid.__init__(self , inherited0__name , inherited1__swept_area , )
		self.directrix = directrix
		self.start_param = start_param
		self.end_param = end_param
		self.reference_surface = reference_surface

	@apply
	def directrix():
		def fget( self ):
			return self._directrix
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directrix is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._directrix = curve(value)
			else:
				self._directrix = value
		return property(**locals())

	@apply
	def start_param():
		def fget( self ):
			return self._start_param
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument start_param is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._start_param = REAL(value)
			else:
				self._start_param = value
		return property(**locals())

	@apply
	def end_param():
		def fget( self ):
			return self._end_param
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument end_param is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._end_param = REAL(value)
			else:
				self._end_param = value
		return property(**locals())

	@apply
	def reference_surface():
		def fget( self ):
			return self._reference_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reference_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._reference_surface = surface(value)
			else:
				self._reference_surface = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_CURVE'  ==  TYPEOF(self.directrix)))  or  (self.reference_surface  ==  self.directrix.self.surface_curve.self.basis_surface))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY person_and_organization_assignment #
####################
class person_and_organization_assignment(BaseEntityClass):
	'''Entity person_and_organization_assignment definition.

	:param assigned_person_and_organization
	:type assigned_person_and_organization:person_and_organization

	:param role
	:type role:person_and_organization_role
	'''
	def __init__( self , assigned_person_and_organization,role, ):
		self.assigned_person_and_organization = assigned_person_and_organization
		self.role = role

	@apply
	def assigned_person_and_organization():
		def fget( self ):
			return self._assigned_person_and_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_person_and_organization is mantatory and can not be set to None')
			if not check_type(value,person_and_organization):
				self._assigned_person_and_organization = person_and_organization(value)
			else:
				self._assigned_person_and_organization = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,person_and_organization_role):
				self._role = person_and_organization_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY cc_design_person_and_organization_assignment #
####################
class cc_design_person_and_organization_assignment(person_and_organization_assignment):
	'''Entity cc_design_person_and_organization_assignment definition.

	:param items
	:type items:SET(1,None,'cc_person_organization_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_person_and_organization , inherited1__role , items, ):
		person_and_organization_assignment.__init__(self , inherited0__assigned_person_and_organization , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'cc_person_organization_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = cc_design_person_and_organization_correlation(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY characteristic_type #
####################
class characteristic_type(group):
	'''Entity characteristic_type definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY annotation_occurrence_relationship #
####################
class annotation_occurrence_relationship(BaseEntityClass):
	'''Entity annotation_occurrence_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_annotation_occurrence
	:type relating_annotation_occurrence:annotation_occurrence

	:param related_annotation_occurrence
	:type related_annotation_occurrence:annotation_occurrence
	'''
	def __init__( self , name,description,relating_annotation_occurrence,related_annotation_occurrence, ):
		self.name = name
		self.description = description
		self.relating_annotation_occurrence = relating_annotation_occurrence
		self.related_annotation_occurrence = related_annotation_occurrence

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_annotation_occurrence():
		def fget( self ):
			return self._relating_annotation_occurrence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_annotation_occurrence is mantatory and can not be set to None')
			if not check_type(value,annotation_occurrence):
				self._relating_annotation_occurrence = annotation_occurrence(value)
			else:
				self._relating_annotation_occurrence = value
		return property(**locals())

	@apply
	def related_annotation_occurrence():
		def fget( self ):
			return self._related_annotation_occurrence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_annotation_occurrence is mantatory and can not be set to None')
			if not check_type(value,annotation_occurrence):
				self._related_annotation_occurrence = annotation_occurrence(value)
			else:
				self._related_annotation_occurrence = value
		return property(**locals())

####################
 # ENTITY annotation_occurrence_associativity #
####################
class annotation_occurrence_associativity(annotation_occurrence_relationship):
	'''Entity annotation_occurrence_associativity definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_annotation_occurrence , inherited3__related_annotation_occurrence ,  ):
		annotation_occurrence_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_annotation_occurrence , inherited3__related_annotation_occurrence , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(TYPEOF(self.self.related_annotation_occurrence)  *  ['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PROJECTION_CURVE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LEADER_CURVE'])  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY dimension_curve_terminator_to_projection_curve_associativity #
####################
class dimension_curve_terminator_to_projection_curve_associativity(annotation_occurrence_associativity):
	'''Entity dimension_curve_terminator_to_projection_curve_associativity definition.

	:param annotation_occurrence_relationship_related_annotation_occurrence
	:type annotation_occurrence_relationship_related_annotation_occurrence:projection_curve

	:param annotation_occurrence_relationship_relating_annotation_occurrence
	:type annotation_occurrence_relationship_relating_annotation_occurrence:dimension_curve_terminator
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_annotation_occurrence , inherited3__related_annotation_occurrence , annotation_occurrence_relationship_related_annotation_occurrence,annotation_occurrence_relationship_relating_annotation_occurrence, ):
		annotation_occurrence_associativity.__init__(self , inherited0__name , inherited1__description , inherited2__relating_annotation_occurrence , inherited3__related_annotation_occurrence , )
		self.annotation_occurrence_relationship_related_annotation_occurrence = annotation_occurrence_relationship_related_annotation_occurrence
		self.annotation_occurrence_relationship_relating_annotation_occurrence = annotation_occurrence_relationship_relating_annotation_occurrence

	@apply
	def annotation_occurrence_relationship_related_annotation_occurrence():
		def fget( self ):
			return self._annotation_occurrence_relationship_related_annotation_occurrence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument annotation_occurrence_relationship_related_annotation_occurrence is mantatory and can not be set to None')
			if not check_type(value,projection_curve):
				self._annotation_occurrence_relationship_related_annotation_occurrence = projection_curve(value)
			else:
				self._annotation_occurrence_relationship_related_annotation_occurrence = value
		return property(**locals())

	@apply
	def annotation_occurrence_relationship_relating_annotation_occurrence():
		def fget( self ):
			return self._annotation_occurrence_relationship_relating_annotation_occurrence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument annotation_occurrence_relationship_relating_annotation_occurrence is mantatory and can not be set to None')
			if not check_type(value,dimension_curve_terminator):
				self._annotation_occurrence_relationship_relating_annotation_occurrence = dimension_curve_terminator(value)
			else:
				self._annotation_occurrence_relationship_relating_annotation_occurrence = value
		return property(**locals())

####################
 # ENTITY offset_curve_3d #
####################
class offset_curve_3d(curve):
	'''Entity offset_curve_3d definition.

	:param basis_curve
	:type basis_curve:curve

	:param distance
	:type distance:length_measure

	:param self_intersect
	:type self_intersect:LOGICAL

	:param ref_direction
	:type ref_direction:direction
	'''
	def __init__( self , inherited0__name , basis_curve,distance,self_intersect,ref_direction, ):
		curve.__init__(self , inherited0__name , )
		self.basis_curve = basis_curve
		self.distance = distance
		self.self_intersect = self_intersect
		self.ref_direction = ref_direction

	@apply
	def basis_curve():
		def fget( self ):
			return self._basis_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._basis_curve = curve(value)
			else:
				self._basis_curve = value
		return property(**locals())

	@apply
	def distance():
		def fget( self ):
			return self._distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._distance = length_measure(value)
			else:
				self._distance = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())

	@apply
	def ref_direction():
		def fget( self ):
			return self._ref_direction
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ref_direction is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._ref_direction = direction(value)
			else:
				self._ref_direction = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.basis_curve.self.dim  ==  3)  and  (self.ref_direction.self.dim  ==  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY point_style #
####################
class point_style(founded_item):
	'''Entity point_style definition.

	:param name
	:type name:label

	:param marker
	:type marker:marker_select

	:param marker_size
	:type marker_size:size_select

	:param marker_colour
	:type marker_colour:colour
	'''
	def __init__( self , name,marker,marker_size,marker_colour, ):
		founded_item.__init__(self , )
		self.name = name
		self.marker = marker
		self.marker_size = marker_size
		self.marker_colour = marker_colour

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def marker():
		def fget( self ):
			return self._marker
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument marker is mantatory and can not be set to None')
			if not check_type(value,marker_select):
				self._marker = marker_select(value)
			else:
				self._marker = value
		return property(**locals())

	@apply
	def marker_size():
		def fget( self ):
			return self._marker_size
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument marker_size is mantatory and can not be set to None')
			if not check_type(value,size_select):
				self._marker_size = size_select(value)
			else:
				self._marker_size = value
		return property(**locals())

	@apply
	def marker_colour():
		def fget( self ):
			return self._marker_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument marker_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._marker_colour = colour(value)
			else:
				self._marker_colour = value
		return property(**locals())

####################
 # ENTITY polar_complex_number_literal #
####################
class polar_complex_number_literal(generic_literal):
	'''Entity polar_complex_number_literal definition.

	:param radius
	:type radius:REAL

	:param angle
	:type angle:REAL
	'''
	def __init__( self , radius,angle, ):
		generic_literal.__init__(self , )
		self.radius = radius
		self.angle = angle

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._radius = REAL(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def angle():
		def fget( self ):
			return self._angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._angle = REAL(value)
			else:
				self._angle = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.radius  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((0  <=  self.angle)  and  (self.angle  <  (2  *   PI )))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY scattering_parameter #
####################
class scattering_parameter(polar_complex_number_literal):
	'''Entity scattering_parameter definition.
	'''
	def __init__( self , inherited0__radius , inherited1__angle ,  ):
		polar_complex_number_literal.__init__(self , inherited0__radius , inherited1__angle , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(TYPEOF(self) - TYPEOF(self.self.polar_complex_number_literal  ==  self.self.scattering_parameter))  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY approval #
####################
class approval(BaseEntityClass):
	'''Entity approval definition.

	:param status
	:type status:approval_status

	:param level
	:type level:label
	'''
	def __init__( self , status,level, ):
		self.status = status
		self.level = level

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument status is mantatory and can not be set to None')
			if not check_type(value,approval_status):
				self._status = approval_status(value)
			else:
				self._status = value
		return property(**locals())

	@apply
	def level():
		def fget( self ):
			return self._level
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument level is mantatory and can not be set to None')
			if not check_type(value,label):
				self._level = label(value)
			else:
				self._level = value
		return property(**locals())

####################
 # ENTITY composite_curve #
####################
class composite_curve(bounded_curve):
	'''Entity composite_curve definition.

	:param segments
	:type segments:LIST(1,None,'composite_curve_segment', scope = schema_scope)

	:param self_intersect
	:type self_intersect:LOGICAL

	:param closed_curve
	:type closed_curve:LOGICAL

	:param n_segments
	:type n_segments:INTEGER
	'''
	def __init__( self , inherited0__name , segments,self_intersect, ):
		bounded_curve.__init__(self , inherited0__name , )
		self.segments = segments
		self.self_intersect = self_intersect

	@apply
	def segments():
		def fget( self ):
			return self._segments
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument segments is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'composite_curve_segment', scope = schema_scope)):
				self._segments = LIST(value)
			else:
				self._segments = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())

	@apply
	def closed_curve():
		def fget( self ):
			attribute_eval = (self.segments[self.n_segments].self.transition  !=  discontinuous)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument closed_curve is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def n_segments():
		def fget( self ):
			attribute_eval = SIZEOF(self.segments)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument n_segments is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((( not self.closed_curve)  and  (SIZEOF(None)  ==  1))  or  (self.closed_curve  and  (SIZEOF(None)  ==  0)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY composite_curve_on_surface #
####################
class composite_curve_on_surface(composite_curve):
	'''Entity composite_curve_on_surface definition.

	:param basis_surface
	:type basis_surface:SET(0,2,'surface', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__segments , inherited2__self_intersect ,  ):
		composite_curve.__init__(self , inherited0__name , inherited1__segments , inherited2__self_intersect , )

	@apply
	def basis_surface():
		def fget( self ):
			attribute_eval = get_basis_surface(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument basis_surface is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.basis_surface)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = constraints_composite_curve_on_surface(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY boundary_curve #
####################
class boundary_curve(composite_curve_on_surface):
	'''Entity boundary_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__segments , inherited2__self_intersect ,  ):
		composite_curve_on_surface.__init__(self , inherited0__name , inherited1__segments , inherited2__self_intersect , )
	def wr1(self):
		eval_wr1_wr = self.self.composite_curve.self.closed_curve
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY event_occurrence_role #
####################
class event_occurrence_role(BaseEntityClass):
	'''Entity event_occurrence_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY fill_area_style_tile_coloured_region #
####################
class fill_area_style_tile_coloured_region(geometric_representation_item):
	'''Entity fill_area_style_tile_coloured_region definition.

	:param closed_curve
	:type closed_curve:curve_or_annotation_curve_occurrence

	:param region_colour
	:type region_colour:colour
	'''
	def __init__( self , inherited0__name , closed_curve,region_colour, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.closed_curve = closed_curve
		self.region_colour = region_colour

	@apply
	def closed_curve():
		def fget( self ):
			return self._closed_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument closed_curve is mantatory and can not be set to None')
			if not check_type(value,curve_or_annotation_curve_occurrence):
				self._closed_curve = curve_or_annotation_curve_occurrence(value)
			else:
				self._closed_curve = value
		return property(**locals())

	@apply
	def region_colour():
		def fget( self ):
			return self._region_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument region_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._region_colour = colour(value)
			else:
				self._region_colour = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((((( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE'  ==  TYPEOF(self.closed_curve)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CIRCLE'  ==  TYPEOF(self.closed_curve)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELLIPSE'  ==  TYPEOF(self.closed_curve)))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_CURVE'  ==  TYPEOF(self.closed_curve))  and  (self.closed_curve.self.b_spline_curve.self.closed_curve  ==  TRUE)))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_CURVE'  ==  TYPEOF(self.closed_curve))  and  (self.closed_curve.self.composite_curve.self.closed_curve  ==  TRUE)))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE'  ==  TYPEOF(self.closed_curve))  and  (self.closed_curve.self.polyline.self.points[LOINDEX(self.closed_curve.self.polyline.self.points)]  ==  self.closed_curve.self.polyline.self.points[HIINDEX(self.closed_curve.self.polyline.self.points)])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY geometric_representation_context #
####################
class geometric_representation_context(representation_context):
	'''Entity geometric_representation_context definition.

	:param coordinate_space_dimension
	:type coordinate_space_dimension:dimension_count
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type , coordinate_space_dimension, ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )
		self.coordinate_space_dimension = coordinate_space_dimension

	@apply
	def coordinate_space_dimension():
		def fget( self ):
			return self._coordinate_space_dimension
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordinate_space_dimension is mantatory and can not be set to None')
			if not check_type(value,dimension_count):
				self._coordinate_space_dimension = dimension_count(value)
			else:
				self._coordinate_space_dimension = value
		return property(**locals())

####################
 # ENTITY range_characteristic #
####################
class range_characteristic(representation,descriptive_representation_item):
	'''Entity range_characteristic definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__name , inherited4__description ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		descriptive_representation_item.__init__(self , inherited3__name , inherited4__description , )
	def wr1(self):
		eval_wr1_wr = ( not (self.self.representation.self.name  ==  ['tolerance','minimum tolerance','maximum tolerance','nominal tolerance','plus minus tolerance','symmetrical tolerance','statistical tolerance']))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY date_assignment #
####################
class date_assignment(BaseEntityClass):
	'''Entity date_assignment definition.

	:param assigned_date
	:type assigned_date:date

	:param role
	:type role:date_role
	'''
	def __init__( self , assigned_date,role, ):
		self.assigned_date = assigned_date
		self.role = role

	@apply
	def assigned_date():
		def fget( self ):
			return self._assigned_date
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_date is mantatory and can not be set to None')
			if not check_type(value,date):
				self._assigned_date = date(value)
			else:
				self._assigned_date = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,date_role):
				self._role = date_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_date_assignment #
####################
class applied_date_assignment(date_assignment):
	'''Entity applied_date_assignment definition.

	:param items
	:type items:SET(1,None,'date_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_date , inherited1__role , items, ):
		date_assignment.__init__(self , inherited0__assigned_date , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'date_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY celsius_temperature_measure_with_unit #
####################
class celsius_temperature_measure_with_unit(measure_with_unit):
	'''Entity celsius_temperature_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY draughting_annotation_occurrence #
####################
class draughting_annotation_occurrence(annotation_occurrence):
	'''Entity draughting_annotation_occurrence definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item ,  ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
	def wr1(self):
		eval_wr1_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_CURVE_OCCURRENCE'  ==  TYPEOF(self)))  or  (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE'  ==  TYPEOF(self)))  or  (SIZEOF(None)  ==  0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE'  ==  TYPEOF(self)))  or  (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE'  ==  TYPEOF(self)))  or  (SIZEOF(None)  ==  0))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE'  ==  TYPEOF(self))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_SYMBOL'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DRAUGHTING_SYMBOL_REPRESENTATION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DRAUGHTING_SUBFIGURE_REPRESENTATION']  *  TYPEOF(self.self.item.self.mapped_item.self.mapping_source.self.mapped_representation))  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self)))  or  (SIZEOF(None)  ==  0))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self)))  or  (SIZEOF(TYPEOF(self.self.item)  *  ['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_TEXT','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TEXT_LITERAL'])  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_TEXT'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(None)  ==  0))
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TEXT_LITERAL'  ==  TYPEOF(self.self.item))))  or  (self.self.item.self.text_literal.self.alignment  ==  ['baseline left','baseline centre','baseline right']))
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_TEXT'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(None)  ==  0))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_TEXT'  ==  TYPEOF(self.self.item))))  or  check_text_alignment(self.self.item))
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_TEXT'  ==  TYPEOF(self.self.item))))  or  check_text_font(self.self.item))
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_TEXT'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(None)  ==  0))
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TEXT_LITERAL_WITH_ASSOCIATED_CURVES'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(None)  ==  0))
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr

	def wr15(self):
		eval_wr15_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'  ==  TYPEOF(self))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES'  ==  TYPEOF(self.self.item))))  or  (SIZEOF(None)  ==  0))
		if not eval_wr15_wr:
			raise AssertionError('Rule wr15 violated')
		else:
			return eval_wr15_wr

	def wr16(self):
		eval_wr16_wr = (SIZEOF(None)  ==  0)
		if not eval_wr16_wr:
			raise AssertionError('Rule wr16 violated')
		else:
			return eval_wr16_wr

	def wr17(self):
		eval_wr17_wr = (SIZEOF(None)  ==  0)
		if not eval_wr17_wr:
			raise AssertionError('Rule wr17 violated')
		else:
			return eval_wr17_wr

	def wr18(self):
		eval_wr18_wr = (SIZEOF(None)  ==  0)
		if not eval_wr18_wr:
			raise AssertionError('Rule wr18 violated')
		else:
			return eval_wr18_wr

	def wr19(self):
		eval_wr19_wr = (SIZEOF(None)  ==  0)
		if not eval_wr19_wr:
			raise AssertionError('Rule wr19 violated')
		else:
			return eval_wr19_wr

	def wr20(self):
		eval_wr20_wr = (SIZEOF(None)  ==  0)
		if not eval_wr20_wr:
			raise AssertionError('Rule wr20 violated')
		else:
			return eval_wr20_wr


####################
 # ENTITY value_range #
####################
class value_range(compound_representation_item):
	'''Entity value_range definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )
	def wr1(self):
		eval_wr1_wr = ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'SET_REPRESENTATION_ITEM')  ==  TYPEOF(self.item_element))  and  value_range_wr1(self.item_element))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = value_range_wr2(self.item_element)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = value_range_wr3(self.item_element)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY frequency_unit #
####################
class frequency_unit(derived_unit):
	'''Entity frequency_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.hertz))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_frequency_unit #
####################
class si_frequency_unit(frequency_unit,si_unit):
	'''Entity si_frequency_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		frequency_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.hertz)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY surface_style_reflectance_ambient #
####################
class surface_style_reflectance_ambient(BaseEntityClass):
	'''Entity surface_style_reflectance_ambient definition.

	:param ambient_reflectance
	:type ambient_reflectance:REAL
	'''
	def __init__( self , ambient_reflectance, ):
		self.ambient_reflectance = ambient_reflectance

	@apply
	def ambient_reflectance():
		def fget( self ):
			return self._ambient_reflectance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ambient_reflectance is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._ambient_reflectance = REAL(value)
			else:
				self._ambient_reflectance = value
		return property(**locals())

####################
 # ENTITY surface_style_reflectance_ambient_diffuse #
####################
class surface_style_reflectance_ambient_diffuse(surface_style_reflectance_ambient):
	'''Entity surface_style_reflectance_ambient_diffuse definition.

	:param diffuse_reflectance
	:type diffuse_reflectance:REAL
	'''
	def __init__( self , inherited0__ambient_reflectance , diffuse_reflectance, ):
		surface_style_reflectance_ambient.__init__(self , inherited0__ambient_reflectance , )
		self.diffuse_reflectance = diffuse_reflectance

	@apply
	def diffuse_reflectance():
		def fget( self ):
			return self._diffuse_reflectance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument diffuse_reflectance is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._diffuse_reflectance = REAL(value)
			else:
				self._diffuse_reflectance = value
		return property(**locals())

####################
 # ENTITY action_status #
####################
class action_status(BaseEntityClass):
	'''Entity action_status definition.

	:param status
	:type status:label

	:param assigned_action
	:type assigned_action:executed_action
	'''
	def __init__( self , status,assigned_action, ):
		self.status = status
		self.assigned_action = assigned_action

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument status is mantatory and can not be set to None')
			if not check_type(value,label):
				self._status = label(value)
			else:
				self._status = value
		return property(**locals())

	@apply
	def assigned_action():
		def fget( self ):
			return self._assigned_action
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_action is mantatory and can not be set to None')
			if not check_type(value,executed_action):
				self._assigned_action = executed_action(value)
			else:
				self._assigned_action = value
		return property(**locals())

####################
 # ENTITY draughting_callout_relationship #
####################
class draughting_callout_relationship(BaseEntityClass):
	'''Entity draughting_callout_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_draughting_callout
	:type relating_draughting_callout:draughting_callout

	:param related_draughting_callout
	:type related_draughting_callout:draughting_callout
	'''
	def __init__( self , name,description,relating_draughting_callout,related_draughting_callout, ):
		self.name = name
		self.description = description
		self.relating_draughting_callout = relating_draughting_callout
		self.related_draughting_callout = related_draughting_callout

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_draughting_callout():
		def fget( self ):
			return self._relating_draughting_callout
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_draughting_callout is mantatory and can not be set to None')
			if not check_type(value,draughting_callout):
				self._relating_draughting_callout = draughting_callout(value)
			else:
				self._relating_draughting_callout = value
		return property(**locals())

	@apply
	def related_draughting_callout():
		def fget( self ):
			return self._related_draughting_callout
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_draughting_callout is mantatory and can not be set to None')
			if not check_type(value,draughting_callout):
				self._related_draughting_callout = draughting_callout(value)
			else:
				self._related_draughting_callout = value
		return property(**locals())

####################
 # ENTITY dimension_pair #
####################
class dimension_pair(draughting_callout_relationship):
	'''Entity dimension_pair definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout ,  ):
		draughting_callout_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['chained','parallel'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(TYPEOF(self.self.relating_draughting_callout)  *  ['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANGULAR_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIAMETER_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINEAR_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORDINATE_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RADIUS_DIMENSION'])  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(TYPEOF(self.self.related_draughting_callout)  *  ['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANGULAR_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIAMETER_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINEAR_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORDINATE_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RADIUS_DIMENSION'])  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY draughting_title #
####################
class draughting_title(BaseEntityClass):
	'''Entity draughting_title definition.

	:param items
	:type items:SET(1,None,'draughting_titled_item', scope = schema_scope)

	:param language
	:type language:label

	:param contents
	:type contents:text
	'''
	def __init__( self , items,language,contents, ):
		self.items = items
		self.language = language
		self.contents = contents

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'draughting_titled_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def language():
		def fget( self ):
			return self._language
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument language is mantatory and can not be set to None')
			if not check_type(value,label):
				self._language = label(value)
			else:
				self._language = value
		return property(**locals())

	@apply
	def contents():
		def fget( self ):
			return self._contents
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument contents is mantatory and can not be set to None')
			if not check_type(value,text):
				self._contents = text(value)
			else:
				self._contents = value
		return property(**locals())

####################
 # ENTITY application_context #
####################
class application_context(BaseEntityClass):
	'''Entity application_context definition.

	:param application
	:type application:label

	:param description
	:type description:text

	:param id
	:type id:identifier

	:param context_elements
	:type context_elements:SET(1,None,'application_context_element', scope = schema_scope)
	'''
	def __init__( self , application, ):
		self.application = application

	@apply
	def application():
		def fget( self ):
			return self._application
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument application is mantatory and can not be set to None')
			if not check_type(value,label):
				self._application = label(value)
			else:
				self._application = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def context_elements():
		def fget( self ):
			return self._context_elements
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument context_elements is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY presented_item #
####################
class presented_item(BaseEntityClass):
	'''Entity presented_item definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY applied_presented_item #
####################
class applied_presented_item(presented_item):
	'''Entity applied_presented_item definition.

	:param items
	:type items:SET(1,None,'presented_item_select', scope = schema_scope)
	'''
	def __init__( self , items, ):
		presented_item.__init__(self , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'presented_item_select', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY change_request #
####################
class change_request(action_request_assignment):
	'''Entity change_request definition.

	:param items
	:type items:SET(1,None,'change_request_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action_request , items, ):
		action_request_assignment.__init__(self , inherited0__assigned_action_request , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'change_request_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY date_and_time #
####################
class date_and_time(BaseEntityClass):
	'''Entity date_and_time definition.

	:param date_component
	:type date_component:date

	:param time_component
	:type time_component:local_time
	'''
	def __init__( self , date_component,time_component, ):
		self.date_component = date_component
		self.time_component = time_component

	@apply
	def date_component():
		def fget( self ):
			return self._date_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument date_component is mantatory and can not be set to None')
			if not check_type(value,date):
				self._date_component = date(value)
			else:
				self._date_component = value
		return property(**locals())

	@apply
	def time_component():
		def fget( self ):
			return self._time_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument time_component is mantatory and can not be set to None')
			if not check_type(value,local_time):
				self._time_component = local_time(value)
			else:
				self._time_component = value
		return property(**locals())

####################
 # ENTITY point_and_vector #
####################
class point_and_vector(compound_representation_item,geometric_representation_item):
	'''Entity point_and_vector definition.

	:param compound_representation_item_item_element
	:type compound_representation_item_item_element:LIST(2,3,'point_and_vector_member', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__item_element , inherited2__name , compound_representation_item_item_element, ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )
		geometric_representation_item.__init__(self , inherited2__name , )
		self.compound_representation_item_item_element = compound_representation_item_item_element

	@apply
	def compound_representation_item_item_element():
		def fget( self ):
			return self._compound_representation_item_item_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument compound_representation_item_item_element is mantatory and can not be set to None')
			if not check_type(value,LIST(2,3,'point_and_vector_member', scope = schema_scope)):
				self._compound_representation_item_item_element = LIST(value)
			else:
				self._compound_representation_item_item_element = value
		return property(**locals())

####################
 # ENTITY derived_shape_aspect #
####################
class derived_shape_aspect(shape_aspect):
	'''Entity derived_shape_aspect definition.

	:param deriving_relationships
	:type deriving_relationships:SET(1,None,'shape_aspect_relationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )

	@apply
	def deriving_relationships():
		def fget( self ):
			return self._deriving_relationships
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument deriving_relationships is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY apex #
####################
class apex(derived_shape_aspect):
	'''Entity apex definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )

####################
 # ENTITY force_measure_with_unit #
####################
class force_measure_with_unit(measure_with_unit):
	'''Entity force_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.FORCE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY application_context_element #
####################
class application_context_element(BaseEntityClass):
	'''Entity application_context_element definition.

	:param name
	:type name:label

	:param frame_of_reference
	:type frame_of_reference:application_context
	'''
	def __init__( self , name,frame_of_reference, ):
		self.name = name
		self.frame_of_reference = frame_of_reference

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def frame_of_reference():
		def fget( self ):
			return self._frame_of_reference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument frame_of_reference is mantatory and can not be set to None')
			if not check_type(value,application_context):
				self._frame_of_reference = application_context(value)
			else:
				self._frame_of_reference = value
		return property(**locals())

####################
 # ENTITY product_definition_context #
####################
class product_definition_context(application_context_element):
	'''Entity product_definition_context definition.

	:param life_cycle_stage
	:type life_cycle_stage:label
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , life_cycle_stage, ):
		application_context_element.__init__(self , inherited0__name , inherited1__frame_of_reference , )
		self.life_cycle_stage = life_cycle_stage

	@apply
	def life_cycle_stage():
		def fget( self ):
			return self._life_cycle_stage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument life_cycle_stage is mantatory and can not be set to None')
			if not check_type(value,label):
				self._life_cycle_stage = label(value)
			else:
				self._life_cycle_stage = value
		return property(**locals())

####################
 # ENTITY instance_usage_context_assignment #
####################
class instance_usage_context_assignment(product_definition_context):
	'''Entity instance_usage_context_assignment definition.

	:param items
	:type items:SET(1,None,'instance_usage_context_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , inherited2__life_cycle_stage , items, ):
		product_definition_context.__init__(self , inherited0__name , inherited1__frame_of_reference , inherited2__life_cycle_stage , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'instance_usage_context_select', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY tolerance_value #
####################
class tolerance_value(BaseEntityClass):
	'''Entity tolerance_value definition.

	:param lower_bound
	:type lower_bound:measure_with_unit

	:param upper_bound
	:type upper_bound:measure_with_unit

	:param lbvc
	:type lbvc:REAL

	:param ubvc
	:type ubvc:REAL
	'''
	def __init__( self , lower_bound,upper_bound, ):
		self.lower_bound = lower_bound
		self.upper_bound = upper_bound

	@apply
	def lower_bound():
		def fget( self ):
			return self._lower_bound
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument lower_bound is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._lower_bound = measure_with_unit(value)
			else:
				self._lower_bound = value
		return property(**locals())

	@apply
	def upper_bound():
		def fget( self ):
			return self._upper_bound
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_bound is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._upper_bound = measure_with_unit(value)
			else:
				self._upper_bound = value
		return property(**locals())

	@apply
	def lbvc():
		def fget( self ):
			attribute_eval = self.lower_bound.self.measure_with_unit.self.value_component
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument lbvc is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def ubvc():
		def fget( self ):
			attribute_eval = self.upper_bound.self.measure_with_unit.self.value_component
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ubvc is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.ubvc  >  self.lbvc)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.upper_bound.self.measure_with_unit.self.unit_component  ==  self.lower_bound.self.measure_with_unit.self.unit_component)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY approval_date_time #
####################
class approval_date_time(BaseEntityClass):
	'''Entity approval_date_time definition.

	:param date_time
	:type date_time:date_time_select

	:param dated_approval
	:type dated_approval:approval

	:param role
	:type role:object_role
	'''
	def __init__( self , date_time,dated_approval, ):
		self.date_time = date_time
		self.dated_approval = dated_approval

	@apply
	def date_time():
		def fget( self ):
			return self._date_time
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument date_time is mantatory and can not be set to None')
			if not check_type(value,date_time_select):
				self._date_time = date_time_select(value)
			else:
				self._date_time = value
		return property(**locals())

	@apply
	def dated_approval():
		def fget( self ):
			return self._dated_approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dated_approval is mantatory and can not be set to None')
			if not check_type(value,approval):
				self._dated_approval = approval(value)
			else:
				self._dated_approval = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY approval_role #
####################
class approval_role(BaseEntityClass):
	'''Entity approval_role definition.

	:param role
	:type role:label

	:param description
	:type description:text
	'''
	def __init__( self , role, ):
		self.role = role

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,label):
				self._role = label(value)
			else:
				self._role = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY composite_sheet_representation #
####################
class composite_sheet_representation(shape_representation):
	'''Entity composite_sheet_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'MANIFOLD_SURFACE_SHAPE_REPRESENTATION']  *  TYPEOF(self))  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_context #
####################
class product_context(application_context_element):
	'''Entity product_context definition.

	:param discipline_type
	:type discipline_type:label
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , discipline_type, ):
		application_context_element.__init__(self , inherited0__name , inherited1__frame_of_reference , )
		self.discipline_type = discipline_type

	@apply
	def discipline_type():
		def fget( self ):
			return self._discipline_type
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument discipline_type is mantatory and can not be set to None')
			if not check_type(value,label):
				self._discipline_type = label(value)
			else:
				self._discipline_type = value
		return property(**locals())

####################
 # ENTITY elementary_surface #
####################
class elementary_surface(surface):
	'''Entity elementary_surface definition.

	:param position
	:type position:axis2_placement_3d
	'''
	def __init__( self , inherited0__name , position, ):
		surface.__init__(self , inherited0__name , )
		self.position = position

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._position = axis2_placement_3d(value)
			else:
				self._position = value
		return property(**locals())

####################
 # ENTITY spherical_surface #
####################
class spherical_surface(elementary_surface):
	'''Entity spherical_surface definition.

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY rule_software_definition #
####################
class rule_software_definition(product_definition):
	'''Entity rule_software_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY rule_definition #
####################
class rule_definition(rule_software_definition):
	'''Entity rule_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		rule_software_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY forward_chaining_rule #
####################
class forward_chaining_rule(rule_definition):
	'''Entity forward_chaining_rule definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		rule_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY annotation_curve_occurrence #
####################
class annotation_curve_occurrence(annotation_occurrence):
	'''Entity annotation_curve_occurrence definition.

	:param styled_item_item
	:type styled_item_item:curve
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , styled_item_item, ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		self.styled_item_item = styled_item_item

	@apply
	def styled_item_item():
		def fget( self ):
			return self._styled_item_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_item_item is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._styled_item_item = curve(value)
			else:
				self._styled_item_item = value
		return property(**locals())

####################
 # ENTITY projection_curve #
####################
class projection_curve(annotation_curve_occurrence):
	'''Entity projection_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item ,  ):
		annotation_curve_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , )

####################
 # ENTITY power_unit #
####################
class power_unit(derived_unit):
	'''Entity power_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.watt))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_power_unit #
####################
class si_power_unit(power_unit,si_unit):
	'''Entity si_power_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		power_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.watt)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY acceleration_unit #
####################
class acceleration_unit(derived_unit):
	'''Entity acceleration_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensional_exponents(1,0,-2,0,0,0,0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY application_protocol_definition #
####################
class application_protocol_definition(BaseEntityClass):
	'''Entity application_protocol_definition definition.

	:param status
	:type status:label

	:param application_interpreted_model_schema_name
	:type application_interpreted_model_schema_name:label

	:param application_protocol_year
	:type application_protocol_year:year_number

	:param application
	:type application:application_context
	'''
	def __init__( self , status,application_interpreted_model_schema_name,application_protocol_year,application, ):
		self.status = status
		self.application_interpreted_model_schema_name = application_interpreted_model_schema_name
		self.application_protocol_year = application_protocol_year
		self.application = application

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument status is mantatory and can not be set to None')
			if not check_type(value,label):
				self._status = label(value)
			else:
				self._status = value
		return property(**locals())

	@apply
	def application_interpreted_model_schema_name():
		def fget( self ):
			return self._application_interpreted_model_schema_name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument application_interpreted_model_schema_name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._application_interpreted_model_schema_name = label(value)
			else:
				self._application_interpreted_model_schema_name = value
		return property(**locals())

	@apply
	def application_protocol_year():
		def fget( self ):
			return self._application_protocol_year
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument application_protocol_year is mantatory and can not be set to None')
			if not check_type(value,year_number):
				self._application_protocol_year = year_number(value)
			else:
				self._application_protocol_year = value
		return property(**locals())

	@apply
	def application():
		def fget( self ):
			return self._application
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument application is mantatory and can not be set to None')
			if not check_type(value,application_context):
				self._application = application_context(value)
			else:
				self._application = value
		return property(**locals())

####################
 # ENTITY variational_representation_item #
####################
class variational_representation_item(representation_item):
	'''Entity variational_representation_item definition.
	'''
	def __init__( self , inherited0__name ,  ):
		representation_item.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY auxiliary_geometric_representation_item #
####################
class auxiliary_geometric_representation_item(geometric_representation_item,variational_representation_item):
	'''Entity auxiliary_geometric_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )
		variational_representation_item.__init__(self , inherited1__name , )

####################
 # ENTITY dimensional_size #
####################
class dimensional_size(BaseEntityClass):
	'''Entity dimensional_size definition.

	:param applies_to
	:type applies_to:shape_aspect

	:param name
	:type name:label
	'''
	def __init__( self , applies_to,name, ):
		self.applies_to = applies_to
		self.name = name

	@apply
	def applies_to():
		def fget( self ):
			return self._applies_to
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument applies_to is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._applies_to = shape_aspect(value)
			else:
				self._applies_to = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.applies_to.self.product_definitional  ==  TRUE)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY externally_defined_dimension_definition #
####################
class externally_defined_dimension_definition(dimensional_size,externally_defined_item):
	'''Entity externally_defined_dimension_definition definition.
	'''
	def __init__( self , inherited0__applies_to , inherited1__name , inherited2__item_id , inherited3__source ,  ):
		dimensional_size.__init__(self , inherited0__applies_to , inherited1__name , )
		externally_defined_item.__init__(self , inherited2__item_id , inherited3__source , )
	def wr1(self):
		eval_wr1_wr = ((self.self.externally_defined_item.self.item_id  ==  'external size dimension')  and  (self.self.externally_defined_item.self.source.self.source_id  ==  'external size dimension specification'))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (1  >=  SIZEOF(None))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY swept_disk_solid #
####################
class swept_disk_solid(solid_model):
	'''Entity swept_disk_solid definition.

	:param directrix
	:type directrix:curve

	:param radius
	:type radius:positive_length_measure

	:param inner_radius
	:type inner_radius:positive_length_measure

	:param start_param
	:type start_param:REAL

	:param end_param
	:type end_param:REAL
	'''
	def __init__( self , inherited0__name , directrix,radius,inner_radius,start_param,end_param, ):
		solid_model.__init__(self , inherited0__name , )
		self.directrix = directrix
		self.radius = radius
		self.inner_radius = inner_radius
		self.start_param = start_param
		self.end_param = end_param

	@apply
	def directrix():
		def fget( self ):
			return self._directrix
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directrix is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._directrix = curve(value)
			else:
				self._directrix = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def inner_radius():
		def fget( self ):
			return self._inner_radius
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,positive_length_measure):
					self._inner_radius = positive_length_measure(value)
				else:
					self._inner_radius = value
			else:
				self._inner_radius = value
		return property(**locals())

	@apply
	def start_param():
		def fget( self ):
			return self._start_param
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument start_param is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._start_param = REAL(value)
			else:
				self._start_param = value
		return property(**locals())

	@apply
	def end_param():
		def fget( self ):
			return self._end_param
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument end_param is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._end_param = REAL(value)
			else:
				self._end_param = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.directrix.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.inner_radius))  or  (self.radius  >  self.inner_radius))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY dimension_callout_relationship #
####################
class dimension_callout_relationship(draughting_callout_relationship):
	'''Entity dimension_callout_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout ,  ):
		draughting_callout_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['primary','secondary'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(TYPEOF(self.self.relating_draughting_callout)  *  ['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ANGULAR_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIAMETER_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LEADER_DIRECTED_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINEAR_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORDINATE_DIMENSION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RADIUS_DIMENSION'])  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(TYPEOF(self.self.related_draughting_callout)  *  ['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PROJECTION_DIRECTED_CALLOUT','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LEADER_DIRECTED_CALLOUT'])  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.related_draughting_callout.self.contents  *  self.self.relating_draughting_callout.self.contents)  ==  self.self.related_draughting_callout.self.contents)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY externally_defined_terminator_symbol #
####################
class externally_defined_terminator_symbol(externally_defined_symbol):
	'''Entity externally_defined_terminator_symbol definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source ,  ):
		externally_defined_symbol.__init__(self , inherited0__item_id , inherited1__source , )

####################
 # ENTITY specified_higher_usage_occurrence #
####################
class specified_higher_usage_occurrence(assembly_component_usage):
	'''Entity specified_higher_usage_occurrence definition.

	:param upper_usage
	:type upper_usage:assembly_component_usage

	:param next_usage
	:type next_usage:next_assembly_usage_occurrence
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , upper_usage,next_usage, ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )
		self.upper_usage = upper_usage
		self.next_usage = next_usage

	@apply
	def upper_usage():
		def fget( self ):
			return self._upper_usage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument upper_usage is mantatory and can not be set to None')
			if not check_type(value,assembly_component_usage):
				self._upper_usage = assembly_component_usage(value)
			else:
				self._upper_usage = value
		return property(**locals())

	@apply
	def next_usage():
		def fget( self ):
			return self._next_usage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument next_usage is mantatory and can not be set to None')
			if not check_type(value,next_assembly_usage_occurrence):
				self._next_usage = next_assembly_usage_occurrence(value)
			else:
				self._next_usage = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self  !=  self.upper_usage)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.product_definition_relationship.self.relating_product_definition  ==  self.upper_usage.self.relating_product_definition)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.product_definition_relationship.self.related_product_definition  ==  self.next_usage.self.related_product_definition)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.upper_usage.self.related_product_definition  ==  self.next_usage.self.relating_product_definition)  or  (SIZEOF(None)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE']  *  TYPEOF(self.upper_usage))  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY dimensional_location_with_path #
####################
class dimensional_location_with_path(dimensional_location):
	'''Entity dimensional_location_with_path definition.

	:param path
	:type path:shape_aspect
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , path, ):
		dimensional_location.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
		self.path = path

	@apply
	def path():
		def fget( self ):
			return self._path
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument path is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._path = shape_aspect(value)
			else:
				self._path = value
		return property(**locals())

####################
 # ENTITY product_definition_formation_with_specified_source #
####################
class product_definition_formation_with_specified_source(product_definition_formation):
	'''Entity product_definition_formation_with_specified_source definition.

	:param make_or_buy
	:type make_or_buy:source
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__of_product , make_or_buy, ):
		product_definition_formation.__init__(self , inherited0__id , inherited1__description , inherited2__of_product , )
		self.make_or_buy = make_or_buy

	@apply
	def make_or_buy():
		def fget( self ):
			return self._make_or_buy
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument make_or_buy is mantatory and can not be set to None')
			if not check_type(value,source):
				self._make_or_buy = source(value)
			else:
				self._make_or_buy = value
		return property(**locals())

####################
 # ENTITY surface_style_transparent #
####################
class surface_style_transparent(BaseEntityClass):
	'''Entity surface_style_transparent definition.

	:param transparency
	:type transparency:REAL
	'''
	def __init__( self , transparency, ):
		self.transparency = transparency

	@apply
	def transparency():
		def fget( self ):
			return self._transparency
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transparency is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._transparency = REAL(value)
			else:
				self._transparency = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((0  <=  self.transparency)  and  (self.transparency  <=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY amount_of_substance_measure_with_unit #
####################
class amount_of_substance_measure_with_unit(measure_with_unit):
	'''Entity amount_of_substance_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY description_attribute #
####################
class description_attribute(BaseEntityClass):
	'''Entity description_attribute definition.

	:param attribute_value
	:type attribute_value:text

	:param described_item
	:type described_item:description_attribute_select
	'''
	def __init__( self , attribute_value,described_item, ):
		self.attribute_value = attribute_value
		self.described_item = described_item

	@apply
	def attribute_value():
		def fget( self ):
			return self._attribute_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_value is mantatory and can not be set to None')
			if not check_type(value,text):
				self._attribute_value = text(value)
			else:
				self._attribute_value = value
		return property(**locals())

	@apply
	def described_item():
		def fget( self ):
			return self._described_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument described_item is mantatory and can not be set to None')
			if not check_type(value,description_attribute_select):
				self._described_item = description_attribute_select(value)
			else:
				self._described_item = value
		return property(**locals())

####################
 # ENTITY dose_equivalent_unit #
####################
class dose_equivalent_unit(derived_unit):
	'''Entity dose_equivalent_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.sievert))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY half_space_solid #
####################
class half_space_solid(geometric_representation_item):
	'''Entity half_space_solid definition.

	:param base_surface
	:type base_surface:surface

	:param agreement_flag
	:type agreement_flag:BOOLEAN
	'''
	def __init__( self , inherited0__name , base_surface,agreement_flag, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.base_surface = base_surface
		self.agreement_flag = agreement_flag

	@apply
	def base_surface():
		def fget( self ):
			return self._base_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._base_surface = surface(value)
			else:
				self._base_surface = value
		return property(**locals())

	@apply
	def agreement_flag():
		def fget( self ):
			return self._agreement_flag
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument agreement_flag is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._agreement_flag = BOOLEAN(value)
			else:
				self._agreement_flag = value
		return property(**locals())

####################
 # ENTITY action_request_solution #
####################
class action_request_solution(BaseEntityClass):
	'''Entity action_request_solution definition.

	:param method
	:type method:action_method

	:param request
	:type request:versioned_action_request

	:param description
	:type description:text

	:param name
	:type name:label
	'''
	def __init__( self , method,request, ):
		self.method = method
		self.request = request

	@apply
	def method():
		def fget( self ):
			return self._method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument method is mantatory and can not be set to None')
			if not check_type(value,action_method):
				self._method = action_method(value)
			else:
				self._method = value
		return property(**locals())

	@apply
	def request():
		def fget( self ):
			return self._request
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument request is mantatory and can not be set to None')
			if not check_type(value,versioned_action_request):
				self._request = versioned_action_request(value)
			else:
				self._request = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY product_concept_feature_category #
####################
class product_concept_feature_category(group):
	'''Entity product_concept_feature_category definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY exclusive_product_concept_feature_category #
####################
class exclusive_product_concept_feature_category(product_concept_feature_category):
	'''Entity exclusive_product_concept_feature_category definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		product_concept_feature_category.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY over_riding_styled_item #
####################
class over_riding_styled_item(styled_item):
	'''Entity over_riding_styled_item definition.

	:param over_ridden_style
	:type over_ridden_style:styled_item
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , over_ridden_style, ):
		styled_item.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		self.over_ridden_style = over_ridden_style

	@apply
	def over_ridden_style():
		def fget( self ):
			return self._over_ridden_style
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument over_ridden_style is mantatory and can not be set to None')
			if not check_type(value,styled_item):
				self._over_ridden_style = styled_item(value)
			else:
				self._over_ridden_style = value
		return property(**locals())

####################
 # ENTITY context_dependent_over_riding_styled_item #
####################
class context_dependent_over_riding_styled_item(over_riding_styled_item):
	'''Entity context_dependent_over_riding_styled_item definition.

	:param style_context
	:type style_context:LIST(1,None,'style_context_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__over_ridden_style , style_context, ):
		over_riding_styled_item.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__over_ridden_style , )
		self.style_context = style_context

	@apply
	def style_context():
		def fget( self ):
			return self._style_context
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_context is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'style_context_select', scope = schema_scope)):
				self._style_context = LIST(value)
			else:
				self._style_context = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(None)  ==  1)  or  (SIZEOF(None)  ==  SIZEOF(self.style_context)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY hidden_element_over_riding_styled_item #
####################
class hidden_element_over_riding_styled_item(context_dependent_over_riding_styled_item):
	'''Entity hidden_element_over_riding_styled_item definition.

	:param styled_item_item
	:type styled_item_item:camera_image

	:param context_dependent_over_riding_styled_item_style_context
	:type context_dependent_over_riding_styled_item_style_context:LIST(1,1,'presentation_view', scope = schema_scope)

	:param container
	:type container:SET(1,None,'presentation_view', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__over_ridden_style , inherited4__style_context , styled_item_item,context_dependent_over_riding_styled_item_style_context, ):
		context_dependent_over_riding_styled_item.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__over_ridden_style , inherited4__style_context , )
		self.styled_item_item = styled_item_item
		self.context_dependent_over_riding_styled_item_style_context = context_dependent_over_riding_styled_item_style_context

	@apply
	def styled_item_item():
		def fget( self ):
			return self._styled_item_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_item_item is mantatory and can not be set to None')
			if not check_type(value,camera_image):
				self._styled_item_item = camera_image(value)
			else:
				self._styled_item_item = value
		return property(**locals())

	@apply
	def context_dependent_over_riding_styled_item_style_context():
		def fget( self ):
			return self._context_dependent_over_riding_styled_item_style_context
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument context_dependent_over_riding_styled_item_style_context is mantatory and can not be set to None')
			if not check_type(value,LIST(1,1,'presentation_view', scope = schema_scope)):
				self._context_dependent_over_riding_styled_item_style_context = LIST(value)
			else:
				self._context_dependent_over_riding_styled_item_style_context = value
		return property(**locals())

	@apply
	def container():
		def fget( self ):
			return self._container
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument container is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CAMERA_MODEL_D3_WITH_HLHSR'  ==  TYPEOF(self.self.item.self.mapped_item.self.mapping_source.self.mapping_origin))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY presentation_size #
####################
class presentation_size(BaseEntityClass):
	'''Entity presentation_size definition.

	:param unit
	:type unit:presentation_size_assignment_select

	:param size
	:type size:planar_box
	'''
	def __init__( self , unit,size, ):
		self.unit = unit
		self.size = size

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unit is mantatory and can not be set to None')
			if not check_type(value,presentation_size_assignment_select):
				self._unit = presentation_size_assignment_select(value)
			else:
				self._unit = value
		return property(**locals())

	@apply
	def size():
		def fget( self ):
			return self._size
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument size is mantatory and can not be set to None')
			if not check_type(value,planar_box):
				self._size = planar_box(value)
			else:
				self._size = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRESENTATION_REPRESENTATION'  ==  TYPEOF(self.self.unit))  and  item_in_context(self.self.size,self.self.unit.self.representation.self.context_of_items))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.AREA_IN_SET'  ==  TYPEOF(self.self.unit))  and  (SIZEOF(None)  ==  0)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY thermal_resistance_measure_with_unit #
####################
class thermal_resistance_measure_with_unit(measure_with_unit):
	'''Entity thermal_resistance_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.THERMAL_RESISTANCE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY uncertainty_measure_with_unit #
####################
class uncertainty_measure_with_unit(measure_with_unit):
	'''Entity uncertainty_measure_with_unit definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component , name,description, ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = valid_measure_value(self.self.measure_with_unit.self.value_component)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY class #
####################
class class_(group):
	'''Entity class definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY class_by_extension #
####################
class class_by_extension(class_):
	'''Entity class_by_extension definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		class.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY edge_based_wireframe_model #
####################
class edge_based_wireframe_model(geometric_representation_item):
	'''Entity edge_based_wireframe_model definition.

	:param ebwm_boundary
	:type ebwm_boundary:SET(1,None,'connected_edge_set', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , ebwm_boundary, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.ebwm_boundary = ebwm_boundary

	@apply
	def ebwm_boundary():
		def fget( self ):
			return self._ebwm_boundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ebwm_boundary is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'connected_edge_set', scope = schema_scope)):
				self._ebwm_boundary = SET(value)
			else:
				self._ebwm_boundary = value
		return property(**locals())

####################
 # ENTITY pre_defined_colour #
####################
class pre_defined_colour(pre_defined_item,colour):
	'''Entity pre_defined_colour definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )
		colour.__init__(self , )

####################
 # ENTITY draughting_pre_defined_colour #
####################
class draughting_pre_defined_colour(pre_defined_colour):
	'''Entity draughting_pre_defined_colour definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_colour.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['red','green','blue','yellow','magenta','cyan','black','white'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY path #
####################
class path(topological_representation_item):
	'''Entity path definition.

	:param edge_list
	:type edge_list:LIST(1,None,'oriented_edge', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , edge_list, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.edge_list = edge_list

	@apply
	def edge_list():
		def fget( self ):
			return self._edge_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edge_list is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'oriented_edge', scope = schema_scope)):
				self._edge_list = LIST(value)
			else:
				self._edge_list = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = path_head_to_tail(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY connected_face_set #
####################
class connected_face_set(topological_representation_item):
	'''Entity connected_face_set definition.

	:param cfs_faces
	:type cfs_faces:SET(1,None,'face', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , cfs_faces, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.cfs_faces = cfs_faces

	@apply
	def cfs_faces():
		def fget( self ):
			return self._cfs_faces
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument cfs_faces is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'face', scope = schema_scope)):
				self._cfs_faces = SET(value)
			else:
				self._cfs_faces = value
		return property(**locals())

####################
 # ENTITY open_shell #
####################
class open_shell(connected_face_set):
	'''Entity open_shell definition.
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces ,  ):
		connected_face_set.__init__(self , inherited0__name , inherited1__cfs_faces , )

####################
 # ENTITY oriented_open_shell #
####################
class oriented_open_shell(open_shell):
	'''Entity oriented_open_shell definition.

	:param open_shell_element
	:type open_shell_element:open_shell

	:param orientation
	:type orientation:BOOLEAN

	:param connected_face_set_cfs_faces
	:type connected_face_set_cfs_faces:SET(1,None,'face', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces , open_shell_element,orientation, ):
		open_shell.__init__(self , inherited0__name , inherited1__cfs_faces , )
		self.open_shell_element = open_shell_element
		self.orientation = orientation

	@apply
	def open_shell_element():
		def fget( self ):
			return self._open_shell_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument open_shell_element is mantatory and can not be set to None')
			if not check_type(value,open_shell):
				self._open_shell_element = open_shell(value)
			else:
				self._open_shell_element = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def connected_face_set_cfs_faces():
		def fget( self ):
			attribute_eval = conditional_reverse(self.self.orientation,self.self.open_shell_element.self.cfs_faces)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument connected_face_set_cfs_faces is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORIENTED_OPEN_SHELL'  ==  TYPEOF(self.self.open_shell_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY tolerance_zone #
####################
class tolerance_zone(shape_aspect):
	'''Entity tolerance_zone definition.

	:param defining_tolerance
	:type defining_tolerance:SET(1,None,'geometric_tolerance', scope = schema_scope)

	:param form
	:type form:tolerance_zone_form
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , defining_tolerance,form, ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		self.defining_tolerance = defining_tolerance
		self.form = form

	@apply
	def defining_tolerance():
		def fget( self ):
			return self._defining_tolerance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument defining_tolerance is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'geometric_tolerance', scope = schema_scope)):
				self._defining_tolerance = SET(value)
			else:
				self._defining_tolerance = value
		return property(**locals())

	@apply
	def form():
		def fget( self ):
			return self._form
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument form is mantatory and can not be set to None')
			if not check_type(value,tolerance_zone_form):
				self._form = tolerance_zone_form(value)
			else:
				self._form = value
		return property(**locals())

####################
 # ENTITY definitional_representation_relationship_with_same_context #
####################
class definitional_representation_relationship_with_same_context(definitional_representation_relationship):
	'''Entity definitional_representation_relationship_with_same_context definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 ,  ):
		definitional_representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
	def wr1(self):
		eval_wr1_wr = (self.self.representation_relationship.self.rep_1.self.context_of_items  ==  self.self.representation_relationship.self.rep_2.self.context_of_items)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY pressure_measure_with_unit #
####################
class pressure_measure_with_unit(measure_with_unit):
	'''Entity pressure_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRESSURE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY right_circular_cylinder #
####################
class right_circular_cylinder(geometric_representation_item):
	'''Entity right_circular_cylinder definition.

	:param position
	:type position:axis1_placement

	:param height
	:type height:positive_length_measure

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , position,height,radius, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.position = position
		self.height = height
		self.radius = radius

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._position = axis1_placement(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._height = positive_length_measure(value)
			else:
				self._height = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY solid_angle_unit #
####################
class solid_angle_unit(named_unit):
	'''Entity solid_angle_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY luminous_intensity_measure_with_unit #
####################
class luminous_intensity_measure_with_unit(measure_with_unit):
	'''Entity luminous_intensity_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LUMINOUS_INTENSITY_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY percentage_ply_definition #
####################
class percentage_ply_definition(product_definition):
	'''Entity percentage_ply_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY role_association #
####################
class role_association(BaseEntityClass):
	'''Entity role_association definition.

	:param role
	:type role:object_role

	:param item_with_role
	:type item_with_role:role_select
	'''
	def __init__( self , role,item_with_role, ):
		self.role = role
		self.item_with_role = item_with_role

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,object_role):
				self._role = object_role(value)
			else:
				self._role = value
		return property(**locals())

	@apply
	def item_with_role():
		def fget( self ):
			return self._item_with_role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_with_role is mantatory and can not be set to None')
			if not check_type(value,role_select):
				self._item_with_role = role_select(value)
			else:
				self._item_with_role = value
		return property(**locals())

####################
 # ENTITY event_occurrence_relationship #
####################
class event_occurrence_relationship(BaseEntityClass):
	'''Entity event_occurrence_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_event
	:type relating_event:event_occurrence

	:param related_event
	:type related_event:event_occurrence
	'''
	def __init__( self , name,description,relating_event,related_event, ):
		self.name = name
		self.description = description
		self.relating_event = relating_event
		self.related_event = related_event

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_event():
		def fget( self ):
			return self._relating_event
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_event is mantatory and can not be set to None')
			if not check_type(value,event_occurrence):
				self._relating_event = event_occurrence(value)
			else:
				self._relating_event = value
		return property(**locals())

	@apply
	def related_event():
		def fget( self ):
			return self._related_event
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_event is mantatory and can not be set to None')
			if not check_type(value,event_occurrence):
				self._related_event = event_occurrence(value)
			else:
				self._related_event = value
		return property(**locals())

####################
 # ENTITY coordinated_universal_time_offset #
####################
class coordinated_universal_time_offset(BaseEntityClass):
	'''Entity coordinated_universal_time_offset definition.

	:param hour_offset
	:type hour_offset:INTEGER

	:param minute_offset
	:type minute_offset:INTEGER

	:param sense
	:type sense:ahead_or_behind

	:param actual_minute_offset
	:type actual_minute_offset:INTEGER
	'''
	def __init__( self , hour_offset,minute_offset,sense, ):
		self.hour_offset = hour_offset
		self.minute_offset = minute_offset
		self.sense = sense

	@apply
	def hour_offset():
		def fget( self ):
			return self._hour_offset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hour_offset is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._hour_offset = INTEGER(value)
			else:
				self._hour_offset = value
		return property(**locals())

	@apply
	def minute_offset():
		def fget( self ):
			return self._minute_offset
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,INTEGER):
					self._minute_offset = INTEGER(value)
				else:
					self._minute_offset = value
			else:
				self._minute_offset = value
		return property(**locals())

	@apply
	def sense():
		def fget( self ):
			return self._sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sense is mantatory and can not be set to None')
			if not check_type(value,ahead_or_behind):
				self._sense = ahead_or_behind(value)
			else:
				self._sense = value
		return property(**locals())

	@apply
	def actual_minute_offset():
		def fget( self ):
			attribute_eval = NVL(self.minute_offset,0)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument actual_minute_offset is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((0  <=  self.hour_offset)  and  (self.hour_offset  <  24))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((0  <=  self.actual_minute_offset)  and  (self.actual_minute_offset  <=  59))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ( not (((self.hour_offset  !=  0)  or  (self.actual_minute_offset  !=  0))  and  (self.sense  ==  exact)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY curve_replica #
####################
class curve_replica(curve):
	'''Entity curve_replica definition.

	:param parent_curve
	:type parent_curve:curve

	:param transformation
	:type transformation:cartesian_transformation_operator
	'''
	def __init__( self , inherited0__name , parent_curve,transformation, ):
		curve.__init__(self , inherited0__name , )
		self.parent_curve = parent_curve
		self.transformation = transformation

	@apply
	def parent_curve():
		def fget( self ):
			return self._parent_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._parent_curve = curve(value)
			else:
				self._parent_curve = value
		return property(**locals())

	@apply
	def transformation():
		def fget( self ):
			return self._transformation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transformation is mantatory and can not be set to None')
			if not check_type(value,cartesian_transformation_operator):
				self._transformation = cartesian_transformation_operator(value)
			else:
				self._transformation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.transformation.self.dim  ==  self.parent_curve.self.dim)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = acyclic_curve_replica(self,self.parent_curve)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY swept_face_solid #
####################
class swept_face_solid(solid_model):
	'''Entity swept_face_solid definition.

	:param swept_face
	:type swept_face:face_surface
	'''
	def __init__( self , inherited0__name , swept_face, ):
		solid_model.__init__(self , inherited0__name , )
		self.swept_face = swept_face

	@apply
	def swept_face():
		def fget( self ):
			return self._swept_face
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument swept_face is mantatory and can not be set to None')
			if not check_type(value,face_surface):
				self._swept_face = face_surface(value)
			else:
				self._swept_face = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLANE'  ==  TYPEOF(self.swept_face.self.face_geometry))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY extruded_face_solid #
####################
class extruded_face_solid(swept_face_solid):
	'''Entity extruded_face_solid definition.

	:param extruded_direction
	:type extruded_direction:direction

	:param depth
	:type depth:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__swept_face , extruded_direction,depth, ):
		swept_face_solid.__init__(self , inherited0__name , inherited1__swept_face , )
		self.extruded_direction = extruded_direction
		self.depth = depth

	@apply
	def extruded_direction():
		def fget( self ):
			return self._extruded_direction
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extruded_direction is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._extruded_direction = direction(value)
			else:
				self._extruded_direction = value
		return property(**locals())

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._depth = positive_length_measure(value)
			else:
				self._depth = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (dot_product(self.self.swept_face_solid.self.swept_face.self.face_geometry.self.elementary_surface.self.position.self.p[3],self.extruded_direction)  !=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY quasi_uniform_surface #
####################
class quasi_uniform_surface(b_spline_surface):
	'''Entity quasi_uniform_surface definition.
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect ,  ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )

####################
 # ENTITY surface_curve #
####################
class surface_curve(curve):
	'''Entity surface_curve definition.

	:param curve_3d
	:type curve_3d:curve

	:param associated_geometry
	:type associated_geometry:LIST(1,2,'pcurve_or_surface', scope = schema_scope)

	:param master_representation
	:type master_representation:preferred_surface_curve_representation

	:param basis_surface
	:type basis_surface:SET(1,2,'surface', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , curve_3d,associated_geometry,master_representation, ):
		curve.__init__(self , inherited0__name , )
		self.curve_3d = curve_3d
		self.associated_geometry = associated_geometry
		self.master_representation = master_representation

	@apply
	def curve_3d():
		def fget( self ):
			return self._curve_3d
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument curve_3d is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._curve_3d = curve(value)
			else:
				self._curve_3d = value
		return property(**locals())

	@apply
	def associated_geometry():
		def fget( self ):
			return self._associated_geometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument associated_geometry is mantatory and can not be set to None')
			if not check_type(value,LIST(1,2,'pcurve_or_surface', scope = schema_scope)):
				self._associated_geometry = LIST(value)
			else:
				self._associated_geometry = value
		return property(**locals())

	@apply
	def master_representation():
		def fget( self ):
			return self._master_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument master_representation is mantatory and can not be set to None')
			if not check_type(value,preferred_surface_curve_representation):
				self._master_representation = preferred_surface_curve_representation(value)
			else:
				self._master_representation = value
		return property(**locals())

	@apply
	def basis_surface():
		def fget( self ):
			attribute_eval = get_basis_surface(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument basis_surface is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.curve_3d.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(self.associated_geometry[1]))  or  (self.master_representation  !=  pcurve_s1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(self.associated_geometry[2]))  or  (self.master_representation  !=  pcurve_s2))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(self.curve_3d)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY surface_style_rendering #
####################
class surface_style_rendering(BaseEntityClass):
	'''Entity surface_style_rendering definition.

	:param rendering_method
	:type rendering_method:shading_surface_method

	:param surface_colour
	:type surface_colour:colour
	'''
	def __init__( self , rendering_method,surface_colour, ):
		self.rendering_method = rendering_method
		self.surface_colour = surface_colour

	@apply
	def rendering_method():
		def fget( self ):
			return self._rendering_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rendering_method is mantatory and can not be set to None')
			if not check_type(value,shading_surface_method):
				self._rendering_method = shading_surface_method(value)
			else:
				self._rendering_method = value
		return property(**locals())

	@apply
	def surface_colour():
		def fget( self ):
			return self._surface_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument surface_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._surface_colour = colour(value)
			else:
				self._surface_colour = value
		return property(**locals())

####################
 # ENTITY action_request_status #
####################
class action_request_status(BaseEntityClass):
	'''Entity action_request_status definition.

	:param status
	:type status:label

	:param assigned_request
	:type assigned_request:versioned_action_request
	'''
	def __init__( self , status,assigned_request, ):
		self.status = status
		self.assigned_request = assigned_request

	@apply
	def status():
		def fget( self ):
			return self._status
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument status is mantatory and can not be set to None')
			if not check_type(value,label):
				self._status = label(value)
			else:
				self._status = value
		return property(**locals())

	@apply
	def assigned_request():
		def fget( self ):
			return self._assigned_request
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_request is mantatory and can not be set to None')
			if not check_type(value,versioned_action_request):
				self._assigned_request = versioned_action_request(value)
			else:
				self._assigned_request = value
		return property(**locals())

####################
 # ENTITY composite_text_with_delineation #
####################
class composite_text_with_delineation(composite_text):
	'''Entity composite_text_with_delineation definition.

	:param delineation
	:type delineation:text_delineation
	'''
	def __init__( self , inherited0__name , inherited1__collected_text , delineation, ):
		composite_text.__init__(self , inherited0__name , inherited1__collected_text , )
		self.delineation = delineation

	@apply
	def delineation():
		def fget( self ):
			return self._delineation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument delineation is mantatory and can not be set to None')
			if not check_type(value,text_delineation):
				self._delineation = text_delineation(value)
			else:
				self._delineation = value
		return property(**locals())

####################
 # ENTITY fill_area_style #
####################
class fill_area_style(founded_item):
	'''Entity fill_area_style definition.

	:param name
	:type name:label

	:param fill_styles
	:type fill_styles:SET(1,None,'fill_style_select', scope = schema_scope)
	'''
	def __init__( self , name,fill_styles, ):
		founded_item.__init__(self , )
		self.name = name
		self.fill_styles = fill_styles

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def fill_styles():
		def fget( self ):
			return self._fill_styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fill_styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'fill_style_select', scope = schema_scope)):
				self._fill_styles = SET(value)
			else:
				self._fill_styles = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY luminous_flux_unit #
####################
class luminous_flux_unit(named_unit):
	'''Entity luminous_flux_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.lumen))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY part_laminate_table #
####################
class part_laminate_table(laminate_table):
	'''Entity part_laminate_table definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		laminate_table.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY ply_laminate_table #
####################
class ply_laminate_table(part_laminate_table):
	'''Entity ply_laminate_table definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		part_laminate_table.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY capacitance_unit #
####################
class capacitance_unit(derived_unit):
	'''Entity capacitance_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.farad))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_capacitance_unit #
####################
class si_capacitance_unit(capacitance_unit,si_unit):
	'''Entity si_capacitance_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		capacitance_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.farad)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY solid_with_double_offset_chamfer #
####################
class solid_with_double_offset_chamfer(solid_with_chamfered_edges):
	'''Entity solid_with_double_offset_chamfer definition.

	:param left_offset_distance
	:type left_offset_distance:positive_length_measure

	:param right_offset_distance
	:type right_offset_distance:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , left_offset_distance,right_offset_distance, ):
		solid_with_chamfered_edges.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , )
		self.left_offset_distance = left_offset_distance
		self.right_offset_distance = right_offset_distance

	@apply
	def left_offset_distance():
		def fget( self ):
			return self._left_offset_distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument left_offset_distance is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._left_offset_distance = positive_length_measure(value)
			else:
				self._left_offset_distance = value
		return property(**locals())

	@apply
	def right_offset_distance():
		def fget( self ):
			return self._right_offset_distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument right_offset_distance is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._right_offset_distance = positive_length_measure(value)
			else:
				self._right_offset_distance = value
		return property(**locals())

####################
 # ENTITY structured_text_representation #
####################
class structured_text_representation(representation):
	'''Entity structured_text_representation definition.

	:param representation_items
	:type representation_items:SET(1,None,'string_representation_item_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_items = representation_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'string_representation_item_select', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())

####################
 # ENTITY inductance_unit #
####################
class inductance_unit(derived_unit):
	'''Entity inductance_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.henry))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_inductance_unit #
####################
class si_inductance_unit(inductance_unit,si_unit):
	'''Entity si_inductance_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		inductance_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.henry)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY property_definition #
####################
class property_definition(BaseEntityClass):
	'''Entity property_definition definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param definition
	:type definition:characterized_definition

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description,definition, ):
		self.name = name
		self.description = description
		self.definition = definition

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,characterized_definition):
				self._definition = characterized_definition(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY property_definition_representation #
####################
class property_definition_representation(BaseEntityClass):
	'''Entity property_definition_representation definition.

	:param definition
	:type definition:represented_definition

	:param used_representation
	:type used_representation:representation

	:param description
	:type description:text

	:param name
	:type name:label
	'''
	def __init__( self , definition,used_representation, ):
		self.definition = definition
		self.used_representation = used_representation

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,represented_definition):
				self._definition = represented_definition(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def used_representation():
		def fget( self ):
			return self._used_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument used_representation is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._used_representation = representation(value)
			else:
				self._used_representation = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY abstract_variable #
####################
class abstract_variable(property_definition,property_definition_representation,representation,representation_item):
	'''Entity abstract_variable definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition , inherited3__definition , inherited4__used_representation , inherited5__name , inherited6__items , inherited7__context_of_items , inherited8__name ,  ):
		property_definition.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )
		property_definition_representation.__init__(self , inherited3__definition , inherited4__used_representation , )
		representation.__init__(self , inherited5__name , inherited6__items , inherited7__context_of_items , )
		representation_item.__init__(self , inherited8__name , )

####################
 # ENTITY composite_curve_segment #
####################
class composite_curve_segment(founded_item):
	'''Entity composite_curve_segment definition.

	:param transition
	:type transition:transition_code

	:param same_sense
	:type same_sense:BOOLEAN

	:param parent_curve
	:type parent_curve:curve

	:param using_curves
	:type using_curves:BAG(1,None,'composite_curve', scope = schema_scope)
	'''
	def __init__( self , transition,same_sense,parent_curve, ):
		founded_item.__init__(self , )
		self.transition = transition
		self.same_sense = same_sense
		self.parent_curve = parent_curve

	@apply
	def transition():
		def fget( self ):
			return self._transition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transition is mantatory and can not be set to None')
			if not check_type(value,transition_code):
				self._transition = transition_code(value)
			else:
				self._transition = value
		return property(**locals())

	@apply
	def same_sense():
		def fget( self ):
			return self._same_sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument same_sense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._same_sense = BOOLEAN(value)
			else:
				self._same_sense = value
		return property(**locals())

	@apply
	def parent_curve():
		def fget( self ):
			return self._parent_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._parent_curve = curve(value)
			else:
				self._parent_curve = value
		return property(**locals())

	@apply
	def using_curves():
		def fget( self ):
			return self._using_curves
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument using_curves is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOUNDED_CURVE'  ==  TYPEOF(self.parent_curve))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY reparametrised_composite_curve_segment #
####################
class reparametrised_composite_curve_segment(composite_curve_segment):
	'''Entity reparametrised_composite_curve_segment definition.

	:param param_length
	:type param_length:parameter_value
	'''
	def __init__( self , inherited0__transition , inherited1__same_sense , inherited2__parent_curve , param_length, ):
		composite_curve_segment.__init__(self , inherited0__transition , inherited1__same_sense , inherited2__parent_curve , )
		self.param_length = param_length

	@apply
	def param_length():
		def fget( self ):
			return self._param_length
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument param_length is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._param_length = parameter_value(value)
			else:
				self._param_length = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.param_length  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY representation_relationship_with_transformation #
####################
class representation_relationship_with_transformation(representation_relationship):
	'''Entity representation_relationship_with_transformation definition.

	:param transformation_operator
	:type transformation_operator:transformation
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , transformation_operator, ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
		self.transformation_operator = transformation_operator

	@apply
	def transformation_operator():
		def fget( self ):
			return self._transformation_operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transformation_operator is mantatory and can not be set to None')
			if not check_type(value,transformation):
				self._transformation_operator = transformation(value)
			else:
				self._transformation_operator = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.representation_relationship.self.rep_1.self.context_of_items  !=  self.self.representation_relationship.self.rep_2.self.context_of_items)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY document_identifier_assignment #
####################
class document_identifier_assignment(group_assignment):
	'''Entity document_identifier_assignment definition.

	:param items
	:type items:SET(1,None,'document_identifier_assigned_item', scope = schema_scope)

	:param group_assignment_assigned_group
	:type group_assignment_assigned_group:document_identifier
	'''
	def __init__( self , inherited0__assigned_group , items,group_assignment_assigned_group, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items
		self.group_assignment_assigned_group = group_assignment_assigned_group

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'document_identifier_assigned_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def group_assignment_assigned_group():
		def fget( self ):
			return self._group_assignment_assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument group_assignment_assigned_group is mantatory and can not be set to None')
			if not check_type(value,document_identifier):
				self._group_assignment_assigned_group = document_identifier(value)
			else:
				self._group_assignment_assigned_group = value
		return property(**locals())

####################
 # ENTITY forward_chaining_rule_premise #
####################
class forward_chaining_rule_premise(property_definition,property_definition_representation,representation):
	'''Entity forward_chaining_rule_premise definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition , inherited3__definition , inherited4__used_representation , inherited5__name , inherited6__items , inherited7__context_of_items ,  ):
		property_definition.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )
		property_definition_representation.__init__(self , inherited3__definition , inherited4__used_representation , )
		representation.__init__(self , inherited5__name , inherited6__items , inherited7__context_of_items , )

####################
 # ENTITY person_and_organization_role #
####################
class person_and_organization_role(BaseEntityClass):
	'''Entity person_and_organization_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY presentation_layer_assignment #
####################
class presentation_layer_assignment(BaseEntityClass):
	'''Entity presentation_layer_assignment definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param assigned_items
	:type assigned_items:SET(1,None,'layered_item', scope = schema_scope)
	'''
	def __init__( self , name,description,assigned_items, ):
		self.name = name
		self.description = description
		self.assigned_items = assigned_items

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def assigned_items():
		def fget( self ):
			return self._assigned_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'layered_item', scope = schema_scope)):
				self._assigned_items = SET(value)
			else:
				self._assigned_items = value
		return property(**locals())

####################
 # ENTITY quasi_uniform_curve #
####################
class quasi_uniform_curve(b_spline_curve):
	'''Entity quasi_uniform_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect ,  ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )

####################
 # ENTITY resistance_unit #
####################
class resistance_unit(derived_unit):
	'''Entity resistance_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.ohm))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_resistance_unit #
####################
class si_resistance_unit(resistance_unit,si_unit):
	'''Entity si_resistance_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		resistance_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.ohm)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY swept_surface #
####################
class swept_surface(surface):
	'''Entity swept_surface definition.

	:param swept_curve
	:type swept_curve:curve
	'''
	def __init__( self , inherited0__name , swept_curve, ):
		surface.__init__(self , inherited0__name , )
		self.swept_curve = swept_curve

	@apply
	def swept_curve():
		def fget( self ):
			return self._swept_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument swept_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._swept_curve = curve(value)
			else:
				self._swept_curve = value
		return property(**locals())

####################
 # ENTITY shelled_solid #
####################
class shelled_solid(modified_solid):
	'''Entity shelled_solid definition.

	:param deleted_face_set
	:type deleted_face_set:SET(1,None,'face_surface', scope = schema_scope)

	:param thickness
	:type thickness:length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , deleted_face_set,thickness, ):
		modified_solid.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , )
		self.deleted_face_set = deleted_face_set
		self.thickness = thickness

	@apply
	def deleted_face_set():
		def fget( self ):
			return self._deleted_face_set
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument deleted_face_set is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'face_surface', scope = schema_scope)):
				self._deleted_face_set = SET(value)
			else:
				self._deleted_face_set = value
		return property(**locals())

	@apply
	def thickness():
		def fget( self ):
			return self._thickness
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thickness is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._thickness = length_measure(value)
			else:
				self._thickness = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.thickness  !=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY complex_shelled_solid #
####################
class complex_shelled_solid(shelled_solid):
	'''Entity complex_shelled_solid definition.

	:param thickened_face_list
	:type thickened_face_list:LIST(1,None,SET(1,None,'face_surface', scope = schema_scope))

	:param thickness_list
	:type thickness_list:LIST(1,None,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__deleted_face_set , inherited4__thickness , thickened_face_list,thickness_list, ):
		shelled_solid.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__deleted_face_set , inherited4__thickness , )
		self.thickened_face_list = thickened_face_list
		self.thickness_list = thickness_list

	@apply
	def thickened_face_list():
		def fget( self ):
			return self._thickened_face_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thickened_face_list is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,SET(1,None,'face_surface', scope = schema_scope))):
				self._thickened_face_list = LIST(value)
			else:
				self._thickened_face_list = value
		return property(**locals())

	@apply
	def thickness_list():
		def fget( self ):
			return self._thickness_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thickness_list is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'REAL', scope = schema_scope)):
				self._thickness_list = LIST(value)
			else:
				self._thickness_list = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.thickened_face_list)  ==  SIZEOF(self.thickness_list))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY concept_feature_relationship #
####################
class concept_feature_relationship(BaseEntityClass):
	'''Entity concept_feature_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_product_concept_feature
	:type relating_product_concept_feature:product_concept_feature

	:param related_product_concept_feature
	:type related_product_concept_feature:product_concept_feature
	'''
	def __init__( self , name,description,relating_product_concept_feature,related_product_concept_feature, ):
		self.name = name
		self.description = description
		self.relating_product_concept_feature = relating_product_concept_feature
		self.related_product_concept_feature = related_product_concept_feature

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_product_concept_feature():
		def fget( self ):
			return self._relating_product_concept_feature
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_product_concept_feature is mantatory and can not be set to None')
			if not check_type(value,product_concept_feature):
				self._relating_product_concept_feature = product_concept_feature(value)
			else:
				self._relating_product_concept_feature = value
		return property(**locals())

	@apply
	def related_product_concept_feature():
		def fget( self ):
			return self._related_product_concept_feature
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_product_concept_feature is mantatory and can not be set to None')
			if not check_type(value,product_concept_feature):
				self._related_product_concept_feature = product_concept_feature(value)
			else:
				self._related_product_concept_feature = value
		return property(**locals())

####################
 # ENTITY concept_feature_relationship_with_condition #
####################
class concept_feature_relationship_with_condition(concept_feature_relationship):
	'''Entity concept_feature_relationship_with_condition definition.

	:param conditional_operator
	:type conditional_operator:concept_feature_operator
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_product_concept_feature , inherited3__related_product_concept_feature , conditional_operator, ):
		concept_feature_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_product_concept_feature , inherited3__related_product_concept_feature , )
		self.conditional_operator = conditional_operator

	@apply
	def conditional_operator():
		def fget( self ):
			return self._conditional_operator
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument conditional_operator is mantatory and can not be set to None')
			if not check_type(value,concept_feature_operator):
				self._conditional_operator = concept_feature_operator(value)
			else:
				self._conditional_operator = value
		return property(**locals())

####################
 # ENTITY presented_item_representation #
####################
class presented_item_representation(BaseEntityClass):
	'''Entity presented_item_representation definition.

	:param presentation
	:type presentation:presentation_representation_select

	:param item
	:type item:presented_item
	'''
	def __init__( self , presentation,item, ):
		self.presentation = presentation
		self.item = item

	@apply
	def presentation():
		def fget( self ):
			return self._presentation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument presentation is mantatory and can not be set to None')
			if not check_type(value,presentation_representation_select):
				self._presentation = presentation_representation_select(value)
			else:
				self._presentation = value
		return property(**locals())

	@apply
	def item():
		def fget( self ):
			return self._item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item is mantatory and can not be set to None')
			if not check_type(value,presented_item):
				self._item = presented_item(value)
			else:
				self._item = value
		return property(**locals())

####################
 # ENTITY satisfies_requirement #
####################
class satisfies_requirement(group):
	'''Entity satisfies_requirement definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY straightness_tolerance #
####################
class straightness_tolerance(geometric_tolerance):
	'''Entity straightness_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY angular_location #
####################
class angular_location(dimensional_location):
	'''Entity angular_location definition.

	:param angle_selection
	:type angle_selection:angle_relator
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , angle_selection, ):
		dimensional_location.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
		self.angle_selection = angle_selection

	@apply
	def angle_selection():
		def fget( self ):
			return self._angle_selection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle_selection is mantatory and can not be set to None')
			if not check_type(value,angle_relator):
				self._angle_selection = angle_relator(value)
			else:
				self._angle_selection = value
		return property(**locals())

####################
 # ENTITY applied_action_request_assignment #
####################
class applied_action_request_assignment(action_request_assignment):
	'''Entity applied_action_request_assignment definition.

	:param items
	:type items:SET(1,None,'action_request_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action_request , items, ):
		action_request_assignment.__init__(self , inherited0__assigned_action_request , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'action_request_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY event_occurrence #
####################
class event_occurrence(BaseEntityClass):
	'''Entity event_occurrence definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY relative_event_occurrence #
####################
class relative_event_occurrence(event_occurrence):
	'''Entity relative_event_occurrence definition.

	:param base_event
	:type base_event:event_occurrence

	:param offset
	:type offset:time_measure_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , base_event,offset, ):
		event_occurrence.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
		self.base_event = base_event
		self.offset = offset

	@apply
	def base_event():
		def fget( self ):
			return self._base_event
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base_event is mantatory and can not be set to None')
			if not check_type(value,event_occurrence):
				self._base_event = event_occurrence(value)
			else:
				self._base_event = value
		return property(**locals())

	@apply
	def offset():
		def fget( self ):
			return self._offset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offset is mantatory and can not be set to None')
			if not check_type(value,time_measure_with_unit):
				self._offset = time_measure_with_unit(value)
			else:
				self._offset = value
		return property(**locals())

####################
 # ENTITY uniform_resource_identifier #
####################
class uniform_resource_identifier(descriptive_representation_item):
	'''Entity uniform_resource_identifier definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		descriptive_representation_item.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY applied_group_assignment #
####################
class applied_group_assignment(group_assignment):
	'''Entity applied_group_assignment definition.

	:param items
	:type items:SET(1,None,'groupable_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_group , items, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'groupable_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY characteristic_data_column_header_link #
####################
class characteristic_data_column_header_link(general_property_relationship):
	'''Entity characteristic_data_column_header_link definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_property , inherited3__related_property ,  ):
		general_property_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_property , inherited3__related_property , )

####################
 # ENTITY configuration_item #
####################
class configuration_item(BaseEntityClass):
	'''Entity configuration_item definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param item_concept
	:type item_concept:product_concept

	:param purpose
	:type purpose:label
	'''
	def __init__( self , id,name,description,item_concept,purpose, ):
		self.id = id
		self.name = name
		self.description = description
		self.item_concept = item_concept
		self.purpose = purpose

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def item_concept():
		def fget( self ):
			return self._item_concept
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_concept is mantatory and can not be set to None')
			if not check_type(value,product_concept):
				self._item_concept = product_concept(value)
			else:
				self._item_concept = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._purpose = label(value)
				else:
					self._purpose = value
			else:
				self._purpose = value
		return property(**locals())

####################
 # ENTITY configurable_item #
####################
class configurable_item(configuration_item):
	'''Entity configurable_item definition.

	:param item_concept_feature
	:type item_concept_feature:SET(1,None,'product_concept_feature_association', scope = schema_scope)
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , item_concept_feature, ):
		configuration_item.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , )
		self.item_concept_feature = item_concept_feature

	@apply
	def item_concept_feature():
		def fget( self ):
			return self._item_concept_feature
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_concept_feature is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'product_concept_feature_association', scope = schema_scope)):
				self._item_concept_feature = SET(value)
			else:
				self._item_concept_feature = value
		return property(**locals())

####################
 # ENTITY global_uncertainty_assigned_context #
####################
class global_uncertainty_assigned_context(representation_context):
	'''Entity global_uncertainty_assigned_context definition.

	:param uncertainty
	:type uncertainty:SET(1,None,'uncertainty_measure_with_unit', scope = schema_scope)
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type , uncertainty, ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )
		self.uncertainty = uncertainty

	@apply
	def uncertainty():
		def fget( self ):
			return self._uncertainty
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uncertainty is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'uncertainty_measure_with_unit', scope = schema_scope)):
				self._uncertainty = SET(value)
			else:
				self._uncertainty = value
		return property(**locals())

####################
 # ENTITY pre_defined_surface_condition_symbol #
####################
class pre_defined_surface_condition_symbol(pre_defined_symbol):
	'''Entity pre_defined_surface_condition_symbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_symbol.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['000','010','020','030','040','050','060','070','001','011','021','031','041','051','061','071','100','110','120','130','140','150','160','170','101','111','121','131','141','151','161','171','200','210','220','230','240','250','260','270','201','211','221','231','241','251','261','271'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rule_set_group #
####################
class rule_set_group(rule_software_definition):
	'''Entity rule_set_group definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		rule_software_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY runout_zone_orientation #
####################
class runout_zone_orientation(BaseEntityClass):
	'''Entity runout_zone_orientation definition.

	:param angle
	:type angle:measure_with_unit
	'''
	def __init__( self , angle, ):
		self.angle = angle

	@apply
	def angle():
		def fget( self ):
			return self._angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._angle = measure_with_unit(value)
			else:
				self._angle = value
		return property(**locals())

####################
 # ENTITY runout_zone_orientation_reference_direction #
####################
class runout_zone_orientation_reference_direction(runout_zone_orientation):
	'''Entity runout_zone_orientation_reference_direction definition.

	:param orientation_defining_relationship
	:type orientation_defining_relationship:shape_aspect_relationship
	'''
	def __init__( self , inherited0__angle , orientation_defining_relationship, ):
		runout_zone_orientation.__init__(self , inherited0__angle , )
		self.orientation_defining_relationship = orientation_defining_relationship

	@apply
	def orientation_defining_relationship():
		def fget( self ):
			return self._orientation_defining_relationship
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation_defining_relationship is mantatory and can not be set to None')
			if not check_type(value,shape_aspect_relationship):
				self._orientation_defining_relationship = shape_aspect_relationship(value)
			else:
				self._orientation_defining_relationship = value
		return property(**locals())

####################
 # ENTITY text_style_with_box_characteristics #
####################
class text_style_with_box_characteristics(text_style):
	'''Entity text_style_with_box_characteristics definition.

	:param characteristics
	:type characteristics:SET(1,4,'box_characteristic_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__character_appearance , characteristics, ):
		text_style.__init__(self , inherited0__name , inherited1__character_appearance , )
		self.characteristics = characteristics

	@apply
	def characteristics():
		def fget( self ):
			return self._characteristics
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument characteristics is mantatory and can not be set to None')
			if not check_type(value,SET(1,4,'box_characteristic_select', scope = schema_scope)):
				self._characteristics = SET(value)
			else:
				self._characteristics = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY connected_face_sub_set #
####################
class connected_face_sub_set(connected_face_set):
	'''Entity connected_face_sub_set definition.

	:param parent_face_set
	:type parent_face_set:connected_face_set
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces , parent_face_set, ):
		connected_face_set.__init__(self , inherited0__name , inherited1__cfs_faces , )
		self.parent_face_set = parent_face_set

	@apply
	def parent_face_set():
		def fget( self ):
			return self._parent_face_set
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_face_set is mantatory and can not be set to None')
			if not check_type(value,connected_face_set):
				self._parent_face_set = connected_face_set(value)
			else:
				self._parent_face_set = value
		return property(**locals())

####################
 # ENTITY func #
####################
class func(compound_representation_item):
	'''Entity func definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY organization_relationship #
####################
class organization_relationship(BaseEntityClass):
	'''Entity organization_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_organization
	:type relating_organization:organization

	:param related_organization
	:type related_organization:organization
	'''
	def __init__( self , name,description,relating_organization,related_organization, ):
		self.name = name
		self.description = description
		self.relating_organization = relating_organization
		self.related_organization = related_organization

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_organization():
		def fget( self ):
			return self._relating_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_organization is mantatory and can not be set to None')
			if not check_type(value,organization):
				self._relating_organization = organization(value)
			else:
				self._relating_organization = value
		return property(**locals())

	@apply
	def related_organization():
		def fget( self ):
			return self._related_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_organization is mantatory and can not be set to None')
			if not check_type(value,organization):
				self._related_organization = organization(value)
			else:
				self._related_organization = value
		return property(**locals())

####################
 # ENTITY light_source_ambient #
####################
class light_source_ambient(light_source):
	'''Entity light_source_ambient definition.
	'''
	def __init__( self , inherited0__name , inherited1__light_colour ,  ):
		light_source.__init__(self , inherited0__name , inherited1__light_colour , )

####################
 # ENTITY parabola #
####################
class parabola(conic):
	'''Entity parabola definition.

	:param focal_dist
	:type focal_dist:length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , focal_dist, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self.focal_dist = focal_dist

	@apply
	def focal_dist():
		def fget( self ):
			return self._focal_dist
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument focal_dist is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._focal_dist = length_measure(value)
			else:
				self._focal_dist = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.focal_dist  !=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rectangular_composite_surface #
####################
class rectangular_composite_surface(bounded_surface):
	'''Entity rectangular_composite_surface definition.

	:param segments
	:type segments:LIST(1,None,LIST(1,None,'surface_patch', scope = schema_scope))

	:param n_u
	:type n_u:INTEGER

	:param n_v
	:type n_v:INTEGER
	'''
	def __init__( self , inherited0__name , segments, ):
		bounded_surface.__init__(self , inherited0__name , )
		self.segments = segments

	@apply
	def segments():
		def fget( self ):
			return self._segments
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument segments is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,LIST(1,None,'surface_patch', scope = schema_scope))):
				self._segments = LIST(value)
			else:
				self._segments = value
		return property(**locals())

	@apply
	def n_u():
		def fget( self ):
			attribute_eval = SIZEOF(self.segments)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument n_u is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def n_v():
		def fget( self ):
			attribute_eval = SIZEOF(self.segments[1])
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument n_v is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = constraints_rectangular_composite_surface(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY magnetic_flux_unit #
####################
class magnetic_flux_unit(derived_unit):
	'''Entity magnetic_flux_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.weber))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_magnetic_flux_unit #
####################
class si_magnetic_flux_unit(magnetic_flux_unit,si_unit):
	'''Entity si_magnetic_flux_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		magnetic_flux_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.weber)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY externally_defined_text_font #
####################
class externally_defined_text_font(externally_defined_item):
	'''Entity externally_defined_text_font definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )

####################
 # ENTITY action_method_relationship #
####################
class action_method_relationship(BaseEntityClass):
	'''Entity action_method_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_method
	:type relating_method:action_method

	:param related_method
	:type related_method:action_method
	'''
	def __init__( self , name,description,relating_method,related_method, ):
		self.name = name
		self.description = description
		self.relating_method = relating_method
		self.related_method = related_method

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_method():
		def fget( self ):
			return self._relating_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_method is mantatory and can not be set to None')
			if not check_type(value,action_method):
				self._relating_method = action_method(value)
			else:
				self._relating_method = value
		return property(**locals())

	@apply
	def related_method():
		def fget( self ):
			return self._related_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_method is mantatory and can not be set to None')
			if not check_type(value,action_method):
				self._related_method = action_method(value)
			else:
				self._related_method = value
		return property(**locals())

####################
 # ENTITY right_to_usage_association #
####################
class right_to_usage_association(action_method_relationship):
	'''Entity right_to_usage_association definition.

	:param action_method_relationship_related_method
	:type action_method_relationship_related_method:information_right

	:param action_method_relationship_relating_method
	:type action_method_relationship_relating_method:information_usage_right

	:param right_applied
	:type right_applied:information_right

	:param right_usage
	:type right_usage:information_usage_right
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_method , inherited3__related_method , action_method_relationship_related_method,action_method_relationship_relating_method, ):
		action_method_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_method , inherited3__related_method , )
		self.action_method_relationship_related_method = action_method_relationship_related_method
		self.action_method_relationship_relating_method = action_method_relationship_relating_method

	@apply
	def action_method_relationship_related_method():
		def fget( self ):
			return self._action_method_relationship_related_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument action_method_relationship_related_method is mantatory and can not be set to None')
			if not check_type(value,information_right):
				self._action_method_relationship_related_method = information_right(value)
			else:
				self._action_method_relationship_related_method = value
		return property(**locals())

	@apply
	def action_method_relationship_relating_method():
		def fget( self ):
			return self._action_method_relationship_relating_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument action_method_relationship_relating_method is mantatory and can not be set to None')
			if not check_type(value,information_usage_right):
				self._action_method_relationship_relating_method = information_usage_right(value)
			else:
				self._action_method_relationship_relating_method = value
		return property(**locals())

	@apply
	def right_applied():
		def fget( self ):
			attribute_eval = self.self.action_method_relationship.self.related_method
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument right_applied is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def right_usage():
		def fget( self ):
			attribute_eval = self.self.action_method_relationship.self.relating_method
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument right_usage is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY face #
####################
class face(topological_representation_item):
	'''Entity face definition.

	:param bounds
	:type bounds:SET(1,None,'face_bound', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , bounds, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.bounds = bounds

	@apply
	def bounds():
		def fget( self ):
			return self._bounds
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument bounds is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'face_bound', scope = schema_scope)):
				self._bounds = SET(value)
			else:
				self._bounds = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not mixed_loop_type_set(list_to_set(list_face_loops(self))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY subface #
####################
class subface(face):
	'''Entity subface definition.

	:param parent_face
	:type parent_face:face
	'''
	def __init__( self , inherited0__name , inherited1__bounds , parent_face, ):
		face.__init__(self , inherited0__name , inherited1__bounds , )
		self.parent_face = parent_face

	@apply
	def parent_face():
		def fget( self ):
			return self._parent_face
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_face is mantatory and can not be set to None')
			if not check_type(value,face):
				self._parent_face = face(value)
			else:
				self._parent_face = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not mixed_loop_type_set(list_to_set(list_face_loops(self))  +  list_to_set(list_face_loops(self.parent_face))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY breakdown_element_group_assignment #
####################
class breakdown_element_group_assignment(group_assignment):
	'''Entity breakdown_element_group_assignment definition.

	:param items
	:type items:SET(1,1,'product_definition_or_breakdown_element_usage', scope = schema_scope)

	:param group_assignment_assigned_group
	:type group_assignment_assigned_group:product_definition_element_relationship
	'''
	def __init__( self , inherited0__assigned_group , items,group_assignment_assigned_group, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items
		self.group_assignment_assigned_group = group_assignment_assigned_group

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,1,'product_definition_or_breakdown_element_usage', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def group_assignment_assigned_group():
		def fget( self ):
			return self._group_assignment_assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument group_assignment_assigned_group is mantatory and can not be set to None')
			if not check_type(value,product_definition_element_relationship):
				self._group_assignment_assigned_group = product_definition_element_relationship(value)
			else:
				self._group_assignment_assigned_group = value
		return property(**locals())

####################
 # ENTITY flatness_tolerance #
####################
class flatness_tolerance(geometric_tolerance):
	'''Entity flatness_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY sourced_requirement #
####################
class sourced_requirement(group_assignment):
	'''Entity sourced_requirement definition.

	:param items
	:type items:SET(1,1,'product_definition', scope = schema_scope)

	:param group_assignment_assigned_group
	:type group_assignment_assigned_group:requirement_source
	'''
	def __init__( self , inherited0__assigned_group , items,group_assignment_assigned_group, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items
		self.group_assignment_assigned_group = group_assignment_assigned_group

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,1,'product_definition', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def group_assignment_assigned_group():
		def fget( self ):
			return self._group_assignment_assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument group_assignment_assigned_group is mantatory and can not be set to None')
			if not check_type(value,requirement_source):
				self._group_assignment_assigned_group = requirement_source(value)
			else:
				self._group_assignment_assigned_group = value
		return property(**locals())

####################
 # ENTITY contract_relationship #
####################
class contract_relationship(BaseEntityClass):
	'''Entity contract_relationship definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_contract
	:type relating_contract:contract

	:param related_contract
	:type related_contract:contract
	'''
	def __init__( self , id,name,description,relating_contract,related_contract, ):
		self.id = id
		self.name = name
		self.description = description
		self.relating_contract = relating_contract
		self.related_contract = related_contract

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_contract():
		def fget( self ):
			return self._relating_contract
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_contract is mantatory and can not be set to None')
			if not check_type(value,contract):
				self._relating_contract = contract(value)
			else:
				self._relating_contract = value
		return property(**locals())

	@apply
	def related_contract():
		def fget( self ):
			return self._related_contract
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_contract is mantatory and can not be set to None')
			if not check_type(value,contract):
				self._related_contract = contract(value)
			else:
				self._related_contract = value
		return property(**locals())

####################
 # ENTITY pre_defined_text_font #
####################
class pre_defined_text_font(pre_defined_item):
	'''Entity pre_defined_text_font definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )

####################
 # ENTITY draughting_pre_defined_text_font #
####################
class draughting_pre_defined_text_font(pre_defined_text_font):
	'''Entity draughting_pre_defined_text_font definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_text_font.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name[1:8]  ==  'ISO 3098')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY real_representation_item #
####################
class real_representation_item(representation_item,real_literal):
	'''Entity real_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__the_value , inherited2__literal_number_the_value ,  ):
		representation_item.__init__(self , inherited0__name , )
		real_literal.__init__(self , inherited1__the_value , inherited2__literal_number_the_value , )

####################
 # ENTITY amount_of_substance_unit #
####################
class amount_of_substance_unit(named_unit):
	'''Entity amount_of_substance_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  1))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY one_direction_repeat_factor #
####################
class one_direction_repeat_factor(geometric_representation_item):
	'''Entity one_direction_repeat_factor definition.

	:param repeat_factor
	:type repeat_factor:vector
	'''
	def __init__( self , inherited0__name , repeat_factor, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.repeat_factor = repeat_factor

	@apply
	def repeat_factor():
		def fget( self ):
			return self._repeat_factor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument repeat_factor is mantatory and can not be set to None')
			if not check_type(value,vector):
				self._repeat_factor = vector(value)
			else:
				self._repeat_factor = value
		return property(**locals())

####################
 # ENTITY atomic_formula #
####################
class atomic_formula(compound_representation_item):
	'''Entity atomic_formula definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY rule_condition #
####################
class rule_condition(atomic_formula):
	'''Entity rule_condition definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		atomic_formula.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY lot_effectivity #
####################
class lot_effectivity(effectivity):
	'''Entity lot_effectivity definition.

	:param effectivity_lot_id
	:type effectivity_lot_id:identifier

	:param effectivity_lot_size
	:type effectivity_lot_size:measure_with_unit
	'''
	def __init__( self , inherited0__id , effectivity_lot_id,effectivity_lot_size, ):
		effectivity.__init__(self , inherited0__id , )
		self.effectivity_lot_id = effectivity_lot_id
		self.effectivity_lot_size = effectivity_lot_size

	@apply
	def effectivity_lot_id():
		def fget( self ):
			return self._effectivity_lot_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument effectivity_lot_id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._effectivity_lot_id = identifier(value)
			else:
				self._effectivity_lot_id = value
		return property(**locals())

	@apply
	def effectivity_lot_size():
		def fget( self ):
			return self._effectivity_lot_size
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument effectivity_lot_size is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._effectivity_lot_size = measure_with_unit(value)
			else:
				self._effectivity_lot_size = value
		return property(**locals())

####################
 # ENTITY surface_of_linear_extrusion #
####################
class surface_of_linear_extrusion(swept_surface):
	'''Entity surface_of_linear_extrusion definition.

	:param extrusion_axis
	:type extrusion_axis:vector
	'''
	def __init__( self , inherited0__name , inherited1__swept_curve , extrusion_axis, ):
		swept_surface.__init__(self , inherited0__name , inherited1__swept_curve , )
		self.extrusion_axis = extrusion_axis

	@apply
	def extrusion_axis():
		def fget( self ):
			return self._extrusion_axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extrusion_axis is mantatory and can not be set to None')
			if not check_type(value,vector):
				self._extrusion_axis = vector(value)
			else:
				self._extrusion_axis = value
		return property(**locals())

####################
 # ENTITY environment #
####################
class environment(BaseEntityClass):
	'''Entity environment definition.

	:param syntactic_representation
	:type syntactic_representation:generic_variable

	:param semantics
	:type semantics:variable_semantics
	'''
	def __init__( self , syntactic_representation,semantics, ):
		self.syntactic_representation = syntactic_representation
		self.semantics = semantics

	@apply
	def syntactic_representation():
		def fget( self ):
			return self._syntactic_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument syntactic_representation is mantatory and can not be set to None')
			if not check_type(value,generic_variable):
				self._syntactic_representation = generic_variable(value)
			else:
				self._syntactic_representation = value
		return property(**locals())

	@apply
	def semantics():
		def fget( self ):
			return self._semantics
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semantics is mantatory and can not be set to None')
			if not check_type(value,variable_semantics):
				self._semantics = variable_semantics(value)
			else:
				self._semantics = value
		return property(**locals())

####################
 # ENTITY geometric_tolerance_relationship #
####################
class geometric_tolerance_relationship(BaseEntityClass):
	'''Entity geometric_tolerance_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_geometric_tolerance
	:type relating_geometric_tolerance:geometric_tolerance

	:param related_geometric_tolerance
	:type related_geometric_tolerance:geometric_tolerance
	'''
	def __init__( self , name,description,relating_geometric_tolerance,related_geometric_tolerance, ):
		self.name = name
		self.description = description
		self.relating_geometric_tolerance = relating_geometric_tolerance
		self.related_geometric_tolerance = related_geometric_tolerance

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_geometric_tolerance():
		def fget( self ):
			return self._relating_geometric_tolerance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_geometric_tolerance is mantatory and can not be set to None')
			if not check_type(value,geometric_tolerance):
				self._relating_geometric_tolerance = geometric_tolerance(value)
			else:
				self._relating_geometric_tolerance = value
		return property(**locals())

	@apply
	def related_geometric_tolerance():
		def fget( self ):
			return self._related_geometric_tolerance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_geometric_tolerance is mantatory and can not be set to None')
			if not check_type(value,geometric_tolerance):
				self._related_geometric_tolerance = geometric_tolerance(value)
			else:
				self._related_geometric_tolerance = value
		return property(**locals())

####################
 # ENTITY ground_fact #
####################
class ground_fact(atomic_formula):
	'''Entity ground_fact definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		atomic_formula.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY acceleration_measure_with_unit #
####################
class acceleration_measure_with_unit(measure_with_unit):
	'''Entity acceleration_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ACCELERATION_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY contract_assignment #
####################
class contract_assignment(BaseEntityClass):
	'''Entity contract_assignment definition.

	:param assigned_contract
	:type assigned_contract:contract

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_contract, ):
		self.assigned_contract = assigned_contract

	@apply
	def assigned_contract():
		def fget( self ):
			return self._assigned_contract
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_contract is mantatory and can not be set to None')
			if not check_type(value,contract):
				self._assigned_contract = contract(value)
			else:
				self._assigned_contract = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_contract_assignment #
####################
class applied_contract_assignment(contract_assignment):
	'''Entity applied_contract_assignment definition.

	:param items
	:type items:SET(1,None,'contract_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_contract , items, ):
		contract_assignment.__init__(self , inherited0__assigned_contract , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'contract_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY shell_based_surface_model #
####################
class shell_based_surface_model(geometric_representation_item):
	'''Entity shell_based_surface_model definition.

	:param sbsm_boundary
	:type sbsm_boundary:SET(1,None,'shell', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , sbsm_boundary, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.sbsm_boundary = sbsm_boundary

	@apply
	def sbsm_boundary():
		def fget( self ):
			return self._sbsm_boundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sbsm_boundary is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'shell', scope = schema_scope)):
				self._sbsm_boundary = SET(value)
			else:
				self._sbsm_boundary = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = constraints_geometry_shell_based_surface_model(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY electric_potential_unit #
####################
class electric_potential_unit(derived_unit):
	'''Entity electric_potential_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.volt))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_electric_potential_unit #
####################
class si_electric_potential_unit(electric_potential_unit,si_unit):
	'''Entity si_electric_potential_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		electric_potential_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.volt)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY solid_with_slot #
####################
class solid_with_slot(solid_with_depression):
	'''Entity solid_with_slot definition.

	:param slot_width
	:type slot_width:positive_length_measure

	:param closed_ends
	:type closed_ends:LIST(2,2,'LOGICAL', scope = schema_scope)

	:param end_exit_faces
	:type end_exit_faces:LIST(2,2,SET(0,None,'face_surface', scope = schema_scope))
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , slot_width,closed_ends,end_exit_faces, ):
		solid_with_depression.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , )
		self.slot_width = slot_width
		self.closed_ends = closed_ends
		self.end_exit_faces = end_exit_faces

	@apply
	def slot_width():
		def fget( self ):
			return self._slot_width
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument slot_width is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._slot_width = positive_length_measure(value)
			else:
				self._slot_width = value
		return property(**locals())

	@apply
	def closed_ends():
		def fget( self ):
			return self._closed_ends
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument closed_ends is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'LOGICAL', scope = schema_scope)):
				self._closed_ends = LIST(value)
			else:
				self._closed_ends = value
		return property(**locals())

	@apply
	def end_exit_faces():
		def fget( self ):
			return self._end_exit_faces
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument end_exit_faces is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,SET(0,None,'face_surface', scope = schema_scope))):
				self._end_exit_faces = LIST(value)
			else:
				self._end_exit_faces = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION'  ==  TYPEOF(self))  and  (self.closed_ends  ==  [FALSE,FALSE])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not (((self.closed_ends[1]  ==  TRUE)  and  (SIZEOF(self.end_exit_faces[1])  !=  0))  or  ((self.closed_ends[2]  ==  TRUE)  and  (SIZEOF(self.end_exit_faces[2])  !=  0))))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY solid_with_straight_slot #
####################
class solid_with_straight_slot(solid_with_slot):
	'''Entity solid_with_straight_slot definition.

	:param slot_length
	:type slot_length:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__slot_width , inherited6__closed_ends , inherited7__end_exit_faces , slot_length, ):
		solid_with_slot.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__slot_width , inherited6__closed_ends , inherited7__end_exit_faces , )
		self.slot_length = slot_length

	@apply
	def slot_length():
		def fget( self ):
			return self._slot_length
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument slot_length is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._slot_length = positive_length_measure(value)
			else:
				self._slot_length = value
		return property(**locals())

####################
 # ENTITY uniform_curve #
####################
class uniform_curve(b_spline_curve):
	'''Entity uniform_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect ,  ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )

####################
 # ENTITY absorbed_dose_unit #
####################
class absorbed_dose_unit(derived_unit):
	'''Entity absorbed_dose_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.gray))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY bezier_curve #
####################
class bezier_curve(b_spline_curve):
	'''Entity bezier_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect ,  ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )

####################
 # ENTITY loop #
####################
class loop(topological_representation_item):
	'''Entity loop definition.
	'''
	def __init__( self , inherited0__name ,  ):
		topological_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY edge_loop #
####################
class edge_loop(loop,path):
	'''Entity edge_loop definition.

	:param ne
	:type ne:INTEGER
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__edge_list ,  ):
		loop.__init__(self , inherited0__name , )
		path.__init__(self , inherited1__name , inherited2__edge_list , )

	@apply
	def ne():
		def fget( self ):
			attribute_eval = SIZEOF(self.self.path.self.edge_list)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument ne is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.path.self.edge_list[1].self.edge_start  ==  self.self.path.self.edge_list[self.ne].self.edge_end)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_force_unit #
####################
class si_force_unit(force_unit,si_unit):
	'''Entity si_force_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		force_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.newton)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY electric_charge_unit #
####################
class electric_charge_unit(derived_unit):
	'''Entity electric_charge_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.coulomb))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_electric_charge_unit #
####################
class si_electric_charge_unit(electric_charge_unit,si_unit):
	'''Entity si_electric_charge_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		electric_charge_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.coulomb)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY solid_with_pocket #
####################
class solid_with_pocket(solid_with_depression):
	'''Entity solid_with_pocket definition.

	:param floor_blend_radius
	:type floor_blend_radius:non_negative_length_measure

	:param draft_angle
	:type draft_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , floor_blend_radius,draft_angle, ):
		solid_with_depression.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , )
		self.floor_blend_radius = floor_blend_radius
		self.draft_angle = draft_angle

	@apply
	def floor_blend_radius():
		def fget( self ):
			return self._floor_blend_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument floor_blend_radius is mantatory and can not be set to None')
			if not check_type(value,non_negative_length_measure):
				self._floor_blend_radius = non_negative_length_measure(value)
			else:
				self._floor_blend_radius = value
		return property(**locals())

	@apply
	def draft_angle():
		def fget( self ):
			return self._draft_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument draft_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._draft_angle = plane_angle_measure(value)
			else:
				self._draft_angle = value
		return property(**locals())

####################
 # ENTITY date #
####################
class date(BaseEntityClass):
	'''Entity date definition.

	:param year_component
	:type year_component:year_number
	'''
	def __init__( self , year_component, ):
		self.year_component = year_component

	@apply
	def year_component():
		def fget( self ):
			return self._year_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument year_component is mantatory and can not be set to None')
			if not check_type(value,year_number):
				self._year_component = year_number(value)
			else:
				self._year_component = value
		return property(**locals())

####################
 # ENTITY calendar_date #
####################
class calendar_date(date):
	'''Entity calendar_date definition.

	:param day_component
	:type day_component:day_in_month_number

	:param month_component
	:type month_component:month_in_year_number
	'''
	def __init__( self , inherited0__year_component , day_component,month_component, ):
		date.__init__(self , inherited0__year_component , )
		self.day_component = day_component
		self.month_component = month_component

	@apply
	def day_component():
		def fget( self ):
			return self._day_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument day_component is mantatory and can not be set to None')
			if not check_type(value,day_in_month_number):
				self._day_component = day_in_month_number(value)
			else:
				self._day_component = value
		return property(**locals())

	@apply
	def month_component():
		def fget( self ):
			return self._month_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument month_component is mantatory and can not be set to None')
			if not check_type(value,month_in_year_number):
				self._month_component = month_in_year_number(value)
			else:
				self._month_component = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = valid_calendar_date(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY dimension_curve_terminator #
####################
class dimension_curve_terminator(terminator_symbol):
	'''Entity dimension_curve_terminator definition.

	:param role
	:type role:dimension_extent_usage
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , inherited4__annotated_curve , role, ):
		terminator_symbol.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , inherited4__annotated_curve , )
		self.role = role

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,dimension_extent_usage):
				self._role = dimension_extent_usage(value)
			else:
				self._role = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIMENSION_CURVE'  ==  TYPEOF(self.self.terminator_symbol.self.annotated_curve))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY externally_defined_curve_font #
####################
class externally_defined_curve_font(externally_defined_item):
	'''Entity externally_defined_curve_font definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )

####################
 # ENTITY point_path #
####################
class point_path(compound_representation_item,geometric_representation_item):
	'''Entity point_path definition.

	:param compound_representation_item_item_element
	:type compound_representation_item_item_element:LIST(1,None,'point_and_vector', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__item_element , inherited2__name , compound_representation_item_item_element, ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )
		geometric_representation_item.__init__(self , inherited2__name , )
		self.compound_representation_item_item_element = compound_representation_item_item_element

	@apply
	def compound_representation_item_item_element():
		def fget( self ):
			return self._compound_representation_item_item_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument compound_representation_item_item_element is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'point_and_vector', scope = schema_scope)):
				self._compound_representation_item_item_element = LIST(value)
			else:
				self._compound_representation_item_item_element = value
		return property(**locals())

####################
 # ENTITY toroidal_surface #
####################
class toroidal_surface(elementary_surface):
	'''Entity toroidal_surface definition.

	:param major_radius
	:type major_radius:positive_length_measure

	:param minor_radius
	:type minor_radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , major_radius,minor_radius, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self.major_radius = major_radius
		self.minor_radius = minor_radius

	@apply
	def major_radius():
		def fget( self ):
			return self._major_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument major_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._major_radius = positive_length_measure(value)
			else:
				self._major_radius = value
		return property(**locals())

	@apply
	def minor_radius():
		def fget( self ):
			return self._minor_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument minor_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._minor_radius = positive_length_measure(value)
			else:
				self._minor_radius = value
		return property(**locals())

####################
 # ENTITY electric_charge_measure_with_unit #
####################
class electric_charge_measure_with_unit(measure_with_unit):
	'''Entity electric_charge_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELECTRIC_CHARGE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY externally_defined_representation_item #
####################
class externally_defined_representation_item(representation_item,externally_defined_item):
	'''Entity externally_defined_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_id , inherited2__source ,  ):
		representation_item.__init__(self , inherited0__name , )
		externally_defined_item.__init__(self , inherited1__item_id , inherited2__source , )

####################
 # ENTITY promissory_usage_occurrence #
####################
class promissory_usage_occurrence(assembly_component_usage):
	'''Entity promissory_usage_occurrence definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator ,  ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )

####################
 # ENTITY product_concept_feature #
####################
class product_concept_feature(BaseEntityClass):
	'''Entity product_concept_feature definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY package_product_concept_feature #
####################
class package_product_concept_feature(product_concept_feature):
	'''Entity package_product_concept_feature definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description ,  ):
		product_concept_feature.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'CONDITIONAL_CONCEPT_FEATURE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY requirement_assigned_object #
####################
class requirement_assigned_object(group_assignment):
	'''Entity requirement_assigned_object definition.

	:param items
	:type items:SET(1,1,'requirement_assigned_item', scope = schema_scope)

	:param group_assignment_assigned_group
	:type group_assignment_assigned_group:requirement_assignment
	'''
	def __init__( self , inherited0__assigned_group , items,group_assignment_assigned_group, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items
		self.group_assignment_assigned_group = group_assignment_assigned_group

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,1,'requirement_assigned_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def group_assignment_assigned_group():
		def fget( self ):
			return self._group_assignment_assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument group_assignment_assigned_group is mantatory and can not be set to None')
			if not check_type(value,requirement_assignment):
				self._group_assignment_assigned_group = requirement_assignment(value)
			else:
				self._group_assignment_assigned_group = value
		return property(**locals())

####################
 # ENTITY solid_with_stepped_round_hole_and_conical_transitions #
####################
class solid_with_stepped_round_hole_and_conical_transitions(solid_with_stepped_round_hole):
	'''Entity solid_with_stepped_round_hole_and_conical_transitions definition.

	:param conical_transitions
	:type conical_transitions:SET(1,None,'conical_stepped_hole_transition', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__segments , inherited6__segment_radii , inherited7__segment_depths , conical_transitions, ):
		solid_with_stepped_round_hole.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__segments , inherited6__segment_radii , inherited7__segment_depths , )
		self.conical_transitions = conical_transitions

	@apply
	def conical_transitions():
		def fget( self ):
			return self._conical_transitions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument conical_transitions is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'conical_stepped_hole_transition', scope = schema_scope)):
				self._conical_transitions = SET(value)
			else:
				self._conical_transitions = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.conical_transitions)  <=  (self.self.solid_with_stepped_round_hole.self.segments  +  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION'  ==  TYPEOF(self)) XOR (SIZEOF(self.conical_transitions)  <=  self.self.solid_with_stepped_round_hole.self.segments))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = validate_countersink_radii(self)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY approval_assignment #
####################
class approval_assignment(BaseEntityClass):
	'''Entity approval_assignment definition.

	:param assigned_approval
	:type assigned_approval:approval

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_approval, ):
		self.assigned_approval = assigned_approval

	@apply
	def assigned_approval():
		def fget( self ):
			return self._assigned_approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_approval is mantatory and can not be set to None')
			if not check_type(value,approval):
				self._assigned_approval = approval(value)
			else:
				self._assigned_approval = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY breakdown_context #
####################
class breakdown_context(product_definition_relationship):
	'''Entity breakdown_context definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY physical_breakdown_context #
####################
class physical_breakdown_context(breakdown_context):
	'''Entity physical_breakdown_context definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		breakdown_context.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY symbol #
####################
class symbol(representation_item):
	'''Entity symbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY curve_style_font #
####################
class curve_style_font(founded_item):
	'''Entity curve_style_font definition.

	:param name
	:type name:label

	:param pattern_list
	:type pattern_list:LIST(1,None,'curve_style_font_pattern', scope = schema_scope)
	'''
	def __init__( self , name,pattern_list, ):
		founded_item.__init__(self , )
		self.name = name
		self.pattern_list = pattern_list

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def pattern_list():
		def fget( self ):
			return self._pattern_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pattern_list is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'curve_style_font_pattern', scope = schema_scope)):
				self._pattern_list = LIST(value)
			else:
				self._pattern_list = value
		return property(**locals())

####################
 # ENTITY procedural_representation_sequence #
####################
class procedural_representation_sequence(representation_item):
	'''Entity procedural_representation_sequence definition.

	:param elements
	:type elements:LIST(1,None,'representation_item', scope = schema_scope)

	:param suppressed_items
	:type suppressed_items:SET(0,None,'representation_item', scope = schema_scope)

	:param rationale
	:type rationale:text
	'''
	def __init__( self , inherited0__name , elements,suppressed_items,rationale, ):
		representation_item.__init__(self , inherited0__name , )
		self.elements = elements
		self.suppressed_items = suppressed_items
		self.rationale = rationale

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument elements is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'representation_item', scope = schema_scope)):
				self._elements = LIST(value)
			else:
				self._elements = value
		return property(**locals())

	@apply
	def suppressed_items():
		def fget( self ):
			return self._suppressed_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument suppressed_items is mantatory and can not be set to None')
			if not check_type(value,SET(0,None,'representation_item', scope = schema_scope)):
				self._suppressed_items = SET(value)
			else:
				self._suppressed_items = value
		return property(**locals())

	@apply
	def rationale():
		def fget( self ):
			return self._rationale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rationale is mantatory and can not be set to None')
			if not check_type(value,text):
				self._rationale = text(value)
			else:
				self._rationale = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY procedural_shape_representation_sequence #
####################
class procedural_shape_representation_sequence(geometric_representation_item,procedural_representation_sequence):
	'''Entity procedural_shape_representation_sequence definition.
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__elements , inherited3__suppressed_items , inherited4__rationale ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )
		procedural_representation_sequence.__init__(self , inherited1__name , inherited2__elements , inherited3__suppressed_items , inherited4__rationale , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY text_font_family #
####################
class text_font_family(BaseEntityClass):
	'''Entity text_font_family definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param fonts
	:type fonts:SET(1,None,'text_font_in_family', scope = schema_scope)
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def fonts():
		def fget( self ):
			return self._fonts
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument fonts is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY back_chaining_rule_body #
####################
class back_chaining_rule_body(property_definition,property_definition_representation,representation):
	'''Entity back_chaining_rule_body definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition , inherited3__definition , inherited4__used_representation , inherited5__name , inherited6__items , inherited7__context_of_items ,  ):
		property_definition.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )
		property_definition_representation.__init__(self , inherited3__definition , inherited4__used_representation , )
		representation.__init__(self , inherited5__name , inherited6__items , inherited7__context_of_items , )

####################
 # ENTITY character_glyph_style_outline #
####################
class character_glyph_style_outline(founded_item):
	'''Entity character_glyph_style_outline definition.

	:param outline_style
	:type outline_style:curve_style
	'''
	def __init__( self , outline_style, ):
		founded_item.__init__(self , )
		self.outline_style = outline_style

	@apply
	def outline_style():
		def fget( self ):
			return self._outline_style
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outline_style is mantatory and can not be set to None')
			if not check_type(value,curve_style):
				self._outline_style = curve_style(value)
			else:
				self._outline_style = value
		return property(**locals())

####################
 # ENTITY solid_with_rectangular_pocket #
####################
class solid_with_rectangular_pocket(solid_with_pocket):
	'''Entity solid_with_rectangular_pocket definition.

	:param pocket_length
	:type pocket_length:positive_length_measure

	:param pocket_width
	:type pocket_width:positive_length_measure

	:param corner_radius
	:type corner_radius:non_negative_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__floor_blend_radius , inherited6__draft_angle , pocket_length,pocket_width,corner_radius, ):
		solid_with_pocket.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__floor_blend_radius , inherited6__draft_angle , )
		self.pocket_length = pocket_length
		self.pocket_width = pocket_width
		self.corner_radius = corner_radius

	@apply
	def pocket_length():
		def fget( self ):
			return self._pocket_length
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pocket_length is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._pocket_length = positive_length_measure(value)
			else:
				self._pocket_length = value
		return property(**locals())

	@apply
	def pocket_width():
		def fget( self ):
			return self._pocket_width
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pocket_width is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._pocket_width = positive_length_measure(value)
			else:
				self._pocket_width = value
		return property(**locals())

	@apply
	def corner_radius():
		def fget( self ):
			return self._corner_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument corner_radius is mantatory and can not be set to None')
			if not check_type(value,non_negative_length_measure):
				self._corner_radius = non_negative_length_measure(value)
			else:
				self._corner_radius = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.corner_radius  <  (self.pocket_width / 2))  and  (self.corner_radius  <  (self.pocket_length / 2)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY value_representation_item #
####################
class value_representation_item(representation_item):
	'''Entity value_representation_item definition.

	:param value_component
	:type value_component:measure_value
	'''
	def __init__( self , inherited0__name , value_component, ):
		representation_item.__init__(self , inherited0__name , )
		self.value_component = value_component

	@apply
	def value_component():
		def fget( self ):
			return self._value_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument value_component is mantatory and can not be set to None')
			if not check_type(value,measure_value):
				self._value_component = measure_value(value)
			else:
				self._value_component = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY position_tolerance #
####################
class position_tolerance(geometric_tolerance):
	'''Entity position_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))  or  (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition_substitute #
####################
class product_definition_substitute(BaseEntityClass):
	'''Entity product_definition_substitute definition.

	:param description
	:type description:text

	:param context_relationship
	:type context_relationship:product_definition_relationship

	:param substitute_definition
	:type substitute_definition:product_definition

	:param name
	:type name:label
	'''
	def __init__( self , description,context_relationship,substitute_definition, ):
		self.description = description
		self.context_relationship = context_relationship
		self.substitute_definition = substitute_definition

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def context_relationship():
		def fget( self ):
			return self._context_relationship
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument context_relationship is mantatory and can not be set to None')
			if not check_type(value,product_definition_relationship):
				self._context_relationship = product_definition_relationship(value)
			else:
				self._context_relationship = value
		return property(**locals())

	@apply
	def substitute_definition():
		def fget( self ):
			return self._substitute_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument substitute_definition is mantatory and can not be set to None')
			if not check_type(value,product_definition):
				self._substitute_definition = product_definition(value)
			else:
				self._substitute_definition = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.context_relationship.self.related_product_definition  !=  self.substitute_definition)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY solid_with_tee_section_slot #
####################
class solid_with_tee_section_slot(solid_with_slot):
	'''Entity solid_with_tee_section_slot definition.

	:param tee_section_width
	:type tee_section_width:positive_length_measure

	:param collar_depth
	:type collar_depth:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__slot_width , inherited6__closed_ends , inherited7__end_exit_faces , tee_section_width,collar_depth, ):
		solid_with_slot.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__slot_width , inherited6__closed_ends , inherited7__end_exit_faces , )
		self.tee_section_width = tee_section_width
		self.collar_depth = collar_depth

	@apply
	def tee_section_width():
		def fget( self ):
			return self._tee_section_width
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tee_section_width is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._tee_section_width = positive_length_measure(value)
			else:
				self._tee_section_width = value
		return property(**locals())

	@apply
	def collar_depth():
		def fget( self ):
			return self._collar_depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument collar_depth is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._collar_depth = positive_length_measure(value)
			else:
				self._collar_depth = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.collar_depth  <  self.self.solid_with_depression.self.depth)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.tee_section_width  >  self.self.solid_with_slot.self.slot_width)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY representation_map #
####################
class representation_map(BaseEntityClass):
	'''Entity representation_map definition.

	:param mapping_origin
	:type mapping_origin:representation_item

	:param mapped_representation
	:type mapped_representation:representation

	:param map_usage
	:type map_usage:SET(1,None,'mapped_item', scope = schema_scope)
	'''
	def __init__( self , mapping_origin,mapped_representation, ):
		self.mapping_origin = mapping_origin
		self.mapped_representation = mapped_representation

	@apply
	def mapping_origin():
		def fget( self ):
			return self._mapping_origin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapping_origin is mantatory and can not be set to None')
			if not check_type(value,representation_item):
				self._mapping_origin = representation_item(value)
			else:
				self._mapping_origin = value
		return property(**locals())

	@apply
	def mapped_representation():
		def fget( self ):
			return self._mapped_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_representation is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._mapped_representation = representation(value)
			else:
				self._mapped_representation = value
		return property(**locals())

	@apply
	def map_usage():
		def fget( self ):
			return self._map_usage
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument map_usage is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = item_in_context(self.self.mapping_origin,self.self.mapped_representation.self.context_of_items)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY symbol_representation_map #
####################
class symbol_representation_map(representation_map):
	'''Entity symbol_representation_map definition.

	:param representation_map_mapped_representation
	:type representation_map_mapped_representation:symbol_representation

	:param representation_map_mapping_origin
	:type representation_map_mapping_origin:axis2_placement
	'''
	def __init__( self , inherited0__mapping_origin , inherited1__mapped_representation , representation_map_mapped_representation,representation_map_mapping_origin, ):
		representation_map.__init__(self , inherited0__mapping_origin , inherited1__mapped_representation , )
		self.representation_map_mapped_representation = representation_map_mapped_representation
		self.representation_map_mapping_origin = representation_map_mapping_origin

	@apply
	def representation_map_mapped_representation():
		def fget( self ):
			return self._representation_map_mapped_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_map_mapped_representation is mantatory and can not be set to None')
			if not check_type(value,symbol_representation):
				self._representation_map_mapped_representation = symbol_representation(value)
			else:
				self._representation_map_mapped_representation = value
		return property(**locals())

	@apply
	def representation_map_mapping_origin():
		def fget( self ):
			return self._representation_map_mapping_origin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_map_mapping_origin is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._representation_map_mapping_origin = axis2_placement(value)
			else:
				self._representation_map_mapping_origin = value
		return property(**locals())

####################
 # ENTITY vector #
####################
class vector(geometric_representation_item):
	'''Entity vector definition.

	:param orientation
	:type orientation:direction

	:param magnitude
	:type magnitude:length_measure
	'''
	def __init__( self , inherited0__name , orientation,magnitude, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.orientation = orientation
		self.magnitude = magnitude

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._orientation = direction(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def magnitude():
		def fget( self ):
			return self._magnitude
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument magnitude is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._magnitude = length_measure(value)
			else:
				self._magnitude = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.magnitude  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY annotation_text #
####################
class annotation_text(mapped_item):
	'''Entity annotation_text definition.

	:param mapped_item_mapping_target
	:type mapped_item_mapping_target:axis2_placement
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , mapped_item_mapping_target, ):
		mapped_item.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , )
		self.mapped_item_mapping_target = mapped_item_mapping_target

	@apply
	def mapped_item_mapping_target():
		def fget( self ):
			return self._mapped_item_mapping_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_target is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._mapped_item_mapping_target = axis2_placement(value)
			else:
				self._mapped_item_mapping_target = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TEXT_STRING_REPRESENTATION'  ==  TYPEOF(self.self.mapped_item.self.mapping_source.self.mapped_representation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM'  ==  TYPEOF(self))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY binary_generic_expression #
####################
class binary_generic_expression(generic_expression):
	'''Entity binary_generic_expression definition.

	:param operands
	:type operands:LIST(2,2,'generic_expression', scope = schema_scope)
	'''
	def __init__( self , operands, ):
		generic_expression.__init__(self , )
		self.operands = operands

	@apply
	def operands():
		def fget( self ):
			return self._operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'generic_expression', scope = schema_scope)):
				self._operands = LIST(value)
			else:
				self._operands = value
		return property(**locals())

####################
 # ENTITY pcurve #
####################
class pcurve(curve):
	'''Entity pcurve definition.

	:param basis_surface
	:type basis_surface:surface

	:param reference_to_curve
	:type reference_to_curve:definitional_representation
	'''
	def __init__( self , inherited0__name , basis_surface,reference_to_curve, ):
		curve.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.reference_to_curve = reference_to_curve

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def reference_to_curve():
		def fget( self ):
			return self._reference_to_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reference_to_curve is mantatory and can not be set to None')
			if not check_type(value,definitional_representation):
				self._reference_to_curve = definitional_representation(value)
			else:
				self._reference_to_curve = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.reference_to_curve.self.representation.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE'  ==  TYPEOF(self.reference_to_curve.self.representation.self.items[1]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.reference_to_curve.self.representation.self.items[1].self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY bounded_pcurve #
####################
class bounded_pcurve(pcurve,bounded_curve):
	'''Entity bounded_pcurve definition.
	'''
	def __init__( self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , inherited3__name ,  ):
		pcurve.__init__(self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , )
		bounded_curve.__init__(self , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOUNDED_CURVE'  ==  TYPEOF(self.self.pcurve.self.reference_to_curve.self.items[1]))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY camera_model_d3_multi_clipping_union #
####################
class camera_model_d3_multi_clipping_union(geometric_representation_item):
	'''Entity camera_model_d3_multi_clipping_union definition.

	:param shape_clipping
	:type shape_clipping:SET(2,None,'camera_model_d3_multi_clipping_union_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , shape_clipping, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.shape_clipping = shape_clipping

	@apply
	def shape_clipping():
		def fget( self ):
			return self._shape_clipping
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument shape_clipping is mantatory and can not be set to None')
			if not check_type(value,SET(2,None,'camera_model_d3_multi_clipping_union_select', scope = schema_scope)):
				self._shape_clipping = SET(value)
			else:
				self._shape_clipping = value
		return property(**locals())

####################
 # ENTITY frequency_measure_with_unit #
####################
class frequency_measure_with_unit(measure_with_unit):
	'''Entity frequency_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.FREQUENCY_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY intersection_curve #
####################
class intersection_curve(surface_curve):
	'''Entity intersection_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation ,  ):
		surface_curve.__init__(self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.surface_curve.self.associated_geometry)  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (associated_surface(self.self.surface_curve.self.associated_geometry[1])  !=  associated_surface(self.self.surface_curve.self.associated_geometry[2]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY presentation_set #
####################
class presentation_set(BaseEntityClass):
	'''Entity presentation_set definition.

	:param areas
	:type areas:SET(1,None,'area_in_set', scope = schema_scope)
	'''
	# This class does not define any attribute.
	pass

	@apply
	def areas():
		def fget( self ):
			return self._areas
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument areas is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY solid_with_trapezoidal_section_slot #
####################
class solid_with_trapezoidal_section_slot(solid_with_slot):
	'''Entity solid_with_trapezoidal_section_slot definition.

	:param draft_angle
	:type draft_angle:plane_angle_measure

	:param floor_fillet_radius
	:type floor_fillet_radius:non_negative_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__slot_width , inherited6__closed_ends , inherited7__end_exit_faces , draft_angle,floor_fillet_radius, ):
		solid_with_slot.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__slot_width , inherited6__closed_ends , inherited7__end_exit_faces , )
		self.draft_angle = draft_angle
		self.floor_fillet_radius = floor_fillet_radius

	@apply
	def draft_angle():
		def fget( self ):
			return self._draft_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument draft_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._draft_angle = plane_angle_measure(value)
			else:
				self._draft_angle = value
		return property(**locals())

	@apply
	def floor_fillet_radius():
		def fget( self ):
			return self._floor_fillet_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument floor_fillet_radius is mantatory and can not be set to None')
			if not check_type(value,non_negative_length_measure):
				self._floor_fillet_radius = non_negative_length_measure(value)
			else:
				self._floor_fillet_radius = value
		return property(**locals())

####################
 # ENTITY trimmed_curve #
####################
class trimmed_curve(bounded_curve):
	'''Entity trimmed_curve definition.

	:param basis_curve
	:type basis_curve:curve

	:param trim_1
	:type trim_1:SET(1,2,'trimming_select', scope = schema_scope)

	:param trim_2
	:type trim_2:SET(1,2,'trimming_select', scope = schema_scope)

	:param sense_agreement
	:type sense_agreement:BOOLEAN

	:param master_representation
	:type master_representation:trimming_preference
	'''
	def __init__( self , inherited0__name , basis_curve,trim_1,trim_2,sense_agreement,master_representation, ):
		bounded_curve.__init__(self , inherited0__name , )
		self.basis_curve = basis_curve
		self.trim_1 = trim_1
		self.trim_2 = trim_2
		self.sense_agreement = sense_agreement
		self.master_representation = master_representation

	@apply
	def basis_curve():
		def fget( self ):
			return self._basis_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._basis_curve = curve(value)
			else:
				self._basis_curve = value
		return property(**locals())

	@apply
	def trim_1():
		def fget( self ):
			return self._trim_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument trim_1 is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'trimming_select', scope = schema_scope)):
				self._trim_1 = SET(value)
			else:
				self._trim_1 = value
		return property(**locals())

	@apply
	def trim_2():
		def fget( self ):
			return self._trim_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument trim_2 is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'trimming_select', scope = schema_scope)):
				self._trim_2 = SET(value)
			else:
				self._trim_2 = value
		return property(**locals())

	@apply
	def sense_agreement():
		def fget( self ):
			return self._sense_agreement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sense_agreement is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._sense_agreement = BOOLEAN(value)
			else:
				self._sense_agreement = value
		return property(**locals())

	@apply
	def master_representation():
		def fget( self ):
			return self._master_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument master_representation is mantatory and can not be set to None')
			if not check_type(value,trimming_preference):
				self._master_representation = trimming_preference(value)
			else:
				self._master_representation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.trim_1)  ==  1)  or  (TYPEOF(self.trim_1[1])  !=  TYPEOF(self.trim_1[2])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((HIINDEX(self.trim_2)  ==  1)  or  (TYPEOF(self.trim_2[1])  !=  TYPEOF(self.trim_2[2])))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY projection_directed_callout #
####################
class projection_directed_callout(draughting_callout):
	'''Entity projection_directed_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.draughting_callout.self.contents)  >=  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY ordinate_dimension #
####################
class ordinate_dimension(projection_directed_callout):
	'''Entity ordinate_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		projection_directed_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY perpendicular_to #
####################
class perpendicular_to(derived_shape_aspect):
	'''Entity perpendicular_to definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY geometric_alignment #
####################
class geometric_alignment(derived_shape_aspect):
	'''Entity geometric_alignment definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  >  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY geometric_intersection #
####################
class geometric_intersection(derived_shape_aspect):
	'''Entity geometric_intersection definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  >  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY presentation_view #
####################
class presentation_view(presentation_representation):
	'''Entity presentation_view definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items ,  ):
		presentation_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , )

####################
 # ENTITY text_literal #
####################
class text_literal(geometric_representation_item):
	'''Entity text_literal definition.

	:param literal
	:type literal:presentable_text

	:param placement
	:type placement:axis2_placement

	:param alignment
	:type alignment:text_alignment

	:param path
	:type path:text_path

	:param font
	:type font:font_select
	'''
	def __init__( self , inherited0__name , literal,placement,alignment,path,font, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.literal = literal
		self.placement = placement
		self.alignment = alignment
		self.path = path
		self.font = font

	@apply
	def literal():
		def fget( self ):
			return self._literal
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument literal is mantatory and can not be set to None')
			if not check_type(value,presentable_text):
				self._literal = presentable_text(value)
			else:
				self._literal = value
		return property(**locals())

	@apply
	def placement():
		def fget( self ):
			return self._placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placement is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._placement = axis2_placement(value)
			else:
				self._placement = value
		return property(**locals())

	@apply
	def alignment():
		def fget( self ):
			return self._alignment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument alignment is mantatory and can not be set to None')
			if not check_type(value,text_alignment):
				self._alignment = text_alignment(value)
			else:
				self._alignment = value
		return property(**locals())

	@apply
	def path():
		def fget( self ):
			return self._path
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument path is mantatory and can not be set to None')
			if not check_type(value,text_path):
				self._path = text_path(value)
			else:
				self._path = value
		return property(**locals())

	@apply
	def font():
		def fget( self ):
			return self._font
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument font is mantatory and can not be set to None')
			if not check_type(value,font_select):
				self._font = font_select(value)
			else:
				self._font = value
		return property(**locals())

####################
 # ENTITY text_literal_with_delineation #
####################
class text_literal_with_delineation(text_literal):
	'''Entity text_literal_with_delineation definition.

	:param delineation
	:type delineation:text_delineation
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , delineation, ):
		text_literal.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , )
		self.delineation = delineation

	@apply
	def delineation():
		def fget( self ):
			return self._delineation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument delineation is mantatory and can not be set to None')
			if not check_type(value,text_delineation):
				self._delineation = text_delineation(value)
			else:
				self._delineation = value
		return property(**locals())

####################
 # ENTITY contact_ratio_representation #
####################
class contact_ratio_representation(representation):
	'''Entity contact_ratio_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.self.items)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((SIZEOF(USEDIN(self,('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PROPERTY_DEFINITION_REPRESENTATION.')  +  'USED_REPRESENTATION'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY dimensional_characteristic_representation #
####################
class dimensional_characteristic_representation(BaseEntityClass):
	'''Entity dimensional_characteristic_representation definition.

	:param dimension
	:type dimension:dimensional_characteristic

	:param representation
	:type representation:shape_dimension_representation
	'''
	def __init__( self , dimension,representation, ):
		self.dimension = dimension
		self.representation = representation

	@apply
	def dimension():
		def fget( self ):
			return self._dimension
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dimension is mantatory and can not be set to None')
			if not check_type(value,dimensional_characteristic):
				self._dimension = dimensional_characteristic(value)
			else:
				self._dimension = value
		return property(**locals())

	@apply
	def representation():
		def fget( self ):
			return self._representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation is mantatory and can not be set to None')
			if not check_type(value,shape_dimension_representation):
				self._representation = shape_dimension_representation(value)
			else:
				self._representation = value
		return property(**locals())

####################
 # ENTITY tolerance_zone_definition #
####################
class tolerance_zone_definition(BaseEntityClass):
	'''Entity tolerance_zone_definition definition.

	:param zone
	:type zone:tolerance_zone

	:param boundaries
	:type boundaries:SET(1,None,'shape_aspect', scope = schema_scope)
	'''
	def __init__( self , zone,boundaries, ):
		self.zone = zone
		self.boundaries = boundaries

	@apply
	def zone():
		def fget( self ):
			return self._zone
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zone is mantatory and can not be set to None')
			if not check_type(value,tolerance_zone):
				self._zone = tolerance_zone(value)
			else:
				self._zone = value
		return property(**locals())

	@apply
	def boundaries():
		def fget( self ):
			return self._boundaries
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument boundaries is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'shape_aspect', scope = schema_scope)):
				self._boundaries = SET(value)
			else:
				self._boundaries = value
		return property(**locals())

####################
 # ENTITY projected_zone_definition #
####################
class projected_zone_definition(tolerance_zone_definition):
	'''Entity projected_zone_definition definition.

	:param projection_end
	:type projection_end:shape_aspect

	:param projected_length
	:type projected_length:measure_with_unit
	'''
	def __init__( self , inherited0__zone , inherited1__boundaries , projection_end,projected_length, ):
		tolerance_zone_definition.__init__(self , inherited0__zone , inherited1__boundaries , )
		self.projection_end = projection_end
		self.projected_length = projected_length

	@apply
	def projection_end():
		def fget( self ):
			return self._projection_end
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument projection_end is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._projection_end = shape_aspect(value)
			else:
				self._projection_end = value
		return property(**locals())

	@apply
	def projected_length():
		def fget( self ):
			return self._projected_length
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument projected_length is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._projected_length = measure_with_unit(value)
			else:
				self._projected_length = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('NUMBER'  ==  TYPEOF(self.projected_length.self.measure_with_unit.self.value_component))  and  (self.projected_length.self.measure_with_unit.self.value_component  >  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (derive_dimensional_exponents(self.projected_length.self.measure_with_unit.self.unit_component)  ==  dimensional_exponents(1,0,0,0,0,0,0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY qualitative_uncertainty #
####################
class qualitative_uncertainty(uncertainty_qualifier):
	'''Entity qualitative_uncertainty definition.

	:param uncertainty_value
	:type uncertainty_value:text
	'''
	def __init__( self , inherited0__measure_name , inherited1__description , uncertainty_value, ):
		uncertainty_qualifier.__init__(self , inherited0__measure_name , inherited1__description , )
		self.uncertainty_value = uncertainty_value

	@apply
	def uncertainty_value():
		def fget( self ):
			return self._uncertainty_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uncertainty_value is mantatory and can not be set to None')
			if not check_type(value,text):
				self._uncertainty_value = text(value)
			else:
				self._uncertainty_value = value
		return property(**locals())

####################
 # ENTITY time_interval_relationship #
####################
class time_interval_relationship(BaseEntityClass):
	'''Entity time_interval_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_time_interval
	:type relating_time_interval:time_interval

	:param related_time_interval
	:type related_time_interval:time_interval
	'''
	def __init__( self , name,description,relating_time_interval,related_time_interval, ):
		self.name = name
		self.description = description
		self.relating_time_interval = relating_time_interval
		self.related_time_interval = related_time_interval

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_time_interval():
		def fget( self ):
			return self._relating_time_interval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_time_interval is mantatory and can not be set to None')
			if not check_type(value,time_interval):
				self._relating_time_interval = time_interval(value)
			else:
				self._relating_time_interval = value
		return property(**locals())

	@apply
	def related_time_interval():
		def fget( self ):
			return self._related_time_interval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_time_interval is mantatory and can not be set to None')
			if not check_type(value,time_interval):
				self._related_time_interval = time_interval(value)
			else:
				self._related_time_interval = value
		return property(**locals())

####################
 # ENTITY classification_assignment #
####################
class classification_assignment(BaseEntityClass):
	'''Entity classification_assignment definition.

	:param assigned_class
	:type assigned_class:group

	:param role
	:type role:classification_role
	'''
	def __init__( self , assigned_class,role, ):
		self.assigned_class = assigned_class
		self.role = role

	@apply
	def assigned_class():
		def fget( self ):
			return self._assigned_class
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_class is mantatory and can not be set to None')
			if not check_type(value,group):
				self._assigned_class = group(value)
			else:
				self._assigned_class = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,classification_role):
				self._role = classification_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_classification_assignment #
####################
class applied_classification_assignment(classification_assignment):
	'''Entity applied_classification_assignment definition.

	:param items
	:type items:SET(1,None,'classification_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_class , inherited1__role , items, ):
		classification_assignment.__init__(self , inherited0__assigned_class , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'classification_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY circular_runout_tolerance #
####################
class circular_runout_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity circular_runout_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY bounded_surface_curve #
####################
class bounded_surface_curve(surface_curve,bounded_curve):
	'''Entity bounded_surface_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , inherited4__name ,  ):
		surface_curve.__init__(self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , )
		bounded_curve.__init__(self , inherited4__name , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOUNDED_CURVE'  ==  TYPEOF(self.self.surface_curve.self.curve_3d))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY document #
####################
class document(BaseEntityClass):
	'''Entity document definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param kind
	:type kind:document_type

	:param representation_types
	:type representation_types:SET(0,None,'document_representation_type', scope = schema_scope)
	'''
	def __init__( self , id,name,description,kind, ):
		self.id = id
		self.name = name
		self.description = description
		self.kind = kind

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def kind():
		def fget( self ):
			return self._kind
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument kind is mantatory and can not be set to None')
			if not check_type(value,document_type):
				self._kind = document_type(value)
			else:
				self._kind = value
		return property(**locals())

	@apply
	def representation_types():
		def fget( self ):
			return self._representation_types
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument representation_types is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY document_file #
####################
class document_file(document,characterized_object):
	'''Entity document_file definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__kind , inherited4__name , inherited5__description ,  ):
		document.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__kind , )
		characterized_object.__init__(self , inherited4__name , inherited5__description , )
	def wr1(self):
		eval_wr1_wr = (self.self.characterized_object.self.name  ==  '')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.characterized_object.self.description))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY action_method #
####################
class action_method(BaseEntityClass):
	'''Entity action_method definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param consequence
	:type consequence:text

	:param purpose
	:type purpose:text
	'''
	def __init__( self , name,description,consequence,purpose, ):
		self.name = name
		self.description = description
		self.consequence = consequence
		self.purpose = purpose

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def consequence():
		def fget( self ):
			return self._consequence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument consequence is mantatory and can not be set to None')
			if not check_type(value,text):
				self._consequence = text(value)
			else:
				self._consequence = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument purpose is mantatory and can not be set to None')
			if not check_type(value,text):
				self._purpose = text(value)
			else:
				self._purpose = value
		return property(**locals())

####################
 # ENTITY class_system #
####################
class class_system(group):
	'''Entity class_system definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY double_offset_shelled_solid #
####################
class double_offset_shelled_solid(shelled_solid):
	'''Entity double_offset_shelled_solid definition.

	:param thickness2
	:type thickness2:length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__deleted_face_set , inherited4__thickness , thickness2, ):
		shelled_solid.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__deleted_face_set , inherited4__thickness , )
		self.thickness2 = thickness2

	@apply
	def thickness2():
		def fget( self ):
			return self._thickness2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thickness2 is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._thickness2 = length_measure(value)
			else:
				self._thickness2 = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.thickness2  !=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.shelled_solid.self.thickness  !=  self.thickness2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY surface_condition_callout #
####################
class surface_condition_callout(draughting_callout):
	'''Entity surface_condition_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY text_literal_with_blanking_box #
####################
class text_literal_with_blanking_box(text_literal):
	'''Entity text_literal_with_blanking_box definition.

	:param blanking
	:type blanking:planar_box
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , blanking, ):
		text_literal.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , )
		self.blanking = blanking

	@apply
	def blanking():
		def fget( self ):
			return self._blanking
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument blanking is mantatory and can not be set to None')
			if not check_type(value,planar_box):
				self._blanking = planar_box(value)
			else:
				self._blanking = value
		return property(**locals())

####################
 # ENTITY curve_style_font_pattern #
####################
class curve_style_font_pattern(founded_item):
	'''Entity curve_style_font_pattern definition.

	:param visible_segment_length
	:type visible_segment_length:positive_length_measure

	:param invisible_segment_length
	:type invisible_segment_length:positive_length_measure
	'''
	def __init__( self , visible_segment_length,invisible_segment_length, ):
		founded_item.__init__(self , )
		self.visible_segment_length = visible_segment_length
		self.invisible_segment_length = invisible_segment_length

	@apply
	def visible_segment_length():
		def fget( self ):
			return self._visible_segment_length
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument visible_segment_length is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._visible_segment_length = positive_length_measure(value)
			else:
				self._visible_segment_length = value
		return property(**locals())

	@apply
	def invisible_segment_length():
		def fget( self ):
			return self._invisible_segment_length
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument invisible_segment_length is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._invisible_segment_length = positive_length_measure(value)
			else:
				self._invisible_segment_length = value
		return property(**locals())

####################
 # ENTITY fact_type #
####################
class fact_type(property_definition):
	'''Entity fact_type definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition ,  ):
		property_definition.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )

####################
 # ENTITY satisfying_item #
####################
class satisfying_item(group_assignment):
	'''Entity satisfying_item definition.

	:param items
	:type items:SET(1,1,'requirement_satisfaction_item', scope = schema_scope)

	:param group_assignment_assigned_group
	:type group_assignment_assigned_group:satisfies_requirement
	'''
	def __init__( self , inherited0__assigned_group , items,group_assignment_assigned_group, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items
		self.group_assignment_assigned_group = group_assignment_assigned_group

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,1,'requirement_satisfaction_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def group_assignment_assigned_group():
		def fget( self ):
			return self._group_assignment_assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument group_assignment_assigned_group is mantatory and can not be set to None')
			if not check_type(value,satisfies_requirement):
				self._group_assignment_assigned_group = satisfies_requirement(value)
			else:
				self._group_assignment_assigned_group = value
		return property(**locals())

####################
 # ENTITY illuminance_unit #
####################
class illuminance_unit(derived_unit):
	'''Entity illuminance_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.lux))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_illuminance_unit #
####################
class si_illuminance_unit(illuminance_unit,si_unit):
	'''Entity si_illuminance_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		illuminance_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.lux)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY constructive_geometry_representation #
####################
class constructive_geometry_representation(representation):
	'''Entity constructive_geometry_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT'  ==  TYPEOF(self.self.context_of_items))  and  ((2  <=  self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension)  and  (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  <=  3)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'REPRESENTATION_RELATIONSHIP.REP_2'))  >  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'REPRESENTATION_MAP.MAPPED_REPRESENTATION'))  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY plane_angle_measure_with_unit #
####################
class plane_angle_measure_with_unit(measure_with_unit):
	'''Entity plane_angle_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLANE_ANGLE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY right_angular_wedge #
####################
class right_angular_wedge(geometric_representation_item):
	'''Entity right_angular_wedge definition.

	:param position
	:type position:axis2_placement_3d

	:param x
	:type x:positive_length_measure

	:param y
	:type y:positive_length_measure

	:param z
	:type z:positive_length_measure

	:param ltx
	:type ltx:length_measure
	'''
	def __init__( self , inherited0__name , position,x,y,z,ltx, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.position = position
		self.x = x
		self.y = y
		self.z = z
		self.ltx = ltx

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._position = axis2_placement_3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def x():
		def fget( self ):
			return self._x
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument x is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._x = positive_length_measure(value)
			else:
				self._x = value
		return property(**locals())

	@apply
	def y():
		def fget( self ):
			return self._y
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument y is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._y = positive_length_measure(value)
			else:
				self._y = value
		return property(**locals())

	@apply
	def z():
		def fget( self ):
			return self._z
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument z is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._z = positive_length_measure(value)
			else:
				self._z = value
		return property(**locals())

	@apply
	def ltx():
		def fget( self ):
			return self._ltx
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ltx is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._ltx = length_measure(value)
			else:
				self._ltx = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((0  <=  self.ltx)  and  (self.ltx  <  self.x))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY text_style_with_spacing #
####################
class text_style_with_spacing(text_style):
	'''Entity text_style_with_spacing definition.

	:param character_spacing
	:type character_spacing:character_spacing_select
	'''
	def __init__( self , inherited0__name , inherited1__character_appearance , character_spacing, ):
		text_style.__init__(self , inherited0__name , inherited1__character_appearance , )
		self.character_spacing = character_spacing

	@apply
	def character_spacing():
		def fget( self ):
			return self._character_spacing
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument character_spacing is mantatory and can not be set to None')
			if not check_type(value,character_spacing_select):
				self._character_spacing = character_spacing_select(value)
			else:
				self._character_spacing = value
		return property(**locals())

####################
 # ENTITY vertex #
####################
class vertex(topological_representation_item):
	'''Entity vertex definition.
	'''
	def __init__( self , inherited0__name ,  ):
		topological_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY elementary_brep_shape_representation #
####################
class elementary_brep_shape_representation(shape_representation):
	'''Entity elementary_brep_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr


####################
 # ENTITY character_glyph_font_usage #
####################
class character_glyph_font_usage(BaseEntityClass):
	'''Entity character_glyph_font_usage definition.

	:param character
	:type character:generic_character_glyph_symbol

	:param font
	:type font:text_font
	'''
	def __init__( self , character,font, ):
		self.character = character
		self.font = font

	@apply
	def character():
		def fget( self ):
			return self._character
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument character is mantatory and can not be set to None')
			if not check_type(value,generic_character_glyph_symbol):
				self._character = generic_character_glyph_symbol(value)
			else:
				self._character = value
		return property(**locals())

	@apply
	def font():
		def fget( self ):
			return self._font
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument font is mantatory and can not be set to None')
			if not check_type(value,text_font):
				self._font = text_font(value)
			else:
				self._font = value
		return property(**locals())

####################
 # ENTITY electric_current_unit #
####################
class electric_current_unit(named_unit):
	'''Entity electric_current_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  1))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY character_glyph_style_stroke #
####################
class character_glyph_style_stroke(founded_item):
	'''Entity character_glyph_style_stroke definition.

	:param stroke_style
	:type stroke_style:curve_style
	'''
	def __init__( self , stroke_style, ):
		founded_item.__init__(self , )
		self.stroke_style = stroke_style

	@apply
	def stroke_style():
		def fget( self ):
			return self._stroke_style
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument stroke_style is mantatory and can not be set to None')
			if not check_type(value,curve_style):
				self._stroke_style = curve_style(value)
			else:
				self._stroke_style = value
		return property(**locals())

####################
 # ENTITY product_definition_effectivity #
####################
class product_definition_effectivity(effectivity):
	'''Entity product_definition_effectivity definition.

	:param usage
	:type usage:product_definition_relationship
	'''
	def __init__( self , inherited0__id , usage, ):
		effectivity.__init__(self , inherited0__id , )
		self.usage = usage

	@apply
	def usage():
		def fget( self ):
			return self._usage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument usage is mantatory and can not be set to None')
			if not check_type(value,product_definition_relationship):
				self._usage = product_definition_relationship(value)
			else:
				self._usage = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY'))  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY configuration_effectivity #
####################
class configuration_effectivity(product_definition_effectivity):
	'''Entity configuration_effectivity definition.

	:param configuration
	:type configuration:configuration_design
	'''
	def __init__( self , inherited0__id , inherited1__usage , configuration, ):
		product_definition_effectivity.__init__(self , inherited0__id , inherited1__usage , )
		self.configuration = configuration

	@apply
	def configuration():
		def fget( self ):
			return self._configuration
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument configuration is mantatory and can not be set to None')
			if not check_type(value,configuration_design):
				self._configuration = configuration_design(value)
			else:
				self._configuration = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRODUCT_DEFINITION_USAGE'  ==  TYPEOF(self.self.product_definition_effectivity.self.usage))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ellipse #
####################
class ellipse(conic):
	'''Entity ellipse definition.

	:param semi_axis_1
	:type semi_axis_1:positive_length_measure

	:param semi_axis_2
	:type semi_axis_2:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , semi_axis_1,semi_axis_2, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self.semi_axis_1 = semi_axis_1
		self.semi_axis_2 = semi_axis_2

	@apply
	def semi_axis_1():
		def fget( self ):
			return self._semi_axis_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_axis_1 is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._semi_axis_1 = positive_length_measure(value)
			else:
				self._semi_axis_1 = value
		return property(**locals())

	@apply
	def semi_axis_2():
		def fget( self ):
			return self._semi_axis_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_axis_2 is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._semi_axis_2 = positive_length_measure(value)
			else:
				self._semi_axis_2 = value
		return property(**locals())

####################
 # ENTITY geometric_tolerance_with_defined_unit #
####################
class geometric_tolerance_with_defined_unit(geometric_tolerance):
	'''Entity geometric_tolerance_with_defined_unit definition.

	:param unit_size
	:type unit_size:measure_with_unit
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , unit_size, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
		self.unit_size = unit_size

	@apply
	def unit_size():
		def fget( self ):
			return self._unit_size
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unit_size is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._unit_size = measure_with_unit(value)
			else:
				self._unit_size = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('NUMBER'  ==  TYPEOF(self.unit_size.self.measure_with_unit.self.value_component))  and  (self.unit_size.self.measure_with_unit.self.value_component  >  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_style_fill_area #
####################
class surface_style_fill_area(founded_item):
	'''Entity surface_style_fill_area definition.

	:param fill_area
	:type fill_area:fill_area_style
	'''
	def __init__( self , fill_area, ):
		founded_item.__init__(self , )
		self.fill_area = fill_area

	@apply
	def fill_area():
		def fget( self ):
			return self._fill_area
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fill_area is mantatory and can not be set to None')
			if not check_type(value,fill_area_style):
				self._fill_area = fill_area_style(value)
			else:
				self._fill_area = value
		return property(**locals())

####################
 # ENTITY breakdown_of #
####################
class breakdown_of(product_definition_relationship):
	'''Entity breakdown_of definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY camera_usage #
####################
class camera_usage(representation_map):
	'''Entity camera_usage definition.

	:param representation_map_mapping_origin
	:type representation_map_mapping_origin:camera_model
	'''
	def __init__( self , inherited0__mapping_origin , inherited1__mapped_representation , representation_map_mapping_origin, ):
		representation_map.__init__(self , inherited0__mapping_origin , inherited1__mapped_representation , )
		self.representation_map_mapping_origin = representation_map_mapping_origin

	@apply
	def representation_map_mapping_origin():
		def fget( self ):
			return self._representation_map_mapping_origin
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_map_mapping_origin is mantatory and can not be set to None')
			if not check_type(value,camera_model):
				self._representation_map_mapping_origin = camera_model(value)
			else:
				self._representation_map_mapping_origin = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRESENTATION_REPRESENTATION'  ==  TYPEOF(self.self.representation_map.self.mapped_representation)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY comparison_expression #
####################
class comparison_expression(boolean_expression,binary_generic_expression):
	'''Entity comparison_expression definition.

	:param binary_generic_expression_operands
	:type binary_generic_expression_operands:LIST(2,2,'expression', scope = schema_scope)
	'''
	def __init__( self , inherited0__operands , binary_generic_expression_operands, ):
		boolean_expression.__init__(self , )
		binary_generic_expression.__init__(self , inherited0__operands , )
		self.binary_generic_expression_operands = binary_generic_expression_operands

	@apply
	def binary_generic_expression_operands():
		def fget( self ):
			return self._binary_generic_expression_operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument binary_generic_expression_operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'expression', scope = schema_scope)):
				self._binary_generic_expression_operands = LIST(value)
			else:
				self._binary_generic_expression_operands = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.NUMERIC_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[1]))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.NUMERIC_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[2])))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOOLEAN_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[1]))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOOLEAN_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[2]))))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.STRING_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[1]))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.STRING_EXPRESSION'  ==  TYPEOF(self.self.binary_generic_expression.self.operands[2]))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY externally_defined_conversion_based_unit #
####################
class externally_defined_conversion_based_unit(conversion_based_unit,externally_defined_item):
	'''Entity externally_defined_conversion_based_unit definition.
	'''
	def __init__( self , inherited0__dimensions , inherited1__name , inherited2__conversion_factor , inherited3__item_id , inherited4__source ,  ):
		conversion_based_unit.__init__(self , inherited0__dimensions , inherited1__name , inherited2__conversion_factor , )
		externally_defined_item.__init__(self , inherited3__item_id , inherited4__source , )

####################
 # ENTITY geometrically_bounded_2d_wireframe_representation #
####################
class geometrically_bounded_2d_wireframe_representation(shape_representation):
	'''Entity geometrically_bounded_2d_wireframe_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  >=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY product_definition_group_assignment #
####################
class product_definition_group_assignment(group_assignment):
	'''Entity product_definition_group_assignment definition.

	:param items
	:type items:SET(1,1,'product_definition_or_product_definition_relationship', scope = schema_scope)

	:param group_assignment_assigned_group
	:type group_assignment_assigned_group:product_definition_element_relationship
	'''
	def __init__( self , inherited0__assigned_group , items,group_assignment_assigned_group, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items
		self.group_assignment_assigned_group = group_assignment_assigned_group

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,1,'product_definition_or_product_definition_relationship', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def group_assignment_assigned_group():
		def fget( self ):
			return self._group_assignment_assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument group_assignment_assigned_group is mantatory and can not be set to None')
			if not check_type(value,product_definition_element_relationship):
				self._group_assignment_assigned_group = product_definition_element_relationship(value)
			else:
				self._group_assignment_assigned_group = value
		return property(**locals())

####################
 # ENTITY solid_with_circular_pocket #
####################
class solid_with_circular_pocket(solid_with_pocket):
	'''Entity solid_with_circular_pocket definition.

	:param pocket_radius
	:type pocket_radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__floor_blend_radius , inherited6__draft_angle , pocket_radius, ):
		solid_with_pocket.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__floor_blend_radius , inherited6__draft_angle , )
		self.pocket_radius = pocket_radius

	@apply
	def pocket_radius():
		def fget( self ):
			return self._pocket_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pocket_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._pocket_radius = positive_length_measure(value)
			else:
				self._pocket_radius = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.solid_with_pocket.self.floor_blend_radius  <=  self.pocket_radius)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY externally_defined_item_relationship #
####################
class externally_defined_item_relationship(BaseEntityClass):
	'''Entity externally_defined_item_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_item
	:type relating_item:externally_defined_item

	:param related_item
	:type related_item:externally_defined_item
	'''
	def __init__( self , name,description,relating_item,related_item, ):
		self.name = name
		self.description = description
		self.relating_item = relating_item
		self.related_item = related_item

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_item():
		def fget( self ):
			return self._relating_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_item is mantatory and can not be set to None')
			if not check_type(value,externally_defined_item):
				self._relating_item = externally_defined_item(value)
			else:
				self._relating_item = value
		return property(**locals())

	@apply
	def related_item():
		def fget( self ):
			return self._related_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_item is mantatory and can not be set to None')
			if not check_type(value,externally_defined_item):
				self._related_item = externally_defined_item(value)
			else:
				self._related_item = value
		return property(**locals())

####################
 # ENTITY int_literal #
####################
class int_literal(literal_number):
	'''Entity int_literal definition.

	:param literal_number_the_value
	:type literal_number_the_value:INTEGER
	'''
	def __init__( self , inherited0__the_value , literal_number_the_value, ):
		literal_number.__init__(self , inherited0__the_value , )
		self.literal_number_the_value = literal_number_the_value

	@apply
	def literal_number_the_value():
		def fget( self ):
			return self._literal_number_the_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument literal_number_the_value is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._literal_number_the_value = INTEGER(value)
			else:
				self._literal_number_the_value = value
		return property(**locals())

####################
 # ENTITY rule_set #
####################
class rule_set(rule_software_definition):
	'''Entity rule_set definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		rule_software_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY uncertainty_assigned_representation #
####################
class uncertainty_assigned_representation(representation):
	'''Entity uncertainty_assigned_representation definition.

	:param uncertainty
	:type uncertainty:SET(1,None,'uncertainty_measure_with_unit', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , uncertainty, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.uncertainty = uncertainty

	@apply
	def uncertainty():
		def fget( self ):
			return self._uncertainty
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uncertainty is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'uncertainty_measure_with_unit', scope = schema_scope)):
				self._uncertainty = SET(value)
			else:
				self._uncertainty = value
		return property(**locals())

####################
 # ENTITY alternate_product_relationship #
####################
class alternate_product_relationship(BaseEntityClass):
	'''Entity alternate_product_relationship definition.

	:param name
	:type name:label

	:param definition
	:type definition:text

	:param alternate
	:type alternate:product

	:param base
	:type base:product

	:param basis
	:type basis:text
	'''
	def __init__( self , name,definition,alternate,base,basis, ):
		self.name = name
		self.definition = definition
		self.alternate = alternate
		self.base = base
		self.basis = basis

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._definition = text(value)
				else:
					self._definition = value
			else:
				self._definition = value
		return property(**locals())

	@apply
	def alternate():
		def fget( self ):
			return self._alternate
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument alternate is mantatory and can not be set to None')
			if not check_type(value,product):
				self._alternate = product(value)
			else:
				self._alternate = value
		return property(**locals())

	@apply
	def base():
		def fget( self ):
			return self._base
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base is mantatory and can not be set to None')
			if not check_type(value,product):
				self._base = product(value)
			else:
				self._base = value
		return property(**locals())

	@apply
	def basis():
		def fget( self ):
			return self._basis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis is mantatory and can not be set to None')
			if not check_type(value,text):
				self._basis = text(value)
			else:
				self._basis = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.alternate  !=  self.base)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY document_type #
####################
class document_type(BaseEntityClass):
	'''Entity document_type definition.

	:param product_data_type
	:type product_data_type:label
	'''
	def __init__( self , product_data_type, ):
		self.product_data_type = product_data_type

	@apply
	def product_data_type():
		def fget( self ):
			return self._product_data_type
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument product_data_type is mantatory and can not be set to None')
			if not check_type(value,label):
				self._product_data_type = label(value)
			else:
				self._product_data_type = value
		return property(**locals())

####################
 # ENTITY document_reference #
####################
class document_reference(BaseEntityClass):
	'''Entity document_reference definition.

	:param assigned_document
	:type assigned_document:document

	:param source
	:type source:label

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_document,source, ):
		self.assigned_document = assigned_document
		self.source = source

	@apply
	def assigned_document():
		def fget( self ):
			return self._assigned_document
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_document is mantatory and can not be set to None')
			if not check_type(value,document):
				self._assigned_document = document(value)
			else:
				self._assigned_document = value
		return property(**locals())

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source is mantatory and can not be set to None')
			if not check_type(value,label):
				self._source = label(value)
			else:
				self._source = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY functional_breakdown_context #
####################
class functional_breakdown_context(breakdown_context):
	'''Entity functional_breakdown_context definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		breakdown_context.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY angle_direction_reference #
####################
class angle_direction_reference(representation_item_relationship,geometric_representation_item):
	'''Entity angle_direction_reference definition.

	:param representation_item_relationship_related_representation_item
	:type representation_item_relationship_related_representation_item:angle_direction_reference_select

	:param representation_item_relationship_relating_representation_item
	:type representation_item_relationship_relating_representation_item:orientation_basis_select
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_representation_item , inherited3__related_representation_item , inherited4__name , representation_item_relationship_related_representation_item,representation_item_relationship_relating_representation_item, ):
		representation_item_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_representation_item , inherited3__related_representation_item , )
		geometric_representation_item.__init__(self , inherited4__name , )
		self.representation_item_relationship_related_representation_item = representation_item_relationship_related_representation_item
		self.representation_item_relationship_relating_representation_item = representation_item_relationship_relating_representation_item

	@apply
	def representation_item_relationship_related_representation_item():
		def fget( self ):
			return self._representation_item_relationship_related_representation_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_item_relationship_related_representation_item is mantatory and can not be set to None')
			if not check_type(value,angle_direction_reference_select):
				self._representation_item_relationship_related_representation_item = angle_direction_reference_select(value)
			else:
				self._representation_item_relationship_related_representation_item = value
		return property(**locals())

	@apply
	def representation_item_relationship_relating_representation_item():
		def fget( self ):
			return self._representation_item_relationship_relating_representation_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_item_relationship_relating_representation_item is mantatory and can not be set to None')
			if not check_type(value,orientation_basis_select):
				self._representation_item_relationship_relating_representation_item = orientation_basis_select(value)
			else:
				self._representation_item_relationship_relating_representation_item = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POINT_PATH'  ==  TYPEOF(self.related_representation_item))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MIN_AND_MAJOR_PLY_ORIENTATION_BASIS'  ==  TYPEOF(self.relating_representation_item)))  or  (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POINT_PATH'  ==  TYPEOF(self.related_representation_item)))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.AXIS2_PLACEMENT_3D'  ==  TYPEOF(self.relating_representation_item))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY draughting_symbol_representation #
####################
class draughting_symbol_representation(symbol_representation):
	'''Entity draughting_symbol_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		symbol_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  >  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ( not acyclic_mapped_item_usage(self))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(self.self.context_of_items.self.representations_in_context)  ==  1)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY mechanical_context #
####################
class mechanical_context(product_context):
	'''Entity mechanical_context definition.
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , inherited2__discipline_type ,  ):
		product_context.__init__(self , inherited0__name , inherited1__frame_of_reference , inherited2__discipline_type , )
	def wr1(self):
		eval_wr1_wr = (self.self.discipline_type  ==  'mechanical')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY planar_extent #
####################
class planar_extent(geometric_representation_item):
	'''Entity planar_extent definition.

	:param size_in_x
	:type size_in_x:length_measure

	:param size_in_y
	:type size_in_y:length_measure
	'''
	def __init__( self , inherited0__name , size_in_x,size_in_y, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.size_in_x = size_in_x
		self.size_in_y = size_in_y

	@apply
	def size_in_x():
		def fget( self ):
			return self._size_in_x
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument size_in_x is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._size_in_x = length_measure(value)
			else:
				self._size_in_x = value
		return property(**locals())

	@apply
	def size_in_y():
		def fget( self ):
			return self._size_in_y
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument size_in_y is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._size_in_y = length_measure(value)
			else:
				self._size_in_y = value
		return property(**locals())

####################
 # ENTITY planar_box #
####################
class planar_box(planar_extent):
	'''Entity planar_box definition.

	:param placement
	:type placement:axis2_placement
	'''
	def __init__( self , inherited0__name , inherited1__size_in_x , inherited2__size_in_y , placement, ):
		planar_extent.__init__(self , inherited0__name , inherited1__size_in_x , inherited2__size_in_y , )
		self.placement = placement

	@apply
	def placement():
		def fget( self ):
			return self._placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placement is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._placement = axis2_placement(value)
			else:
				self._placement = value
		return property(**locals())

####################
 # ENTITY binary_numeric_expression #
####################
class binary_numeric_expression(numeric_expression,binary_generic_expression):
	'''Entity binary_numeric_expression definition.

	:param binary_generic_expression_operands
	:type binary_generic_expression_operands:LIST(2,2,'numeric_expression', scope = schema_scope)
	'''
	def __init__( self , inherited0__operands , binary_generic_expression_operands, ):
		numeric_expression.__init__(self , )
		binary_generic_expression.__init__(self , inherited0__operands , )
		self.binary_generic_expression_operands = binary_generic_expression_operands

	@apply
	def binary_generic_expression_operands():
		def fget( self ):
			return self._binary_generic_expression_operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument binary_generic_expression_operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'numeric_expression', scope = schema_scope)):
				self._binary_generic_expression_operands = LIST(value)
			else:
				self._binary_generic_expression_operands = value
		return property(**locals())

####################
 # ENTITY slash_expression #
####################
class slash_expression(binary_numeric_expression):
	'''Entity slash_expression definition.
	'''
	def __init__( self , inherited0__operands , inherited1__binary_generic_expression_operands ,  ):
		binary_numeric_expression.__init__(self , inherited0__operands , inherited1__binary_generic_expression_operands , )

####################
 # ENTITY rational_representation_item #
####################
class rational_representation_item(representation_item,slash_expression):
	'''Entity rational_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__operands , inherited2__binary_generic_expression_operands ,  ):
		representation_item.__init__(self , inherited0__name , )
		slash_expression.__init__(self , inherited1__operands , inherited2__binary_generic_expression_operands , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY shell_based_wireframe_model #
####################
class shell_based_wireframe_model(geometric_representation_item):
	'''Entity shell_based_wireframe_model definition.

	:param sbwm_boundary
	:type sbwm_boundary:SET(1,None,'shell', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , sbwm_boundary, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.sbwm_boundary = sbwm_boundary

	@apply
	def sbwm_boundary():
		def fget( self ):
			return self._sbwm_boundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sbwm_boundary is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'shell', scope = schema_scope)):
				self._sbwm_boundary = SET(value)
			else:
				self._sbwm_boundary = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = constraints_geometry_shell_based_wireframe_model(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY class_by_intension #
####################
class class_by_intension(class_):
	'''Entity class_by_intension definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		class.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY manifold_subsurface_shape_representation #
####################
class manifold_subsurface_shape_representation(shape_representation):
	'''Entity manifold_subsurface_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr


####################
 # ENTITY perpendicularity_tolerance #
####################
class perpendicularity_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity perpendicularity_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY entity_assertion #
####################
class entity_assertion(fact_type):
	'''Entity entity_assertion definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition ,  ):
		fact_type.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )

####################
 # ENTITY plus_minus_tolerance #
####################
class plus_minus_tolerance(BaseEntityClass):
	'''Entity plus_minus_tolerance definition.

	:param range
	:type range:tolerance_method_definition

	:param toleranced_dimension
	:type toleranced_dimension:dimensional_characteristic
	'''
	def __init__( self , range,toleranced_dimension, ):
		self.range = range
		self.toleranced_dimension = toleranced_dimension

	@apply
	def range():
		def fget( self ):
			return self._range
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument range is mantatory and can not be set to None')
			if not check_type(value,tolerance_method_definition):
				self._range = tolerance_method_definition(value)
			else:
				self._range = value
		return property(**locals())

	@apply
	def toleranced_dimension():
		def fget( self ):
			return self._toleranced_dimension
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument toleranced_dimension is mantatory and can not be set to None')
			if not check_type(value,dimensional_characteristic):
				self._toleranced_dimension = dimensional_characteristic(value)
			else:
				self._toleranced_dimension = value
		return property(**locals())

####################
 # ENTITY effectivity_relationship #
####################
class effectivity_relationship(BaseEntityClass):
	'''Entity effectivity_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param related_effectivity
	:type related_effectivity:effectivity

	:param relating_effectivity
	:type relating_effectivity:effectivity
	'''
	def __init__( self , name,description,related_effectivity,relating_effectivity, ):
		self.name = name
		self.description = description
		self.related_effectivity = related_effectivity
		self.relating_effectivity = relating_effectivity

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def related_effectivity():
		def fget( self ):
			return self._related_effectivity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_effectivity is mantatory and can not be set to None')
			if not check_type(value,effectivity):
				self._related_effectivity = effectivity(value)
			else:
				self._related_effectivity = value
		return property(**locals())

	@apply
	def relating_effectivity():
		def fget( self ):
			return self._relating_effectivity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_effectivity is mantatory and can not be set to None')
			if not check_type(value,effectivity):
				self._relating_effectivity = effectivity(value)
			else:
				self._relating_effectivity = value
		return property(**locals())

####################
 # ENTITY solid_with_angle_based_chamfer #
####################
class solid_with_angle_based_chamfer(solid_with_chamfered_edges):
	'''Entity solid_with_angle_based_chamfer definition.

	:param offset_distance
	:type offset_distance:positive_length_measure

	:param left_offset
	:type left_offset:BOOLEAN

	:param offset_angle
	:type offset_angle:positive_plane_angle_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , offset_distance,left_offset,offset_angle, ):
		solid_with_chamfered_edges.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , )
		self.offset_distance = offset_distance
		self.left_offset = left_offset
		self.offset_angle = offset_angle

	@apply
	def offset_distance():
		def fget( self ):
			return self._offset_distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offset_distance is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._offset_distance = positive_length_measure(value)
			else:
				self._offset_distance = value
		return property(**locals())

	@apply
	def left_offset():
		def fget( self ):
			return self._left_offset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument left_offset is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._left_offset = BOOLEAN(value)
			else:
				self._left_offset = value
		return property(**locals())

	@apply
	def offset_angle():
		def fget( self ):
			return self._offset_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offset_angle is mantatory and can not be set to None')
			if not check_type(value,positive_plane_angle_measure):
				self._offset_angle = positive_plane_angle_measure(value)
			else:
				self._offset_angle = value
		return property(**locals())

####################
 # ENTITY applied_identification_assignment #
####################
class applied_identification_assignment(identification_assignment):
	'''Entity applied_identification_assignment definition.

	:param items
	:type items:SET(1,None,'identification_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_id , inherited1__role , items, ):
		identification_assignment.__init__(self , inherited0__assigned_id , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'identification_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY contract #
####################
class contract(BaseEntityClass):
	'''Entity contract definition.

	:param name
	:type name:label

	:param purpose
	:type purpose:text

	:param kind
	:type kind:contract_type
	'''
	def __init__( self , name,purpose,kind, ):
		self.name = name
		self.purpose = purpose
		self.kind = kind

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument purpose is mantatory and can not be set to None')
			if not check_type(value,text):
				self._purpose = text(value)
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def kind():
		def fget( self ):
			return self._kind
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument kind is mantatory and can not be set to None')
			if not check_type(value,contract_type):
				self._kind = contract_type(value)
			else:
				self._kind = value
		return property(**locals())

####################
 # ENTITY attribute_value_assignment #
####################
class attribute_value_assignment(BaseEntityClass):
	'''Entity attribute_value_assignment definition.

	:param attribute_name
	:type attribute_name:label

	:param attribute_value
	:type attribute_value:attribute_type

	:param role
	:type role:attribute_value_role
	'''
	def __init__( self , attribute_name,attribute_value,role, ):
		self.attribute_name = attribute_name
		self.attribute_value = attribute_value
		self.role = role

	@apply
	def attribute_name():
		def fget( self ):
			return self._attribute_name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._attribute_name = label(value)
			else:
				self._attribute_name = value
		return property(**locals())

	@apply
	def attribute_value():
		def fget( self ):
			return self._attribute_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_value is mantatory and can not be set to None')
			if not check_type(value,attribute_type):
				self._attribute_value = attribute_type(value)
			else:
				self._attribute_value = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,attribute_value_role):
				self._role = attribute_value_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY datum_feature #
####################
class datum_feature(shape_aspect):
	'''Entity datum_feature definition.

	:param feature_basis_relationship
	:type feature_basis_relationship:SET(1,None,'shape_aspect_relationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )

	@apply
	def feature_basis_relationship():
		def fget( self ):
			return self._feature_basis_relationship
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument feature_basis_relationship is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.shape_aspect.self.product_definitional  ==  TRUE)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY dimensional_exponents #
####################
class dimensional_exponents(BaseEntityClass):
	'''Entity dimensional_exponents definition.

	:param length_exponent
	:type length_exponent:REAL

	:param mass_exponent
	:type mass_exponent:REAL

	:param time_exponent
	:type time_exponent:REAL

	:param electric_current_exponent
	:type electric_current_exponent:REAL

	:param thermodynamic_temperature_exponent
	:type thermodynamic_temperature_exponent:REAL

	:param amount_of_substance_exponent
	:type amount_of_substance_exponent:REAL

	:param luminous_intensity_exponent
	:type luminous_intensity_exponent:REAL
	'''
	def __init__( self , length_exponent,mass_exponent,time_exponent,electric_current_exponent,thermodynamic_temperature_exponent,amount_of_substance_exponent,luminous_intensity_exponent, ):
		self.length_exponent = length_exponent
		self.mass_exponent = mass_exponent
		self.time_exponent = time_exponent
		self.electric_current_exponent = electric_current_exponent
		self.thermodynamic_temperature_exponent = thermodynamic_temperature_exponent
		self.amount_of_substance_exponent = amount_of_substance_exponent
		self.luminous_intensity_exponent = luminous_intensity_exponent

	@apply
	def length_exponent():
		def fget( self ):
			return self._length_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument length_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._length_exponent = REAL(value)
			else:
				self._length_exponent = value
		return property(**locals())

	@apply
	def mass_exponent():
		def fget( self ):
			return self._mass_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mass_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._mass_exponent = REAL(value)
			else:
				self._mass_exponent = value
		return property(**locals())

	@apply
	def time_exponent():
		def fget( self ):
			return self._time_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument time_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._time_exponent = REAL(value)
			else:
				self._time_exponent = value
		return property(**locals())

	@apply
	def electric_current_exponent():
		def fget( self ):
			return self._electric_current_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument electric_current_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._electric_current_exponent = REAL(value)
			else:
				self._electric_current_exponent = value
		return property(**locals())

	@apply
	def thermodynamic_temperature_exponent():
		def fget( self ):
			return self._thermodynamic_temperature_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument thermodynamic_temperature_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._thermodynamic_temperature_exponent = REAL(value)
			else:
				self._thermodynamic_temperature_exponent = value
		return property(**locals())

	@apply
	def amount_of_substance_exponent():
		def fget( self ):
			return self._amount_of_substance_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument amount_of_substance_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._amount_of_substance_exponent = REAL(value)
			else:
				self._amount_of_substance_exponent = value
		return property(**locals())

	@apply
	def luminous_intensity_exponent():
		def fget( self ):
			return self._luminous_intensity_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument luminous_intensity_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._luminous_intensity_exponent = REAL(value)
			else:
				self._luminous_intensity_exponent = value
		return property(**locals())

####################
 # ENTITY pre_defined_geometrical_tolerance_symbol #
####################
class pre_defined_geometrical_tolerance_symbol(pre_defined_symbol):
	'''Entity pre_defined_geometrical_tolerance_symbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_symbol.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['angularity','basic dimension','blanked datum reference','circular runout','circularity','concentricity','cylindricity','datum target identification','diameter','filled datum reference','flatness','least material condition','maximum material condition','parallelism','perpendicularity','position','profile of a line','profile of a surface','projected tolerance zone','regardless of feature size','straightness','symmetry','total runout'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY radioactivity_measure_with_unit #
####################
class radioactivity_measure_with_unit(measure_with_unit):
	'''Entity radioactivity_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RADIOACTIVITY_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY start_request #
####################
class start_request(action_request_assignment):
	'''Entity start_request definition.

	:param items
	:type items:SET(1,None,'start_request_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action_request , items, ):
		action_request_assignment.__init__(self , inherited0__assigned_action_request , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'start_request_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY symmetric_shape_aspect #
####################
class symmetric_shape_aspect(shape_aspect):
	'''Entity symmetric_shape_aspect definition.

	:param basis_relationships
	:type basis_relationships:SET(1,None,'shape_aspect_relationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )

	@apply
	def basis_relationships():
		def fget( self ):
			return self._basis_relationships
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument basis_relationships is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY attribute_assertion #
####################
class attribute_assertion(fact_type,property_definition_representation,representation):
	'''Entity attribute_assertion definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition , inherited3__definition , inherited4__used_representation , inherited5__name , inherited6__items , inherited7__context_of_items ,  ):
		fact_type.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )
		property_definition_representation.__init__(self , inherited3__definition , inherited4__used_representation , )
		representation.__init__(self , inherited5__name , inherited6__items , inherited7__context_of_items , )

####################
 # ENTITY parallelism_tolerance #
####################
class parallelism_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity parallelism_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY solid_with_through_depression #
####################
class solid_with_through_depression(solid_with_depression):
	'''Entity solid_with_through_depression definition.

	:param exit_faces
	:type exit_faces:SET(1,None,'face_surface', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , exit_faces, ):
		solid_with_depression.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , )
		self.exit_faces = exit_faces

	@apply
	def exit_faces():
		def fget( self ):
			return self._exit_faces
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument exit_faces is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'face_surface', scope = schema_scope)):
				self._exit_faces = SET(value)
			else:
				self._exit_faces = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(TYPEOF(self)  *  ['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_HOLE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_POCKET','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_SLOT'])  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY track_blended_solid #
####################
class track_blended_solid(edge_blended_solid):
	'''Entity track_blended_solid definition.
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges ,  ):
		edge_blended_solid.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , )
	def wr1(self):
		eval_wr1_wr = check_continuous_edges(self.self.edge_blended_solid.self.blended_edges)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY cc_design_specification_reference #
####################
class cc_design_specification_reference(document_reference):
	'''Entity cc_design_specification_reference definition.

	:param items
	:type items:SET(1,None,'cc_specified_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_document , inherited1__source , items, ):
		document_reference.__init__(self , inherited0__assigned_document , inherited1__source , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'cc_specified_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY supplied_part_relationship #
####################
class supplied_part_relationship(product_definition_relationship):
	'''Entity supplied_part_relationship definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY characterized_class #
####################
class characterized_class(characterized_object,class_):
	'''Entity characterized_class definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__name , inherited3__description ,  ):
		characterized_object.__init__(self , inherited0__name , inherited1__description , )
		class.__init__(self , inherited2__name , inherited3__description , )

####################
 # ENTITY externally_defined_tile_style #
####################
class externally_defined_tile_style(externally_defined_item,geometric_representation_item):
	'''Entity externally_defined_tile_style definition.
	'''
	def __init__( self , inherited0__item_id , inherited1__source , inherited2__name ,  ):
		externally_defined_item.__init__(self , inherited0__item_id , inherited1__source , )
		geometric_representation_item.__init__(self , inherited2__name , )

####################
 # ENTITY pre_defined_terminator_symbol #
####################
class pre_defined_terminator_symbol(pre_defined_symbol):
	'''Entity pre_defined_terminator_symbol definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_symbol.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['blanked arrow','blanked box','blanked dot','blanked triangle','dimension origin','filled arrow','filled box','filled dot','integral symbol','open arrow','slash','unfilled arrow','unfilled triangle','filled triangle'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY vector_style #
####################
class vector_style(curve_style,pre_defined_terminator_symbol):
	'''Entity vector_style definition.
	'''
	def __init__( self , inherited0__name , inherited1__curve_font , inherited2__curve_width , inherited3__curve_colour , inherited4__name ,  ):
		curve_style.__init__(self , inherited0__name , inherited1__curve_font , inherited2__curve_width , inherited3__curve_colour , )
		pre_defined_terminator_symbol.__init__(self , inherited4__name , )

####################
 # ENTITY time_interval_assignment #
####################
class time_interval_assignment(BaseEntityClass):
	'''Entity time_interval_assignment definition.

	:param assigned_time_interval
	:type assigned_time_interval:time_interval

	:param role
	:type role:time_interval_role
	'''
	def __init__( self , assigned_time_interval,role, ):
		self.assigned_time_interval = assigned_time_interval
		self.role = role

	@apply
	def assigned_time_interval():
		def fget( self ):
			return self._assigned_time_interval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_time_interval is mantatory and can not be set to None')
			if not check_type(value,time_interval):
				self._assigned_time_interval = time_interval(value)
			else:
				self._assigned_time_interval = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,time_interval_role):
				self._role = time_interval_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_time_interval_assignment #
####################
class applied_time_interval_assignment(time_interval_assignment):
	'''Entity applied_time_interval_assignment definition.

	:param items
	:type items:SET(0,None,'time_interval_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_time_interval , inherited1__role , items, ):
		time_interval_assignment.__init__(self , inherited0__assigned_time_interval , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(0,None,'time_interval_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY organizational_project_relationship #
####################
class organizational_project_relationship(BaseEntityClass):
	'''Entity organizational_project_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_organizational_project
	:type relating_organizational_project:organizational_project

	:param related_organizational_project
	:type related_organizational_project:organizational_project
	'''
	def __init__( self , name,description,relating_organizational_project,related_organizational_project, ):
		self.name = name
		self.description = description
		self.relating_organizational_project = relating_organizational_project
		self.related_organizational_project = related_organizational_project

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_organizational_project():
		def fget( self ):
			return self._relating_organizational_project
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_organizational_project is mantatory and can not be set to None')
			if not check_type(value,organizational_project):
				self._relating_organizational_project = organizational_project(value)
			else:
				self._relating_organizational_project = value
		return property(**locals())

	@apply
	def related_organizational_project():
		def fget( self ):
			return self._related_organizational_project
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_organizational_project is mantatory and can not be set to None')
			if not check_type(value,organizational_project):
				self._related_organizational_project = organizational_project(value)
			else:
				self._related_organizational_project = value
		return property(**locals())

####################
 # ENTITY configuration_item_revision_sequence #
####################
class configuration_item_revision_sequence(configuration_item_relationship):
	'''Entity configuration_item_revision_sequence definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_configuration_item , inherited3__related_configuration_item ,  ):
		configuration_item_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_configuration_item , inherited3__related_configuration_item , )

####################
 # ENTITY context_dependent_shape_representation #
####################
class context_dependent_shape_representation(BaseEntityClass):
	'''Entity context_dependent_shape_representation definition.

	:param representation_relation
	:type representation_relation:shape_representation_relationship

	:param represented_product_relation
	:type represented_product_relation:product_definition_shape

	:param description
	:type description:text

	:param name
	:type name:label
	'''
	def __init__( self , representation_relation,represented_product_relation, ):
		self.representation_relation = representation_relation
		self.represented_product_relation = represented_product_relation

	@apply
	def representation_relation():
		def fget( self ):
			return self._representation_relation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relation is mantatory and can not be set to None')
			if not check_type(value,shape_representation_relationship):
				self._representation_relation = shape_representation_relationship(value)
			else:
				self._representation_relation = value
		return property(**locals())

	@apply
	def represented_product_relation():
		def fget( self ):
			return self._represented_product_relation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument represented_product_relation is mantatory and can not be set to None')
			if not check_type(value,product_definition_shape):
				self._represented_product_relation = product_definition_shape(value)
			else:
				self._represented_product_relation = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP'  ==  TYPEOF(self.self.represented_product_relation.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY degenerate_toroidal_surface #
####################
class degenerate_toroidal_surface(toroidal_surface):
	'''Entity degenerate_toroidal_surface definition.

	:param select_outer
	:type select_outer:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__position , inherited2__major_radius , inherited3__minor_radius , select_outer, ):
		toroidal_surface.__init__(self , inherited0__name , inherited1__position , inherited2__major_radius , inherited3__minor_radius , )
		self.select_outer = select_outer

	@apply
	def select_outer():
		def fget( self ):
			return self._select_outer
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument select_outer is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._select_outer = BOOLEAN(value)
			else:
				self._select_outer = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.major_radius  <  self.minor_radius)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY shape_aspect_associativity #
####################
class shape_aspect_associativity(shape_aspect_relationship):
	'''Entity shape_aspect_associativity definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect ,  ):
		shape_aspect_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_shape_aspect , inherited3__related_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = self.self.relating_shape_aspect.self.product_definitional
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not self.self.related_shape_aspect.self.product_definitional)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY conditional_concept_feature #
####################
class conditional_concept_feature(product_concept_feature):
	'''Entity conditional_concept_feature definition.

	:param condition
	:type condition:concept_feature_relationship_with_condition
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , condition, ):
		product_concept_feature.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
		self.condition = condition

	@apply
	def condition():
		def fget( self ):
			return self._condition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument condition is mantatory and can not be set to None')
			if not check_type(value,concept_feature_relationship_with_condition):
				self._condition = concept_feature_relationship_with_condition(value)
			else:
				self._condition = value
		return property(**locals())

####################
 # ENTITY ordinal_date #
####################
class ordinal_date(date):
	'''Entity ordinal_date definition.

	:param day_component
	:type day_component:day_in_year_number
	'''
	def __init__( self , inherited0__year_component , day_component, ):
		date.__init__(self , inherited0__year_component , )
		self.day_component = day_component

	@apply
	def day_component():
		def fget( self ):
			return self._day_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument day_component is mantatory and can not be set to None')
			if not check_type(value,day_in_year_number):
				self._day_component = day_in_year_number(value)
			else:
				self._day_component = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((( not leap_year(self.self.year_component))  and  ((1  <=  self.day_component)  and  (self.day_component  <=  365)))  or  (leap_year(self.self.year_component)  and  ((1  <=  self.day_component)  and  (self.day_component  <=  366))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY presentation_style_assignment #
####################
class presentation_style_assignment(founded_item):
	'''Entity presentation_style_assignment definition.

	:param styles
	:type styles:SET(1,None,'presentation_style_select', scope = schema_scope)
	'''
	def __init__( self , styles, ):
		founded_item.__init__(self , )
		self.styles = styles

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'presentation_style_select', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  <=  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY external_source #
####################
class external_source(BaseEntityClass):
	'''Entity external_source definition.

	:param source_id
	:type source_id:source_item

	:param description
	:type description:text
	'''
	def __init__( self , source_id, ):
		self.source_id = source_id

	@apply
	def source_id():
		def fget( self ):
			return self._source_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source_id is mantatory and can not be set to None')
			if not check_type(value,source_item):
				self._source_id = source_item(value)
			else:
				self._source_id = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY external_class_library #
####################
class external_class_library(external_source):
	'''Entity external_class_library definition.
	'''
	def __init__( self , inherited0__source_id ,  ):
		external_source.__init__(self , inherited0__source_id , )

####################
 # ENTITY face_outer_bound #
####################
class face_outer_bound(face_bound):
	'''Entity face_outer_bound definition.
	'''
	def __init__( self , inherited0__name , inherited1__bound , inherited2__orientation ,  ):
		face_bound.__init__(self , inherited0__name , inherited1__bound , inherited2__orientation , )

####################
 # ENTITY geometric_item_specific_usage #
####################
class geometric_item_specific_usage(item_identified_representation_usage):
	'''Entity geometric_item_specific_usage definition.

	:param item_identified_representation_usage_definition
	:type item_identified_representation_usage_definition:geometric_item_specific_usage_select

	:param item_identified_representation_usage_identified_item
	:type item_identified_representation_usage_identified_item:geometric_representation_item

	:param item_identified_representation_usage_used_representation
	:type item_identified_representation_usage_used_representation:shape_representation
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition , inherited3__used_representation , inherited4__identified_item , item_identified_representation_usage_definition,item_identified_representation_usage_identified_item,item_identified_representation_usage_used_representation, ):
		item_identified_representation_usage.__init__(self , inherited0__name , inherited1__description , inherited2__definition , inherited3__used_representation , inherited4__identified_item , )
		self.item_identified_representation_usage_definition = item_identified_representation_usage_definition
		self.item_identified_representation_usage_identified_item = item_identified_representation_usage_identified_item
		self.item_identified_representation_usage_used_representation = item_identified_representation_usage_used_representation

	@apply
	def item_identified_representation_usage_definition():
		def fget( self ):
			return self._item_identified_representation_usage_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_definition is mantatory and can not be set to None')
			if not check_type(value,geometric_item_specific_usage_select):
				self._item_identified_representation_usage_definition = geometric_item_specific_usage_select(value)
			else:
				self._item_identified_representation_usage_definition = value
		return property(**locals())

	@apply
	def item_identified_representation_usage_identified_item():
		def fget( self ):
			return self._item_identified_representation_usage_identified_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_identified_item is mantatory and can not be set to None')
			if not check_type(value,geometric_representation_item):
				self._item_identified_representation_usage_identified_item = geometric_representation_item(value)
			else:
				self._item_identified_representation_usage_identified_item = value
		return property(**locals())

	@apply
	def item_identified_representation_usage_used_representation():
		def fget( self ):
			return self._item_identified_representation_usage_used_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_used_representation is mantatory and can not be set to None')
			if not check_type(value,shape_representation):
				self._item_identified_representation_usage_used_representation = shape_representation(value)
			else:
				self._item_identified_representation_usage_used_representation = value
		return property(**locals())

####################
 # ENTITY mass_measure_with_unit #
####################
class mass_measure_with_unit(measure_with_unit):
	'''Entity mass_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MASS_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_texture_representation #
####################
class surface_texture_representation(representation):
	'''Entity surface_texture_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  >  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (((SIZEOF(USEDIN(self,('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'REPRESENTATION_RELATIONSHIP.')  +  'REP_1'))  <=  1)  and  (SIZEOF(USEDIN(self,('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'REPRESENTATION_RELATIONSHIP.')  +  'REP_2'))  ==  0))  and  (SIZEOF(None)  ==  SIZEOF(USEDIN(self,('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'REPRESENTATION_RELATIONSHIP.')  +  'REP_1'))))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((SIZEOF(USEDIN(self,('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PROPERTY_DEFINITION_REPRESENTATION.')  +  'USED_REPRESENTATION'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY text_font #
####################
class text_font(BaseEntityClass):
	'''Entity text_font definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param glyphs
	:type glyphs:SET(1,None,'character_glyph_font_usage', scope = schema_scope)
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def glyphs():
		def fget( self ):
			return self._glyphs
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument glyphs is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY brep_with_voids #
####################
class brep_with_voids(manifold_solid_brep):
	'''Entity brep_with_voids definition.

	:param voids
	:type voids:SET(1,None,'oriented_closed_shell', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__outer , voids, ):
		manifold_solid_brep.__init__(self , inherited0__name , inherited1__outer , )
		self.voids = voids

	@apply
	def voids():
		def fget( self ):
			return self._voids
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument voids is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'oriented_closed_shell', scope = schema_scope)):
				self._voids = SET(value)
			else:
				self._voids = value
		return property(**locals())

####################
 # ENTITY datum_target #
####################
class datum_target(shape_aspect):
	'''Entity datum_target definition.

	:param target_id
	:type target_id:identifier

	:param target_basis_relationship
	:type target_basis_relationship:SET(1,None,'shape_aspect_relationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , target_id, ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		self.target_id = target_id

	@apply
	def target_id():
		def fget( self ):
			return self._target_id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument target_id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._target_id = identifier(value)
			else:
				self._target_id = value
		return property(**locals())

	@apply
	def target_basis_relationship():
		def fget( self ):
			return self._target_basis_relationship
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument target_basis_relationship is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.shape_aspect.self.product_definitional  ==  TRUE)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY revolved_face_solid #
####################
class revolved_face_solid(swept_face_solid):
	'''Entity revolved_face_solid definition.

	:param axis
	:type axis:axis1_placement

	:param angle
	:type angle:plane_angle_measure

	:param axis_line
	:type axis_line:line
	'''
	def __init__( self , inherited0__name , inherited1__swept_face , axis,angle, ):
		swept_face_solid.__init__(self , inherited0__name , inherited1__swept_face , )
		self.axis = axis
		self.angle = angle

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axis is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._axis = axis1_placement(value)
			else:
				self._axis = value
		return property(**locals())

	@apply
	def angle():
		def fget( self ):
			return self._angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._angle = plane_angle_measure(value)
			else:
				self._angle = value
		return property(**locals())

	@apply
	def axis_line():
		def fget( self ):
			attribute_eval = (((representation_item('')  ==  geometric_representation_item())  ==  curve())  ==  line(self.axis.self.location,(representation_item('')  ==  geometric_representation_item())  ==  vector(self.axis.self.z,1)))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument axis_line is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY revolved_face_solid_with_trim_conditions #
####################
class revolved_face_solid_with_trim_conditions(revolved_face_solid):
	'''Entity revolved_face_solid_with_trim_conditions definition.

	:param first_trim_condition
	:type first_trim_condition:trim_condition_select

	:param second_trim_condition
	:type second_trim_condition:trim_condition_select
	'''
	def __init__( self , inherited0__name , inherited1__swept_face , inherited2__axis , inherited3__angle , first_trim_condition,second_trim_condition, ):
		revolved_face_solid.__init__(self , inherited0__name , inherited1__swept_face , inherited2__axis , inherited3__angle , )
		self.first_trim_condition = first_trim_condition
		self.second_trim_condition = second_trim_condition

	@apply
	def first_trim_condition():
		def fget( self ):
			return self._first_trim_condition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument first_trim_condition is mantatory and can not be set to None')
			if not check_type(value,trim_condition_select):
				self._first_trim_condition = trim_condition_select(value)
			else:
				self._first_trim_condition = value
		return property(**locals())

	@apply
	def second_trim_condition():
		def fget( self ):
			return self._second_trim_condition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument second_trim_condition is mantatory and can not be set to None')
			if not check_type(value,trim_condition_select):
				self._second_trim_condition = trim_condition_select(value)
			else:
				self._second_trim_condition = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_MEASURE'  ==  TYPEOF(self.first_trim_condition))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_MEASURE'  ==  TYPEOF(self.second_trim_condition))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLANE_ANGLE_MEASURE'  ==  TYPEOF(self.first_trim_condition))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLANE_ANGLE_MEASURE'  ==  TYPEOF(self.second_trim_condition)))  and  (self.first_trim_condition  ==  self.second_trim_condition)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY surface_style_usage #
####################
class surface_style_usage(founded_item):
	'''Entity surface_style_usage definition.

	:param side
	:type side:surface_side

	:param style
	:type style:surface_side_style_select
	'''
	def __init__( self , side,style, ):
		founded_item.__init__(self , )
		self.side = side
		self.style = style

	@apply
	def side():
		def fget( self ):
			return self._side
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument side is mantatory and can not be set to None')
			if not check_type(value,surface_side):
				self._side = surface_side(value)
			else:
				self._side = value
		return property(**locals())

	@apply
	def style():
		def fget( self ):
			return self._style
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style is mantatory and can not be set to None')
			if not check_type(value,surface_side_style_select):
				self._style = surface_side_style_select(value)
			else:
				self._style = value
		return property(**locals())

####################
 # ENTITY thermodynamic_temperature_unit #
####################
class thermodynamic_temperature_unit(named_unit):
	'''Entity thermodynamic_temperature_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  1))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY week_of_year_and_day_date #
####################
class week_of_year_and_day_date(date):
	'''Entity week_of_year_and_day_date definition.

	:param week_component
	:type week_component:week_in_year_number

	:param day_component
	:type day_component:day_in_week_number
	'''
	def __init__( self , inherited0__year_component , week_component,day_component, ):
		date.__init__(self , inherited0__year_component , )
		self.week_component = week_component
		self.day_component = day_component

	@apply
	def week_component():
		def fget( self ):
			return self._week_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument week_component is mantatory and can not be set to None')
			if not check_type(value,week_in_year_number):
				self._week_component = week_in_year_number(value)
			else:
				self._week_component = value
		return property(**locals())

	@apply
	def day_component():
		def fget( self ):
			return self._day_component
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,day_in_week_number):
					self._day_component = day_in_week_number(value)
				else:
					self._day_component = value
			else:
				self._day_component = value
		return property(**locals())

####################
 # ENTITY composite_text_with_blanking_box #
####################
class composite_text_with_blanking_box(composite_text):
	'''Entity composite_text_with_blanking_box definition.

	:param blanking
	:type blanking:planar_box
	'''
	def __init__( self , inherited0__name , inherited1__collected_text , blanking, ):
		composite_text.__init__(self , inherited0__name , inherited1__collected_text , )
		self.blanking = blanking

	@apply
	def blanking():
		def fget( self ):
			return self._blanking
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument blanking is mantatory and can not be set to None')
			if not check_type(value,planar_box):
				self._blanking = planar_box(value)
			else:
				self._blanking = value
		return property(**locals())

####################
 # ENTITY datum_feature_callout #
####################
class datum_feature_callout(draughting_callout):
	'''Entity datum_feature_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY organization_role #
####################
class organization_role(BaseEntityClass):
	'''Entity organization_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY camera_model_d3_multi_clipping_intersection #
####################
class camera_model_d3_multi_clipping_intersection(geometric_representation_item):
	'''Entity camera_model_d3_multi_clipping_intersection definition.

	:param shape_clipping
	:type shape_clipping:SET(2,None,'camera_model_d3_multi_clipping_interection_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , shape_clipping, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.shape_clipping = shape_clipping

	@apply
	def shape_clipping():
		def fget( self ):
			return self._shape_clipping
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument shape_clipping is mantatory and can not be set to None')
			if not check_type(value,SET(2,None,'camera_model_d3_multi_clipping_interection_select', scope = schema_scope)):
				self._shape_clipping = SET(value)
			else:
				self._shape_clipping = value
		return property(**locals())

####################
 # ENTITY point_on_curve #
####################
class point_on_curve(point):
	'''Entity point_on_curve definition.

	:param basis_curve
	:type basis_curve:curve

	:param point_parameter
	:type point_parameter:parameter_value
	'''
	def __init__( self , inherited0__name , basis_curve,point_parameter, ):
		point.__init__(self , inherited0__name , )
		self.basis_curve = basis_curve
		self.point_parameter = point_parameter

	@apply
	def basis_curve():
		def fget( self ):
			return self._basis_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._basis_curve = curve(value)
			else:
				self._basis_curve = value
		return property(**locals())

	@apply
	def point_parameter():
		def fget( self ):
			return self._point_parameter
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument point_parameter is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._point_parameter = parameter_value(value)
			else:
				self._point_parameter = value
		return property(**locals())

####################
 # ENTITY surface_style_rendering_with_properties #
####################
class surface_style_rendering_with_properties(surface_style_rendering):
	'''Entity surface_style_rendering_with_properties definition.

	:param properties
	:type properties:SET(1,2,'rendering_properties_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__rendering_method , inherited1__surface_colour , properties, ):
		surface_style_rendering.__init__(self , inherited0__rendering_method , inherited1__surface_colour , )
		self.properties = properties

	@apply
	def properties():
		def fget( self ):
			return self._properties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument properties is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'rendering_properties_select', scope = schema_scope)):
				self._properties = SET(value)
			else:
				self._properties = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.self.properties)  ==  1) XOR (TYPEOF(self.self.properties[1])  !=  TYPEOF(self.self.properties[2])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY default_tolerance_table_cell #
####################
class default_tolerance_table_cell(compound_representation_item):
	'''Entity default_tolerance_table_cell definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = default_tolerance_table_cell_wr2(self.self.compound_representation_item.self.item_element)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = default_tolerance_table_cell_wr3(self.self.compound_representation_item.self.item_element)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = default_tolerance_table_cell_wr4(self.self.compound_representation_item.self.item_element)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = default_tolerance_table_cell_wr5(self.self.compound_representation_item.self.item_element)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY dimension_curve_directed_callout #
####################
class dimension_curve_directed_callout(draughting_callout):
	'''Entity dimension_curve_directed_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.draughting_callout.self.contents)  >=  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY diameter_dimension #
####################
class diameter_dimension(dimension_curve_directed_callout):
	'''Entity diameter_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		dimension_curve_directed_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY shell_based_wireframe_shape_representation #
####################
class shell_based_wireframe_shape_representation(shape_representation):
	'''Entity shell_based_wireframe_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  3)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr


####################
 # ENTITY solid_with_rectangular_pattern #
####################
class solid_with_rectangular_pattern(solid_with_shape_element_pattern):
	'''Entity solid_with_rectangular_pattern definition.

	:param row_count
	:type row_count:positive_integer

	:param column_count
	:type column_count:positive_integer

	:param row_spacing
	:type row_spacing:length_measure

	:param column_spacing
	:type column_spacing:length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__replicated_element , row_count,column_count,row_spacing,column_spacing, ):
		solid_with_shape_element_pattern.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__replicated_element , )
		self.row_count = row_count
		self.column_count = column_count
		self.row_spacing = row_spacing
		self.column_spacing = column_spacing

	@apply
	def row_count():
		def fget( self ):
			return self._row_count
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument row_count is mantatory and can not be set to None')
			if not check_type(value,positive_integer):
				self._row_count = positive_integer(value)
			else:
				self._row_count = value
		return property(**locals())

	@apply
	def column_count():
		def fget( self ):
			return self._column_count
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument column_count is mantatory and can not be set to None')
			if not check_type(value,positive_integer):
				self._column_count = positive_integer(value)
			else:
				self._column_count = value
		return property(**locals())

	@apply
	def row_spacing():
		def fget( self ):
			return self._row_spacing
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument row_spacing is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._row_spacing = length_measure(value)
			else:
				self._row_spacing = value
		return property(**locals())

	@apply
	def column_spacing():
		def fget( self ):
			return self._column_spacing
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument column_spacing is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._column_spacing = length_measure(value)
			else:
				self._column_spacing = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.row_count  *  self.column_count)  >  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY solid_with_incomplete_rectangular_pattern #
####################
class solid_with_incomplete_rectangular_pattern(solid_with_rectangular_pattern):
	'''Entity solid_with_incomplete_rectangular_pattern definition.

	:param omitted_instances
	:type omitted_instances:SET(1,None,LIST(2,2,'INTEGER', scope = schema_scope))
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__replicated_element , inherited5__row_count , inherited6__column_count , inherited7__row_spacing , inherited8__column_spacing , omitted_instances, ):
		solid_with_rectangular_pattern.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__replicated_element , inherited5__row_count , inherited6__column_count , inherited7__row_spacing , inherited8__column_spacing , )
		self.omitted_instances = omitted_instances

	@apply
	def omitted_instances():
		def fget( self ):
			return self._omitted_instances
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument omitted_instances is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,LIST(2,2,'INTEGER', scope = schema_scope))):
				self._omitted_instances = SET(value)
			else:
				self._omitted_instances = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ([1,1]  ==  self.omitted_instances))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.omitted_instances)  <  ((self.self.solid_with_rectangular_pattern.self.row_count  *  self.self.solid_with_rectangular_pattern.self.column_count) - 1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY total_runout_tolerance #
####################
class total_runout_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity total_runout_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition_context_role #
####################
class product_definition_context_role(BaseEntityClass):
	'''Entity product_definition_context_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY character_glyph_symbol_outline #
####################
class character_glyph_symbol_outline(character_glyph_symbol):
	'''Entity character_glyph_symbol_outline definition.

	:param outlines
	:type outlines:SET(1,None,'annotation_fill_area', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__character_box , inherited4__baseline_ratio , outlines, ):
		character_glyph_symbol.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__character_box , inherited4__baseline_ratio , )
		self.outlines = outlines

	@apply
	def outlines():
		def fget( self ):
			return self._outlines
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument outlines is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'annotation_fill_area', scope = schema_scope)):
				self._outlines = SET(value)
			else:
				self._outlines = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.outlines  <=  self.self.representation.self.items)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY conical_stepped_hole_transition #
####################
class conical_stepped_hole_transition(geometric_representation_item):
	'''Entity conical_stepped_hole_transition definition.

	:param transition_number
	:type transition_number:positive_integer

	:param cone_apex_angle
	:type cone_apex_angle:plane_angle_measure

	:param cone_base_radius
	:type cone_base_radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , transition_number,cone_apex_angle,cone_base_radius, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.transition_number = transition_number
		self.cone_apex_angle = cone_apex_angle
		self.cone_base_radius = cone_base_radius

	@apply
	def transition_number():
		def fget( self ):
			return self._transition_number
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transition_number is mantatory and can not be set to None')
			if not check_type(value,positive_integer):
				self._transition_number = positive_integer(value)
			else:
				self._transition_number = value
		return property(**locals())

	@apply
	def cone_apex_angle():
		def fget( self ):
			return self._cone_apex_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument cone_apex_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._cone_apex_angle = plane_angle_measure(value)
			else:
				self._cone_apex_angle = value
		return property(**locals())

	@apply
	def cone_base_radius():
		def fget( self ):
			return self._cone_base_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument cone_base_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._cone_base_radius = positive_length_measure(value)
			else:
				self._cone_base_radius = value
		return property(**locals())

####################
 # ENTITY text_literal_with_associated_curves #
####################
class text_literal_with_associated_curves(text_literal):
	'''Entity text_literal_with_associated_curves definition.

	:param associated_curves
	:type associated_curves:SET(1,None,'curve', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , associated_curves, ):
		text_literal.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , )
		self.associated_curves = associated_curves

	@apply
	def associated_curves():
		def fget( self ):
			return self._associated_curves
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument associated_curves is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'curve', scope = schema_scope)):
				self._associated_curves = SET(value)
			else:
				self._associated_curves = value
		return property(**locals())

####################
 # ENTITY face_surface #
####################
class face_surface(face,geometric_representation_item):
	'''Entity face_surface definition.

	:param face_geometry
	:type face_geometry:surface

	:param same_sense
	:type same_sense:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__bounds , inherited2__name , face_geometry,same_sense, ):
		face.__init__(self , inherited0__name , inherited1__bounds , )
		geometric_representation_item.__init__(self , inherited2__name , )
		self.face_geometry = face_geometry
		self.same_sense = same_sense

	@apply
	def face_geometry():
		def fget( self ):
			return self._face_geometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument face_geometry is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._face_geometry = surface(value)
			else:
				self._face_geometry = value
		return property(**locals())

	@apply
	def same_sense():
		def fget( self ):
			return self._same_sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument same_sense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._same_sense = BOOLEAN(value)
			else:
				self._same_sense = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORIENTED_SURFACE'  ==  TYPEOF(self.face_geometry)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY material_property #
####################
class material_property(property_definition):
	'''Entity material_property definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition ,  ):
		property_definition.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )
	def wr1(self):
		eval_wr1_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CHARACTERIZED_OBJECT'  ==  TYPEOF(self.self.property_definition.self.definition))  or  (SIZEOF(bag_to_set(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) - None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY oriented_face #
####################
class oriented_face(face):
	'''Entity oriented_face definition.

	:param face_element
	:type face_element:face

	:param orientation
	:type orientation:BOOLEAN

	:param face_bounds
	:type face_bounds:SET(1,None,'face_bound', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__bounds , face_element,orientation, ):
		face.__init__(self , inherited0__name , inherited1__bounds , )
		self.face_element = face_element
		self.orientation = orientation

	@apply
	def face_element():
		def fget( self ):
			return self._face_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument face_element is mantatory and can not be set to None')
			if not check_type(value,face):
				self._face_element = face(value)
			else:
				self._face_element = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def face_bounds():
		def fget( self ):
			attribute_eval = conditional_reverse(self.self.orientation,self.self.face_element.self.bounds)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument face_bounds is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORIENTED_FACE'  ==  TYPEOF(self.self.face_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_of_revolution #
####################
class surface_of_revolution(swept_surface):
	'''Entity surface_of_revolution definition.

	:param axis_position
	:type axis_position:axis1_placement

	:param axis_line
	:type axis_line:line
	'''
	def __init__( self , inherited0__name , inherited1__swept_curve , axis_position, ):
		swept_surface.__init__(self , inherited0__name , inherited1__swept_curve , )
		self.axis_position = axis_position

	@apply
	def axis_position():
		def fget( self ):
			return self._axis_position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axis_position is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._axis_position = axis1_placement(value)
			else:
				self._axis_position = value
		return property(**locals())

	@apply
	def axis_line():
		def fget( self ):
			attribute_eval = (((representation_item('')  ==  geometric_representation_item())  ==  curve())  ==  line(self.axis_position.self.location,(representation_item('')  ==  geometric_representation_item())  ==  vector(self.axis_position.self.z,1)))
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument axis_line is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY user_selected_elements #
####################
class user_selected_elements(representation_item):
	'''Entity user_selected_elements definition.

	:param picked_items
	:type picked_items:SET(1,None,'representation_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , picked_items, ):
		representation_item.__init__(self , inherited0__name , )
		self.picked_items = picked_items

	@apply
	def picked_items():
		def fget( self ):
			return self._picked_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument picked_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'representation_item', scope = schema_scope)):
				self._picked_items = SET(value)
			else:
				self._picked_items = value
		return property(**locals())

####################
 # ENTITY user_selected_shape_elements #
####################
class user_selected_shape_elements(user_selected_elements):
	'''Entity user_selected_shape_elements definition.
	'''
	def __init__( self , inherited0__name , inherited1__picked_items ,  ):
		user_selected_elements.__init__(self , inherited0__name , inherited1__picked_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY angular_size #
####################
class angular_size(dimensional_size):
	'''Entity angular_size definition.

	:param angle_selection
	:type angle_selection:angle_relator
	'''
	def __init__( self , inherited0__applies_to , inherited1__name , angle_selection, ):
		dimensional_size.__init__(self , inherited0__applies_to , inherited1__name , )
		self.angle_selection = angle_selection

	@apply
	def angle_selection():
		def fget( self ):
			return self._angle_selection
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument angle_selection is mantatory and can not be set to None')
			if not check_type(value,angle_relator):
				self._angle_selection = angle_relator(value)
			else:
				self._angle_selection = value
		return property(**locals())

####################
 # ENTITY organizational_project_assignment #
####################
class organizational_project_assignment(BaseEntityClass):
	'''Entity organizational_project_assignment definition.

	:param assigned_organizational_project
	:type assigned_organizational_project:organizational_project

	:param role
	:type role:organizational_project_role
	'''
	def __init__( self , assigned_organizational_project,role, ):
		self.assigned_organizational_project = assigned_organizational_project
		self.role = role

	@apply
	def assigned_organizational_project():
		def fget( self ):
			return self._assigned_organizational_project
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_organizational_project is mantatory and can not be set to None')
			if not check_type(value,organizational_project):
				self._assigned_organizational_project = organizational_project(value)
			else:
				self._assigned_organizational_project = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,organizational_project_role):
				self._role = organizational_project_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY applied_organizational_project_assignment #
####################
class applied_organizational_project_assignment(organizational_project_assignment):
	'''Entity applied_organizational_project_assignment definition.

	:param items
	:type items:SET(1,None,'project_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_organizational_project , inherited1__role , items, ):
		organizational_project_assignment.__init__(self , inherited0__assigned_organizational_project , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'project_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY product_identification #
####################
class product_identification(configuration_item,characterized_object):
	'''Entity product_identification definition.

	:param configuration_item_item_concept
	:type configuration_item_item_concept:product_class
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , inherited5__name , inherited6__description , configuration_item_item_concept, ):
		configuration_item.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , )
		characterized_object.__init__(self , inherited5__name , inherited6__description , )
		self.configuration_item_item_concept = configuration_item_item_concept

	@apply
	def configuration_item_item_concept():
		def fget( self ):
			return self._configuration_item_item_concept
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument configuration_item_item_concept is mantatory and can not be set to None')
			if not check_type(value,product_class):
				self._configuration_item_item_concept = product_class(value)
			else:
				self._configuration_item_item_concept = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'CONFIGURABLE_ITEM')  ==  TYPEOF(self))) XOR (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PRODUCT_SPECIFICATION')  ==  TYPEOF(self)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY product_specification #
####################
class product_specification(product_identification,configurable_item):
	'''Entity product_specification definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , inherited5__name , inherited6__description , inherited7__configuration_item_item_concept , inherited8__id , inherited9__name , inherited10__description , inherited11__item_concept , inherited12__purpose , inherited13__item_concept_feature ,  ):
		product_identification.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_concept , inherited4__purpose , inherited5__name , inherited6__description , inherited7__configuration_item_item_concept , )
		configurable_item.__init__(self , inherited8__id , inherited9__name , inherited10__description , inherited11__item_concept , inherited12__purpose , inherited13__item_concept_feature , )

####################
 # ENTITY advanced_brep_shape_representation #
####################
class advanced_brep_shape_representation(shape_representation):
	'''Entity advanced_brep_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY thickness_laminate_table #
####################
class thickness_laminate_table(zone_structural_makeup):
	'''Entity thickness_laminate_table definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		zone_structural_makeup.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY property_definition_relationship #
####################
class property_definition_relationship(BaseEntityClass):
	'''Entity property_definition_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_property_definition
	:type relating_property_definition:property_definition

	:param related_property_definition
	:type related_property_definition:property_definition
	'''
	def __init__( self , name,description,relating_property_definition,related_property_definition, ):
		self.name = name
		self.description = description
		self.relating_property_definition = relating_property_definition
		self.related_property_definition = related_property_definition

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_property_definition():
		def fget( self ):
			return self._relating_property_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_property_definition is mantatory and can not be set to None')
			if not check_type(value,property_definition):
				self._relating_property_definition = property_definition(value)
			else:
				self._relating_property_definition = value
		return property(**locals())

	@apply
	def related_property_definition():
		def fget( self ):
			return self._related_property_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_property_definition is mantatory and can not be set to None')
			if not check_type(value,property_definition):
				self._related_property_definition = property_definition(value)
			else:
				self._related_property_definition = value
		return property(**locals())

####################
 # ENTITY edge_curve #
####################
class edge_curve(edge,geometric_representation_item):
	'''Entity edge_curve definition.

	:param edge_geometry
	:type edge_geometry:curve

	:param same_sense
	:type same_sense:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__edge_start , inherited2__edge_end , inherited3__name , edge_geometry,same_sense, ):
		edge.__init__(self , inherited0__name , inherited1__edge_start , inherited2__edge_end , )
		geometric_representation_item.__init__(self , inherited3__name , )
		self.edge_geometry = edge_geometry
		self.same_sense = same_sense

	@apply
	def edge_geometry():
		def fget( self ):
			return self._edge_geometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edge_geometry is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._edge_geometry = curve(value)
			else:
				self._edge_geometry = value
		return property(**locals())

	@apply
	def same_sense():
		def fget( self ):
			return self._same_sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument same_sense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._same_sense = BOOLEAN(value)
			else:
				self._same_sense = value
		return property(**locals())

####################
 # ENTITY simple_clause #
####################
class simple_clause(compound_representation_item):
	'''Entity simple_clause definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY literal_disjunction #
####################
class literal_disjunction(simple_clause):
	'''Entity literal_disjunction definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		simple_clause.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY positioned_sketch #
####################
class positioned_sketch(geometric_representation_item):
	'''Entity positioned_sketch definition.

	:param sketch_basis
	:type sketch_basis:sketch_basis_select

	:param auxiliary_elements
	:type auxiliary_elements:SET(0,None,'auxiliary_geometric_representation_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , sketch_basis,auxiliary_elements, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.sketch_basis = sketch_basis
		self.auxiliary_elements = auxiliary_elements

	@apply
	def sketch_basis():
		def fget( self ):
			return self._sketch_basis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sketch_basis is mantatory and can not be set to None')
			if not check_type(value,sketch_basis_select):
				self._sketch_basis = sketch_basis_select(value)
			else:
				self._sketch_basis = value
		return property(**locals())

	@apply
	def auxiliary_elements():
		def fget( self ):
			return self._auxiliary_elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument auxiliary_elements is mantatory and can not be set to None')
			if not check_type(value,SET(0,None,'auxiliary_geometric_representation_item', scope = schema_scope)):
				self._auxiliary_elements = SET(value)
			else:
				self._auxiliary_elements = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_BOUNDED_SURFACE'  ==  TYPEOF(self.sketch_basis))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLANE'  ==  TYPEOF(self.sketch_basis.self.curve_bounded_surface.self.basis_surface)))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.FACE_SURFACE'  ==  TYPEOF(self.sketch_basis))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLANE'  ==  TYPEOF(self.sketch_basis.self.face_surface.self.face_geometry)))))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY radius_dimension #
####################
class radius_dimension(dimension_curve_directed_callout):
	'''Entity radius_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		dimension_curve_directed_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_property #
####################
class action_property(BaseEntityClass):
	'''Entity action_property definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param definition
	:type definition:characterized_action_definition
	'''
	def __init__( self , name,description,definition, ):
		self.name = name
		self.description = description
		self.definition = definition

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,characterized_action_definition):
				self._definition = characterized_action_definition(value)
			else:
				self._definition = value
		return property(**locals())

####################
 # ENTITY electric_current_measure_with_unit #
####################
class electric_current_measure_with_unit(measure_with_unit):
	'''Entity electric_current_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELECTRIC_CURRENT_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surfaced_open_shell #
####################
class surfaced_open_shell(open_shell):
	'''Entity surfaced_open_shell definition.
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces ,  ):
		open_shell.__init__(self , inherited0__name , inherited1__cfs_faces , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY boxed_half_space #
####################
class boxed_half_space(half_space_solid):
	'''Entity boxed_half_space definition.

	:param enclosure
	:type enclosure:box_domain
	'''
	def __init__( self , inherited0__name , inherited1__base_surface , inherited2__agreement_flag , enclosure, ):
		half_space_solid.__init__(self , inherited0__name , inherited1__base_surface , inherited2__agreement_flag , )
		self.enclosure = enclosure

	@apply
	def enclosure():
		def fget( self ):
			return self._enclosure
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument enclosure is mantatory and can not be set to None')
			if not check_type(value,box_domain):
				self._enclosure = box_domain(value)
			else:
				self._enclosure = value
		return property(**locals())

####################
 # ENTITY document_product_association #
####################
class document_product_association(BaseEntityClass):
	'''Entity document_product_association definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_document
	:type relating_document:document

	:param related_product
	:type related_product:product_or_formation_or_definition
	'''
	def __init__( self , name,description,relating_document,related_product, ):
		self.name = name
		self.description = description
		self.relating_document = relating_document
		self.related_product = related_product

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_document():
		def fget( self ):
			return self._relating_document
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_document is mantatory and can not be set to None')
			if not check_type(value,document):
				self._relating_document = document(value)
			else:
				self._relating_document = value
		return property(**locals())

	@apply
	def related_product():
		def fget( self ):
			return self._related_product
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_product is mantatory and can not be set to None')
			if not check_type(value,product_or_formation_or_definition):
				self._related_product = product_or_formation_or_definition(value)
			else:
				self._related_product = value
		return property(**locals())

####################
 # ENTITY document_product_equivalence #
####################
class document_product_equivalence(document_product_association):
	'''Entity document_product_equivalence definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_document , inherited3__related_product ,  ):
		document_product_association.__init__(self , inherited0__name , inherited1__description , inherited2__relating_document , inherited3__related_product , )
	def wr1(self):
		eval_wr1_wr = (self.self.document_product_association.self.name  ==  'equivalence')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRODUCT'  ==  TYPEOF(self.self.document_product_association.self.related_product)))  or  ((self.self.document_product_association.self.relating_document.self.kind.self.product_data_type  ==  'configuration controlled document')  and  (SIZEOF(None)  ==  1)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRODUCT_DEFINITION_FORMATION'  ==  TYPEOF(self.self.related_product)))  or  ((self.self.document_product_association.self.relating_document.self.kind.self.product_data_type  ==  'configuration controlled document version')  and  (SIZEOF(None)  ==  1)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRODUCT_DEFINITION'  ==  TYPEOF(self.self.related_product)))  or  ((self.self.document_product_association.self.relating_document.self.kind.self.product_data_type  ==  'configuration controlled document definition')  and  (SIZEOF(None)  ==  1)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY point_replica #
####################
class point_replica(point):
	'''Entity point_replica definition.

	:param parent_pt
	:type parent_pt:point

	:param transformation
	:type transformation:cartesian_transformation_operator
	'''
	def __init__( self , inherited0__name , parent_pt,transformation, ):
		point.__init__(self , inherited0__name , )
		self.parent_pt = parent_pt
		self.transformation = transformation

	@apply
	def parent_pt():
		def fget( self ):
			return self._parent_pt
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_pt is mantatory and can not be set to None')
			if not check_type(value,point):
				self._parent_pt = point(value)
			else:
				self._parent_pt = value
		return property(**locals())

	@apply
	def transformation():
		def fget( self ):
			return self._transformation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transformation is mantatory and can not be set to None')
			if not check_type(value,cartesian_transformation_operator):
				self._transformation = cartesian_transformation_operator(value)
			else:
				self._transformation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.transformation.self.dim  ==  self.parent_pt.self.dim)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = acyclic_point_replica(self,self.parent_pt)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY product #
####################
class product(BaseEntityClass):
	'''Entity product definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param frame_of_reference
	:type frame_of_reference:SET(1,None,'product_context', scope = schema_scope)
	'''
	def __init__( self , id,name,description,frame_of_reference, ):
		self.id = id
		self.name = name
		self.description = description
		self.frame_of_reference = frame_of_reference

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument id is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def frame_of_reference():
		def fget( self ):
			return self._frame_of_reference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument frame_of_reference is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'product_context', scope = schema_scope)):
				self._frame_of_reference = SET(value)
			else:
				self._frame_of_reference = value
		return property(**locals())

####################
 # ENTITY product_definition_context_association #
####################
class product_definition_context_association(BaseEntityClass):
	'''Entity product_definition_context_association definition.

	:param definition
	:type definition:product_definition

	:param frame_of_reference
	:type frame_of_reference:product_definition_context

	:param role
	:type role:product_definition_context_role
	'''
	def __init__( self , definition,frame_of_reference,role, ):
		self.definition = definition
		self.frame_of_reference = frame_of_reference
		self.role = role

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,product_definition):
				self._definition = product_definition(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def frame_of_reference():
		def fget( self ):
			return self._frame_of_reference
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument frame_of_reference is mantatory and can not be set to None')
			if not check_type(value,product_definition_context):
				self._frame_of_reference = product_definition_context(value)
			else:
				self._frame_of_reference = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,product_definition_context_role):
				self._role = product_definition_context_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY datum_reference #
####################
class datum_reference(BaseEntityClass):
	'''Entity datum_reference definition.

	:param precedence
	:type precedence:INTEGER

	:param referenced_datum
	:type referenced_datum:datum
	'''
	def __init__( self , precedence,referenced_datum, ):
		self.precedence = precedence
		self.referenced_datum = referenced_datum

	@apply
	def precedence():
		def fget( self ):
			return self._precedence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument precedence is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._precedence = INTEGER(value)
			else:
				self._precedence = value
		return property(**locals())

	@apply
	def referenced_datum():
		def fget( self ):
			return self._referenced_datum
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument referenced_datum is mantatory and can not be set to None')
			if not check_type(value,datum):
				self._referenced_datum = datum(value)
			else:
				self._referenced_datum = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.precedence  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY picture_representation #
####################
class picture_representation(presentation_view):
	'''Entity picture_representation definition.

	:param representation_items
	:type representation_items:SET(2,None,'picture_representation_item_select', scope = schema_scope)

	:param size
	:type size:presentation_size
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , representation_items, ):
		presentation_view.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , )
		self.representation_items = representation_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(2,None,'picture_representation_item_select', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())

	@apply
	def size():
		def fget( self ):
			return self._size
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument size is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY rectangular_trimmed_surface #
####################
class rectangular_trimmed_surface(bounded_surface):
	'''Entity rectangular_trimmed_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param u1
	:type u1:parameter_value

	:param u2
	:type u2:parameter_value

	:param v1
	:type v1:parameter_value

	:param v2
	:type v2:parameter_value

	:param usense
	:type usense:BOOLEAN

	:param vsense
	:type vsense:BOOLEAN
	'''
	def __init__( self , inherited0__name , basis_surface,u1,u2,v1,v2,usense,vsense, ):
		bounded_surface.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.u1 = u1
		self.u2 = u2
		self.v1 = v1
		self.v2 = v2
		self.usense = usense
		self.vsense = vsense

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def u1():
		def fget( self ):
			return self._u1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u1 is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._u1 = parameter_value(value)
			else:
				self._u1 = value
		return property(**locals())

	@apply
	def u2():
		def fget( self ):
			return self._u2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u2 is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._u2 = parameter_value(value)
			else:
				self._u2 = value
		return property(**locals())

	@apply
	def v1():
		def fget( self ):
			return self._v1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v1 is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._v1 = parameter_value(value)
			else:
				self._v1 = value
		return property(**locals())

	@apply
	def v2():
		def fget( self ):
			return self._v2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v2 is mantatory and can not be set to None')
			if not check_type(value,parameter_value):
				self._v2 = parameter_value(value)
			else:
				self._v2 = value
		return property(**locals())

	@apply
	def usense():
		def fget( self ):
			return self._usense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument usense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._usense = BOOLEAN(value)
			else:
				self._usense = value
		return property(**locals())

	@apply
	def vsense():
		def fget( self ):
			return self._vsense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vsense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._vsense = BOOLEAN(value)
			else:
				self._vsense = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.u1  !=  self.u2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.v1  !=  self.v2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELEMENTARY_SURFACE'  ==  TYPEOF(self.basis_surface))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLANE'  ==  TYPEOF(self.basis_surface))))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_OF_REVOLUTION'  ==  TYPEOF(self.basis_surface)))  or  (self.usense  ==  (self.u2  >  self.u1)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SPHERICAL_SURFACE'  ==  TYPEOF(self.basis_surface))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TOROIDAL_SURFACE'  ==  TYPEOF(self.basis_surface)))  or  (self.vsense  ==  (self.v2  >  self.v1)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY id_attribute #
####################
class id_attribute(BaseEntityClass):
	'''Entity id_attribute definition.

	:param attribute_value
	:type attribute_value:identifier

	:param identified_item
	:type identified_item:id_attribute_select
	'''
	def __init__( self , attribute_value,identified_item, ):
		self.attribute_value = attribute_value
		self.identified_item = identified_item

	@apply
	def attribute_value():
		def fget( self ):
			return self._attribute_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_value is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._attribute_value = identifier(value)
			else:
				self._attribute_value = value
		return property(**locals())

	@apply
	def identified_item():
		def fget( self ):
			return self._identified_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument identified_item is mantatory and can not be set to None')
			if not check_type(value,id_attribute_select):
				self._identified_item = id_attribute_select(value)
			else:
				self._identified_item = value
		return property(**locals())

####################
 # ENTITY language #
####################
class language(group):
	'''Entity language definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )
	def wr1(self):
		eval_wr1_wr = (self.self.group.self.name  !=  '')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY plane #
####################
class plane(elementary_surface):
	'''Entity plane definition.
	'''
	def __init__( self , inherited0__name , inherited1__position ,  ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )

####################
 # ENTITY thickened_face_solid #
####################
class thickened_face_solid(solid_model):
	'''Entity thickened_face_solid definition.

	:param base_element
	:type base_element:generalized_surface_select

	:param offset1
	:type offset1:length_measure

	:param offset2
	:type offset2:length_measure
	'''
	def __init__( self , inherited0__name , base_element,offset1,offset2, ):
		solid_model.__init__(self , inherited0__name , )
		self.base_element = base_element
		self.offset1 = offset1
		self.offset2 = offset2

	@apply
	def base_element():
		def fget( self ):
			return self._base_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base_element is mantatory and can not be set to None')
			if not check_type(value,generalized_surface_select):
				self._base_element = generalized_surface_select(value)
			else:
				self._base_element = value
		return property(**locals())

	@apply
	def offset1():
		def fget( self ):
			return self._offset1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offset1 is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._offset1 = length_measure(value)
			else:
				self._offset1 = value
		return property(**locals())

	@apply
	def offset2():
		def fget( self ):
			return self._offset2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offset2 is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._offset2 = length_measure(value)
			else:
				self._offset2 = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE'  ==  TYPEOF(self.base_element))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOUNDED_SURFACE'  ==  TYPEOF(self.base_element)))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.offset1  !=  self.offset2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY annotation_plane #
####################
class annotation_plane(annotation_occurrence,geometric_representation_item):
	'''Entity annotation_plane definition.

	:param elements
	:type elements:SET(1,None,'annotation_plane_element', scope = schema_scope)

	:param styled_item_item
	:type styled_item_item:plane_or_planar_box
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__name , elements,styled_item_item, ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		geometric_representation_item.__init__(self , inherited3__name , )
		self.elements = elements
		self.styled_item_item = styled_item_item

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,SET(1,None,'annotation_plane_element', scope = schema_scope)):
					self._elements = SET(value)
				else:
					self._elements = value
			else:
				self._elements = value
		return property(**locals())

	@apply
	def styled_item_item():
		def fget( self ):
			return self._styled_item_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_item_item is mantatory and can not be set to None')
			if not check_type(value,plane_or_planar_box):
				self._styled_item_item = plane_or_planar_box(value)
			else:
				self._styled_item_item = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PLANAR_BOX')  ==  TYPEOF(self.self.styled_item.self.item)))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'AXIS2_PLACEMENT_3D')  ==  TYPEOF(self.self.styled_item.self.item.self.planar_box.self.placement)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PLANAR_BOX')  ==  TYPEOF(self.self.styled_item.self.item))  and  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'CURVE_STYLE')  ==  TYPEOF(self.self.styled_item.self.styles[1].self.presentation_style_assignment.self.styles[1])))  or  ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PLANE')  ==  TYPEOF(self.self.styled_item.self.item))  and  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'FILL_AREA_STYLE')  ==  TYPEOF(self.self.styled_item.self.styles[1].self.presentation_style_assignment.self.styles[1]))))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((SIZEOF(self.self.styled_item.self.styles)  ==  1)  and  (SIZEOF(self.self.styled_item.self.styles[1].self.presentation_style_assignment.self.styles)  ==  1))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY breakdown_element_usage #
####################
class breakdown_element_usage(product_definition_relationship):
	'''Entity breakdown_element_usage definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY change #
####################
class change(action_assignment):
	'''Entity change definition.

	:param items
	:type items:SET(1,None,'work_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action , items, ):
		action_assignment.__init__(self , inherited0__assigned_action , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'work_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY circle #
####################
class circle(conic):
	'''Entity circle definition.

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY classification_role #
####################
class classification_role(BaseEntityClass):
	'''Entity classification_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY composite_assembly_sequence_definition #
####################
class composite_assembly_sequence_definition(product_definition):
	'''Entity composite_assembly_sequence_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY line #
####################
class line(curve):
	'''Entity line definition.

	:param pnt
	:type pnt:cartesian_point

	:param dir
	:type dir:vector
	'''
	def __init__( self , inherited0__name , pnt,dir, ):
		curve.__init__(self , inherited0__name , )
		self.pnt = pnt
		self.dir = dir

	@apply
	def pnt():
		def fget( self ):
			return self._pnt
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pnt is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._pnt = cartesian_point(value)
			else:
				self._pnt = value
		return property(**locals())

	@apply
	def dir():
		def fget( self ):
			return self._dir
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dir is mantatory and can not be set to None')
			if not check_type(value,vector):
				self._dir = vector(value)
			else:
				self._dir = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.dir.self.dim  ==  self.pnt.self.dim)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY general_property_association #
####################
class general_property_association(BaseEntityClass):
	'''Entity general_property_association definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param base_definition
	:type base_definition:general_property

	:param derived_definition
	:type derived_definition:derived_property_select
	'''
	def __init__( self , name,description,base_definition,derived_definition, ):
		self.name = name
		self.description = description
		self.base_definition = base_definition
		self.derived_definition = derived_definition

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def base_definition():
		def fget( self ):
			return self._base_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base_definition is mantatory and can not be set to None')
			if not check_type(value,general_property):
				self._base_definition = general_property(value)
			else:
				self._base_definition = value
		return property(**locals())

	@apply
	def derived_definition():
		def fget( self ):
			return self._derived_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument derived_definition is mantatory and can not be set to None')
			if not check_type(value,derived_property_select):
				self._derived_definition = derived_property_select(value)
			else:
				self._derived_definition = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self.derived_definition,('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'GENERAL_PROPERTY_ASSOCIATION.')  +  'DERIVED_DEFINITION'))  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.derived_definition.self.name  ==  self.base_definition.self.name)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY date_representation_item #
####################
class date_representation_item(representation_item,date):
	'''Entity date_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__year_component ,  ):
		representation_item.__init__(self , inherited0__name , )
		date.__init__(self , inherited1__year_component , )

####################
 # ENTITY product_definition_element_relationship #
####################
class product_definition_element_relationship(group):
	'''Entity product_definition_element_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY surface_style_segmentation_curve #
####################
class surface_style_segmentation_curve(founded_item):
	'''Entity surface_style_segmentation_curve definition.

	:param style_of_segmentation_curve
	:type style_of_segmentation_curve:curve_or_render
	'''
	def __init__( self , style_of_segmentation_curve, ):
		founded_item.__init__(self , )
		self.style_of_segmentation_curve = style_of_segmentation_curve

	@apply
	def style_of_segmentation_curve():
		def fget( self ):
			return self._style_of_segmentation_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_segmentation_curve is mantatory and can not be set to None')
			if not check_type(value,curve_or_render):
				self._style_of_segmentation_curve = curve_or_render(value)
			else:
				self._style_of_segmentation_curve = value
		return property(**locals())

####################
 # ENTITY view_volume #
####################
class view_volume(founded_item):
	'''Entity view_volume definition.

	:param projection_type
	:type projection_type:central_or_parallel

	:param projection_point
	:type projection_point:cartesian_point

	:param view_plane_distance
	:type view_plane_distance:length_measure

	:param front_plane_distance
	:type front_plane_distance:length_measure

	:param front_plane_clipping
	:type front_plane_clipping:BOOLEAN

	:param back_plane_distance
	:type back_plane_distance:length_measure

	:param back_plane_clipping
	:type back_plane_clipping:BOOLEAN

	:param view_volume_sides_clipping
	:type view_volume_sides_clipping:BOOLEAN

	:param view_window
	:type view_window:planar_box
	'''
	def __init__( self , projection_type,projection_point,view_plane_distance,front_plane_distance,front_plane_clipping,back_plane_distance,back_plane_clipping,view_volume_sides_clipping,view_window, ):
		founded_item.__init__(self , )
		self.projection_type = projection_type
		self.projection_point = projection_point
		self.view_plane_distance = view_plane_distance
		self.front_plane_distance = front_plane_distance
		self.front_plane_clipping = front_plane_clipping
		self.back_plane_distance = back_plane_distance
		self.back_plane_clipping = back_plane_clipping
		self.view_volume_sides_clipping = view_volume_sides_clipping
		self.view_window = view_window

	@apply
	def projection_type():
		def fget( self ):
			return self._projection_type
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument projection_type is mantatory and can not be set to None')
			if not check_type(value,central_or_parallel):
				self._projection_type = central_or_parallel(value)
			else:
				self._projection_type = value
		return property(**locals())

	@apply
	def projection_point():
		def fget( self ):
			return self._projection_point
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument projection_point is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._projection_point = cartesian_point(value)
			else:
				self._projection_point = value
		return property(**locals())

	@apply
	def view_plane_distance():
		def fget( self ):
			return self._view_plane_distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument view_plane_distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._view_plane_distance = length_measure(value)
			else:
				self._view_plane_distance = value
		return property(**locals())

	@apply
	def front_plane_distance():
		def fget( self ):
			return self._front_plane_distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument front_plane_distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._front_plane_distance = length_measure(value)
			else:
				self._front_plane_distance = value
		return property(**locals())

	@apply
	def front_plane_clipping():
		def fget( self ):
			return self._front_plane_clipping
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument front_plane_clipping is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._front_plane_clipping = BOOLEAN(value)
			else:
				self._front_plane_clipping = value
		return property(**locals())

	@apply
	def back_plane_distance():
		def fget( self ):
			return self._back_plane_distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument back_plane_distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._back_plane_distance = length_measure(value)
			else:
				self._back_plane_distance = value
		return property(**locals())

	@apply
	def back_plane_clipping():
		def fget( self ):
			return self._back_plane_clipping
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument back_plane_clipping is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._back_plane_clipping = BOOLEAN(value)
			else:
				self._back_plane_clipping = value
		return property(**locals())

	@apply
	def view_volume_sides_clipping():
		def fget( self ):
			return self._view_volume_sides_clipping
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument view_volume_sides_clipping is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._view_volume_sides_clipping = BOOLEAN(value)
			else:
				self._view_volume_sides_clipping = value
		return property(**locals())

	@apply
	def view_window():
		def fget( self ):
			return self._view_window
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument view_window is mantatory and can not be set to None')
			if not check_type(value,planar_box):
				self._view_window = planar_box(value)
			else:
				self._view_window = value
		return property(**locals())

####################
 # ENTITY curve_swept_solid_shape_representation #
####################
class curve_swept_solid_shape_representation(shape_representation):
	'''Entity curve_swept_solid_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY material_property_representation #
####################
class material_property_representation(property_definition_representation):
	'''Entity material_property_representation definition.

	:param dependent_environment
	:type dependent_environment:data_environment
	'''
	def __init__( self , inherited0__definition , inherited1__used_representation , dependent_environment, ):
		property_definition_representation.__init__(self , inherited0__definition , inherited1__used_representation , )
		self.dependent_environment = dependent_environment

	@apply
	def dependent_environment():
		def fget( self ):
			return self._dependent_environment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument dependent_environment is mantatory and can not be set to None')
			if not check_type(value,data_environment):
				self._dependent_environment = data_environment(value)
			else:
				self._dependent_environment = value
		return property(**locals())

####################
 # ENTITY breakdown_element_realization #
####################
class breakdown_element_realization(characterized_object,product_definition_element_relationship):
	'''Entity breakdown_element_realization definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__name , inherited3__description ,  ):
		characterized_object.__init__(self , inherited0__name , inherited1__description , )
		product_definition_element_relationship.__init__(self , inherited2__name , inherited3__description , )

####################
 # ENTITY geometrical_tolerance_callout #
####################
class geometrical_tolerance_callout(draughting_callout):
	'''Entity geometrical_tolerance_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY source_for_requirement #
####################
class source_for_requirement(group_assignment):
	'''Entity source_for_requirement definition.

	:param items
	:type items:SET(1,1,'requirement_source_item', scope = schema_scope)

	:param group_assignment_assigned_group
	:type group_assignment_assigned_group:requirement_source
	'''
	def __init__( self , inherited0__assigned_group , items,group_assignment_assigned_group, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items
		self.group_assignment_assigned_group = group_assignment_assigned_group

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,1,'requirement_source_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def group_assignment_assigned_group():
		def fget( self ):
			return self._group_assignment_assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument group_assignment_assigned_group is mantatory and can not be set to None')
			if not check_type(value,requirement_source):
				self._group_assignment_assigned_group = requirement_source(value)
			else:
				self._group_assignment_assigned_group = value
		return property(**locals())

####################
 # ENTITY geometric_set #
####################
class geometric_set(geometric_representation_item):
	'''Entity geometric_set definition.

	:param elements
	:type elements:SET(1,None,'geometric_set_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , elements, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.elements = elements

	@apply
	def elements():
		def fget( self ):
			return self._elements
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument elements is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'geometric_set_select', scope = schema_scope)):
				self._elements = SET(value)
			else:
				self._elements = value
		return property(**locals())

####################
 # ENTITY geometric_curve_set #
####################
class geometric_curve_set(geometric_set):
	'''Entity geometric_curve_set definition.
	'''
	def __init__( self , inherited0__name , inherited1__elements ,  ):
		geometric_set.__init__(self , inherited0__name , inherited1__elements , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_method_role #
####################
class action_method_role(BaseEntityClass):
	'''Entity action_method_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY personal_address #
####################
class personal_address(address):
	'''Entity personal_address definition.

	:param people
	:type people:SET(1,None,'person', scope = schema_scope)

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , people,description, ):
		address.__init__(self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , )
		self.people = people
		self.description = description

	@apply
	def people():
		def fget( self ):
			return self._people
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument people is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'person', scope = schema_scope)):
				self._people = SET(value)
			else:
				self._people = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY si_dose_equivalent_unit #
####################
class si_dose_equivalent_unit(dose_equivalent_unit,si_unit):
	'''Entity si_dose_equivalent_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		dose_equivalent_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.sievert)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY document_relationship #
####################
class document_relationship(BaseEntityClass):
	'''Entity document_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_document
	:type relating_document:document

	:param related_document
	:type related_document:document
	'''
	def __init__( self , name,description,relating_document,related_document, ):
		self.name = name
		self.description = description
		self.relating_document = relating_document
		self.related_document = related_document

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_document():
		def fget( self ):
			return self._relating_document
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_document is mantatory and can not be set to None')
			if not check_type(value,document):
				self._relating_document = document(value)
			else:
				self._relating_document = value
		return property(**locals())

	@apply
	def related_document():
		def fget( self ):
			return self._related_document
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_document is mantatory and can not be set to None')
			if not check_type(value,document):
				self._related_document = document(value)
			else:
				self._related_document = value
		return property(**locals())

####################
 # ENTITY indirectly_selected_elements #
####################
class indirectly_selected_elements(user_selected_elements):
	'''Entity indirectly_selected_elements definition.

	:param indirectly_picked_items
	:type indirectly_picked_items:SET(1,None,'representation_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__picked_items , indirectly_picked_items, ):
		user_selected_elements.__init__(self , inherited0__name , inherited1__picked_items , )
		self.indirectly_picked_items = indirectly_picked_items

	@apply
	def indirectly_picked_items():
		def fget( self ):
			return self._indirectly_picked_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument indirectly_picked_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'representation_item', scope = schema_scope)):
				self._indirectly_picked_items = SET(value)
			else:
				self._indirectly_picked_items = value
		return property(**locals())

####################
 # ENTITY make_from_usage_option #
####################
class make_from_usage_option(product_definition_usage):
	'''Entity make_from_usage_option definition.

	:param ranking
	:type ranking:INTEGER

	:param ranking_rationale
	:type ranking_rationale:text

	:param quantity
	:type quantity:measure_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , ranking,ranking_rationale,quantity, ):
		product_definition_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )
		self.ranking = ranking
		self.ranking_rationale = ranking_rationale
		self.quantity = quantity

	@apply
	def ranking():
		def fget( self ):
			return self._ranking
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ranking is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._ranking = INTEGER(value)
			else:
				self._ranking = value
		return property(**locals())

	@apply
	def ranking_rationale():
		def fget( self ):
			return self._ranking_rationale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ranking_rationale is mantatory and can not be set to None')
			if not check_type(value,text):
				self._ranking_rationale = text(value)
			else:
				self._ranking_rationale = value
		return property(**locals())

	@apply
	def quantity():
		def fget( self ):
			return self._quantity
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument quantity is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._quantity = measure_with_unit(value)
			else:
				self._quantity = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not ('NUMBER'  ==  TYPEOF(self.quantity.self.value_component)))  or  (self.quantity.self.value_component  >  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY outer_boundary_curve #
####################
class outer_boundary_curve(boundary_curve):
	'''Entity outer_boundary_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__segments , inherited2__self_intersect ,  ):
		boundary_curve.__init__(self , inherited0__name , inherited1__segments , inherited2__self_intersect , )

####################
 # ENTITY shape_representation_relationship #
####################
class shape_representation_relationship(representation_relationship):
	'''Entity shape_representation_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 ,  ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SHAPE_REPRESENTATION'  ==  (TYPEOF(self.self.representation_relationship.self.rep_1)  +  TYPEOF(self.self.representation_relationship.self.rep_2)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY tagged_text_item #
####################
class tagged_text_item(descriptive_representation_item):
	'''Entity tagged_text_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		descriptive_representation_item.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY type_qualifier #
####################
class type_qualifier(BaseEntityClass):
	'''Entity type_qualifier definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY annotation_fill_area #
####################
class annotation_fill_area(geometric_representation_item):
	'''Entity annotation_fill_area definition.

	:param boundaries
	:type boundaries:SET(1,None,'curve', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , boundaries, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.boundaries = boundaries

	@apply
	def boundaries():
		def fget( self ):
			return self._boundaries
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument boundaries is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'curve', scope = schema_scope)):
				self._boundaries = SET(value)
			else:
				self._boundaries = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.self.geometric_representation_item.self.dim  ==  3)  or  (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_approval_assignment #
####################
class applied_approval_assignment(approval_assignment):
	'''Entity applied_approval_assignment definition.

	:param items
	:type items:SET(1,None,'approval_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_approval , items, ):
		approval_assignment.__init__(self , inherited0__assigned_approval , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'approval_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY assembly_component_usage_substitute #
####################
class assembly_component_usage_substitute(BaseEntityClass):
	'''Entity assembly_component_usage_substitute definition.

	:param name
	:type name:label

	:param definition
	:type definition:text

	:param base
	:type base:assembly_component_usage

	:param substitute
	:type substitute:assembly_component_usage
	'''
	def __init__( self , name,definition,base,substitute, ):
		self.name = name
		self.definition = definition
		self.base = base
		self.substitute = substitute

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._definition = text(value)
				else:
					self._definition = value
			else:
				self._definition = value
		return property(**locals())

	@apply
	def base():
		def fget( self ):
			return self._base
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument base is mantatory and can not be set to None')
			if not check_type(value,assembly_component_usage):
				self._base = assembly_component_usage(value)
			else:
				self._base = value
		return property(**locals())

	@apply
	def substitute():
		def fget( self ):
			return self._substitute
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument substitute is mantatory and can not be set to None')
			if not check_type(value,assembly_component_usage):
				self._substitute = assembly_component_usage(value)
			else:
				self._substitute = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.base.self.relating_product_definition  ==  self.substitute.self.relating_product_definition)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.base  !=  self.substitute)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY drawing_definition #
####################
class drawing_definition(BaseEntityClass):
	'''Entity drawing_definition definition.

	:param drawing_number
	:type drawing_number:identifier

	:param drawing_type
	:type drawing_type:label
	'''
	def __init__( self , drawing_number,drawing_type, ):
		self.drawing_number = drawing_number
		self.drawing_type = drawing_type

	@apply
	def drawing_number():
		def fget( self ):
			return self._drawing_number
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument drawing_number is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._drawing_number = identifier(value)
			else:
				self._drawing_number = value
		return property(**locals())

	@apply
	def drawing_type():
		def fget( self ):
			return self._drawing_type
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,label):
					self._drawing_type = label(value)
				else:
					self._drawing_type = value
			else:
				self._drawing_type = value
		return property(**locals())

####################
 # ENTITY degenerate_pcurve #
####################
class degenerate_pcurve(point):
	'''Entity degenerate_pcurve definition.

	:param basis_surface
	:type basis_surface:surface

	:param reference_to_curve
	:type reference_to_curve:definitional_representation
	'''
	def __init__( self , inherited0__name , basis_surface,reference_to_curve, ):
		point.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.reference_to_curve = reference_to_curve

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def reference_to_curve():
		def fget( self ):
			return self._reference_to_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reference_to_curve is mantatory and can not be set to None')
			if not check_type(value,definitional_representation):
				self._reference_to_curve = definitional_representation(value)
			else:
				self._reference_to_curve = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.reference_to_curve.self.representation.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE'  ==  TYPEOF(self.reference_to_curve.self.representation.self.items[1]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.reference_to_curve.self.representation.self.items[1].self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY evaluated_degenerate_pcurve #
####################
class evaluated_degenerate_pcurve(degenerate_pcurve):
	'''Entity evaluated_degenerate_pcurve definition.

	:param equivalent_point
	:type equivalent_point:cartesian_point
	'''
	def __init__( self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , equivalent_point, ):
		degenerate_pcurve.__init__(self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , )
		self.equivalent_point = equivalent_point

	@apply
	def equivalent_point():
		def fget( self ):
			return self._equivalent_point
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument equivalent_point is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._equivalent_point = cartesian_point(value)
			else:
				self._equivalent_point = value
		return property(**locals())

####################
 # ENTITY solid_angle_measure_with_unit #
####################
class solid_angle_measure_with_unit(measure_with_unit):
	'''Entity solid_angle_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_ANGLE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY user_defined_curve_font #
####################
class user_defined_curve_font(curve_style_font,mapped_item):
	'''Entity user_defined_curve_font definition.
	'''
	def __init__( self , inherited0__name , inherited1__pattern_list , inherited2__name , inherited3__mapping_source , inherited4__mapping_target ,  ):
		curve_style_font.__init__(self , inherited0__name , inherited1__pattern_list , )
		mapped_item.__init__(self , inherited2__name , inherited3__mapping_source , inherited4__mapping_target , )

####################
 # ENTITY connected_edge_set #
####################
class connected_edge_set(topological_representation_item):
	'''Entity connected_edge_set definition.

	:param ces_edges
	:type ces_edges:SET(1,None,'edge', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , ces_edges, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.ces_edges = ces_edges

	@apply
	def ces_edges():
		def fget( self ):
			return self._ces_edges
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ces_edges is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'edge', scope = schema_scope)):
				self._ces_edges = SET(value)
			else:
				self._ces_edges = value
		return property(**locals())

####################
 # ENTITY external_source_relationship #
####################
class external_source_relationship(BaseEntityClass):
	'''Entity external_source_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_source
	:type relating_source:external_source

	:param related_source
	:type related_source:external_source
	'''
	def __init__( self , name,description,relating_source,related_source, ):
		self.name = name
		self.description = description
		self.relating_source = relating_source
		self.related_source = related_source

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_source():
		def fget( self ):
			return self._relating_source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_source is mantatory and can not be set to None')
			if not check_type(value,external_source):
				self._relating_source = external_source(value)
			else:
				self._relating_source = value
		return property(**locals())

	@apply
	def related_source():
		def fget( self ):
			return self._related_source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_source is mantatory and can not be set to None')
			if not check_type(value,external_source):
				self._related_source = external_source(value)
			else:
				self._related_source = value
		return property(**locals())

####################
 # ENTITY action #
####################
class action(BaseEntityClass):
	'''Entity action definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param chosen_method
	:type chosen_method:action_method

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description,chosen_method, ):
		self.name = name
		self.description = description
		self.chosen_method = chosen_method

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def chosen_method():
		def fget( self ):
			return self._chosen_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument chosen_method is mantatory and can not be set to None')
			if not check_type(value,action_method):
				self._chosen_method = action_method(value)
			else:
				self._chosen_method = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY executed_action #
####################
class executed_action(action):
	'''Entity executed_action definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method ,  ):
		action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )

####################
 # ENTITY directed_action #
####################
class directed_action(executed_action):
	'''Entity directed_action definition.

	:param directive
	:type directive:action_directive
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method , directive, ):
		executed_action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )
		self.directive = directive

	@apply
	def directive():
		def fget( self ):
			return self._directive
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument directive is mantatory and can not be set to None')
			if not check_type(value,action_directive):
				self._directive = action_directive(value)
			else:
				self._directive = value
		return property(**locals())

####################
 # ENTITY pre_defined_curve_font #
####################
class pre_defined_curve_font(pre_defined_item):
	'''Entity pre_defined_curve_font definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )

####################
 # ENTITY draughting_pre_defined_curve_font #
####################
class draughting_pre_defined_curve_font(pre_defined_curve_font):
	'''Entity draughting_pre_defined_curve_font definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_curve_font.__init__(self , inherited0__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['continuous','chain','chain double dash','dashed','dotted'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY standard_uncertainty #
####################
class standard_uncertainty(uncertainty_qualifier):
	'''Entity standard_uncertainty definition.

	:param uncertainty_value
	:type uncertainty_value:REAL
	'''
	def __init__( self , inherited0__measure_name , inherited1__description , uncertainty_value, ):
		uncertainty_qualifier.__init__(self , inherited0__measure_name , inherited1__description , )
		self.uncertainty_value = uncertainty_value

	@apply
	def uncertainty_value():
		def fget( self ):
			return self._uncertainty_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument uncertainty_value is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._uncertainty_value = REAL(value)
			else:
				self._uncertainty_value = value
		return property(**locals())

####################
 # ENTITY expanded_uncertainty #
####################
class expanded_uncertainty(standard_uncertainty):
	'''Entity expanded_uncertainty definition.

	:param coverage_factor
	:type coverage_factor:REAL
	'''
	def __init__( self , inherited0__measure_name , inherited1__description , inherited2__uncertainty_value , coverage_factor, ):
		standard_uncertainty.__init__(self , inherited0__measure_name , inherited1__description , inherited2__uncertainty_value , )
		self.coverage_factor = coverage_factor

	@apply
	def coverage_factor():
		def fget( self ):
			return self._coverage_factor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coverage_factor is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._coverage_factor = REAL(value)
			else:
				self._coverage_factor = value
		return property(**locals())

####################
 # ENTITY shape_feature_definition #
####################
class shape_feature_definition(characterized_object):
	'''Entity shape_feature_definition definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		characterized_object.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY instanced_feature #
####################
class instanced_feature(shape_aspect,shape_feature_definition):
	'''Entity instanced_feature definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , inherited4__name , inherited5__description ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		shape_feature_definition.__init__(self , inherited4__name , inherited5__description , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRODUCT_DEFINITION'  ==  TYPEOF(self.self.shape_aspect.self.of_shape.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = self.self.shape_aspect.self.product_definitional
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY organizational_project #
####################
class organizational_project(BaseEntityClass):
	'''Entity organizational_project definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param responsible_organizations
	:type responsible_organizations:SET(1,None,'organization', scope = schema_scope)

	:param id
	:type id:identifier
	'''
	def __init__( self , name,description,responsible_organizations, ):
		self.name = name
		self.description = description
		self.responsible_organizations = responsible_organizations

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def responsible_organizations():
		def fget( self ):
			return self._responsible_organizations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument responsible_organizations is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'organization', scope = schema_scope)):
				self._responsible_organizations = SET(value)
			else:
				self._responsible_organizations = value
		return property(**locals())

	@apply
	def id():
		def fget( self ):
			attribute_eval = get_id_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument id is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ID_ATTRIBUTE.IDENTIFIED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY user_defined_terminator_symbol #
####################
class user_defined_terminator_symbol(mapped_item,pre_defined_symbol):
	'''Entity user_defined_terminator_symbol definition.
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , inherited3__name ,  ):
		mapped_item.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , )
		pre_defined_symbol.__init__(self , inherited3__name , )

####################
 # ENTITY date_time_role #
####################
class date_time_role(BaseEntityClass):
	'''Entity date_time_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY drawing_sheet_revision_sequence #
####################
class drawing_sheet_revision_sequence(representation_relationship):
	'''Entity drawing_sheet_revision_sequence definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 ,  ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
	def wr1(self):
		eval_wr1_wr = (self.self.representation_relationship.self.rep_1  !=  self.self.representation_relationship.self.rep_2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DRAWING_SHEET_REVISION'  ==  TYPEOF(self.self.representation_relationship.self.rep_1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DRAWING_SHEET_REVISION'  ==  TYPEOF(self.self.representation_relationship.self.rep_2))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY ratio_unit #
####################
class ratio_unit(named_unit):
	'''Entity ratio_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_style_reflectance_ambient_diffuse_specular #
####################
class surface_style_reflectance_ambient_diffuse_specular(surface_style_reflectance_ambient_diffuse):
	'''Entity surface_style_reflectance_ambient_diffuse_specular definition.

	:param specular_reflectance
	:type specular_reflectance:REAL

	:param specular_exponent
	:type specular_exponent:REAL

	:param specular_colour
	:type specular_colour:colour
	'''
	def __init__( self , inherited0__ambient_reflectance , inherited1__diffuse_reflectance , specular_reflectance,specular_exponent,specular_colour, ):
		surface_style_reflectance_ambient_diffuse.__init__(self , inherited0__ambient_reflectance , inherited1__diffuse_reflectance , )
		self.specular_reflectance = specular_reflectance
		self.specular_exponent = specular_exponent
		self.specular_colour = specular_colour

	@apply
	def specular_reflectance():
		def fget( self ):
			return self._specular_reflectance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument specular_reflectance is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._specular_reflectance = REAL(value)
			else:
				self._specular_reflectance = value
		return property(**locals())

	@apply
	def specular_exponent():
		def fget( self ):
			return self._specular_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument specular_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._specular_exponent = REAL(value)
			else:
				self._specular_exponent = value
		return property(**locals())

	@apply
	def specular_colour():
		def fget( self ):
			return self._specular_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument specular_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._specular_colour = colour(value)
			else:
				self._specular_colour = value
		return property(**locals())

####################
 # ENTITY action_relationship #
####################
class action_relationship(BaseEntityClass):
	'''Entity action_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_action
	:type relating_action:action

	:param related_action
	:type related_action:action
	'''
	def __init__( self , name,description,relating_action,related_action, ):
		self.name = name
		self.description = description
		self.relating_action = relating_action
		self.related_action = related_action

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_action():
		def fget( self ):
			return self._relating_action
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_action is mantatory and can not be set to None')
			if not check_type(value,action):
				self._relating_action = action(value)
			else:
				self._relating_action = value
		return property(**locals())

	@apply
	def related_action():
		def fget( self ):
			return self._related_action
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_action is mantatory and can not be set to None')
			if not check_type(value,action):
				self._related_action = action(value)
			else:
				self._related_action = value
		return property(**locals())

####################
 # ENTITY applied_document_reference #
####################
class applied_document_reference(document_reference):
	'''Entity applied_document_reference definition.

	:param items
	:type items:SET(1,None,'document_reference_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_document , inherited1__source , items, ):
		document_reference.__init__(self , inherited0__assigned_document , inherited1__source , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'document_reference_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY area_in_set #
####################
class area_in_set(BaseEntityClass):
	'''Entity area_in_set definition.

	:param area
	:type area:presentation_area

	:param in_set
	:type in_set:presentation_set
	'''
	def __init__( self , area,in_set, ):
		self.area = area
		self.in_set = in_set

	@apply
	def area():
		def fget( self ):
			return self._area
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument area is mantatory and can not be set to None')
			if not check_type(value,presentation_area):
				self._area = presentation_area(value)
			else:
				self._area = value
		return property(**locals())

	@apply
	def in_set():
		def fget( self ):
			return self._in_set
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument in_set is mantatory and can not be set to None')
			if not check_type(value,presentation_set):
				self._in_set = presentation_set(value)
			else:
				self._in_set = value
		return property(**locals())

####################
 # ENTITY extruded_area_solid #
####################
class extruded_area_solid(swept_area_solid):
	'''Entity extruded_area_solid definition.

	:param extruded_direction
	:type extruded_direction:direction

	:param depth
	:type depth:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__swept_area , extruded_direction,depth, ):
		swept_area_solid.__init__(self , inherited0__name , inherited1__swept_area , )
		self.extruded_direction = extruded_direction
		self.depth = depth

	@apply
	def extruded_direction():
		def fget( self ):
			return self._extruded_direction
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extruded_direction is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._extruded_direction = direction(value)
			else:
				self._extruded_direction = value
		return property(**locals())

	@apply
	def depth():
		def fget( self ):
			return self._depth
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument depth is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._depth = positive_length_measure(value)
			else:
				self._depth = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (dot_product(self.self.swept_area_solid.self.swept_area.self.basis_surface.self.elementary_surface.self.position.self.p[3],self.extruded_direction)  !=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY known_source #
####################
class known_source(external_source,pre_defined_item):
	'''Entity known_source definition.
	'''
	def __init__( self , inherited0__source_id , inherited1__name ,  ):
		external_source.__init__(self , inherited0__source_id , )
		pre_defined_item.__init__(self , inherited1__name , )

####################
 # ENTITY solid_curve_font #
####################
class solid_curve_font(pre_defined_curve_font):
	'''Entity solid_curve_font definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_curve_font.__init__(self , inherited0__name , )

####################
 # ENTITY extension #
####################
class extension(derived_shape_aspect):
	'''Entity extension definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY luminous_flux_measure_with_unit #
####################
class luminous_flux_measure_with_unit(measure_with_unit):
	'''Entity luminous_flux_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LUMINOUS_FLUX_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY min_and_major_ply_orientation_basis #
####################
class min_and_major_ply_orientation_basis(representation_item_relationship,geometric_representation_item):
	'''Entity min_and_major_ply_orientation_basis definition.

	:param representation_item_relationship_related_representation_item
	:type representation_item_relationship_related_representation_item:axis2_placement_3d

	:param representation_item_relationship_relating_representation_item
	:type representation_item_relationship_relating_representation_item:axis2_placement_3d

	:param major_orientation_basis
	:type major_orientation_basis:axis2_placement_3d

	:param minor_orientation_basis
	:type minor_orientation_basis:axis2_placement_3d
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_representation_item , inherited3__related_representation_item , inherited4__name , representation_item_relationship_related_representation_item,representation_item_relationship_relating_representation_item, ):
		representation_item_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_representation_item , inherited3__related_representation_item , )
		geometric_representation_item.__init__(self , inherited4__name , )
		self.representation_item_relationship_related_representation_item = representation_item_relationship_related_representation_item
		self.representation_item_relationship_relating_representation_item = representation_item_relationship_relating_representation_item

	@apply
	def representation_item_relationship_related_representation_item():
		def fget( self ):
			return self._representation_item_relationship_related_representation_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_item_relationship_related_representation_item is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._representation_item_relationship_related_representation_item = axis2_placement_3d(value)
			else:
				self._representation_item_relationship_related_representation_item = value
		return property(**locals())

	@apply
	def representation_item_relationship_relating_representation_item():
		def fget( self ):
			return self._representation_item_relationship_relating_representation_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_item_relationship_relating_representation_item is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._representation_item_relationship_relating_representation_item = axis2_placement_3d(value)
			else:
				self._representation_item_relationship_relating_representation_item = value
		return property(**locals())

	@apply
	def major_orientation_basis():
		def fget( self ):
			attribute_eval = self.self.representation_item_relationship.self.related_representation_item
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument major_orientation_basis is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def minor_orientation_basis():
		def fget( self ):
			attribute_eval = self.self.representation_item_relationship.self.relating_representation_item
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument minor_orientation_basis is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY curve_bounded_surface #
####################
class curve_bounded_surface(bounded_surface):
	'''Entity curve_bounded_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param boundaries
	:type boundaries:SET(1,None,'boundary_curve', scope = schema_scope)

	:param implicit_outer
	:type implicit_outer:BOOLEAN
	'''
	def __init__( self , inherited0__name , basis_surface,boundaries,implicit_outer, ):
		bounded_surface.__init__(self , inherited0__name , )
		self.basis_surface = basis_surface
		self.boundaries = boundaries
		self.implicit_outer = implicit_outer

	@apply
	def basis_surface():
		def fget( self ):
			return self._basis_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._basis_surface = surface(value)
			else:
				self._basis_surface = value
		return property(**locals())

	@apply
	def boundaries():
		def fget( self ):
			return self._boundaries
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument boundaries is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'boundary_curve', scope = schema_scope)):
				self._boundaries = SET(value)
			else:
				self._boundaries = value
		return property(**locals())

	@apply
	def implicit_outer():
		def fget( self ):
			return self._implicit_outer
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument implicit_outer is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._implicit_outer = BOOLEAN(value)
			else:
				self._implicit_outer = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not self.implicit_outer)  or  (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not self.implicit_outer)  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOUNDED_SURFACE'  ==  TYPEOF(self.basis_surface)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  <=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY solid_with_curved_slot #
####################
class solid_with_curved_slot(solid_with_slot):
	'''Entity solid_with_curved_slot definition.

	:param slot_centreline
	:type slot_centreline:bounded_curve
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__slot_width , inherited6__closed_ends , inherited7__end_exit_faces , slot_centreline, ):
		solid_with_slot.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__slot_width , inherited6__closed_ends , inherited7__end_exit_faces , )
		self.slot_centreline = slot_centreline

	@apply
	def slot_centreline():
		def fget( self ):
			return self._slot_centreline
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument slot_centreline is mantatory and can not be set to None')
			if not check_type(value,bounded_curve):
				self._slot_centreline = bounded_curve(value)
			else:
				self._slot_centreline = value
		return property(**locals())

####################
 # ENTITY leader_curve #
####################
class leader_curve(annotation_curve_occurrence):
	'''Entity leader_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item ,  ):
		annotation_curve_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY back_chaining_rule #
####################
class back_chaining_rule(rule_definition):
	'''Entity back_chaining_rule definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		rule_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY background_colour #
####################
class background_colour(colour):
	'''Entity background_colour definition.

	:param presentation
	:type presentation:area_or_view
	'''
	def __init__( self , presentation, ):
		colour.__init__(self , )
		self.presentation = presentation

	@apply
	def presentation():
		def fget( self ):
			return self._presentation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument presentation is mantatory and can not be set to None')
			if not check_type(value,area_or_view):
				self._presentation = area_or_view(value)
			else:
				self._presentation = value
		return property(**locals())

####################
 # ENTITY closed_shell #
####################
class closed_shell(connected_face_set):
	'''Entity closed_shell definition.
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces ,  ):
		connected_face_set.__init__(self , inherited0__name , inherited1__cfs_faces , )

####################
 # ENTITY design_make_from_relationship #
####################
class design_make_from_relationship(product_definition_relationship):
	'''Entity design_make_from_relationship definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY externally_defined_general_property #
####################
class externally_defined_general_property(general_property,externally_defined_item):
	'''Entity externally_defined_general_property definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__item_id , inherited4__source ,  ):
		general_property.__init__(self , inherited0__id , inherited1__name , inherited2__description , )
		externally_defined_item.__init__(self , inherited3__item_id , inherited4__source , )

####################
 # ENTITY pressure_unit #
####################
class pressure_unit(derived_unit):
	'''Entity pressure_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.pascal))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY track_blended_solid_with_end_conditions #
####################
class track_blended_solid_with_end_conditions(track_blended_solid):
	'''Entity track_blended_solid_with_end_conditions definition.

	:param end_conditions
	:type end_conditions:LIST(2,2,'blend_end_condition_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , end_conditions, ):
		track_blended_solid.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , )
		self.end_conditions = end_conditions

	@apply
	def end_conditions():
		def fget( self ):
			return self._end_conditions
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument end_conditions is mantatory and can not be set to None')
			if not check_type(value,LIST(2,2,'blend_end_condition_select', scope = schema_scope)):
				self._end_conditions = LIST(value)
			else:
				self._end_conditions = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(TYPEOF(self)  *  ['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_CONSTANT_RADIUS_EDGE_BLEND','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_VARIABLE_RADIUS_EDGE_BLEND','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_CHAMFERED_EDGES'])  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VERTEX'  ==  TYPEOF(self.end_conditions[1]))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VERTEX'  ==  TYPEOF(self.end_conditions[2]))))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VERTEX'  ==  TYPEOF(self.end_conditions[1]))  and  ( not ((self.end_conditions[1]  ==  self.self.edge_blended_solid.self.blended_edges[1].self.edge_start) XOR (self.end_conditions[1]  ==  self.self.edge_blended_solid.self.blended_edges[1].self.edge_end)))))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VERTEX'  ==  TYPEOF(self.end_conditions[2]))  and  ( not ((self.end_conditions[2]  ==  self.self.edge_blended_solid.self.blended_edges[HIINDEX(self.self.edge_blended_solid.self.blended_edges)].self.edge_start) XOR (self.end_conditions[2]  ==  self.self.edge_blended_solid.self.blended_edges[HIINDEX(self.self.edge_blended_solid.self.blended_edges)].self.edge_end)))))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY name_assignment #
####################
class name_assignment(BaseEntityClass):
	'''Entity name_assignment definition.

	:param assigned_name
	:type assigned_name:label

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_name, ):
		self.assigned_name = assigned_name

	@apply
	def assigned_name():
		def fget( self ):
			return self._assigned_name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._assigned_name = label(value)
			else:
				self._assigned_name = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_name_assignment #
####################
class applied_name_assignment(name_assignment):
	'''Entity applied_name_assignment definition.

	:param item
	:type item:name_item
	'''
	def __init__( self , inherited0__assigned_name , item, ):
		name_assignment.__init__(self , inherited0__assigned_name , )
		self.item = item

	@apply
	def item():
		def fget( self ):
			return self._item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item is mantatory and can not be set to None')
			if not check_type(value,name_item):
				self._item = name_item(value)
			else:
				self._item = value
		return property(**locals())

####################
 # ENTITY characteristic_data_column_header #
####################
class characteristic_data_column_header(general_property):
	'''Entity characteristic_data_column_header definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description ,  ):
		general_property.__init__(self , inherited0__id , inherited1__name , inherited2__description , )

####################
 # ENTITY complex_clause #
####################
class complex_clause(compound_representation_item):
	'''Entity complex_clause definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY complex_disjunctive_clause #
####################
class complex_disjunctive_clause(complex_clause):
	'''Entity complex_disjunctive_clause definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		complex_clause.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY draughting_subfigure_representation #
####################
class draughting_subfigure_representation(symbol_representation):
	'''Entity draughting_subfigure_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		symbol_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  >  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ( not acyclic_mapped_item_usage(self))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(self.self.context_of_items.self.representations_in_context)  ==  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY draughting_text_literal_with_delineation #
####################
class draughting_text_literal_with_delineation(text_literal_with_delineation):
	'''Entity draughting_text_literal_with_delineation definition.
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , inherited6__delineation ,  ):
		text_literal_with_delineation.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , inherited6__delineation , )
	def wr1(self):
		eval_wr1_wr = (self.self.delineation  ==  ['underline','overline'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY qualified_representation_item #
####################
class qualified_representation_item(representation_item):
	'''Entity qualified_representation_item definition.

	:param qualifiers
	:type qualifiers:SET(1,None,'value_qualifier', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , qualifiers, ):
		representation_item.__init__(self , inherited0__name , )
		self.qualifiers = qualifiers

	@apply
	def qualifiers():
		def fget( self ):
			return self._qualifiers
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument qualifiers is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'value_qualifier', scope = schema_scope)):
				self._qualifiers = SET(value)
			else:
				self._qualifiers = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY text_font_in_family #
####################
class text_font_in_family(BaseEntityClass):
	'''Entity text_font_in_family definition.

	:param font
	:type font:text_font

	:param family
	:type family:text_font_family
	'''
	def __init__( self , font,family, ):
		self.font = font
		self.family = family

	@apply
	def font():
		def fget( self ):
			return self._font
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument font is mantatory and can not be set to None')
			if not check_type(value,text_font):
				self._font = text_font(value)
			else:
				self._font = value
		return property(**locals())

	@apply
	def family():
		def fget( self ):
			return self._family
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument family is mantatory and can not be set to None')
			if not check_type(value,text_font_family):
				self._family = text_font_family(value)
			else:
				self._family = value
		return property(**locals())

####################
 # ENTITY extruded_face_solid_with_trim_conditions #
####################
class extruded_face_solid_with_trim_conditions(extruded_face_solid):
	'''Entity extruded_face_solid_with_trim_conditions definition.

	:param first_trim_condition
	:type first_trim_condition:trim_condition_select

	:param second_trim_condition
	:type second_trim_condition:trim_condition_select

	:param first_trim_intent
	:type first_trim_intent:trim_intent

	:param second_trim_intent
	:type second_trim_intent:trim_intent

	:param first_offset
	:type first_offset:non_negative_length_measure

	:param second_offset
	:type second_offset:non_negative_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__swept_face , inherited2__extruded_direction , inherited3__depth , first_trim_condition,second_trim_condition,first_trim_intent,second_trim_intent,first_offset,second_offset, ):
		extruded_face_solid.__init__(self , inherited0__name , inherited1__swept_face , inherited2__extruded_direction , inherited3__depth , )
		self.first_trim_condition = first_trim_condition
		self.second_trim_condition = second_trim_condition
		self.first_trim_intent = first_trim_intent
		self.second_trim_intent = second_trim_intent
		self.first_offset = first_offset
		self.second_offset = second_offset

	@apply
	def first_trim_condition():
		def fget( self ):
			return self._first_trim_condition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument first_trim_condition is mantatory and can not be set to None')
			if not check_type(value,trim_condition_select):
				self._first_trim_condition = trim_condition_select(value)
			else:
				self._first_trim_condition = value
		return property(**locals())

	@apply
	def second_trim_condition():
		def fget( self ):
			return self._second_trim_condition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument second_trim_condition is mantatory and can not be set to None')
			if not check_type(value,trim_condition_select):
				self._second_trim_condition = trim_condition_select(value)
			else:
				self._second_trim_condition = value
		return property(**locals())

	@apply
	def first_trim_intent():
		def fget( self ):
			return self._first_trim_intent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument first_trim_intent is mantatory and can not be set to None')
			if not check_type(value,trim_intent):
				self._first_trim_intent = trim_intent(value)
			else:
				self._first_trim_intent = value
		return property(**locals())

	@apply
	def second_trim_intent():
		def fget( self ):
			return self._second_trim_intent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument second_trim_intent is mantatory and can not be set to None')
			if not check_type(value,trim_intent):
				self._second_trim_intent = trim_intent(value)
			else:
				self._second_trim_intent = value
		return property(**locals())

	@apply
	def first_offset():
		def fget( self ):
			return self._first_offset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument first_offset is mantatory and can not be set to None')
			if not check_type(value,non_negative_length_measure):
				self._first_offset = non_negative_length_measure(value)
			else:
				self._first_offset = value
		return property(**locals())

	@apply
	def second_offset():
		def fget( self ):
			return self._second_offset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument second_offset is mantatory and can not be set to None')
			if not check_type(value,non_negative_length_measure):
				self._second_offset = non_negative_length_measure(value)
			else:
				self._second_offset = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLANE_ANGLE_MEASURE'  ==  TYPEOF(self.first_trim_condition))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLANE_ANGLE_MEASURE'  ==  TYPEOF(self.second_trim_condition))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_MEASURE'  ==  TYPEOF(self.first_trim_condition))  and  ((self.first_trim_intent  ==  trim_intent.self.offset)  or  (self.first_trim_intent  ==  trim_intent.self.up_to_next)))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_MEASURE'  ==  TYPEOF(self.second_trim_condition))  and  ((self.second_trim_intent  ==  trim_intent.self.offset)  or  (self.second_trim_intent  ==  trim_intent.self.up_to_next)))))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ( not ((( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_MEASURE'  ==  TYPEOF(self.first_trim_condition)))  and  ((self.first_trim_intent  ==  trim_intent.self.blind)  or  (self.first_trim_intent  ==  trim_intent.self.through_all)))  or  (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_MEASURE'  ==  TYPEOF(self.second_trim_condition)))  and  ((self.second_trim_intent  ==  trim_intent.self.blind)  or  (self.second_trim_intent  ==  trim_intent.self.through_all)))))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((((self.first_trim_intent  ==  trim_intent.self.offset)  and  (self.first_offset  >  0)) XOR ((self.first_trim_intent  !=  trim_intent.self.offset)  and  (self.first_offset  ==  0)))  and  (((self.second_trim_intent  ==  trim_intent.self.offset)  and  (self.second_offset  >  0)) XOR ((self.second_trim_intent  !=  trim_intent.self.offset)  and  (self.second_offset  ==  0))))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ( not ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_MEASURE'  ==  TYPEOF(self.first_trim_condition))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_MEASURE'  ==  TYPEOF(self.second_trim_condition)))  and  (self.first_trim_condition  ==  self.second_trim_condition)))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY extruded_face_solid_with_multiple_draft_angles #
####################
class extruded_face_solid_with_multiple_draft_angles(extruded_face_solid_with_trim_conditions):
	'''Entity extruded_face_solid_with_multiple_draft_angles definition.

	:param drafted_edges
	:type drafted_edges:LIST(2,None,SET(1,None,'edge_curve', scope = schema_scope))

	:param draft_angles
	:type draft_angles:LIST(2,None,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__swept_face , inherited2__extruded_direction , inherited3__depth , inherited4__first_trim_condition , inherited5__second_trim_condition , inherited6__first_trim_intent , inherited7__second_trim_intent , inherited8__first_offset , inherited9__second_offset , drafted_edges,draft_angles, ):
		extruded_face_solid_with_trim_conditions.__init__(self , inherited0__name , inherited1__swept_face , inherited2__extruded_direction , inherited3__depth , inherited4__first_trim_condition , inherited5__second_trim_condition , inherited6__first_trim_intent , inherited7__second_trim_intent , inherited8__first_offset , inherited9__second_offset , )
		self.drafted_edges = drafted_edges
		self.draft_angles = draft_angles

	@apply
	def drafted_edges():
		def fget( self ):
			return self._drafted_edges
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument drafted_edges is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,SET(1,None,'edge_curve', scope = schema_scope))):
				self._drafted_edges = LIST(value)
			else:
				self._drafted_edges = value
		return property(**locals())

	@apply
	def draft_angles():
		def fget( self ):
			return self._draft_angles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument draft_angles is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._draft_angles = LIST(value)
			else:
				self._draft_angles = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.drafted_edges)  ==  SIZEOF(self.draft_angles))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY time_interval_role #
####################
class time_interval_role(BaseEntityClass):
	'''Entity time_interval_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY externally_defined_currency #
####################
class externally_defined_currency(currency,externally_defined_context_dependent_unit):
	'''Entity externally_defined_currency definition.
	'''
	def __init__( self , inherited0__dimensions , inherited1__name , inherited2__dimensions , inherited3__name , inherited4__item_id , inherited5__source ,  ):
		currency.__init__(self , inherited0__dimensions , inherited1__name , )
		externally_defined_context_dependent_unit.__init__(self , inherited2__dimensions , inherited3__name , inherited4__item_id , inherited5__source , )

####################
 # ENTITY generic_variable #
####################
class generic_variable(simple_generic_expression):
	'''Entity generic_variable definition.

	:param interpretation
	:type interpretation:environment
	'''
	def __init__( self ,  ):
		simple_generic_expression.__init__(self , )

	@apply
	def interpretation():
		def fget( self ):
			return self._interpretation
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument interpretation is INVERSE. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY percentage_laminate_table #
####################
class percentage_laminate_table(zone_structural_makeup):
	'''Entity percentage_laminate_table definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		zone_structural_makeup.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY radioactivity_unit #
####################
class radioactivity_unit(derived_unit):
	'''Entity radioactivity_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.becquerel))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_radioactivity_unit #
####################
class si_radioactivity_unit(radioactivity_unit,si_unit):
	'''Entity si_radioactivity_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		radioactivity_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.becquerel)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY solid_with_spherical_bottom_round_hole #
####################
class solid_with_spherical_bottom_round_hole(solid_with_stepped_round_hole):
	'''Entity solid_with_spherical_bottom_round_hole definition.

	:param sphere_radius
	:type sphere_radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__segments , inherited6__segment_radii , inherited7__segment_depths , sphere_radius, ):
		solid_with_stepped_round_hole.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__segments , inherited6__segment_radii , inherited7__segment_depths , )
		self.sphere_radius = sphere_radius

	@apply
	def sphere_radius():
		def fget( self ):
			return self._sphere_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sphere_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._sphere_radius = positive_length_measure(value)
			else:
				self._sphere_radius = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.sphere_radius  >=  self.self.solid_with_stepped_round_hole.self.segment_radii[self.segments])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY effectivity_context_assignment #
####################
class effectivity_context_assignment(BaseEntityClass):
	'''Entity effectivity_context_assignment definition.

	:param assigned_effectivity_assignment
	:type assigned_effectivity_assignment:effectivity_assignment

	:param role
	:type role:effectivity_context_role
	'''
	def __init__( self , assigned_effectivity_assignment,role, ):
		self.assigned_effectivity_assignment = assigned_effectivity_assignment
		self.role = role

	@apply
	def assigned_effectivity_assignment():
		def fget( self ):
			return self._assigned_effectivity_assignment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_effectivity_assignment is mantatory and can not be set to None')
			if not check_type(value,effectivity_assignment):
				self._assigned_effectivity_assignment = effectivity_assignment(value)
			else:
				self._assigned_effectivity_assignment = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,effectivity_context_role):
				self._role = effectivity_context_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY configured_effectivity_context_assignment #
####################
class configured_effectivity_context_assignment(effectivity_context_assignment):
	'''Entity configured_effectivity_context_assignment definition.

	:param items
	:type items:SET(1,None,'configured_effectivity_context_item', scope = schema_scope)

	:param effectivity_context_assignment_assigned_effectivity_assignment
	:type effectivity_context_assignment_assigned_effectivity_assignment:configured_effectivity_assignment
	'''
	def __init__( self , inherited0__assigned_effectivity_assignment , inherited1__role , items,effectivity_context_assignment_assigned_effectivity_assignment, ):
		effectivity_context_assignment.__init__(self , inherited0__assigned_effectivity_assignment , inherited1__role , )
		self.items = items
		self.effectivity_context_assignment_assigned_effectivity_assignment = effectivity_context_assignment_assigned_effectivity_assignment

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'configured_effectivity_context_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def effectivity_context_assignment_assigned_effectivity_assignment():
		def fget( self ):
			return self._effectivity_context_assignment_assigned_effectivity_assignment
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument effectivity_context_assignment_assigned_effectivity_assignment is mantatory and can not be set to None')
			if not check_type(value,configured_effectivity_assignment):
				self._effectivity_context_assignment_assigned_effectivity_assignment = configured_effectivity_assignment(value)
			else:
				self._effectivity_context_assignment_assigned_effectivity_assignment = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY drawing_revision #
####################
class drawing_revision(presentation_set):
	'''Entity drawing_revision definition.

	:param revision_identifier
	:type revision_identifier:identifier

	:param drawing_identifier
	:type drawing_identifier:drawing_definition

	:param intended_scale
	:type intended_scale:text
	'''
	def __init__( self , revision_identifier,drawing_identifier,intended_scale, ):
		presentation_set.__init__(self , )
		self.revision_identifier = revision_identifier
		self.drawing_identifier = drawing_identifier
		self.intended_scale = intended_scale

	@apply
	def revision_identifier():
		def fget( self ):
			return self._revision_identifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument revision_identifier is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._revision_identifier = identifier(value)
			else:
				self._revision_identifier = value
		return property(**locals())

	@apply
	def drawing_identifier():
		def fget( self ):
			return self._drawing_identifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument drawing_identifier is mantatory and can not be set to None')
			if not check_type(value,drawing_definition):
				self._drawing_identifier = drawing_definition(value)
			else:
				self._drawing_identifier = value
		return property(**locals())

	@apply
	def intended_scale():
		def fget( self ):
			return self._intended_scale
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._intended_scale = text(value)
				else:
					self._intended_scale = value
			else:
				self._intended_scale = value
		return property(**locals())

####################
 # ENTITY non_manifold_surface_shape_representation #
####################
class non_manifold_surface_shape_representation(shape_representation):
	'''Entity non_manifold_surface_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(None)  ==  0)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = (SIZEOF(None)  ==  0)
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr


####################
 # ENTITY angularity_tolerance #
####################
class angularity_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity angularity_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY placed_datum_target_feature #
####################
class placed_datum_target_feature(datum_target):
	'''Entity placed_datum_target_feature definition.

	:param representation_associations
	:type representation_associations:SET(0,None,'property_definition_representation', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , inherited4__target_id ,  ):
		datum_target.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , inherited4__target_id , )

	@apply
	def representation_associations():
		def fget( self ):
			attribute_eval = get_shape_aspect_property_definition_representations(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument representation_associations is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.description  ==  ['point','line','rectangle','circle','circular line'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = valid_datum_target_parameters(self)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY product_concept_feature_category_usage #
####################
class product_concept_feature_category_usage(group_assignment):
	'''Entity product_concept_feature_category_usage definition.

	:param items
	:type items:SET(1,None,'category_usage_item', scope = schema_scope)

	:param group_assignment_assigned_group
	:type group_assignment_assigned_group:product_concept_feature_category
	'''
	def __init__( self , inherited0__assigned_group , items,group_assignment_assigned_group, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items
		self.group_assignment_assigned_group = group_assignment_assigned_group

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'category_usage_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def group_assignment_assigned_group():
		def fget( self ):
			return self._group_assignment_assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument group_assignment_assigned_group is mantatory and can not be set to None')
			if not check_type(value,product_concept_feature_category):
				self._group_assignment_assigned_group = product_concept_feature_category(value)
			else:
				self._group_assignment_assigned_group = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.role.self.name  ==  ['mandatory category usage','optional category usage'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY box_domain #
####################
class box_domain(founded_item):
	'''Entity box_domain definition.

	:param corner
	:type corner:cartesian_point

	:param xlength
	:type xlength:positive_length_measure

	:param ylength
	:type ylength:positive_length_measure

	:param zlength
	:type zlength:positive_length_measure
	'''
	def __init__( self , corner,xlength,ylength,zlength, ):
		founded_item.__init__(self , )
		self.corner = corner
		self.xlength = xlength
		self.ylength = ylength
		self.zlength = zlength

	@apply
	def corner():
		def fget( self ):
			return self._corner
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument corner is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._corner = cartesian_point(value)
			else:
				self._corner = value
		return property(**locals())

	@apply
	def xlength():
		def fget( self ):
			return self._xlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument xlength is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._xlength = positive_length_measure(value)
			else:
				self._xlength = value
		return property(**locals())

	@apply
	def ylength():
		def fget( self ):
			return self._ylength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument ylength is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._ylength = positive_length_measure(value)
			else:
				self._ylength = value
		return property(**locals())

	@apply
	def zlength():
		def fget( self ):
			return self._zlength
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zlength is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._zlength = positive_length_measure(value)
			else:
				self._zlength = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY definitional_representation #
####################
class definitional_representation(representation):
	'''Entity definitional_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'  ==  TYPEOF(self.self.representation.self.context_of_items))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY information_right #
####################
class information_right(action_method):
	'''Entity information_right definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__consequence , inherited3__purpose ,  ):
		action_method.__init__(self , inherited0__name , inherited1__description , inherited2__consequence , inherited3__purpose , )

####################
 # ENTITY precision_qualifier #
####################
class precision_qualifier(BaseEntityClass):
	'''Entity precision_qualifier definition.

	:param precision_value
	:type precision_value:INTEGER
	'''
	def __init__( self , precision_value, ):
		self.precision_value = precision_value

	@apply
	def precision_value():
		def fget( self ):
			return self._precision_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument precision_value is mantatory and can not be set to None')
			if not check_type(value,INTEGER):
				self._precision_value = INTEGER(value)
			else:
				self._precision_value = value
		return property(**locals())

####################
 # ENTITY date_role #
####################
class date_role(BaseEntityClass):
	'''Entity date_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY fill_area_style_tile_curve_with_style #
####################
class fill_area_style_tile_curve_with_style(geometric_representation_item):
	'''Entity fill_area_style_tile_curve_with_style definition.

	:param styled_curve
	:type styled_curve:annotation_curve_occurrence
	'''
	def __init__( self , inherited0__name , styled_curve, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.styled_curve = styled_curve

	@apply
	def styled_curve():
		def fget( self ):
			return self._styled_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_curve is mantatory and can not be set to None')
			if not check_type(value,annotation_curve_occurrence):
				self._styled_curve = annotation_curve_occurrence(value)
			else:
				self._styled_curve = value
		return property(**locals())

####################
 # ENTITY dimension_callout_component_relationship #
####################
class dimension_callout_component_relationship(draughting_callout_relationship):
	'''Entity dimension_callout_component_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout ,  ):
		draughting_callout_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_draughting_callout , inherited3__related_draughting_callout , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['prefix','suffix'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.STRUCTURED_DIMENSION_CALLOUT'  ==  TYPEOF(self.self.relating_draughting_callout))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(TYPEOF(self.self.related_draughting_callout)  *  ['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LEADER_DIRECTED_CALLOUT','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PROJECTION_DIRECTED_CALLOUT','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.STRUCTURED_DIMENSION_CALLOUT'])  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((self.self.related_draughting_callout.self.contents  *  self.self.relating_draughting_callout.self.contents)  ==  self.self.related_draughting_callout.self.contents)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ((self.self.name  ==  'prefix')  and  (SIZEOF(None)  ==  0))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((self.self.name  ==  'suffix')  and  (SIZEOF(None)  ==  0))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY light_source_directional #
####################
class light_source_directional(light_source):
	'''Entity light_source_directional definition.

	:param orientation
	:type orientation:direction
	'''
	def __init__( self , inherited0__name , inherited1__light_colour , orientation, ):
		light_source.__init__(self , inherited0__name , inherited1__light_colour , )
		self.orientation = orientation

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._orientation = direction(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY product_definition_shape #
####################
class product_definition_shape(property_definition):
	'''Entity product_definition_shape definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition ,  ):
		property_definition.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CHARACTERIZED_OBJECT']  *  TYPEOF(self.self.property_definition.self.definition))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY attribute_value_role #
####################
class attribute_value_role(BaseEntityClass):
	'''Entity attribute_value_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY requirement_source #
####################
class requirement_source(group):
	'''Entity requirement_source definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY bezier_surface #
####################
class bezier_surface(b_spline_surface):
	'''Entity bezier_surface definition.
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect ,  ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )

####################
 # ENTITY csg_solid #
####################
class csg_solid(solid_model):
	'''Entity csg_solid definition.

	:param tree_root_expression
	:type tree_root_expression:csg_select
	'''
	def __init__( self , inherited0__name , tree_root_expression, ):
		solid_model.__init__(self , inherited0__name , )
		self.tree_root_expression = tree_root_expression

	@apply
	def tree_root_expression():
		def fget( self ):
			return self._tree_root_expression
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tree_root_expression is mantatory and can not be set to None')
			if not check_type(value,csg_select):
				self._tree_root_expression = csg_select(value)
			else:
				self._tree_root_expression = value
		return property(**locals())

####################
 # ENTITY parallel_offset #
####################
class parallel_offset(derived_shape_aspect):
	'''Entity parallel_offset definition.

	:param offset
	:type offset:measure_with_unit
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , offset, ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		self.offset = offset

	@apply
	def offset():
		def fget( self ):
			return self._offset
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument offset is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._offset = measure_with_unit(value)
			else:
				self._offset = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY indirectly_selected_shape_elements #
####################
class indirectly_selected_shape_elements(indirectly_selected_elements,user_selected_shape_elements):
	'''Entity indirectly_selected_shape_elements definition.
	'''
	def __init__( self , inherited0__name , inherited1__picked_items , inherited2__indirectly_picked_items , inherited3__name , inherited4__picked_items ,  ):
		indirectly_selected_elements.__init__(self , inherited0__name , inherited1__picked_items , inherited2__indirectly_picked_items , )
		user_selected_shape_elements.__init__(self , inherited3__name , inherited4__picked_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY camera_model_d3_with_hlhsr #
####################
class camera_model_d3_with_hlhsr(camera_model_d3):
	'''Entity camera_model_d3_with_hlhsr definition.

	:param hidden_line_surface_removal
	:type hidden_line_surface_removal:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__view_reference_system , inherited2__perspective_of_volume , hidden_line_surface_removal, ):
		camera_model_d3.__init__(self , inherited0__name , inherited1__view_reference_system , inherited2__perspective_of_volume , )
		self.hidden_line_surface_removal = hidden_line_surface_removal

	@apply
	def hidden_line_surface_removal():
		def fget( self ):
			return self._hidden_line_surface_removal
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hidden_line_surface_removal is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._hidden_line_surface_removal = BOOLEAN(value)
			else:
				self._hidden_line_surface_removal = value
		return property(**locals())

####################
 # ENTITY functional_element_usage #
####################
class functional_element_usage(breakdown_element_usage):
	'''Entity functional_element_usage definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		breakdown_element_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY person_and_organization_address #
####################
class person_and_organization_address(organizational_address,personal_address):
	'''Entity person_and_organization_address definition.

	:param organizational_address_organizations
	:type organizational_address_organizations:SET(1,1,'organization', scope = schema_scope)

	:param personal_address_people
	:type personal_address_people:SET(1,1,'person', scope = schema_scope)
	'''
	def __init__( self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , inherited12__organizations , inherited13__description , inherited14__internal_location , inherited15__street_number , inherited16__street , inherited17__postal_box , inherited18__town , inherited19__region , inherited20__postal_code , inherited21__country , inherited22__facsimile_number , inherited23__telephone_number , inherited24__electronic_mail_address , inherited25__telex_number , inherited26__people , inherited27__description , organizational_address_organizations,personal_address_people, ):
		organizational_address.__init__(self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , inherited12__organizations , inherited13__description , )
		personal_address.__init__(self , inherited14__internal_location , inherited15__street_number , inherited16__street , inherited17__postal_box , inherited18__town , inherited19__region , inherited20__postal_code , inherited21__country , inherited22__facsimile_number , inherited23__telephone_number , inherited24__electronic_mail_address , inherited25__telex_number , inherited26__people , inherited27__description , )
		self.organizational_address_organizations = organizational_address_organizations
		self.personal_address_people = personal_address_people

	@apply
	def organizational_address_organizations():
		def fget( self ):
			return self._organizational_address_organizations
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument organizational_address_organizations is mantatory and can not be set to None')
			if not check_type(value,SET(1,1,'organization', scope = schema_scope)):
				self._organizational_address_organizations = SET(value)
			else:
				self._organizational_address_organizations = value
		return property(**locals())

	@apply
	def personal_address_people():
		def fget( self ):
			return self._personal_address_people
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument personal_address_people is mantatory and can not be set to None')
			if not check_type(value,SET(1,1,'person', scope = schema_scope)):
				self._personal_address_people = SET(value)
			else:
				self._personal_address_people = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY start_work #
####################
class start_work(action_assignment):
	'''Entity start_work definition.

	:param items
	:type items:SET(1,None,'work_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action , items, ):
		action_assignment.__init__(self , inherited0__assigned_action , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'work_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY fill_area_style_colour #
####################
class fill_area_style_colour(BaseEntityClass):
	'''Entity fill_area_style_colour definition.

	:param name
	:type name:label

	:param fill_colour
	:type fill_colour:colour
	'''
	def __init__( self , name,fill_colour, ):
		self.name = name
		self.fill_colour = fill_colour

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def fill_colour():
		def fget( self ):
			return self._fill_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fill_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._fill_colour = colour(value)
			else:
				self._fill_colour = value
		return property(**locals())

####################
 # ENTITY product_material_composition_relationship #
####################
class product_material_composition_relationship(product_definition_relationship):
	'''Entity product_material_composition_relationship definition.

	:param class_
	:type class_:label

	:param constituent_amount
	:type constituent_amount:SET(1,None,'characterized_product_composition_value', scope = schema_scope)

	:param composition_basis
	:type composition_basis:label

	:param determination_method
	:type determination_method:text
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , class_,constituent_amount,composition_basis,determination_method, ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )
		self.class_ = class_
		self.constituent_amount = constituent_amount
		self.composition_basis = composition_basis
		self.determination_method = determination_method

	@apply
	def class_():
		def fget( self ):
			return self._class_
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument class_ is mantatory and can not be set to None')
			if not check_type(value,label):
				self._class_ = label(value)
			else:
				self._class_ = value
		return property(**locals())

	@apply
	def constituent_amount():
		def fget( self ):
			return self._constituent_amount
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constituent_amount is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'characterized_product_composition_value', scope = schema_scope)):
				self._constituent_amount = SET(value)
			else:
				self._constituent_amount = value
		return property(**locals())

	@apply
	def composition_basis():
		def fget( self ):
			return self._composition_basis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument composition_basis is mantatory and can not be set to None')
			if not check_type(value,label):
				self._composition_basis = label(value)
			else:
				self._composition_basis = value
		return property(**locals())

	@apply
	def determination_method():
		def fget( self ):
			return self._determination_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument determination_method is mantatory and can not be set to None')
			if not check_type(value,text):
				self._determination_method = text(value)
			else:
				self._determination_method = value
		return property(**locals())

####################
 # ENTITY rule_action #
####################
class rule_action(action):
	'''Entity rule_action definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method ,  ):
		action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )

####################
 # ENTITY surface_profile_tolerance #
####################
class surface_profile_tolerance(geometric_tolerance):
	'''Entity surface_profile_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))  or  (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY contract_type #
####################
class contract_type(BaseEntityClass):
	'''Entity contract_type definition.

	:param description
	:type description:label
	'''
	def __init__( self , description, ):
		self.description = description

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,label):
				self._description = label(value)
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY b_spline_curve_with_knots #
####################
class b_spline_curve_with_knots(b_spline_curve):
	'''Entity b_spline_curve_with_knots definition.

	:param knot_multiplicities
	:type knot_multiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param knots
	:type knots:LIST(2,None,'REAL', scope = schema_scope)

	:param knot_spec
	:type knot_spec:knot_type

	:param upper_index_on_knots
	:type upper_index_on_knots:INTEGER
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , knot_multiplicities,knots,knot_spec, ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )
		self.knot_multiplicities = knot_multiplicities
		self.knots = knots
		self.knot_spec = knot_spec

	@apply
	def knot_multiplicities():
		def fget( self ):
			return self._knot_multiplicities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knot_multiplicities is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
				self._knot_multiplicities = LIST(value)
			else:
				self._knot_multiplicities = value
		return property(**locals())

	@apply
	def knots():
		def fget( self ):
			return self._knots
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knots is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._knots = LIST(value)
			else:
				self._knots = value
		return property(**locals())

	@apply
	def knot_spec():
		def fget( self ):
			return self._knot_spec
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knot_spec is mantatory and can not be set to None')
			if not check_type(value,knot_type):
				self._knot_spec = knot_type(value)
			else:
				self._knot_spec = value
		return property(**locals())

	@apply
	def upper_index_on_knots():
		def fget( self ):
			attribute_eval = SIZEOF(self.knots)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument upper_index_on_knots is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = constraints_param_b_spline(self.degree,self.upper_index_on_knots,self.upper_index_on_control_points,self.knot_multiplicities,self.knots)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.knot_multiplicities)  ==  self.upper_index_on_knots)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY document_usage_role #
####################
class document_usage_role(BaseEntityClass):
	'''Entity document_usage_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY fill_area_style_hatching #
####################
class fill_area_style_hatching(geometric_representation_item):
	'''Entity fill_area_style_hatching definition.

	:param hatch_line_appearance
	:type hatch_line_appearance:curve_style

	:param start_of_next_hatch_line
	:type start_of_next_hatch_line:one_direction_repeat_factor

	:param point_of_reference_hatch_line
	:type point_of_reference_hatch_line:cartesian_point

	:param pattern_start
	:type pattern_start:cartesian_point

	:param hatch_line_angle
	:type hatch_line_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , hatch_line_appearance,start_of_next_hatch_line,point_of_reference_hatch_line,pattern_start,hatch_line_angle, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.hatch_line_appearance = hatch_line_appearance
		self.start_of_next_hatch_line = start_of_next_hatch_line
		self.point_of_reference_hatch_line = point_of_reference_hatch_line
		self.pattern_start = pattern_start
		self.hatch_line_angle = hatch_line_angle

	@apply
	def hatch_line_appearance():
		def fget( self ):
			return self._hatch_line_appearance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hatch_line_appearance is mantatory and can not be set to None')
			if not check_type(value,curve_style):
				self._hatch_line_appearance = curve_style(value)
			else:
				self._hatch_line_appearance = value
		return property(**locals())

	@apply
	def start_of_next_hatch_line():
		def fget( self ):
			return self._start_of_next_hatch_line
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument start_of_next_hatch_line is mantatory and can not be set to None')
			if not check_type(value,one_direction_repeat_factor):
				self._start_of_next_hatch_line = one_direction_repeat_factor(value)
			else:
				self._start_of_next_hatch_line = value
		return property(**locals())

	@apply
	def point_of_reference_hatch_line():
		def fget( self ):
			return self._point_of_reference_hatch_line
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument point_of_reference_hatch_line is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._point_of_reference_hatch_line = cartesian_point(value)
			else:
				self._point_of_reference_hatch_line = value
		return property(**locals())

	@apply
	def pattern_start():
		def fget( self ):
			return self._pattern_start
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument pattern_start is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._pattern_start = cartesian_point(value)
			else:
				self._pattern_start = value
		return property(**locals())

	@apply
	def hatch_line_angle():
		def fget( self ):
			return self._hatch_line_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hatch_line_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._hatch_line_angle = plane_angle_measure(value)
			else:
				self._hatch_line_angle = value
		return property(**locals())

####################
 # ENTITY tangent #
####################
class tangent(derived_shape_aspect):
	'''Entity tangent definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.derived_shape_aspect.self.deriving_relationships)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY cc_design_approval #
####################
class cc_design_approval(approval_assignment):
	'''Entity cc_design_approval definition.

	:param items
	:type items:SET(1,None,'approved_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_approval , items, ):
		approval_assignment.__init__(self , inherited0__assigned_approval , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'approved_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY conductance_measure_with_unit #
####################
class conductance_measure_with_unit(measure_with_unit):
	'''Entity conductance_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CONDUCTANCE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ruled_surface_swept_area_solid #
####################
class ruled_surface_swept_area_solid(surface_curve_swept_area_solid):
	'''Entity ruled_surface_swept_area_solid definition.
	'''
	def __init__( self , inherited0__name , inherited1__swept_area , inherited2__directrix , inherited3__start_param , inherited4__end_param , inherited5__reference_surface ,  ):
		surface_curve_swept_area_solid.__init__(self , inherited0__name , inherited1__swept_area , inherited2__directrix , inherited3__start_param , inherited4__end_param , inherited5__reference_surface , )
	def wr1(self):
		eval_wr1_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_SURFACE'  ==  TYPEOF(self.self.reference_surface))  and  (self.self.reference_surface.self.b_spline_surface.self.u_degree  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(self.self.directrix))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_CURVE'  ==  TYPEOF(self.self.directrix.self.surface_curve.self.curve_3d))  and  (self.self.directrix.self.surface_curve.self.curve_3d.self.b_spline_curve.self.degree  ==  self.self.reference_surface.self.b_spline_surface.self.v_degree)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY attribute_language_assignment #
####################
class attribute_language_assignment(attribute_classification_assignment):
	'''Entity attribute_language_assignment definition.

	:param items
	:type items:SET(1,None,'attribute_language_item', scope = schema_scope)

	:param attribute_classification_assignment_assigned_class
	:type attribute_classification_assignment_assigned_class:language
	'''
	def __init__( self , inherited0__assigned_class , inherited1__attribute_name , inherited2__role , items,attribute_classification_assignment_assigned_class, ):
		attribute_classification_assignment.__init__(self , inherited0__assigned_class , inherited1__attribute_name , inherited2__role , )
		self.items = items
		self.attribute_classification_assignment_assigned_class = attribute_classification_assignment_assigned_class

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'attribute_language_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def attribute_classification_assignment_assigned_class():
		def fget( self ):
			return self._attribute_classification_assignment_assigned_class
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument attribute_classification_assignment_assigned_class is mantatory and can not be set to None')
			if not check_type(value,language):
				self._attribute_classification_assignment_assigned_class = language(value)
			else:
				self._attribute_classification_assignment_assigned_class = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.attribute_classification_assignment.self.role.self.name  ==  ['primary','translated'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.attribute_classification_assignment.self.attribute_name  !=  '')
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY si_pressure_unit #
####################
class si_pressure_unit(pressure_unit,si_unit):
	'''Entity si_pressure_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		pressure_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.pascal)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY edge_based_wireframe_shape_representation #
####################
class edge_based_wireframe_shape_representation(shape_representation):
	'''Entity edge_based_wireframe_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  3)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr


####################
 # ENTITY derived_unit_element #
####################
class derived_unit_element(BaseEntityClass):
	'''Entity derived_unit_element definition.

	:param unit
	:type unit:named_unit

	:param exponent
	:type exponent:REAL
	'''
	def __init__( self , unit,exponent, ):
		self.unit = unit
		self.exponent = exponent

	@apply
	def unit():
		def fget( self ):
			return self._unit
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument unit is mantatory and can not be set to None')
			if not check_type(value,named_unit):
				self._unit = named_unit(value)
			else:
				self._unit = value
		return property(**locals())

	@apply
	def exponent():
		def fget( self ):
			return self._exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._exponent = REAL(value)
			else:
				self._exponent = value
		return property(**locals())

####################
 # ENTITY geometrically_bounded_wireframe_shape_representation #
####################
class geometrically_bounded_wireframe_shape_representation(shape_representation):
	'''Entity geometrically_bounded_wireframe_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY cc_design_contract #
####################
class cc_design_contract(contract_assignment):
	'''Entity cc_design_contract definition.

	:param items
	:type items:SET(1,None,'contracted_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_contract , items, ):
		contract_assignment.__init__(self , inherited0__assigned_contract , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'contracted_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY extent #
####################
class extent(characterized_object):
	'''Entity extent definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		characterized_object.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY extruded_face_solid_with_draft_angle #
####################
class extruded_face_solid_with_draft_angle(extruded_face_solid_with_trim_conditions):
	'''Entity extruded_face_solid_with_draft_angle definition.

	:param draft_angle
	:type draft_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , inherited1__swept_face , inherited2__extruded_direction , inherited3__depth , inherited4__first_trim_condition , inherited5__second_trim_condition , inherited6__first_trim_intent , inherited7__second_trim_intent , inherited8__first_offset , inherited9__second_offset , draft_angle, ):
		extruded_face_solid_with_trim_conditions.__init__(self , inherited0__name , inherited1__swept_face , inherited2__extruded_direction , inherited3__depth , inherited4__first_trim_condition , inherited5__second_trim_condition , inherited6__first_trim_intent , inherited7__second_trim_intent , inherited8__first_offset , inherited9__second_offset , )
		self.draft_angle = draft_angle

	@apply
	def draft_angle():
		def fget( self ):
			return self._draft_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument draft_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._draft_angle = plane_angle_measure(value)
			else:
				self._draft_angle = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.draft_angle  !=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY linear_dimension #
####################
class linear_dimension(dimension_curve_directed_callout):
	'''Entity linear_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		dimension_curve_directed_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY roundness_tolerance #
####################
class roundness_tolerance(geometric_tolerance):
	'''Entity roundness_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY seam_curve #
####################
class seam_curve(surface_curve):
	'''Entity seam_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation ,  ):
		surface_curve.__init__(self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.surface_curve.self.associated_geometry)  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (associated_surface(self.self.surface_curve.self.associated_geometry[1])  ==  associated_surface(self.self.surface_curve.self.associated_geometry[2]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(self.self.surface_curve.self.associated_geometry[1]))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(self.self.surface_curve.self.associated_geometry[2]))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY solid_with_groove #
####################
class solid_with_groove(solid_with_depression):
	'''Entity solid_with_groove definition.

	:param groove_radius
	:type groove_radius:positive_length_measure

	:param groove_width
	:type groove_width:positive_length_measure

	:param draft_angle
	:type draft_angle:plane_angle_measure

	:param floor_fillet_radius
	:type floor_fillet_radius:non_negative_length_measure

	:param external_groove
	:type external_groove:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , groove_radius,groove_width,draft_angle,floor_fillet_radius,external_groove, ):
		solid_with_depression.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , )
		self.groove_radius = groove_radius
		self.groove_width = groove_width
		self.draft_angle = draft_angle
		self.floor_fillet_radius = floor_fillet_radius
		self.external_groove = external_groove

	@apply
	def groove_radius():
		def fget( self ):
			return self._groove_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument groove_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._groove_radius = positive_length_measure(value)
			else:
				self._groove_radius = value
		return property(**locals())

	@apply
	def groove_width():
		def fget( self ):
			return self._groove_width
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument groove_width is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._groove_width = positive_length_measure(value)
			else:
				self._groove_width = value
		return property(**locals())

	@apply
	def draft_angle():
		def fget( self ):
			return self._draft_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument draft_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._draft_angle = plane_angle_measure(value)
			else:
				self._draft_angle = value
		return property(**locals())

	@apply
	def floor_fillet_radius():
		def fget( self ):
			return self._floor_fillet_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument floor_fillet_radius is mantatory and can not be set to None')
			if not check_type(value,non_negative_length_measure):
				self._floor_fillet_radius = non_negative_length_measure(value)
			else:
				self._floor_fillet_radius = value
		return property(**locals())

	@apply
	def external_groove():
		def fget( self ):
			return self._external_groove
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument external_groove is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._external_groove = BOOLEAN(value)
			else:
				self._external_groove = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION'  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY datum_target_callout #
####################
class datum_target_callout(draughting_callout):
	'''Entity datum_target_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY literal_conjunction #
####################
class literal_conjunction(simple_clause):
	'''Entity literal_conjunction definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		simple_clause.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY axis2_placement_3d #
####################
class axis2_placement_3d(placement):
	'''Entity axis2_placement_3d definition.

	:param axis
	:type axis:direction

	:param ref_direction
	:type ref_direction:direction

	:param p
	:type p:LIST(3,3,'direction', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__location , axis,ref_direction, ):
		placement.__init__(self , inherited0__name , inherited1__location , )
		self.axis = axis
		self.ref_direction = ref_direction

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._axis = direction(value)
				else:
					self._axis = value
			else:
				self._axis = value
		return property(**locals())

	@apply
	def ref_direction():
		def fget( self ):
			return self._ref_direction
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,direction):
					self._ref_direction = direction(value)
				else:
					self._ref_direction = value
			else:
				self._ref_direction = value
		return property(**locals())

	@apply
	def p():
		def fget( self ):
			attribute_eval = build_axes(self.axis,self.ref_direction)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.placement.self.location.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.axis))  or  (self.axis.self.dim  ==  3))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not EXISTS(self.ref_direction))  or  (self.ref_direction.self.dim  ==  3))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((( not EXISTS(self.axis))  or  ( not EXISTS(self.ref_direction)))  or  (cross_product(self.axis,self.ref_direction).self.magnitude  >  0))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY datum #
####################
class datum(shape_aspect):
	'''Entity datum definition.

	:param identification
	:type identification:identifier

	:param established_by_relationships
	:type established_by_relationships:SET(1,None,'shape_aspect_relationship', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , identification, ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		self.identification = identification

	@apply
	def identification():
		def fget( self ):
			return self._identification
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument identification is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._identification = identifier(value)
			else:
				self._identification = value
		return property(**locals())

	@apply
	def established_by_relationships():
		def fget( self ):
			return self._established_by_relationships
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument established_by_relationships is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMMON_DATUM'  ==  TYPEOF(self)) XOR (SIZEOF(None)  ==  1) XOR (SIZEOF(None)  >=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY integer_representation_item #
####################
class integer_representation_item(representation_item,int_literal):
	'''Entity integer_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__the_value , inherited2__literal_number_the_value ,  ):
		representation_item.__init__(self , inherited0__name , )
		int_literal.__init__(self , inherited1__the_value , inherited2__literal_number_the_value , )

####################
 # ENTITY rational_b_spline_surface #
####################
class rational_b_spline_surface(b_spline_surface):
	'''Entity rational_b_spline_surface definition.

	:param weights_data
	:type weights_data:LIST(2,None,LIST(2,None,'REAL', scope = schema_scope))

	:param weights
	:type weights:ARRAY(0,u_upper,ARRAY(0,v_upper,'REAL', scope = schema_scope))
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , weights_data, ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )
		self.weights_data = weights_data

	@apply
	def weights_data():
		def fget( self ):
			return self._weights_data
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument weights_data is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,LIST(2,None,'REAL', scope = schema_scope))):
				self._weights_data = LIST(value)
			else:
				self._weights_data = value
		return property(**locals())

	@apply
	def weights():
		def fget( self ):
			attribute_eval = make_array_of_array(self.weights_data,0,self.u_upper,0,self.v_upper)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument weights is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.weights_data)  ==  SIZEOF(self.self.b_spline_surface.self.control_points_list))  and  (SIZEOF(self.weights_data[1])  ==  SIZEOF(self.self.b_spline_surface.self.control_points_list[1])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = surface_weights_positive(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY configuration_design #
####################
class configuration_design(BaseEntityClass):
	'''Entity configuration_design definition.

	:param configuration
	:type configuration:configuration_item

	:param design
	:type design:configuration_design_item

	:param description
	:type description:text

	:param name
	:type name:label
	'''
	def __init__( self , configuration,design, ):
		self.configuration = configuration
		self.design = design

	@apply
	def configuration():
		def fget( self ):
			return self._configuration
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument configuration is mantatory and can not be set to None')
			if not check_type(value,configuration_item):
				self._configuration = configuration_item(value)
			else:
				self._configuration = value
		return property(**locals())

	@apply
	def design():
		def fget( self ):
			return self._design
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument design is mantatory and can not be set to None')
			if not check_type(value,configuration_design_item):
				self._design = configuration_design_item(value)
			else:
				self._design = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY design_context #
####################
class design_context(product_definition_context):
	'''Entity design_context definition.
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , inherited2__life_cycle_stage ,  ):
		product_definition_context.__init__(self , inherited0__name , inherited1__frame_of_reference , inherited2__life_cycle_stage , )
	def wr1(self):
		eval_wr1_wr = (self.self.life_cycle_stage  ==  'design')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY drawing_sheet_revision #
####################
class drawing_sheet_revision(presentation_area):
	'''Entity drawing_sheet_revision definition.

	:param revision_identifier
	:type revision_identifier:identifier
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , revision_identifier, ):
		presentation_area.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , )
		self.revision_identifier = revision_identifier

	@apply
	def revision_identifier():
		def fget( self ):
			return self._revision_identifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument revision_identifier is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._revision_identifier = identifier(value)
			else:
				self._revision_identifier = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition_with_associated_documents #
####################
class product_definition_with_associated_documents(product_definition):
	'''Entity product_definition_with_associated_documents definition.

	:param documentation_ids
	:type documentation_ids:SET(1,None,'document', scope = schema_scope)
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , documentation_ids, ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )
		self.documentation_ids = documentation_ids

	@apply
	def documentation_ids():
		def fget( self ):
			return self._documentation_ids
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument documentation_ids is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'document', scope = schema_scope)):
				self._documentation_ids = SET(value)
			else:
				self._documentation_ids = value
		return property(**locals())

####################
 # ENTITY torus #
####################
class torus(geometric_representation_item):
	'''Entity torus definition.

	:param position
	:type position:axis1_placement

	:param major_radius
	:type major_radius:positive_length_measure

	:param minor_radius
	:type minor_radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , position,major_radius,minor_radius, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.position = position
		self.major_radius = major_radius
		self.minor_radius = minor_radius

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._position = axis1_placement(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def major_radius():
		def fget( self ):
			return self._major_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument major_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._major_radius = positive_length_measure(value)
			else:
				self._major_radius = value
		return property(**locals())

	@apply
	def minor_radius():
		def fget( self ):
			return self._minor_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument minor_radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._minor_radius = positive_length_measure(value)
			else:
				self._minor_radius = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.major_radius  >  self.minor_radius)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_concept_relationship #
####################
class product_concept_relationship(BaseEntityClass):
	'''Entity product_concept_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_product_concept
	:type relating_product_concept:product_concept

	:param related_product_concept
	:type related_product_concept:product_concept
	'''
	def __init__( self , name,description,relating_product_concept,related_product_concept, ):
		self.name = name
		self.description = description
		self.relating_product_concept = relating_product_concept
		self.related_product_concept = related_product_concept

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_product_concept():
		def fget( self ):
			return self._relating_product_concept
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_product_concept is mantatory and can not be set to None')
			if not check_type(value,product_concept):
				self._relating_product_concept = product_concept(value)
			else:
				self._relating_product_concept = value
		return property(**locals())

	@apply
	def related_product_concept():
		def fget( self ):
			return self._related_product_concept
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_product_concept is mantatory and can not be set to None')
			if not check_type(value,product_concept):
				self._related_product_concept = product_concept(value)
			else:
				self._related_product_concept = value
		return property(**locals())

####################
 # ENTITY annotation_text_occurrence #
####################
class annotation_text_occurrence(annotation_occurrence):
	'''Entity annotation_text_occurrence definition.

	:param styled_item_item
	:type styled_item_item:annotation_text_occurrence_item
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , styled_item_item, ):
		annotation_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , )
		self.styled_item_item = styled_item_item

	@apply
	def styled_item_item():
		def fget( self ):
			return self._styled_item_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styled_item_item is mantatory and can not be set to None')
			if not check_type(value,annotation_text_occurrence_item):
				self._styled_item_item = annotation_text_occurrence_item(value)
			else:
				self._styled_item_item = value
		return property(**locals())

####################
 # ENTITY common_datum #
####################
class common_datum(composite_shape_aspect,datum):
	'''Entity common_datum definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , inherited4__name , inherited5__description , inherited6__of_shape , inherited7__product_definitional , inherited8__identification ,  ):
		composite_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
		datum.__init__(self , inherited4__name , inherited5__description , inherited6__of_shape , inherited7__product_definitional , inherited8__identification , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.composite_shape_aspect.self.component_relationships)  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY dimension_curve #
####################
class dimension_curve(annotation_curve_occurrence):
	'''Entity dimension_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item ,  ):
		annotation_curve_occurrence.__init__(self , inherited0__name , inherited1__styles , inherited2__item , inherited3__styled_item_item , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <=  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  <=  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY luminous_intensity_unit #
####################
class luminous_intensity_unit(named_unit):
	'''Entity luminous_intensity_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY multiple_arity_boolean_expression #
####################
class multiple_arity_boolean_expression(boolean_expression,multiple_arity_generic_expression):
	'''Entity multiple_arity_boolean_expression definition.

	:param multiple_arity_generic_expression_operands
	:type multiple_arity_generic_expression_operands:LIST(2,None,'boolean_expression', scope = schema_scope)
	'''
	def __init__( self , inherited0__operands , multiple_arity_generic_expression_operands, ):
		boolean_expression.__init__(self , )
		multiple_arity_generic_expression.__init__(self , inherited0__operands , )
		self.multiple_arity_generic_expression_operands = multiple_arity_generic_expression_operands

	@apply
	def multiple_arity_generic_expression_operands():
		def fget( self ):
			return self._multiple_arity_generic_expression_operands
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument multiple_arity_generic_expression_operands is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'boolean_expression', scope = schema_scope)):
				self._multiple_arity_generic_expression_operands = LIST(value)
			else:
				self._multiple_arity_generic_expression_operands = value
		return property(**locals())

####################
 # ENTITY inductance_measure_with_unit #
####################
class inductance_measure_with_unit(measure_with_unit):
	'''Entity inductance_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.INDUCTANCE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY organization #
####################
class organization(BaseEntityClass):
	'''Entity organization definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id,name,description, ):
		self.id = id
		self.name = name
		self.description = description

	@apply
	def id():
		def fget( self ):
			return self._id
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,identifier):
					self._id = identifier(value)
				else:
					self._id = value
			else:
				self._id = value
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY dimension_callout #
####################
class dimension_callout(draughting_callout):
	'''Entity dimension_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LEADER_DIRECTED_CALLOUT'  ==  TYPEOF(self)) XOR (SIZEOF(None)  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PROJECTION_DIRECTED_CALLOUT'  ==  TYPEOF(self)) XOR (SIZEOF(None)  ==  0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT'  ==  TYPEOF(self)) XOR (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY multi_language_attribute_assignment #
####################
class multi_language_attribute_assignment(attribute_value_assignment):
	'''Entity multi_language_attribute_assignment definition.

	:param items
	:type items:SET(1,None,'multi_language_attribute_item', scope = schema_scope)

	:param translation_language
	:type translation_language:language

	:param language_indication
	:type language_indication:SET(1,1,'attribute_language_assignment', scope = schema_scope)
	'''
	def __init__( self , inherited0__attribute_name , inherited1__attribute_value , inherited2__role , items, ):
		attribute_value_assignment.__init__(self , inherited0__attribute_name , inherited1__attribute_value , inherited2__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'multi_language_attribute_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def translation_language():
		def fget( self ):
			attribute_eval = self.language_indication[1].self.attribute_classification_assignment.self.assigned_class
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument translation_language is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def language_indication():
		def fget( self ):
			return self._language_indication
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument language_indication is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.attribute_value_assignment.self.role.self.name  ==  'alternate language')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.attribute_value_assignment.self.attribute_name  !=  '')
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY rep_item_group #
####################
class rep_item_group(group,representation_item):
	'''Entity rep_item_group definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__name ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )
		representation_item.__init__(self , inherited2__name , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PRESENTATION_LAYER_ASSIGNMENT.')  +  'ASSIGNED_ITEMS'))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'GEOMETRIC_REPRESENTATION_ITEM','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'TOPOLOGICAL_REPRESENTATION_ITEM','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'MAPPED_ITEM','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'STYLED_ITEM']  *  TYPEOF(self))  ==  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY power_measure_with_unit #
####################
class power_measure_with_unit(measure_with_unit):
	'''Entity power_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POWER_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY colour_rgb #
####################
class colour_rgb(colour_specification):
	'''Entity colour_rgb definition.

	:param red
	:type red:REAL

	:param green
	:type green:REAL

	:param blue
	:type blue:REAL
	'''
	def __init__( self , inherited0__name , red,green,blue, ):
		colour_specification.__init__(self , inherited0__name , )
		self.red = red
		self.green = green
		self.blue = blue

	@apply
	def red():
		def fget( self ):
			return self._red
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument red is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._red = REAL(value)
			else:
				self._red = value
		return property(**locals())

	@apply
	def green():
		def fget( self ):
			return self._green
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument green is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._green = REAL(value)
			else:
				self._green = value
		return property(**locals())

	@apply
	def blue():
		def fget( self ):
			return self._blue
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument blue is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._blue = REAL(value)
			else:
				self._blue = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((0  <=  self.red)  and  (self.red  <=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((0  <=  self.green)  and  (self.green  <=  1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((0  <=  self.blue)  and  (self.blue  <=  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY referenced_modified_datum #
####################
class referenced_modified_datum(datum_reference):
	'''Entity referenced_modified_datum definition.

	:param modifier
	:type modifier:limit_condition
	'''
	def __init__( self , inherited0__precedence , inherited1__referenced_datum , modifier, ):
		datum_reference.__init__(self , inherited0__precedence , inherited1__referenced_datum , )
		self.modifier = modifier

	@apply
	def modifier():
		def fget( self ):
			return self._modifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument modifier is mantatory and can not be set to None')
			if not check_type(value,limit_condition):
				self._modifier = limit_condition(value)
			else:
				self._modifier = value
		return property(**locals())

####################
 # ENTITY cc_design_certification #
####################
class cc_design_certification(certification_assignment):
	'''Entity cc_design_certification definition.

	:param items
	:type items:SET(1,None,'certified_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_certification , items, ):
		certification_assignment.__init__(self , inherited0__assigned_certification , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'certified_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY mechanical_design_presentation_representation_with_draughting #
####################
class mechanical_design_presentation_representation_with_draughting(representation):
	'''Entity mechanical_design_presentation_representation_with_draughting definition.

	:param representation_items
	:type representation_items:SET(1,None,'camera_model_d3', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , representation_items, ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
		self.representation_items = representation_items

	@apply
	def representation_items():
		def fget( self ):
			return self._representation_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'camera_model_d3', scope = schema_scope)):
				self._representation_items = SET(value)
			else:
				self._representation_items = value
		return property(**locals())

####################
 # ENTITY b_spline_surface_with_knots #
####################
class b_spline_surface_with_knots(b_spline_surface):
	'''Entity b_spline_surface_with_knots definition.

	:param u_multiplicities
	:type u_multiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param v_multiplicities
	:type v_multiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param u_knots
	:type u_knots:LIST(2,None,'REAL', scope = schema_scope)

	:param v_knots
	:type v_knots:LIST(2,None,'REAL', scope = schema_scope)

	:param knot_spec
	:type knot_spec:knot_type

	:param knot_u_upper
	:type knot_u_upper:INTEGER

	:param knot_v_upper
	:type knot_v_upper:INTEGER
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , u_multiplicities,v_multiplicities,u_knots,v_knots,knot_spec, ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )
		self.u_multiplicities = u_multiplicities
		self.v_multiplicities = v_multiplicities
		self.u_knots = u_knots
		self.v_knots = v_knots
		self.knot_spec = knot_spec

	@apply
	def u_multiplicities():
		def fget( self ):
			return self._u_multiplicities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_multiplicities is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
				self._u_multiplicities = LIST(value)
			else:
				self._u_multiplicities = value
		return property(**locals())

	@apply
	def v_multiplicities():
		def fget( self ):
			return self._v_multiplicities
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_multiplicities is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
				self._v_multiplicities = LIST(value)
			else:
				self._v_multiplicities = value
		return property(**locals())

	@apply
	def u_knots():
		def fget( self ):
			return self._u_knots
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_knots is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._u_knots = LIST(value)
			else:
				self._u_knots = value
		return property(**locals())

	@apply
	def v_knots():
		def fget( self ):
			return self._v_knots
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_knots is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._v_knots = LIST(value)
			else:
				self._v_knots = value
		return property(**locals())

	@apply
	def knot_spec():
		def fget( self ):
			return self._knot_spec
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument knot_spec is mantatory and can not be set to None')
			if not check_type(value,knot_type):
				self._knot_spec = knot_type(value)
			else:
				self._knot_spec = value
		return property(**locals())

	@apply
	def knot_u_upper():
		def fget( self ):
			attribute_eval = SIZEOF(self.u_knots)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument knot_u_upper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def knot_v_upper():
		def fget( self ):
			attribute_eval = SIZEOF(self.v_knots)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument knot_v_upper is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = constraints_param_b_spline(self.self.b_spline_surface.self.u_degree,self.knot_u_upper,self.self.b_spline_surface.self.u_upper,self.u_multiplicities,self.u_knots)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = constraints_param_b_spline(self.self.b_spline_surface.self.v_degree,self.knot_v_upper,self.self.b_spline_surface.self.v_upper,self.v_multiplicities,self.v_knots)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(self.u_multiplicities)  ==  self.knot_u_upper)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(self.v_multiplicities)  ==  self.knot_v_upper)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY evaluation_product_definition #
####################
class evaluation_product_definition(product_definition):
	'''Entity evaluation_product_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY class_usage_effectivity_context_assignment #
####################
class class_usage_effectivity_context_assignment(effectivity_context_assignment):
	'''Entity class_usage_effectivity_context_assignment definition.

	:param items
	:type items:SET(1,None,'class_usage_effectivity_context_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_effectivity_assignment , inherited1__role , items, ):
		effectivity_context_assignment.__init__(self , inherited0__assigned_effectivity_assignment , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'class_usage_effectivity_context_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.role.self.name  ==  'class usage influence')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT'  ==  TYPEOF(self.self.assigned_effectivity_assignment))  and  (SIZEOF(TYPEOF(self.self.assigned_effectivity_assignment.self.assigned_effectivity))  ==  1))  and  (self.self.assigned_effectivity_assignment.self.assigned_effectivity.self.id  ==  'class usage'))  and  (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY pre_defined_surface_side_style #
####################
class pre_defined_surface_side_style(pre_defined_item):
	'''Entity pre_defined_surface_side_style definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )

####################
 # ENTITY velocity_measure_with_unit #
####################
class velocity_measure_with_unit(measure_with_unit):
	'''Entity velocity_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VELOCITY_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ratio_measure_with_unit #
####################
class ratio_measure_with_unit(measure_with_unit):
	'''Entity ratio_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RATIO_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY dielectric_constant_measure_with_unit #
####################
class dielectric_constant_measure_with_unit(ratio_measure_with_unit):
	'''Entity dielectric_constant_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		ratio_measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )

####################
 # ENTITY effectivity_context_role #
####################
class effectivity_context_role(BaseEntityClass):
	'''Entity effectivity_context_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY included_text_block #
####################
class included_text_block(mapped_item):
	'''Entity included_text_block definition.
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target ,  ):
		mapped_item.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.STRUCTURED_TEXT_REPRESENTATION'  ==  TYPEOF(self.self.mapped_item.self.mapping_source.self.mapped_representation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY modified_geometric_tolerance #
####################
class modified_geometric_tolerance(geometric_tolerance):
	'''Entity modified_geometric_tolerance definition.

	:param modifier
	:type modifier:limit_condition
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , modifier, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , )
		self.modifier = modifier

	@apply
	def modifier():
		def fget( self ):
			return self._modifier
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument modifier is mantatory and can not be set to None')
			if not check_type(value,limit_condition):
				self._modifier = limit_condition(value)
			else:
				self._modifier = value
		return property(**locals())

####################
 # ENTITY certification_type #
####################
class certification_type(BaseEntityClass):
	'''Entity certification_type definition.

	:param description
	:type description:label
	'''
	def __init__( self , description, ):
		self.description = description

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,label):
				self._description = label(value)
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY currency_measure_with_unit #
####################
class currency_measure_with_unit(measure_with_unit):
	'''Entity currency_measure_with_unit definition.

	:param measure_with_unit_unit_component
	:type measure_with_unit_unit_component:currency
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component , measure_with_unit_unit_component, ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
		self.measure_with_unit_unit_component = measure_with_unit_unit_component

	@apply
	def measure_with_unit_unit_component():
		def fget( self ):
			return self._measure_with_unit_unit_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument measure_with_unit_unit_component is mantatory and can not be set to None')
			if not check_type(value,currency):
				self._measure_with_unit_unit_component = currency(value)
			else:
				self._measure_with_unit_unit_component = value
		return property(**locals())

####################
 # ENTITY draughting_elements #
####################
class draughting_elements(draughting_callout):
	'''Entity draughting_elements definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT'  ==  TYPEOF(self)))  or  (SIZEOF(None)  <=  2))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  <=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  <=  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY information_usage_right #
####################
class information_usage_right(action_method):
	'''Entity information_usage_right definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__consequence , inherited3__purpose ,  ):
		action_method.__init__(self , inherited0__name , inherited1__description , inherited2__consequence , inherited3__purpose , )

####################
 # ENTITY ply_laminate_definition #
####################
class ply_laminate_definition(product_definition):
	'''Entity ply_laminate_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY oriented_path #
####################
class oriented_path(path):
	'''Entity oriented_path definition.

	:param path_element
	:type path_element:path

	:param orientation
	:type orientation:BOOLEAN

	:param path_edge_list
	:type path_edge_list:LIST(1,None,'oriented_edge', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__edge_list , path_element,orientation, ):
		path.__init__(self , inherited0__name , inherited1__edge_list , )
		self.path_element = path_element
		self.orientation = orientation

	@apply
	def path_element():
		def fget( self ):
			return self._path_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument path_element is mantatory and can not be set to None')
			if not check_type(value,path):
				self._path_element = path(value)
			else:
				self._path_element = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def path_edge_list():
		def fget( self ):
			attribute_eval = conditional_reverse(self.self.orientation,self.self.path_element.self.edge_list)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument path_edge_list is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORIENTED_PATH'  ==  TYPEOF(self.self.path_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY absorbed_dose_measure_with_unit #
####################
class absorbed_dose_measure_with_unit(measure_with_unit):
	'''Entity absorbed_dose_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ABSORBED_DOSE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY face_based_surface_model #
####################
class face_based_surface_model(geometric_representation_item):
	'''Entity face_based_surface_model definition.

	:param fbsm_faces
	:type fbsm_faces:SET(1,None,'connected_face_set', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , fbsm_faces, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.fbsm_faces = fbsm_faces

	@apply
	def fbsm_faces():
		def fget( self ):
			return self._fbsm_faces
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fbsm_faces is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'connected_face_set', scope = schema_scope)):
				self._fbsm_faces = SET(value)
			else:
				self._fbsm_faces = value
		return property(**locals())

####################
 # ENTITY measure_qualification #
####################
class measure_qualification(BaseEntityClass):
	'''Entity measure_qualification definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param qualified_measure
	:type qualified_measure:measure_with_unit

	:param qualifiers
	:type qualifiers:SET(1,None,'value_qualifier', scope = schema_scope)
	'''
	def __init__( self , name,description,qualified_measure,qualifiers, ):
		self.name = name
		self.description = description
		self.qualified_measure = qualified_measure
		self.qualifiers = qualifiers

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def qualified_measure():
		def fget( self ):
			return self._qualified_measure
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument qualified_measure is mantatory and can not be set to None')
			if not check_type(value,measure_with_unit):
				self._qualified_measure = measure_with_unit(value)
			else:
				self._qualified_measure = value
		return property(**locals())

	@apply
	def qualifiers():
		def fget( self ):
			return self._qualifiers
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument qualifiers is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'value_qualifier', scope = schema_scope)):
				self._qualifiers = SET(value)
			else:
				self._qualifiers = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  <  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.REPRESENTATION_ITEM'  ==  TYPEOF(self.self.measure_qualification.self.qualified_measure)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY mechanical_design_and_draughting_relationship #
####################
class mechanical_design_and_draughting_relationship(definitional_representation_relationship_with_same_context):
	'''Entity mechanical_design_and_draughting_relationship definition.

	:param representation_relationship_rep_1
	:type representation_relationship_rep_1:mechanical_design_and_draughting_relationship_select

	:param representation_relationship_rep_2
	:type representation_relationship_rep_2:mechanical_design_and_draughting_relationship_select
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , representation_relationship_rep_1,representation_relationship_rep_2, ):
		definitional_representation_relationship_with_same_context.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
		self.representation_relationship_rep_1 = representation_relationship_rep_1
		self.representation_relationship_rep_2 = representation_relationship_rep_2

	@apply
	def representation_relationship_rep_1():
		def fget( self ):
			return self._representation_relationship_rep_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_rep_1 is mantatory and can not be set to None')
			if not check_type(value,mechanical_design_and_draughting_relationship_select):
				self._representation_relationship_rep_1 = mechanical_design_and_draughting_relationship_select(value)
			else:
				self._representation_relationship_rep_1 = value
		return property(**locals())

	@apply
	def representation_relationship_rep_2():
		def fget( self ):
			return self._representation_relationship_rep_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_rep_2 is mantatory and can not be set to None')
			if not check_type(value,mechanical_design_and_draughting_relationship_select):
				self._representation_relationship_rep_2 = mechanical_design_and_draughting_relationship_select(value)
			else:
				self._representation_relationship_rep_2 = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DRAUGHTING_MODEL')  ==  TYPEOF(self.rep_2)))  or  ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DRAUGHTING_MODEL')  ==  TYPEOF(self.rep_1))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'SHAPE_REPRESENTATION')  ==  TYPEOF(self.rep_1))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION')  ==  TYPEOF(self.rep_2)))  or  ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION')  ==  TYPEOF(self.rep_1))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'SHAPE_REPRESENTATION')  ==  TYPEOF(self.rep_1))))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION')  ==  TYPEOF(self.rep_2)))  or  ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION')  ==  TYPEOF(self.rep_1))  or  (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'SHAPE_REPRESENTATION')  ==  TYPEOF(self.rep_1))))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY row_variable #
####################
class row_variable(abstract_variable):
	'''Entity row_variable definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition , inherited3__definition , inherited4__used_representation , inherited5__name , inherited6__items , inherited7__context_of_items , inherited8__name ,  ):
		abstract_variable.__init__(self , inherited0__name , inherited1__description , inherited2__definition , inherited3__definition , inherited4__used_representation , inherited5__name , inherited6__items , inherited7__context_of_items , inherited8__name , )

####################
 # ENTITY security_classification #
####################
class security_classification(BaseEntityClass):
	'''Entity security_classification definition.

	:param name
	:type name:label

	:param purpose
	:type purpose:text

	:param security_level
	:type security_level:security_classification_level
	'''
	def __init__( self , name,purpose,security_level, ):
		self.name = name
		self.purpose = purpose
		self.security_level = security_level

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def purpose():
		def fget( self ):
			return self._purpose
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument purpose is mantatory and can not be set to None')
			if not check_type(value,text):
				self._purpose = text(value)
			else:
				self._purpose = value
		return property(**locals())

	@apply
	def security_level():
		def fget( self ):
			return self._security_level
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument security_level is mantatory and can not be set to None')
			if not check_type(value,security_classification_level):
				self._security_level = security_classification_level(value)
			else:
				self._security_level = value
		return property(**locals())

####################
 # ENTITY vertex_loop #
####################
class vertex_loop(loop):
	'''Entity vertex_loop definition.

	:param loop_vertex
	:type loop_vertex:vertex
	'''
	def __init__( self , inherited0__name , loop_vertex, ):
		loop.__init__(self , inherited0__name , )
		self.loop_vertex = loop_vertex

	@apply
	def loop_vertex():
		def fget( self ):
			return self._loop_vertex
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument loop_vertex is mantatory and can not be set to None')
			if not check_type(value,vertex):
				self._loop_vertex = vertex(value)
			else:
				self._loop_vertex = value
		return property(**locals())

####################
 # ENTITY runout_zone_definition #
####################
class runout_zone_definition(tolerance_zone_definition):
	'''Entity runout_zone_definition definition.

	:param orientation
	:type orientation:runout_zone_orientation
	'''
	def __init__( self , inherited0__zone , inherited1__boundaries , orientation, ):
		tolerance_zone_definition.__init__(self , inherited0__zone , inherited1__boundaries , )
		self.orientation = orientation

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,runout_zone_orientation):
				self._orientation = runout_zone_orientation(value)
			else:
				self._orientation = value
		return property(**locals())

####################
 # ENTITY applied_effectivity_assignment #
####################
class applied_effectivity_assignment(effectivity_assignment):
	'''Entity applied_effectivity_assignment definition.

	:param items
	:type items:SET(1,None,'effectivity_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_effectivity , items, ):
		effectivity_assignment.__init__(self , inherited0__assigned_effectivity , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'effectivity_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY composite_assembly_table #
####################
class composite_assembly_table(part_laminate_table):
	'''Entity composite_assembly_table definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		part_laminate_table.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY approval_status #
####################
class approval_status(BaseEntityClass):
	'''Entity approval_status definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY cartesian_point #
####################
class cartesian_point(point):
	'''Entity cartesian_point definition.

	:param coordinates
	:type coordinates:LIST(1,3,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , coordinates, ):
		point.__init__(self , inherited0__name , )
		self.coordinates = coordinates

	@apply
	def coordinates():
		def fget( self ):
			return self._coordinates
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument coordinates is mantatory and can not be set to None')
			if not check_type(value,LIST(1,3,'REAL', scope = schema_scope)):
				self._coordinates = LIST(value)
			else:
				self._coordinates = value
		return property(**locals())

####################
 # ENTITY curve_style_rendering #
####################
class curve_style_rendering(BaseEntityClass):
	'''Entity curve_style_rendering definition.

	:param rendering_method
	:type rendering_method:shading_curve_method

	:param rendering_properties
	:type rendering_properties:surface_rendering_properties
	'''
	def __init__( self , rendering_method,rendering_properties, ):
		self.rendering_method = rendering_method
		self.rendering_properties = rendering_properties

	@apply
	def rendering_method():
		def fget( self ):
			return self._rendering_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rendering_method is mantatory and can not be set to None')
			if not check_type(value,shading_curve_method):
				self._rendering_method = shading_curve_method(value)
			else:
				self._rendering_method = value
		return property(**locals())

	@apply
	def rendering_properties():
		def fget( self ):
			return self._rendering_properties
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rendering_properties is mantatory and can not be set to None')
			if not check_type(value,surface_rendering_properties):
				self._rendering_properties = surface_rendering_properties(value)
			else:
				self._rendering_properties = value
		return property(**locals())

####################
 # ENTITY composite_text_with_associated_curves #
####################
class composite_text_with_associated_curves(composite_text):
	'''Entity composite_text_with_associated_curves definition.

	:param associated_curves
	:type associated_curves:SET(1,None,'curve', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__collected_text , associated_curves, ):
		composite_text.__init__(self , inherited0__name , inherited1__collected_text , )
		self.associated_curves = associated_curves

	@apply
	def associated_curves():
		def fget( self ):
			return self._associated_curves
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument associated_curves is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'curve', scope = schema_scope)):
				self._associated_curves = SET(value)
			else:
				self._associated_curves = value
		return property(**locals())

####################
 # ENTITY compound_shape_representation #
####################
class compound_shape_representation(shape_representation):
	'''Entity compound_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'GEOMETRIC_REPRESENTATION_CONTEXT')  ==  TYPEOF(self.self.context_of_items))  and  (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  >  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY fill_area_style_tiles #
####################
class fill_area_style_tiles(geometric_representation_item):
	'''Entity fill_area_style_tiles definition.

	:param tiling_pattern
	:type tiling_pattern:two_direction_repeat_factor

	:param tiles
	:type tiles:SET(1,None,'fill_area_style_tile_shape_select', scope = schema_scope)

	:param tiling_scale
	:type tiling_scale:positive_ratio_measure
	'''
	def __init__( self , inherited0__name , tiling_pattern,tiles,tiling_scale, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.tiling_pattern = tiling_pattern
		self.tiles = tiles
		self.tiling_scale = tiling_scale

	@apply
	def tiling_pattern():
		def fget( self ):
			return self._tiling_pattern
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tiling_pattern is mantatory and can not be set to None')
			if not check_type(value,two_direction_repeat_factor):
				self._tiling_pattern = two_direction_repeat_factor(value)
			else:
				self._tiling_pattern = value
		return property(**locals())

	@apply
	def tiles():
		def fget( self ):
			return self._tiles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tiles is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'fill_area_style_tile_shape_select', scope = schema_scope)):
				self._tiles = SET(value)
			else:
				self._tiles = value
		return property(**locals())

	@apply
	def tiling_scale():
		def fget( self ):
			return self._tiling_scale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument tiling_scale is mantatory and can not be set to None')
			if not check_type(value,positive_ratio_measure):
				self._tiling_scale = positive_ratio_measure(value)
			else:
				self._tiling_scale = value
		return property(**locals())

####################
 # ENTITY laid_defined_transformation #
####################
class laid_defined_transformation(transformation_with_derived_angle):
	'''Entity laid_defined_transformation definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__item_defined_transformation_transform_item_1 , inherited5__item_defined_transformation_transform_item_2 ,  ):
		transformation_with_derived_angle.__init__(self , inherited0__name , inherited1__description , inherited2__transform_item_1 , inherited3__transform_item_2 , inherited4__item_defined_transformation_transform_item_1 , inherited5__item_defined_transformation_transform_item_2 , )

####################
 # ENTITY structured_text_composition #
####################
class structured_text_composition(compound_representation_item):
	'''Entity structured_text_composition definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		compound_representation_item.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY drawing_sheet_revision_usage #
####################
class drawing_sheet_revision_usage(area_in_set):
	'''Entity drawing_sheet_revision_usage definition.

	:param sheet_number
	:type sheet_number:identifier
	'''
	def __init__( self , inherited0__area , inherited1__in_set , sheet_number, ):
		area_in_set.__init__(self , inherited0__area , inherited1__in_set , )
		self.sheet_number = sheet_number

	@apply
	def sheet_number():
		def fget( self ):
			return self._sheet_number
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sheet_number is mantatory and can not be set to None')
			if not check_type(value,identifier):
				self._sheet_number = identifier(value)
			else:
				self._sheet_number = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DRAWING_SHEET_REVISION'  ==  TYPEOF(self.self.area_in_set.self.area))  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DRAWING_REVISION'  ==  TYPEOF(self.self.area_in_set.self.in_set)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY magnetic_flux_density_measure_with_unit #
####################
class magnetic_flux_density_measure_with_unit(measure_with_unit):
	'''Entity magnetic_flux_density_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MAGNETIC_FLUX_DENSITY_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY parametric_representation_context #
####################
class parametric_representation_context(representation_context):
	'''Entity parametric_representation_context definition.
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type ,  ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )

####################
 # ENTITY limits_and_fits #
####################
class limits_and_fits(BaseEntityClass):
	'''Entity limits_and_fits definition.

	:param form_variance
	:type form_variance:label

	:param zone_variance
	:type zone_variance:label

	:param grade
	:type grade:label

	:param source
	:type source:text
	'''
	def __init__( self , form_variance,zone_variance,grade,source, ):
		self.form_variance = form_variance
		self.zone_variance = zone_variance
		self.grade = grade
		self.source = source

	@apply
	def form_variance():
		def fget( self ):
			return self._form_variance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument form_variance is mantatory and can not be set to None')
			if not check_type(value,label):
				self._form_variance = label(value)
			else:
				self._form_variance = value
		return property(**locals())

	@apply
	def zone_variance():
		def fget( self ):
			return self._zone_variance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zone_variance is mantatory and can not be set to None')
			if not check_type(value,label):
				self._zone_variance = label(value)
			else:
				self._zone_variance = value
		return property(**locals())

	@apply
	def grade():
		def fget( self ):
			return self._grade
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument grade is mantatory and can not be set to None')
			if not check_type(value,label):
				self._grade = label(value)
			else:
				self._grade = value
		return property(**locals())

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source is mantatory and can not be set to None')
			if not check_type(value,text):
				self._source = text(value)
			else:
				self._source = value
		return property(**locals())

####################
 # ENTITY product_concept_context #
####################
class product_concept_context(application_context_element):
	'''Entity product_concept_context definition.

	:param market_segment_type
	:type market_segment_type:label
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , market_segment_type, ):
		application_context_element.__init__(self , inherited0__name , inherited1__frame_of_reference , )
		self.market_segment_type = market_segment_type

	@apply
	def market_segment_type():
		def fget( self ):
			return self._market_segment_type
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument market_segment_type is mantatory and can not be set to None')
			if not check_type(value,label):
				self._market_segment_type = label(value)
			else:
				self._market_segment_type = value
		return property(**locals())

####################
 # ENTITY text_literal_with_extent #
####################
class text_literal_with_extent(text_literal):
	'''Entity text_literal_with_extent definition.

	:param extent
	:type extent:planar_extent
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , extent, ):
		text_literal.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , )
		self.extent = extent

	@apply
	def extent():
		def fget( self ):
			return self._extent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument extent is mantatory and can not be set to None')
			if not check_type(value,planar_extent):
				self._extent = planar_extent(value)
			else:
				self._extent = value
		return property(**locals())

####################
 # ENTITY cartesian_transformation_operator_2d #
####################
class cartesian_transformation_operator_2d(cartesian_transformation_operator):
	'''Entity cartesian_transformation_operator_2d definition.

	:param u
	:type u:LIST(2,2,'direction', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__description , inherited3__axis1 , inherited4__axis2 , inherited5__local_origin , inherited6__scale ,  ):
		cartesian_transformation_operator.__init__(self , inherited0__name , inherited1__name , inherited2__description , inherited3__axis1 , inherited4__axis2 , inherited5__local_origin , inherited6__scale , )

	@apply
	def u():
		def fget( self ):
			attribute_eval = base_axis(2,self.self.cartesian_transformation_operator.self.axis1,self.self.cartesian_transformation_operator.self.axis2, None )
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument u is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY conductance_unit #
####################
class conductance_unit(derived_unit):
	'''Entity conductance_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensions_for_si_unit(si_unit_name.self.siemens))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY energy_measure_with_unit #
####################
class energy_measure_with_unit(measure_with_unit):
	'''Entity energy_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ENERGY_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY global_assignment #
####################
class global_assignment(representation_item_relationship):
	'''Entity global_assignment definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_representation_item , inherited3__related_representation_item ,  ):
		representation_item_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_representation_item , inherited3__related_representation_item , )

####################
 # ENTITY rule_superseded_assignment #
####################
class rule_superseded_assignment(action_assignment):
	'''Entity rule_superseded_assignment definition.

	:param items
	:type items:SET(1,None,'rule_superseded_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action , items, ):
		action_assignment.__init__(self , inherited0__assigned_action , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'rule_superseded_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY illuminance_measure_with_unit #
####################
class illuminance_measure_with_unit(measure_with_unit):
	'''Entity illuminance_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ILLUMINANCE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_patch #
####################
class surface_patch(founded_item):
	'''Entity surface_patch definition.

	:param parent_surface
	:type parent_surface:bounded_surface

	:param u_transition
	:type u_transition:transition_code

	:param v_transition
	:type v_transition:transition_code

	:param u_sense
	:type u_sense:BOOLEAN

	:param v_sense
	:type v_sense:BOOLEAN

	:param using_surfaces
	:type using_surfaces:BAG(1,None,'rectangular_composite_surface', scope = schema_scope)
	'''
	def __init__( self , parent_surface,u_transition,v_transition,u_sense,v_sense, ):
		founded_item.__init__(self , )
		self.parent_surface = parent_surface
		self.u_transition = u_transition
		self.v_transition = v_transition
		self.u_sense = u_sense
		self.v_sense = v_sense

	@apply
	def parent_surface():
		def fget( self ):
			return self._parent_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_surface is mantatory and can not be set to None')
			if not check_type(value,bounded_surface):
				self._parent_surface = bounded_surface(value)
			else:
				self._parent_surface = value
		return property(**locals())

	@apply
	def u_transition():
		def fget( self ):
			return self._u_transition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_transition is mantatory and can not be set to None')
			if not check_type(value,transition_code):
				self._u_transition = transition_code(value)
			else:
				self._u_transition = value
		return property(**locals())

	@apply
	def v_transition():
		def fget( self ):
			return self._v_transition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_transition is mantatory and can not be set to None')
			if not check_type(value,transition_code):
				self._v_transition = transition_code(value)
			else:
				self._v_transition = value
		return property(**locals())

	@apply
	def u_sense():
		def fget( self ):
			return self._u_sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument u_sense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._u_sense = BOOLEAN(value)
			else:
				self._u_sense = value
		return property(**locals())

	@apply
	def v_sense():
		def fget( self ):
			return self._v_sense
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument v_sense is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._v_sense = BOOLEAN(value)
			else:
				self._v_sense = value
		return property(**locals())

	@apply
	def using_surfaces():
		def fget( self ):
			return self._using_surfaces
		def fset( self, value ):
		# INVERSE argument
			raise AssertionError('Argument using_surfaces is INVERSE. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_BOUNDED_SURFACE'  ==  TYPEOF(self.parent_surface)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY security_classification_assignment #
####################
class security_classification_assignment(BaseEntityClass):
	'''Entity security_classification_assignment definition.

	:param assigned_security_classification
	:type assigned_security_classification:security_classification

	:param role
	:type role:object_role
	'''
	def __init__( self , assigned_security_classification, ):
		self.assigned_security_classification = assigned_security_classification

	@apply
	def assigned_security_classification():
		def fget( self ):
			return self._assigned_security_classification
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument assigned_security_classification is mantatory and can not be set to None')
			if not check_type(value,security_classification):
				self._assigned_security_classification = security_classification(value)
			else:
				self._assigned_security_classification = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			attribute_eval = get_role(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument role is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY applied_security_classification_assignment #
####################
class applied_security_classification_assignment(security_classification_assignment):
	'''Entity applied_security_classification_assignment definition.

	:param items
	:type items:SET(1,None,'security_classification_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_security_classification , items, ):
		security_classification_assignment.__init__(self , inherited0__assigned_security_classification , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'security_classification_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY product_definition_occurrence_relationship #
####################
class product_definition_occurrence_relationship(BaseEntityClass):
	'''Entity product_definition_occurrence_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param occurrence
	:type occurrence:product_definition

	:param occurrence_usage
	:type occurrence_usage:assembly_component_usage
	'''
	def __init__( self , name,description,occurrence,occurrence_usage, ):
		self.name = name
		self.description = description
		self.occurrence = occurrence
		self.occurrence_usage = occurrence_usage

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def occurrence():
		def fget( self ):
			return self._occurrence
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument occurrence is mantatory and can not be set to None')
			if not check_type(value,product_definition):
				self._occurrence = product_definition(value)
			else:
				self._occurrence = value
		return property(**locals())

	@apply
	def occurrence_usage():
		def fget( self ):
			return self._occurrence_usage
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument occurrence_usage is mantatory and can not be set to None')
			if not check_type(value,assembly_component_usage):
				self._occurrence_usage = assembly_component_usage(value)
			else:
				self._occurrence_usage = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.occurrence_usage.self.relating_product_definition  !=  self.occurrence)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.occurrence_usage.self.related_product_definition  !=  self.occurrence)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.occurrence.self.formation  ==  self.occurrence_usage.self.related_product_definition.self.formation)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY requirement_view_definition_relationship #
####################
class requirement_view_definition_relationship(product_definition_relationship):
	'''Entity requirement_view_definition_relationship definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY concentricity_tolerance #
####################
class concentricity_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity concentricity_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY length_unit #
####################
class length_unit(named_unit):
	'''Entity length_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  1)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY volume_measure_with_unit #
####################
class volume_measure_with_unit(measure_with_unit):
	'''Entity volume_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VOLUME_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY dimension_related_tolerance_zone_element #
####################
class dimension_related_tolerance_zone_element(BaseEntityClass):
	'''Entity dimension_related_tolerance_zone_element definition.

	:param related_dimension
	:type related_dimension:dimensional_location

	:param related_element
	:type related_element:tolerance_zone_definition
	'''
	def __init__( self , related_dimension,related_element, ):
		self.related_dimension = related_dimension
		self.related_element = related_element

	@apply
	def related_dimension():
		def fget( self ):
			return self._related_dimension
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_dimension is mantatory and can not be set to None')
			if not check_type(value,dimensional_location):
				self._related_dimension = dimensional_location(value)
			else:
				self._related_dimension = value
		return property(**locals())

	@apply
	def related_element():
		def fget( self ):
			return self._related_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_element is mantatory and can not be set to None')
			if not check_type(value,tolerance_zone_definition):
				self._related_element = tolerance_zone_definition(value)
			else:
				self._related_element = value
		return property(**locals())

####################
 # ENTITY electric_potential_measure_with_unit #
####################
class electric_potential_measure_with_unit(measure_with_unit):
	'''Entity electric_potential_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELECTRIC_POTENTIAL_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY externally_defined_class #
####################
class externally_defined_class(class_,externally_defined_item):
	'''Entity externally_defined_class definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__item_id , inherited3__source ,  ):
		class.__init__(self , inherited0__name , inherited1__description , )
		externally_defined_item.__init__(self , inherited2__item_id , inherited3__source , )

####################
 # ENTITY ply_laminate_sequence_definition #
####################
class ply_laminate_sequence_definition(product_definition):
	'''Entity ply_laminate_sequence_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY magnetic_flux_measure_with_unit #
####################
class magnetic_flux_measure_with_unit(measure_with_unit):
	'''Entity magnetic_flux_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MAGNETIC_FLUX_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_absorbed_dose_unit #
####################
class si_absorbed_dose_unit(absorbed_dose_unit,si_unit):
	'''Entity si_absorbed_dose_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		absorbed_dose_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.gray)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY surface_style_control_grid #
####################
class surface_style_control_grid(founded_item):
	'''Entity surface_style_control_grid definition.

	:param style_of_control_grid
	:type style_of_control_grid:curve_or_render
	'''
	def __init__( self , style_of_control_grid, ):
		founded_item.__init__(self , )
		self.style_of_control_grid = style_of_control_grid

	@apply
	def style_of_control_grid():
		def fget( self ):
			return self._style_of_control_grid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_control_grid is mantatory and can not be set to None')
			if not check_type(value,curve_or_render):
				self._style_of_control_grid = curve_or_render(value)
			else:
				self._style_of_control_grid = value
		return property(**locals())

####################
 # ENTITY advanced_face #
####################
class advanced_face(face_surface):
	'''Entity advanced_face definition.
	'''
	def __init__( self , inherited0__name , inherited1__bounds , inherited2__name , inherited3__face_geometry , inherited4__same_sense ,  ):
		face_surface.__init__(self , inherited0__name , inherited1__bounds , inherited2__name , inherited3__face_geometry , inherited4__same_sense , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELEMENTARY_SURFACE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_SURFACE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SWEPT_SURFACE']  *  TYPEOF(self.face_geometry))  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SWEPT_SURFACE'  ==  TYPEOF(self.face_geometry)))  or  (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CONIC','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_CURVE']  *  TYPEOF(self.face_geometry.self.swept_surface.self.swept_curve))  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = ((( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SWEPT_SURFACE'  ==  TYPEOF(self.face_geometry)))  or  (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE'  ==  TYPEOF(self.face_geometry.self.swept_surface.self.swept_curve)))  or  (SIZEOF(self.face_geometry.self.swept_surface.self.swept_curve.self.polyline.self.points)  >=  3)))  and  (SIZEOF(None)  ==  0))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr


####################
 # ENTITY measure_representation_item #
####################
class measure_representation_item(representation_item,measure_with_unit):
	'''Entity measure_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__value_component , inherited2__unit_component ,  ):
		representation_item.__init__(self , inherited0__name , )
		measure_with_unit.__init__(self , inherited1__value_component , inherited2__unit_component , )

####################
 # ENTITY usage_association #
####################
class usage_association(action_method_relationship):
	'''Entity usage_association definition.

	:param action_method_relationship_related_method
	:type action_method_relationship_related_method:information_usage_right

	:param action_method_relationship_relating_method
	:type action_method_relationship_relating_method:information_usage_right

	:param related
	:type related:information_usage_right

	:param relating
	:type relating:information_usage_right
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_method , inherited3__related_method , action_method_relationship_related_method,action_method_relationship_relating_method, ):
		action_method_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_method , inherited3__related_method , )
		self.action_method_relationship_related_method = action_method_relationship_related_method
		self.action_method_relationship_relating_method = action_method_relationship_relating_method

	@apply
	def action_method_relationship_related_method():
		def fget( self ):
			return self._action_method_relationship_related_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument action_method_relationship_related_method is mantatory and can not be set to None')
			if not check_type(value,information_usage_right):
				self._action_method_relationship_related_method = information_usage_right(value)
			else:
				self._action_method_relationship_related_method = value
		return property(**locals())

	@apply
	def action_method_relationship_relating_method():
		def fget( self ):
			return self._action_method_relationship_relating_method
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument action_method_relationship_relating_method is mantatory and can not be set to None')
			if not check_type(value,information_usage_right):
				self._action_method_relationship_relating_method = information_usage_right(value)
			else:
				self._action_method_relationship_relating_method = value
		return property(**locals())

	@apply
	def related():
		def fget( self ):
			attribute_eval = self.self.action_method_relationship.self.related_method
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument related is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def relating():
		def fget( self ):
			attribute_eval = self.self.action_method_relationship.self.relating_method
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument relating is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY year_month #
####################
class year_month(date):
	'''Entity year_month definition.

	:param month_component
	:type month_component:month_in_year_number
	'''
	def __init__( self , inherited0__year_component , month_component, ):
		date.__init__(self , inherited0__year_component , )
		self.month_component = month_component

	@apply
	def month_component():
		def fget( self ):
			return self._month_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument month_component is mantatory and can not be set to None')
			if not check_type(value,month_in_year_number):
				self._month_component = month_in_year_number(value)
			else:
				self._month_component = value
		return property(**locals())

####################
 # ENTITY document_identifier #
####################
class document_identifier(group):
	'''Entity document_identifier definition.
	'''
	def __init__( self , inherited0__name , inherited1__description ,  ):
		group.__init__(self , inherited0__name , inherited1__description , )

####################
 # ENTITY object_role #
####################
class object_role(BaseEntityClass):
	'''Entity object_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY right_circular_cone #
####################
class right_circular_cone(geometric_representation_item):
	'''Entity right_circular_cone definition.

	:param position
	:type position:axis1_placement

	:param height
	:type height:positive_length_measure

	:param radius
	:type radius:length_measure

	:param semi_angle
	:type semi_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , position,height,radius,semi_angle, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.position = position
		self.height = height
		self.radius = radius
		self.semi_angle = semi_angle

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis1_placement):
				self._position = axis1_placement(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def height():
		def fget( self ):
			return self._height
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument height is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._height = positive_length_measure(value)
			else:
				self._height = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._radius = length_measure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def semi_angle():
		def fget( self ):
			return self._semi_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._semi_angle = plane_angle_measure(value)
			else:
				self._semi_angle = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.radius  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY security_classification_level #
####################
class security_classification_level(BaseEntityClass):
	'''Entity security_classification_level definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self.name = name

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

####################
 # ENTITY symbol_target #
####################
class symbol_target(geometric_representation_item):
	'''Entity symbol_target definition.

	:param placement
	:type placement:axis2_placement

	:param x_scale
	:type x_scale:positive_ratio_measure

	:param y_scale
	:type y_scale:positive_ratio_measure
	'''
	def __init__( self , inherited0__name , placement,x_scale,y_scale, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.placement = placement
		self.x_scale = x_scale
		self.y_scale = y_scale

	@apply
	def placement():
		def fget( self ):
			return self._placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument placement is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._placement = axis2_placement(value)
			else:
				self._placement = value
		return property(**locals())

	@apply
	def x_scale():
		def fget( self ):
			return self._x_scale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument x_scale is mantatory and can not be set to None')
			if not check_type(value,positive_ratio_measure):
				self._x_scale = positive_ratio_measure(value)
			else:
				self._x_scale = value
		return property(**locals())

	@apply
	def y_scale():
		def fget( self ):
			return self._y_scale
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument y_scale is mantatory and can not be set to None')
			if not check_type(value,positive_ratio_measure):
				self._y_scale = positive_ratio_measure(value)
			else:
				self._y_scale = value
		return property(**locals())

####################
 # ENTITY thermodynamic_temperature_measure_with_unit #
####################
class thermodynamic_temperature_measure_with_unit(measure_with_unit):
	'''Entity thermodynamic_temperature_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY approval_relationship #
####################
class approval_relationship(BaseEntityClass):
	'''Entity approval_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_approval
	:type relating_approval:approval

	:param related_approval
	:type related_approval:approval
	'''
	def __init__( self , name,description,relating_approval,related_approval, ):
		self.name = name
		self.description = description
		self.relating_approval = relating_approval
		self.related_approval = related_approval

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

	@apply
	def relating_approval():
		def fget( self ):
			return self._relating_approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument relating_approval is mantatory and can not be set to None')
			if not check_type(value,approval):
				self._relating_approval = approval(value)
			else:
				self._relating_approval = value
		return property(**locals())

	@apply
	def related_approval():
		def fget( self ):
			return self._related_approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument related_approval is mantatory and can not be set to None')
			if not check_type(value,approval):
				self._related_approval = approval(value)
			else:
				self._related_approval = value
		return property(**locals())

####################
 # ENTITY pre_defined_tile #
####################
class pre_defined_tile(pre_defined_item):
	'''Entity pre_defined_tile definition.
	'''
	def __init__( self , inherited0__name ,  ):
		pre_defined_item.__init__(self , inherited0__name , )

####################
 # ENTITY moments_of_inertia_representation #
####################
class moments_of_inertia_representation(representation):
	'''Entity moments_of_inertia_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.self.items)  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY polyline #
####################
class polyline(bounded_curve):
	'''Entity polyline definition.

	:param points
	:type points:LIST(2,None,'cartesian_point', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , points, ):
		bounded_curve.__init__(self , inherited0__name , )
		self.points = points

	@apply
	def points():
		def fget( self ):
			return self._points
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument points is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'cartesian_point', scope = schema_scope)):
				self._points = LIST(value)
			else:
				self._points = value
		return property(**locals())

####################
 # ENTITY resistance_measure_with_unit #
####################
class resistance_measure_with_unit(measure_with_unit):
	'''Entity resistance_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RESISTANCE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY approval_person_organization #
####################
class approval_person_organization(BaseEntityClass):
	'''Entity approval_person_organization definition.

	:param person_organization
	:type person_organization:person_organization_select

	:param authorized_approval
	:type authorized_approval:approval

	:param role
	:type role:approval_role
	'''
	def __init__( self , person_organization,authorized_approval,role, ):
		self.person_organization = person_organization
		self.authorized_approval = authorized_approval
		self.role = role

	@apply
	def person_organization():
		def fget( self ):
			return self._person_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument person_organization is mantatory and can not be set to None')
			if not check_type(value,person_organization_select):
				self._person_organization = person_organization_select(value)
			else:
				self._person_organization = value
		return property(**locals())

	@apply
	def authorized_approval():
		def fget( self ):
			return self._authorized_approval
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument authorized_approval is mantatory and can not be set to None')
			if not check_type(value,approval):
				self._authorized_approval = approval(value)
			else:
				self._authorized_approval = value
		return property(**locals())

	@apply
	def role():
		def fget( self ):
			return self._role
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument role is mantatory and can not be set to None')
			if not check_type(value,approval_role):
				self._role = approval_role(value)
			else:
				self._role = value
		return property(**locals())

####################
 # ENTITY document_representation_type #
####################
class document_representation_type(BaseEntityClass):
	'''Entity document_representation_type definition.

	:param name
	:type name:label

	:param represented_document
	:type represented_document:document
	'''
	def __init__( self , name,represented_document, ):
		self.name = name
		self.represented_document = represented_document

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def represented_document():
		def fget( self ):
			return self._represented_document
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument represented_document is mantatory and can not be set to None')
			if not check_type(value,document):
				self._represented_document = document(value)
			else:
				self._represented_document = value
		return property(**locals())

####################
 # ENTITY surface_style_silhouette #
####################
class surface_style_silhouette(founded_item):
	'''Entity surface_style_silhouette definition.

	:param style_of_silhouette
	:type style_of_silhouette:curve_or_render
	'''
	def __init__( self , style_of_silhouette, ):
		founded_item.__init__(self , )
		self.style_of_silhouette = style_of_silhouette

	@apply
	def style_of_silhouette():
		def fget( self ):
			return self._style_of_silhouette
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_silhouette is mantatory and can not be set to None')
			if not check_type(value,curve_or_render):
				self._style_of_silhouette = curve_or_render(value)
			else:
				self._style_of_silhouette = value
		return property(**locals())

####################
 # ENTITY structured_dimension_callout #
####################
class structured_dimension_callout(draughting_callout):
	'''Entity structured_dimension_callout definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		draughting_callout.__init__(self , inherited0__name , inherited1__contents , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(TYPEOF(self)  *  ['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DATUM_FEATURE_CALLOUT','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DATUM_TARGET_CALLOUT','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.GEOMETRICAL_TOLERANCE_CALLOUT','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LEADER_DIRECTED_CALLOUT','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PROJECTION_DIRECTED_CALLOUT','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT'])  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  >=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  <=  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  <=  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (( not (SIZEOF(None)  >  0))  or  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (( not (SIZEOF(None)  >  0))  or  (SIZEOF(None)  ==  1))
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY time_interval_based_effectivity #
####################
class time_interval_based_effectivity(effectivity):
	'''Entity time_interval_based_effectivity definition.

	:param effectivity_period
	:type effectivity_period:time_interval
	'''
	def __init__( self , inherited0__id , effectivity_period, ):
		effectivity.__init__(self , inherited0__id , )
		self.effectivity_period = effectivity_period

	@apply
	def effectivity_period():
		def fget( self ):
			return self._effectivity_period
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument effectivity_period is mantatory and can not be set to None')
			if not check_type(value,time_interval):
				self._effectivity_period = time_interval(value)
			else:
				self._effectivity_period = value
		return property(**locals())

####################
 # ENTITY velocity_unit #
####################
class velocity_unit(derived_unit):
	'''Entity velocity_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensional_exponents(1,0,-1,0,0,0,0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY dimensional_size_with_path #
####################
class dimensional_size_with_path(dimensional_size):
	'''Entity dimensional_size_with_path definition.

	:param path
	:type path:shape_aspect
	'''
	def __init__( self , inherited0__applies_to , inherited1__name , path, ):
		dimensional_size.__init__(self , inherited0__applies_to , inherited1__name , )
		self.path = path

	@apply
	def path():
		def fget( self ):
			return self._path
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument path is mantatory and can not be set to None')
			if not check_type(value,shape_aspect):
				self._path = shape_aspect(value)
			else:
				self._path = value
		return property(**locals())

####################
 # ENTITY two_direction_repeat_factor #
####################
class two_direction_repeat_factor(one_direction_repeat_factor):
	'''Entity two_direction_repeat_factor definition.

	:param second_repeat_factor
	:type second_repeat_factor:vector
	'''
	def __init__( self , inherited0__name , inherited1__repeat_factor , second_repeat_factor, ):
		one_direction_repeat_factor.__init__(self , inherited0__name , inherited1__repeat_factor , )
		self.second_repeat_factor = second_repeat_factor

	@apply
	def second_repeat_factor():
		def fget( self ):
			return self._second_repeat_factor
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument second_repeat_factor is mantatory and can not be set to None')
			if not check_type(value,vector):
				self._second_repeat_factor = vector(value)
			else:
				self._second_repeat_factor = value
		return property(**locals())

####################
 # ENTITY solid_with_general_pocket #
####################
class solid_with_general_pocket(solid_with_pocket):
	'''Entity solid_with_general_pocket definition.

	:param profile
	:type profile:positioned_sketch

	:param reference_point
	:type reference_point:point
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__floor_blend_radius , inherited6__draft_angle , profile,reference_point, ):
		solid_with_pocket.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__floor_blend_radius , inherited6__draft_angle , )
		self.profile = profile
		self.reference_point = reference_point

	@apply
	def profile():
		def fget( self ):
			return self._profile
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument profile is mantatory and can not be set to None')
			if not check_type(value,positioned_sketch):
				self._profile = positioned_sketch(value)
			else:
				self._profile = value
		return property(**locals())

	@apply
	def reference_point():
		def fget( self ):
			return self._reference_point
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reference_point is mantatory and can not be set to None')
			if not check_type(value,point):
				self._reference_point = point(value)
			else:
				self._reference_point = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_BOUNDED_SURFACE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.FACE_SURFACE']  *  TYPEOF(self.profile.self.sketch_basis))  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.profile  ==  using_items(self.reference_point,[]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY invisibility #
####################
class invisibility(BaseEntityClass):
	'''Entity invisibility definition.

	:param invisible_items
	:type invisible_items:SET(1,None,'invisible_item', scope = schema_scope)
	'''
	def __init__( self , invisible_items, ):
		self.invisible_items = invisible_items

	@apply
	def invisible_items():
		def fget( self ):
			return self._invisible_items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument invisible_items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'invisible_item', scope = schema_scope)):
				self._invisible_items = SET(value)
			else:
				self._invisible_items = value
		return property(**locals())

####################
 # ENTITY percentage_laminate_definition #
####################
class percentage_laminate_definition(product_definition):
	'''Entity percentage_laminate_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY predefined_picture_representation_item #
####################
class predefined_picture_representation_item(picture_representation_item):
	'''Entity predefined_picture_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__binary_value ,  ):
		picture_representation_item.__init__(self , inherited0__name , inherited1__binary_value , )
	def wr1(self):
		eval_wr1_wr = (self.self.representation_item.self.name  ==  self.pre_defined_picture_representation_types)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_replica #
####################
class surface_replica(surface):
	'''Entity surface_replica definition.

	:param parent_surface
	:type parent_surface:surface

	:param transformation
	:type transformation:cartesian_transformation_operator_3d
	'''
	def __init__( self , inherited0__name , parent_surface,transformation, ):
		surface.__init__(self , inherited0__name , )
		self.parent_surface = parent_surface
		self.transformation = transformation

	@apply
	def parent_surface():
		def fget( self ):
			return self._parent_surface
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_surface is mantatory and can not be set to None')
			if not check_type(value,surface):
				self._parent_surface = surface(value)
			else:
				self._parent_surface = value
		return property(**locals())

	@apply
	def transformation():
		def fget( self ):
			return self._transformation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transformation is mantatory and can not be set to None')
			if not check_type(value,cartesian_transformation_operator_3d):
				self._transformation = cartesian_transformation_operator_3d(value)
			else:
				self._transformation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = acyclic_surface_replica(self,self.parent_surface)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY text_style_with_mirror #
####################
class text_style_with_mirror(text_style):
	'''Entity text_style_with_mirror definition.

	:param mirror_placement
	:type mirror_placement:axis2_placement
	'''
	def __init__( self , inherited0__name , inherited1__character_appearance , mirror_placement, ):
		text_style.__init__(self , inherited0__name , inherited1__character_appearance , )
		self.mirror_placement = mirror_placement

	@apply
	def mirror_placement():
		def fget( self ):
			return self._mirror_placement
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mirror_placement is mantatory and can not be set to None')
			if not check_type(value,axis2_placement):
				self._mirror_placement = axis2_placement(value)
			else:
				self._mirror_placement = value
		return property(**locals())

####################
 # ENTITY context_dependent_invisibility #
####################
class context_dependent_invisibility(invisibility):
	'''Entity context_dependent_invisibility definition.

	:param presentation_context
	:type presentation_context:invisibility_context
	'''
	def __init__( self , inherited0__invisible_items , presentation_context, ):
		invisibility.__init__(self , inherited0__invisible_items , )
		self.presentation_context = presentation_context

	@apply
	def presentation_context():
		def fget( self ):
			return self._presentation_context
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument presentation_context is mantatory and can not be set to None')
			if not check_type(value,invisibility_context):
				self._presentation_context = invisibility_context(value)
			else:
				self._presentation_context = value
		return property(**locals())

####################
 # ENTITY solid_with_general_protrusion #
####################
class solid_with_general_protrusion(solid_with_protrusion):
	'''Entity solid_with_general_protrusion definition.

	:param profile
	:type profile:positioned_sketch

	:param reference_point
	:type reference_point:point
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__protrusion_height , inherited5__protrusion_draft_angle , profile,reference_point, ):
		solid_with_protrusion.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__protrusion_height , inherited5__protrusion_draft_angle , )
		self.profile = profile
		self.reference_point = reference_point

	@apply
	def profile():
		def fget( self ):
			return self._profile
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument profile is mantatory and can not be set to None')
			if not check_type(value,positioned_sketch):
				self._profile = positioned_sketch(value)
			else:
				self._profile = value
		return property(**locals())

	@apply
	def reference_point():
		def fget( self ):
			return self._reference_point
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument reference_point is mantatory and can not be set to None')
			if not check_type(value,point):
				self._reference_point = point(value)
			else:
				self._reference_point = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_BOUNDED_SURFACE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.FACE_SURFACE']  *  TYPEOF(self.profile.self.sketch_basis))  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.profile  ==  using_items(self.reference_point,[]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY cc_design_security_classification #
####################
class cc_design_security_classification(security_classification_assignment):
	'''Entity cc_design_security_classification definition.

	:param items
	:type items:SET(1,None,'cc_classified_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_security_classification , items, ):
		security_classification_assignment.__init__(self , inherited0__assigned_security_classification , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'cc_classified_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY faceted_brep_shape_representation #
####################
class faceted_brep_shape_representation(shape_representation):
	'''Entity faceted_brep_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY solid_with_variable_radius_edge_blend #
####################
class solid_with_variable_radius_edge_blend(edge_blended_solid,track_blended_solid):
	'''Entity solid_with_variable_radius_edge_blend definition.

	:param point_list
	:type point_list:LIST(2,None,'point', scope = schema_scope)

	:param radius_list
	:type radius_list:LIST(2,None,'REAL', scope = schema_scope)

	:param edge_function_list
	:type edge_function_list:LIST(1,None,'blend_radius_variation_type', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , inherited4__name , inherited5__rationale , inherited6__base_solid , inherited7__blended_edges , point_list,radius_list,edge_function_list, ):
		edge_blended_solid.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , )
		track_blended_solid.__init__(self , inherited4__name , inherited5__rationale , inherited6__base_solid , inherited7__blended_edges , )
		self.point_list = point_list
		self.radius_list = radius_list
		self.edge_function_list = edge_function_list

	@apply
	def point_list():
		def fget( self ):
			return self._point_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument point_list is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'point', scope = schema_scope)):
				self._point_list = LIST(value)
			else:
				self._point_list = value
		return property(**locals())

	@apply
	def radius_list():
		def fget( self ):
			return self._radius_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius_list is mantatory and can not be set to None')
			if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
				self._radius_list = LIST(value)
			else:
				self._radius_list = value
		return property(**locals())

	@apply
	def edge_function_list():
		def fget( self ):
			return self._edge_function_list
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument edge_function_list is mantatory and can not be set to None')
			if not check_type(value,LIST(1,None,'blend_radius_variation_type', scope = schema_scope)):
				self._edge_function_list = LIST(value)
			else:
				self._edge_function_list = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.point_list)  ==  SIZEOF(self.radius_list))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.edge_function_list)  ==  (SIZEOF(self.radius_list) - 1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ( not ((self.point_list[1]  ==  self.point_list[HIINDEX(self.point_list)])  and  ( not (self.radius_list[1]  ==  self.radius_list[HIINDEX(self.radius_list)]))))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY document_usage_constraint #
####################
class document_usage_constraint(BaseEntityClass):
	'''Entity document_usage_constraint definition.

	:param source
	:type source:document

	:param subject_element
	:type subject_element:label

	:param subject_element_value
	:type subject_element_value:text
	'''
	def __init__( self , source,subject_element,subject_element_value, ):
		self.source = source
		self.subject_element = subject_element
		self.subject_element_value = subject_element_value

	@apply
	def source():
		def fget( self ):
			return self._source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument source is mantatory and can not be set to None')
			if not check_type(value,document):
				self._source = document(value)
			else:
				self._source = value
		return property(**locals())

	@apply
	def subject_element():
		def fget( self ):
			return self._subject_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument subject_element is mantatory and can not be set to None')
			if not check_type(value,label):
				self._subject_element = label(value)
			else:
				self._subject_element = value
		return property(**locals())

	@apply
	def subject_element_value():
		def fget( self ):
			return self._subject_element_value
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument subject_element_value is mantatory and can not be set to None')
			if not check_type(value,text):
				self._subject_element_value = text(value)
			else:
				self._subject_element_value = value
		return property(**locals())

####################
 # ENTITY light_source_spot #
####################
class light_source_spot(light_source):
	'''Entity light_source_spot definition.

	:param position
	:type position:cartesian_point

	:param orientation
	:type orientation:direction

	:param concentration_exponent
	:type concentration_exponent:REAL

	:param constant_attenuation
	:type constant_attenuation:REAL

	:param distance_attenuation
	:type distance_attenuation:REAL

	:param spread_angle
	:type spread_angle:positive_plane_angle_measure
	'''
	def __init__( self , inherited0__name , inherited1__light_colour , position,orientation,concentration_exponent,constant_attenuation,distance_attenuation,spread_angle, ):
		light_source.__init__(self , inherited0__name , inherited1__light_colour , )
		self.position = position
		self.orientation = orientation
		self.concentration_exponent = concentration_exponent
		self.constant_attenuation = constant_attenuation
		self.distance_attenuation = distance_attenuation
		self.spread_angle = spread_angle

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,cartesian_point):
				self._position = cartesian_point(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,direction):
				self._orientation = direction(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def concentration_exponent():
		def fget( self ):
			return self._concentration_exponent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument concentration_exponent is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._concentration_exponent = REAL(value)
			else:
				self._concentration_exponent = value
		return property(**locals())

	@apply
	def constant_attenuation():
		def fget( self ):
			return self._constant_attenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument constant_attenuation is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._constant_attenuation = REAL(value)
			else:
				self._constant_attenuation = value
		return property(**locals())

	@apply
	def distance_attenuation():
		def fget( self ):
			return self._distance_attenuation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance_attenuation is mantatory and can not be set to None')
			if not check_type(value,REAL):
				self._distance_attenuation = REAL(value)
			else:
				self._distance_attenuation = value
		return property(**locals())

	@apply
	def spread_angle():
		def fget( self ):
			return self._spread_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument spread_angle is mantatory and can not be set to None')
			if not check_type(value,positive_plane_angle_measure):
				self._spread_angle = positive_plane_angle_measure(value)
			else:
				self._spread_angle = value
		return property(**locals())

####################
 # ENTITY mechanical_design_shaded_presentation_area #
####################
class mechanical_design_shaded_presentation_area(presentation_area):
	'''Entity mechanical_design_shaded_presentation_area definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items ,  ):
		presentation_area.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , inherited3__representation_context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((SIZEOF(None)  ==  0)  and  (SIZEOF(None)  ==  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  0))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY physical_element_usage #
####################
class physical_element_usage(breakdown_element_usage):
	'''Entity physical_element_usage definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		breakdown_element_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY configuration_item_hierarchical_relationship #
####################
class configuration_item_hierarchical_relationship(configuration_item_relationship):
	'''Entity configuration_item_hierarchical_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__relating_configuration_item , inherited3__related_configuration_item ,  ):
		configuration_item_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__relating_configuration_item , inherited3__related_configuration_item , )

####################
 # ENTITY date_time_representation_item #
####################
class date_time_representation_item(representation_item,date_and_time):
	'''Entity date_time_representation_item definition.
	'''
	def __init__( self , inherited0__name , inherited1__date_component , inherited2__time_component ,  ):
		representation_item.__init__(self , inherited0__name , )
		date_and_time.__init__(self , inherited1__date_component , inherited2__time_component , )

####################
 # ENTITY presentation_style_by_context #
####################
class presentation_style_by_context(presentation_style_assignment):
	'''Entity presentation_style_by_context definition.

	:param style_context
	:type style_context:style_context_select
	'''
	def __init__( self , inherited0__styles , style_context, ):
		presentation_style_assignment.__init__(self , inherited0__styles , )
		self.style_context = style_context

	@apply
	def style_context():
		def fget( self ):
			return self._style_context
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_context is mantatory and can not be set to None')
			if not check_type(value,style_context_select):
				self._style_context = style_context_select(value)
			else:
				self._style_context = value
		return property(**locals())

####################
 # ENTITY scalar_variable #
####################
class scalar_variable(abstract_variable):
	'''Entity scalar_variable definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition , inherited3__definition , inherited4__used_representation , inherited5__name , inherited6__items , inherited7__context_of_items , inherited8__name ,  ):
		abstract_variable.__init__(self , inherited0__name , inherited1__description , inherited2__definition , inherited3__definition , inherited4__used_representation , inherited5__name , inherited6__items , inherited7__context_of_items , inherited8__name , )

####################
 # ENTITY shape_dimension_representation #
####################
class shape_dimension_representation(shape_representation):
	'''Entity shape_dimension_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.self.representation.self.items)  <=  3)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY vertex_point #
####################
class vertex_point(vertex,geometric_representation_item):
	'''Entity vertex_point definition.

	:param vertex_geometry
	:type vertex_geometry:point
	'''
	def __init__( self , inherited0__name , inherited1__name , vertex_geometry, ):
		vertex.__init__(self , inherited0__name , )
		geometric_representation_item.__init__(self , inherited1__name , )
		self.vertex_geometry = vertex_geometry

	@apply
	def vertex_geometry():
		def fget( self ):
			return self._vertex_geometry
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vertex_geometry is mantatory and can not be set to None')
			if not check_type(value,point):
				self._vertex_geometry = point(value)
			else:
				self._vertex_geometry = value
		return property(**locals())

####################
 # ENTITY annotation_symbol #
####################
class annotation_symbol(mapped_item):
	'''Entity annotation_symbol definition.

	:param mapped_item_mapping_source
	:type mapped_item_mapping_source:symbol_representation_map

	:param mapped_item_mapping_target
	:type mapped_item_mapping_target:symbol_target
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , mapped_item_mapping_source,mapped_item_mapping_target, ):
		mapped_item.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , )
		self.mapped_item_mapping_source = mapped_item_mapping_source
		self.mapped_item_mapping_target = mapped_item_mapping_target

	@apply
	def mapped_item_mapping_source():
		def fget( self ):
			return self._mapped_item_mapping_source
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_source is mantatory and can not be set to None')
			if not check_type(value,symbol_representation_map):
				self._mapped_item_mapping_source = symbol_representation_map(value)
			else:
				self._mapped_item_mapping_source = value
		return property(**locals())

	@apply
	def mapped_item_mapping_target():
		def fget( self ):
			return self._mapped_item_mapping_target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument mapped_item_mapping_target is mantatory and can not be set to None')
			if not check_type(value,symbol_target):
				self._mapped_item_mapping_target = symbol_target(value)
			else:
				self._mapped_item_mapping_target = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM'  ==  TYPEOF(self))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY cc_design_date_and_time_assignment #
####################
class cc_design_date_and_time_assignment(date_and_time_assignment):
	'''Entity cc_design_date_and_time_assignment definition.

	:param items
	:type items:SET(1,None,'date_time_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_date_and_time , inherited1__role , items, ):
		date_and_time_assignment.__init__(self , inherited0__assigned_date_and_time , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'date_time_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY centre_of_symmetry #
####################
class centre_of_symmetry(derived_shape_aspect):
	'''Entity centre_of_symmetry definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		derived_shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY oriented_closed_shell #
####################
class oriented_closed_shell(closed_shell):
	'''Entity oriented_closed_shell definition.

	:param closed_shell_element
	:type closed_shell_element:closed_shell

	:param orientation
	:type orientation:BOOLEAN

	:param connected_face_set_cfs_faces
	:type connected_face_set_cfs_faces:SET(1,None,'face', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces , closed_shell_element,orientation, ):
		closed_shell.__init__(self , inherited0__name , inherited1__cfs_faces , )
		self.closed_shell_element = closed_shell_element
		self.orientation = orientation

	@apply
	def closed_shell_element():
		def fget( self ):
			return self._closed_shell_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument closed_shell_element is mantatory and can not be set to None')
			if not check_type(value,closed_shell):
				self._closed_shell_element = closed_shell(value)
			else:
				self._closed_shell_element = value
		return property(**locals())

	@apply
	def orientation():
		def fget( self ):
			return self._orientation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument orientation is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._orientation = BOOLEAN(value)
			else:
				self._orientation = value
		return property(**locals())

	@apply
	def connected_face_set_cfs_faces():
		def fget( self ):
			attribute_eval = conditional_reverse(self.self.orientation,self.self.closed_shell_element.self.cfs_faces)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument connected_face_set_cfs_faces is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORIENTED_CLOSED_SHELL'  ==  TYPEOF(self.self.closed_shell_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY constructive_geometry_representation_relationship #
####################
class constructive_geometry_representation_relationship(representation_relationship):
	'''Entity constructive_geometry_representation_relationship definition.

	:param representation_relationship_rep_1
	:type representation_relationship_rep_1:constructive_geometry_representation_or_shape_represenation

	:param representation_relationship_rep_2
	:type representation_relationship_rep_2:constructive_geometry_representation
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , representation_relationship_rep_1,representation_relationship_rep_2, ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
		self.representation_relationship_rep_1 = representation_relationship_rep_1
		self.representation_relationship_rep_2 = representation_relationship_rep_2

	@apply
	def representation_relationship_rep_1():
		def fget( self ):
			return self._representation_relationship_rep_1
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_rep_1 is mantatory and can not be set to None')
			if not check_type(value,constructive_geometry_representation_or_shape_represenation):
				self._representation_relationship_rep_1 = constructive_geometry_representation_or_shape_represenation(value)
			else:
				self._representation_relationship_rep_1 = value
		return property(**locals())

	@apply
	def representation_relationship_rep_2():
		def fget( self ):
			return self._representation_relationship_rep_2
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_relationship_rep_2 is mantatory and can not be set to None')
			if not check_type(value,constructive_geometry_representation):
				self._representation_relationship_rep_2 = constructive_geometry_representation(value)
			else:
				self._representation_relationship_rep_2 = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((self.self.rep_1.self.context_of_items  ==  self.self.rep_2.self.context_of_items)  and  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT'  ==  TYPEOF(self.self.rep_1.self.context_of_items)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION')  ==  TYPEOF(self)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY hardness_representation #
####################
class hardness_representation(representation):
	'''Entity hardness_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (((2  <=  SIZEOF(self.self.items))  and  (SIZEOF(self.self.items)  <=  4))  and  ((SIZEOF(None)  +  SIZEOF(None))  ==  SIZEOF(self.self.items)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  <=  1)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  <=  1)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = ((SIZEOF(USEDIN(self,('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PROPERTY_DEFINITION_REPRESENTATION.')  +  'USED_REPRESENTATION'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY person_and_organization #
####################
class person_and_organization(BaseEntityClass):
	'''Entity person_and_organization definition.

	:param the_person
	:type the_person:person

	:param the_organization
	:type the_organization:organization

	:param description
	:type description:text

	:param name
	:type name:label
	'''
	def __init__( self , the_person,the_organization, ):
		self.the_person = the_person
		self.the_organization = the_organization

	@apply
	def the_person():
		def fget( self ):
			return self._the_person
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument the_person is mantatory and can not be set to None')
			if not check_type(value,person):
				self._the_person = person(value)
			else:
				self._the_person = value
		return property(**locals())

	@apply
	def the_organization():
		def fget( self ):
			return self._the_organization
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument the_organization is mantatory and can not be set to None')
			if not check_type(value,organization):
				self._the_organization = organization(value)
			else:
				self._the_organization = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			attribute_eval = get_description_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument description is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def name():
		def fget( self ):
			attribute_eval = get_name_value(self)
			return attribute_eval
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument name is DERIVED. It is computed and can not be set to any value')
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'NAME_ATTRIBUTE.NAMED_ITEM'))  <=  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(USEDIN(self,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY thickness_laminate_definition #
####################
class thickness_laminate_definition(product_definition):
	'''Entity thickness_laminate_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY curve_dimension #
####################
class curve_dimension(dimension_curve_directed_callout):
	'''Entity curve_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		dimension_curve_directed_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY inclusion_product_concept_feature #
####################
class inclusion_product_concept_feature(conditional_concept_feature):
	'''Entity inclusion_product_concept_feature definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__condition ,  ):
		conditional_concept_feature.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__condition , )
	def wr1(self):
		eval_wr1_wr = ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PACKAGE_PRODUCT_CONCEPT_FEATURE')  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((SIZEOF(None)  +  SIZEOF(None))  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.condition.self.conditional_operator.self.name  ==  'implication')
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY satisfied_requirement #
####################
class satisfied_requirement(group_assignment):
	'''Entity satisfied_requirement definition.

	:param items
	:type items:SET(1,1,'product_definition', scope = schema_scope)

	:param group_assignment_assigned_group
	:type group_assignment_assigned_group:satisfies_requirement
	'''
	def __init__( self , inherited0__assigned_group , items,group_assignment_assigned_group, ):
		group_assignment.__init__(self , inherited0__assigned_group , )
		self.items = items
		self.group_assignment_assigned_group = group_assignment_assigned_group

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,1,'product_definition', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

	@apply
	def group_assignment_assigned_group():
		def fget( self ):
			return self._group_assignment_assigned_group
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument group_assignment_assigned_group is mantatory and can not be set to None')
			if not check_type(value,satisfies_requirement):
				self._group_assignment_assigned_group = satisfies_requirement(value)
			else:
				self._group_assignment_assigned_group = value
		return property(**locals())

####################
 # ENTITY si_conductance_unit #
####################
class si_conductance_unit(conductance_unit,si_unit):
	'''Entity si_conductance_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		conductance_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.siemens)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY pre_defined_point_marker_symbol #
####################
class pre_defined_point_marker_symbol(pre_defined_marker,pre_defined_symbol):
	'''Entity pre_defined_point_marker_symbol definition.
	'''
	def __init__( self , inherited0__name , inherited1__name ,  ):
		pre_defined_marker.__init__(self , inherited0__name , )
		pre_defined_symbol.__init__(self , inherited1__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.name  ==  ['asterisk','circle','dot','plus','square','triangle','x'])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY sphere #
####################
class sphere(geometric_representation_item):
	'''Entity sphere definition.

	:param radius
	:type radius:positive_length_measure

	:param centre
	:type centre:point
	'''
	def __init__( self , inherited0__name , radius,centre, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.radius = radius
		self.centre = centre

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def centre():
		def fget( self ):
			return self._centre
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument centre is mantatory and can not be set to None')
			if not check_type(value,point):
				self._centre = point(value)
			else:
				self._centre = value
		return property(**locals())

####################
 # ENTITY cylindrical_surface #
####################
class cylindrical_surface(elementary_surface):
	'''Entity cylindrical_surface definition.

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY local_time #
####################
class local_time(BaseEntityClass):
	'''Entity local_time definition.

	:param hour_component
	:type hour_component:hour_in_day

	:param minute_component
	:type minute_component:minute_in_hour

	:param second_component
	:type second_component:second_in_minute

	:param zone
	:type zone:coordinated_universal_time_offset
	'''
	def __init__( self , hour_component,minute_component,second_component,zone, ):
		self.hour_component = hour_component
		self.minute_component = minute_component
		self.second_component = second_component
		self.zone = zone

	@apply
	def hour_component():
		def fget( self ):
			return self._hour_component
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument hour_component is mantatory and can not be set to None')
			if not check_type(value,hour_in_day):
				self._hour_component = hour_in_day(value)
			else:
				self._hour_component = value
		return property(**locals())

	@apply
	def minute_component():
		def fget( self ):
			return self._minute_component
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,minute_in_hour):
					self._minute_component = minute_in_hour(value)
				else:
					self._minute_component = value
			else:
				self._minute_component = value
		return property(**locals())

	@apply
	def second_component():
		def fget( self ):
			return self._second_component
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,second_in_minute):
					self._second_component = second_in_minute(value)
				else:
					self._second_component = value
			else:
				self._second_component = value
		return property(**locals())

	@apply
	def zone():
		def fget( self ):
			return self._zone
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument zone is mantatory and can not be set to None')
			if not check_type(value,coordinated_universal_time_offset):
				self._zone = coordinated_universal_time_offset(value)
			else:
				self._zone = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = valid_time(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY mass_unit #
####################
class mass_unit(named_unit):
	'''Entity mass_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  1))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY symbol_colour #
####################
class symbol_colour(BaseEntityClass):
	'''Entity symbol_colour definition.

	:param colour_of_symbol
	:type colour_of_symbol:colour
	'''
	def __init__( self , colour_of_symbol, ):
		self.colour_of_symbol = colour_of_symbol

	@apply
	def colour_of_symbol():
		def fget( self ):
			return self._colour_of_symbol
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument colour_of_symbol is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._colour_of_symbol = colour(value)
			else:
				self._colour_of_symbol = value
		return property(**locals())

####################
 # ENTITY user_defined_marker #
####################
class user_defined_marker(mapped_item,pre_defined_marker):
	'''Entity user_defined_marker definition.
	'''
	def __init__( self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , inherited3__name ,  ):
		mapped_item.__init__(self , inherited0__name , inherited1__mapping_source , inherited2__mapping_target , )
		pre_defined_marker.__init__(self , inherited3__name , )

####################
 # ENTITY rule_supersedence #
####################
class rule_supersedence(rule_action):
	'''Entity rule_supersedence definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method ,  ):
		rule_action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )

####################
 # ENTITY solid_replica #
####################
class solid_replica(solid_model):
	'''Entity solid_replica definition.

	:param parent_solid
	:type parent_solid:solid_model

	:param transformation
	:type transformation:cartesian_transformation_operator_3d
	'''
	def __init__( self , inherited0__name , parent_solid,transformation, ):
		solid_model.__init__(self , inherited0__name , )
		self.parent_solid = parent_solid
		self.transformation = transformation

	@apply
	def parent_solid():
		def fget( self ):
			return self._parent_solid
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument parent_solid is mantatory and can not be set to None')
			if not check_type(value,solid_model):
				self._parent_solid = solid_model(value)
			else:
				self._parent_solid = value
		return property(**locals())

	@apply
	def transformation():
		def fget( self ):
			return self._transformation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument transformation is mantatory and can not be set to None')
			if not check_type(value,cartesian_transformation_operator_3d):
				self._transformation = cartesian_transformation_operator_3d(value)
			else:
				self._transformation = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = acyclic_solid_replica(self,self.parent_solid)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.parent_solid.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY material_designation_characterization #
####################
class material_designation_characterization(BaseEntityClass):
	'''Entity material_designation_characterization definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param designation
	:type designation:material_designation

	:param property
	:type property:characterized_material_property
	'''
	def __init__( self , name,description,designation,property, ):
		self.name = name
		self.description = description
		self.designation = designation
		self.property = property

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def designation():
		def fget( self ):
			return self._designation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument designation is mantatory and can not be set to None')
			if not check_type(value,material_designation):
				self._designation = material_designation(value)
			else:
				self._designation = value
		return property(**locals())

	@apply
	def property():
		def fget( self ):
			return self._property
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument property is mantatory and can not be set to None')
			if not check_type(value,characterized_material_property):
				self._property = characterized_material_property(value)
			else:
				self._property = value
		return property(**locals())

####################
 # ENTITY vertex_shell #
####################
class vertex_shell(topological_representation_item):
	'''Entity vertex_shell definition.

	:param vertex_shell_extent
	:type vertex_shell_extent:vertex_loop
	'''
	def __init__( self , inherited0__name , vertex_shell_extent, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.vertex_shell_extent = vertex_shell_extent

	@apply
	def vertex_shell_extent():
		def fget( self ):
			return self._vertex_shell_extent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument vertex_shell_extent is mantatory and can not be set to None')
			if not check_type(value,vertex_loop):
				self._vertex_shell_extent = vertex_loop(value)
			else:
				self._vertex_shell_extent = value
		return property(**locals())

####################
 # ENTITY coaxiality_tolerance #
####################
class coaxiality_tolerance(geometric_tolerance_with_datum_reference):
	'''Entity coaxiality_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system ,  ):
		geometric_tolerance_with_datum_reference.__init__(self , inherited0__name , inherited1__description , inherited2__magnitude , inherited3__toleranced_shape_aspect , inherited4__datum_system , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.geometric_tolerance_with_datum_reference.self.datum_system)  <=  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY externally_defined_string #
####################
class externally_defined_string(externally_defined_representation_item):
	'''Entity externally_defined_string definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_id , inherited2__source ,  ):
		externally_defined_representation_item.__init__(self , inherited0__name , inherited1__item_id , inherited2__source , )

####################
 # ENTITY poly_loop #
####################
class poly_loop(loop,geometric_representation_item):
	'''Entity poly_loop definition.

	:param polygon
	:type polygon:LIST(3,None,'cartesian_point', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__name , polygon, ):
		loop.__init__(self , inherited0__name , )
		geometric_representation_item.__init__(self , inherited1__name , )
		self.polygon = polygon

	@apply
	def polygon():
		def fget( self ):
			return self._polygon
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument polygon is mantatory and can not be set to None')
			if not check_type(value,LIST(3,None,'cartesian_point', scope = schema_scope)):
				self._polygon = LIST(value)
			else:
				self._polygon = value
		return property(**locals())

####################
 # ENTITY surface_rendering_properties #
####################
class surface_rendering_properties(BaseEntityClass):
	'''Entity surface_rendering_properties definition.

	:param rendered_colour
	:type rendered_colour:colour
	'''
	def __init__( self , rendered_colour, ):
		self.rendered_colour = rendered_colour

	@apply
	def rendered_colour():
		def fget( self ):
			return self._rendered_colour
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument rendered_colour is mantatory and can not be set to None')
			if not check_type(value,colour):
				self._rendered_colour = colour(value)
			else:
				self._rendered_colour = value
		return property(**locals())

####################
 # ENTITY wire_shell #
####################
class wire_shell(topological_representation_item):
	'''Entity wire_shell definition.

	:param wire_shell_extent
	:type wire_shell_extent:SET(1,None,'loop', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , wire_shell_extent, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self.wire_shell_extent = wire_shell_extent

	@apply
	def wire_shell_extent():
		def fget( self ):
			return self._wire_shell_extent
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument wire_shell_extent is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'loop', scope = schema_scope)):
				self._wire_shell_extent = SET(value)
			else:
				self._wire_shell_extent = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ( not mixed_loop_type_set(self.wire_shell_extent))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY draughting_model_item_association #
####################
class draughting_model_item_association(item_identified_representation_usage):
	'''Entity draughting_model_item_association definition.

	:param item_identified_representation_usage_definition
	:type item_identified_representation_usage_definition:shape_definition

	:param item_identified_representation_usage_identified_item
	:type item_identified_representation_usage_identified_item:draughting_model_item_association_select

	:param item_identified_representation_usage_used_representation
	:type item_identified_representation_usage_used_representation:draughting_model
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition , inherited3__used_representation , inherited4__identified_item , item_identified_representation_usage_definition,item_identified_representation_usage_identified_item,item_identified_representation_usage_used_representation, ):
		item_identified_representation_usage.__init__(self , inherited0__name , inherited1__description , inherited2__definition , inherited3__used_representation , inherited4__identified_item , )
		self.item_identified_representation_usage_definition = item_identified_representation_usage_definition
		self.item_identified_representation_usage_identified_item = item_identified_representation_usage_identified_item
		self.item_identified_representation_usage_used_representation = item_identified_representation_usage_used_representation

	@apply
	def item_identified_representation_usage_definition():
		def fget( self ):
			return self._item_identified_representation_usage_definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_definition is mantatory and can not be set to None')
			if not check_type(value,shape_definition):
				self._item_identified_representation_usage_definition = shape_definition(value)
			else:
				self._item_identified_representation_usage_definition = value
		return property(**locals())

	@apply
	def item_identified_representation_usage_identified_item():
		def fget( self ):
			return self._item_identified_representation_usage_identified_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_identified_item is mantatory and can not be set to None')
			if not check_type(value,draughting_model_item_association_select):
				self._item_identified_representation_usage_identified_item = draughting_model_item_association_select(value)
			else:
				self._item_identified_representation_usage_identified_item = value
		return property(**locals())

	@apply
	def item_identified_representation_usage_used_representation():
		def fget( self ):
			return self._item_identified_representation_usage_used_representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument item_identified_representation_usage_used_representation is mantatory and can not be set to None')
			if not check_type(value,draughting_model):
				self._item_identified_representation_usage_used_representation = draughting_model(value)
			else:
				self._item_identified_representation_usage_used_representation = value
		return property(**locals())

####################
 # ENTITY geometric_model_element_relationship #
####################
class geometric_model_element_relationship(geometric_representation_item,representation_item_relationship):
	'''Entity geometric_model_element_relationship definition.

	:param representation_item_relationship_related_representation_item
	:type representation_item_relationship_related_representation_item:geometric_representation_item

	:param representation_item_relationship_relating_representation_item
	:type representation_item_relationship_relating_representation_item:geometric_representation_item
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__description , inherited3__relating_representation_item , inherited4__related_representation_item , representation_item_relationship_related_representation_item,representation_item_relationship_relating_representation_item, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		representation_item_relationship.__init__(self , inherited1__name , inherited2__description , inherited3__relating_representation_item , inherited4__related_representation_item , )
		self.representation_item_relationship_related_representation_item = representation_item_relationship_related_representation_item
		self.representation_item_relationship_relating_representation_item = representation_item_relationship_relating_representation_item

	@apply
	def representation_item_relationship_related_representation_item():
		def fget( self ):
			return self._representation_item_relationship_related_representation_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_item_relationship_related_representation_item is mantatory and can not be set to None')
			if not check_type(value,geometric_representation_item):
				self._representation_item_relationship_related_representation_item = geometric_representation_item(value)
			else:
				self._representation_item_relationship_related_representation_item = value
		return property(**locals())

	@apply
	def representation_item_relationship_relating_representation_item():
		def fget( self ):
			return self._representation_item_relationship_relating_representation_item
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation_item_relationship_relating_representation_item is mantatory and can not be set to None')
			if not check_type(value,geometric_representation_item):
				self._representation_item_relationship_relating_representation_item = geometric_representation_item(value)
			else:
				self._representation_item_relationship_relating_representation_item = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.self.representation_item_relationship.self.relating_representation_item  !=  self.self.representation_item_relationship.self.related_representation_item)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY solid_with_flat_bottom_round_hole #
####################
class solid_with_flat_bottom_round_hole(solid_with_stepped_round_hole):
	'''Entity solid_with_flat_bottom_round_hole definition.

	:param fillet_radius
	:type fillet_radius:non_negative_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__segments , inherited6__segment_radii , inherited7__segment_depths , fillet_radius, ):
		solid_with_stepped_round_hole.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__placing , inherited4__depth , inherited5__segments , inherited6__segment_radii , inherited7__segment_depths , )
		self.fillet_radius = fillet_radius

	@apply
	def fillet_radius():
		def fget( self ):
			return self._fillet_radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument fillet_radius is mantatory and can not be set to None')
			if not check_type(value,non_negative_length_measure):
				self._fillet_radius = non_negative_length_measure(value)
			else:
				self._fillet_radius = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.fillet_radius  <  self.self.solid_with_stepped_round_hole.self.segment_radii[self.segments])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_style_boundary #
####################
class surface_style_boundary(founded_item):
	'''Entity surface_style_boundary definition.

	:param style_of_boundary
	:type style_of_boundary:curve_or_render
	'''
	def __init__( self , style_of_boundary, ):
		founded_item.__init__(self , )
		self.style_of_boundary = style_of_boundary

	@apply
	def style_of_boundary():
		def fget( self ):
			return self._style_of_boundary
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_boundary is mantatory and can not be set to None')
			if not check_type(value,curve_or_render):
				self._style_of_boundary = curve_or_render(value)
			else:
				self._style_of_boundary = value
		return property(**locals())

####################
 # ENTITY area_unit #
####################
class area_unit(derived_unit):
	'''Entity area_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensional_exponents(2,0,0,0,0,0,0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY offset_curve_2d #
####################
class offset_curve_2d(curve):
	'''Entity offset_curve_2d definition.

	:param basis_curve
	:type basis_curve:curve

	:param distance
	:type distance:length_measure

	:param self_intersect
	:type self_intersect:LOGICAL
	'''
	def __init__( self , inherited0__name , basis_curve,distance,self_intersect, ):
		curve.__init__(self , inherited0__name , )
		self.basis_curve = basis_curve
		self.distance = distance
		self.self_intersect = self_intersect

	@apply
	def basis_curve():
		def fget( self ):
			return self._basis_curve
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument basis_curve is mantatory and can not be set to None')
			if not check_type(value,curve):
				self._basis_curve = curve(value)
			else:
				self._basis_curve = value
		return property(**locals())

	@apply
	def distance():
		def fget( self ):
			return self._distance
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument distance is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._distance = length_measure(value)
			else:
				self._distance = value
		return property(**locals())

	@apply
	def self_intersect():
		def fget( self ):
			return self._self_intersect
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument self_intersect is mantatory and can not be set to None')
			if not check_type(value,LOGICAL):
				self._self_intersect = LOGICAL(value)
			else:
				self._self_intersect = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.basis_curve.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY shape_definition_representation #
####################
class shape_definition_representation(property_definition_representation):
	'''Entity shape_definition_representation definition.
	'''
	def __init__( self , inherited0__definition , inherited1__used_representation ,  ):
		property_definition_representation.__init__(self , inherited0__definition , inherited1__used_representation , )
	def wr1(self):
		eval_wr1_wr = (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRODUCT_DEFINITION_SHAPE'  ==  TYPEOF(self.self.definition))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SHAPE_DEFINITION'  ==  TYPEOF(self.self.definition.self.definition)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SHAPE_REPRESENTATION'  ==  TYPEOF(self.self.used_representation))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY si_energy_unit #
####################
class si_energy_unit(energy_unit,si_unit):
	'''Entity si_energy_unit definition.
	'''
	def __init__( self , inherited0__elements , inherited1__dimensions , inherited2__prefix , inherited3__name ,  ):
		energy_unit.__init__(self , inherited0__elements , )
		si_unit.__init__(self , inherited1__dimensions , inherited2__prefix , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = (self.self.si_unit.self.name  ==  si_unit_name.self.joule)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ( not EXISTS(self.self.derived_unit.self.name))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY complex_conjunctive_clause #
####################
class complex_conjunctive_clause(complex_clause):
	'''Entity complex_conjunctive_clause definition.
	'''
	def __init__( self , inherited0__name , inherited1__item_element ,  ):
		complex_clause.__init__(self , inherited0__name , inherited1__item_element , )

####################
 # ENTITY solid_with_constant_radius_edge_blend #
####################
class solid_with_constant_radius_edge_blend(edge_blended_solid):
	'''Entity solid_with_constant_radius_edge_blend definition.

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , radius, ):
		edge_blended_solid.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , inherited3__blended_edges , )
		self.radius = radius

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._radius = positive_length_measure(value)
			else:
				self._radius = value
		return property(**locals())

####################
 # ENTITY symbol_style #
####################
class symbol_style(founded_item):
	'''Entity symbol_style definition.

	:param name
	:type name:label

	:param style_of_symbol
	:type style_of_symbol:symbol_style_select
	'''
	def __init__( self , name,style_of_symbol, ):
		founded_item.__init__(self , )
		self.name = name
		self.style_of_symbol = style_of_symbol

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def style_of_symbol():
		def fget( self ):
			return self._style_of_symbol
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_symbol is mantatory and can not be set to None')
			if not check_type(value,symbol_style_select):
				self._style_of_symbol = symbol_style_select(value)
			else:
				self._style_of_symbol = value
		return property(**locals())

####################
 # ENTITY tactile_appearance_representation #
####################
class tactile_appearance_representation(representation):
	'''Entity tactile_appearance_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ((SIZEOF(USEDIN(self,('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PROPERTY_DEFINITION_REPRESENTATION.')  +  'USED_REPRESENTATION'))  ==  1)  and  (SIZEOF(None)  ==  1))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY volume_unit #
####################
class volume_unit(derived_unit):
	'''Entity volume_unit definition.
	'''
	def __init__( self , inherited0__elements ,  ):
		derived_unit.__init__(self , inherited0__elements , )
	def wr1(self):
		eval_wr1_wr = (derive_dimensional_exponents(self)  ==  dimensional_exponents(3,0,0,0,0,0,0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY conical_surface #
####################
class conical_surface(elementary_surface):
	'''Entity conical_surface definition.

	:param radius
	:type radius:length_measure

	:param semi_angle
	:type semi_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius,semi_angle, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self.radius = radius
		self.semi_angle = semi_angle

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			if not check_type(value,length_measure):
				self._radius = length_measure(value)
			else:
				self._radius = value
		return property(**locals())

	@apply
	def semi_angle():
		def fget( self ):
			return self._semi_angle
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument semi_angle is mantatory and can not be set to None')
			if not check_type(value,plane_angle_measure):
				self._semi_angle = plane_angle_measure(value)
			else:
				self._semi_angle = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (self.radius  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY flat_pattern_ply_representation_relationship #
####################
class flat_pattern_ply_representation_relationship(shape_representation_relationship):
	'''Entity flat_pattern_ply_representation_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 ,  ):
		shape_representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SHAPE_REPRESENTATION'  ==  (TYPEOF(self.self.representation_relationship.self.rep_1)  *  TYPEOF(self.self.representation_relationship.self.rep_2)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.representation_relationship.self.rep_1.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  3)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY applied_person_and_organization_assignment #
####################
class applied_person_and_organization_assignment(person_and_organization_assignment):
	'''Entity applied_person_and_organization_assignment definition.

	:param items
	:type items:SET(1,None,'person_and_organization_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_person_and_organization , inherited1__role , items, ):
		person_and_organization_assignment.__init__(self , inherited0__assigned_person_and_organization , inherited1__role , )
		self.items = items

	@apply
	def items():
		def fget( self ):
			return self._items
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument items is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'person_and_organization_item', scope = schema_scope)):
				self._items = SET(value)
			else:
				self._items = value
		return property(**locals())

####################
 # ENTITY block #
####################
class block(geometric_representation_item):
	'''Entity block definition.

	:param position
	:type position:axis2_placement_3d

	:param x
	:type x:positive_length_measure

	:param y
	:type y:positive_length_measure

	:param z
	:type z:positive_length_measure
	'''
	def __init__( self , inherited0__name , position,x,y,z, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.position = position
		self.x = x
		self.y = y
		self.z = z

	@apply
	def position():
		def fget( self ):
			return self._position
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument position is mantatory and can not be set to None')
			if not check_type(value,axis2_placement_3d):
				self._position = axis2_placement_3d(value)
			else:
				self._position = value
		return property(**locals())

	@apply
	def x():
		def fget( self ):
			return self._x
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument x is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._x = positive_length_measure(value)
			else:
				self._x = value
		return property(**locals())

	@apply
	def y():
		def fget( self ):
			return self._y
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument y is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._y = positive_length_measure(value)
			else:
				self._y = value
		return property(**locals())

	@apply
	def z():
		def fget( self ):
			return self._z
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument z is mantatory and can not be set to None')
			if not check_type(value,positive_length_measure):
				self._z = positive_length_measure(value)
			else:
				self._z = value
		return property(**locals())

####################
 # ENTITY global_unit_assigned_context #
####################
class global_unit_assigned_context(representation_context):
	'''Entity global_unit_assigned_context definition.

	:param units
	:type units:SET(1,None,'unit', scope = schema_scope)
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type , units, ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )
		self.units = units

	@apply
	def units():
		def fget( self ):
			return self._units
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument units is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'unit', scope = schema_scope)):
				self._units = SET(value)
			else:
				self._units = value
		return property(**locals())

####################
 # ENTITY placed_feature #
####################
class placed_feature(shape_aspect):
	'''Entity placed_feature definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional ,  ):
		shape_aspect.__init__(self , inherited0__name , inherited1__description , inherited2__of_shape , inherited3__product_definitional , )

####################
 # ENTITY surface_style_parameter_line #
####################
class surface_style_parameter_line(founded_item):
	'''Entity surface_style_parameter_line definition.

	:param style_of_parameter_lines
	:type style_of_parameter_lines:curve_or_render

	:param direction_counts
	:type direction_counts:SET(1,2,'direction_count_select', scope = schema_scope)
	'''
	def __init__( self , style_of_parameter_lines,direction_counts, ):
		founded_item.__init__(self , )
		self.style_of_parameter_lines = style_of_parameter_lines
		self.direction_counts = direction_counts

	@apply
	def style_of_parameter_lines():
		def fget( self ):
			return self._style_of_parameter_lines
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument style_of_parameter_lines is mantatory and can not be set to None')
			if not check_type(value,curve_or_render):
				self._style_of_parameter_lines = curve_or_render(value)
			else:
				self._style_of_parameter_lines = value
		return property(**locals())

	@apply
	def direction_counts():
		def fget( self ):
			return self._direction_counts
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument direction_counts is mantatory and can not be set to None')
			if not check_type(value,SET(1,2,'direction_count_select', scope = schema_scope)):
				self._direction_counts = SET(value)
			else:
				self._direction_counts = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.self.direction_counts)  ==  1) XOR (TYPEOF(self.self.direction_counts[1])  !=  TYPEOF(self.self.direction_counts[2])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY camera_model_with_light_sources #
####################
class camera_model_with_light_sources(camera_model_d3):
	'''Entity camera_model_with_light_sources definition.

	:param sources
	:type sources:SET(1,None,'light_source', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__view_reference_system , inherited2__perspective_of_volume , sources, ):
		camera_model_d3.__init__(self , inherited0__name , inherited1__view_reference_system , inherited2__perspective_of_volume , )
		self.sources = sources

	@apply
	def sources():
		def fget( self ):
			return self._sources
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sources is mantatory and can not be set to None')
			if not check_type(value,SET(1,None,'light_source', scope = schema_scope)):
				self._sources = SET(value)
			else:
				self._sources = value
		return property(**locals())

####################
 # ENTITY specification_definition #
####################
class specification_definition(product_definition):
	'''Entity specification_definition definition.
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference ,  ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )

####################
 # ENTITY surface_side_style #
####################
class surface_side_style(founded_item):
	'''Entity surface_side_style definition.

	:param name
	:type name:label

	:param styles
	:type styles:SET(1,7,'surface_style_element_select', scope = schema_scope)
	'''
	def __init__( self , name,styles, ):
		founded_item.__init__(self , )
		self.name = name
		self.styles = styles

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def styles():
		def fget( self ):
			return self._styles
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument styles is mantatory and can not be set to None')
			if not check_type(value,SET(1,7,'surface_style_element_select', scope = schema_scope)):
				self._styles = SET(value)
			else:
				self._styles = value
		return property(**locals())
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY time_measure_with_unit #
####################
class time_measure_with_unit(measure_with_unit):
	'''Entity time_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TIME_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_property_representation #
####################
class action_property_representation(BaseEntityClass):
	'''Entity action_property_representation definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param property
	:type property:action_property

	:param representation
	:type representation:representation
	'''
	def __init__( self , name,description,property,representation, ):
		self.name = name
		self.description = description
		self.property = property
		self.representation = representation

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument description is mantatory and can not be set to None')
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		return property(**locals())

	@apply
	def property():
		def fget( self ):
			return self._property
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument property is mantatory and can not be set to None')
			if not check_type(value,action_property):
				self._property = action_property(value)
			else:
				self._property = value
		return property(**locals())

	@apply
	def representation():
		def fget( self ):
			return self._representation
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument representation is mantatory and can not be set to None')
			if not check_type(value,representation):
				self._representation = representation(value)
			else:
				self._representation = value
		return property(**locals())

####################
 # ENTITY angular_dimension #
####################
class angular_dimension(dimension_curve_directed_callout):
	'''Entity angular_dimension definition.
	'''
	def __init__( self , inherited0__name , inherited1__contents ,  ):
		dimension_curve_directed_callout.__init__(self , inherited0__name , inherited1__contents , )

####################
 # ENTITY defined_symbol #
####################
class defined_symbol(geometric_representation_item):
	'''Entity defined_symbol definition.

	:param definition
	:type definition:defined_symbol_select

	:param target
	:type target:symbol_target
	'''
	def __init__( self , inherited0__name , definition,target, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self.definition = definition
		self.target = target

	@apply
	def definition():
		def fget( self ):
			return self._definition
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument definition is mantatory and can not be set to None')
			if not check_type(value,defined_symbol_select):
				self._definition = defined_symbol_select(value)
			else:
				self._definition = value
		return property(**locals())

	@apply
	def target():
		def fget( self ):
			return self._target
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument target is mantatory and can not be set to None')
			if not check_type(value,symbol_target):
				self._target = symbol_target(value)
			else:
				self._target = value
		return property(**locals())

####################
 # ENTITY dimension_text_associativity #
####################
class dimension_text_associativity(text_literal,mapped_item):
	'''Entity dimension_text_associativity definition.
	'''
	def __init__( self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , inherited6__name , inherited7__mapping_source , inherited8__mapping_target ,  ):
		text_literal.__init__(self , inherited0__name , inherited1__literal , inherited2__placement , inherited3__alignment , inherited4__path , inherited5__font , )
		mapped_item.__init__(self , inherited6__name , inherited7__mapping_source , inherited8__mapping_target , )
	def wr1(self):
		eval_wr1_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SHAPE_DIMENSION_REPRESENTATION'  ==  TYPEOF(self.self.mapped_item.self.mapping_source.self.mapped_representation))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DRAUGHTING_CALLOUT'  ==  TYPEOF(self.self.mapped_item.self.mapping_target))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY loss_tangent_measure_with_unit #
####################
class loss_tangent_measure_with_unit(ratio_measure_with_unit):
	'''Entity loss_tangent_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		ratio_measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )

####################
 # ENTITY organizational_project_role #
####################
class organizational_project_role(BaseEntityClass):
	'''Entity organizational_project_role definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self.name = name
		self.description = description

	@apply
	def name():
		def fget( self ):
			return self._name
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument name is mantatory and can not be set to None')
			if not check_type(value,label):
				self._name = label(value)
			else:
				self._name = value
		return property(**locals())

	@apply
	def description():
		def fget( self ):
			return self._description
		def fset( self, value ):
			if value != None: # OPTIONAL attribute
				if not check_type(value,text):
					self._description = text(value)
				else:
					self._description = value
			else:
				self._description = value
		return property(**locals())

####################
 # ENTITY sculptured_solid #
####################
class sculptured_solid(modified_solid):
	'''Entity sculptured_solid definition.

	:param sculpturing_element
	:type sculpturing_element:generalized_surface_select

	:param positive_side
	:type positive_side:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__rationale , inherited2__base_solid , sculpturing_element,positive_side, ):
		modified_solid.__init__(self , inherited0__name , inherited1__rationale , inherited2__base_solid , )
		self.sculpturing_element = sculpturing_element
		self.positive_side = positive_side

	@apply
	def sculpturing_element():
		def fget( self ):
			return self._sculpturing_element
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument sculpturing_element is mantatory and can not be set to None')
			if not check_type(value,generalized_surface_select):
				self._sculpturing_element = generalized_surface_select(value)
			else:
				self._sculpturing_element = value
		return property(**locals())

	@apply
	def positive_side():
		def fget( self ):
			return self._positive_side
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument positive_side is mantatory and can not be set to None')
			if not check_type(value,BOOLEAN):
				self._positive_side = BOOLEAN(value)
			else:
				self._positive_side = value
		return property(**locals())

####################
 # FUNCTION build_2axes #
####################
def build_2axes(ref_direction,):
	'''
	:param ref_direction
	:type ref_direction:direction
	'''
	return [d,orthogonal_complement(d)]

####################
 # FUNCTION item_in_context #
####################
def item_in_context(item,cntxt,):
	'''
	:param item
	:type item:representation_item
	:param cntxt
	:type cntxt:representation_context
	'''
	if (SIZEOF(USEDIN(item,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.REPRESENTATION.ITEMS')  *  cntxt.representations_in_context)  >  0):
		return TRUE
	else:
		y = None
		if (SIZEOF(y)  >  0):
			for  i in range(1,HIINDEX(y),1):
				if (item_in_context(y[i],cntxt)):
					return TRUE
	return FALSE

####################
 # FUNCTION default_tolerance_table_cell_wr3 #
####################
def default_tolerance_table_cell_wr3(agg,):
	'''
	:param agg
	:type agg:compound_item_definition
	'''
	# begin/end block
	if ((SIZEOF(None)  ==  1)  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION default_tolerance_table_cell_wr2 #
####################
def default_tolerance_table_cell_wr2(agg,):
	'''
	:param agg
	:type agg:compound_item_definition
	'''
	# begin/end block
	if (SIZEOF(agg)  <=  5):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION gbsf_check_point #
####################
def gbsf_check_point(pnt,):
	'''
	:param pnt
	:type pnt:point
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CARTESIAN_POINT'  ==  TYPEOF(pnt)):
		return TRUE
	else:
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POINT_ON_CURVE'  ==  TYPEOF(pnt)):
			return gbsf_check_curve(pnt.point_on_curve.basis_curve)
		else:
			if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POINT_ON_SURFACE'  ==  TYPEOF(pnt)):
				return gbsf_check_surface(pnt.point_on_surface.basis_surface)
			else:
				if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DEGENERATE_PCURVE'  ==  TYPEOF(pnt)):
					return gbsf_check_curve(pnt.degenerate_pcurve.reference_to_curve.representation.items[1])  and  gbsf_check_surface(pnt.degenerate_pcurve.basis_surface)
	return FALSE

####################
 # FUNCTION acyclic_solid_replica #
####################
def acyclic_solid_replica(rep,parent,):
	'''
	:param rep
	:type rep:solid_replica
	:param parent
	:type parent:solid_model
	'''
	if ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_REPLICA'  ==  TYPEOF(parent))):
		return TRUE
	if (parent  ==  rep):
		return FALSE
	else:
		return acyclic_solid_replica(rep,parent.solid_replica.parent_solid)

####################
 # FUNCTION build_axes #
####################
def build_axes(axis,ref_direction,):
	'''
	:param axis
	:type axis:direction
	:param ref_direction
	:type ref_direction:direction
	'''
	d1 = NVL(normalise(axis),dummy_gri  ==  direction([0,0,1]))
	d2 = first_proj_axis(d1,ref_direction)
	return [d2,normalise(cross_product(d1,d2)).vector.orientation,d1]

####################
 # FUNCTION derive_angle #
####################
def derive_angle(placement_1,placement_2,):
	'''
	:param placement_1
	:type placement_1:axis2_placement_3d
	:param placement_2
	:type placement_2:axis2_placement_3d
	'''
	v1 = placement_1.p[1]
	v2 = placement_2.p[1]
	mag_v1 = SQRT((v1.direction_ratios[1]  *  v1.direction_ratios[1])  +  (v1.direction_ratios[2]  *  v1.direction_ratios[2]))
	mag_v2 = SQRT((v2.direction_ratios[1]  *  v2.direction_ratios[1])  +  (v2.direction_ratios[2]  *  v2.direction_ratios[2]))
	if ((mag_v1  ==  0)  or  (mag_v2  ==  0)):
		theta = 0
		return theta
	theta = ACOS(((v1.direction_ratios[1]  *  v2.direction_ratios[1])  +  (v1.direction_ratios[2]  *  v2.direction_ratios[2])) / (mag_v1  *  mag_v2))
	return theta

####################
 # FUNCTION edge_reversed #
####################
def edge_reversed(an_edge,):
	'''
	:param an_edge
	:type an_edge:edge
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORIENTED_EDGE'  ==  TYPEOF(an_edge)):
		the_reverse = (dummy_tri  ==  edge(an_edge.edge_end,an_edge.edge_start))  ==  oriented_edge(an_edge.oriented_edge.edge_element, not an_edge.oriented_edge.orientation)
	else:
		the_reverse = (dummy_tri  ==  edge(an_edge.edge_end,an_edge.edge_start))  ==  oriented_edge(an_edge,FALSE)
	return the_reverse

####################
 # FUNCTION default_tolerance_table_cell_wr5 #
####################
def default_tolerance_table_cell_wr5(agg,):
	'''
	:param agg
	:type agg:compound_item_definition
	'''
	# begin/end block
	if ((SIZEOF(None)  <=  1)  and  (SIZEOF(None)  ==  SIZEOF(None))):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION cc_design_person_and_organization_correlation #
####################
def cc_design_person_and_organization_correlation(e,):
	'''
	:param e
	:type e:cc_design_person_and_organization_assignment
	'''
	po_role = e.person_and_organization_assignment.role.name
	case_selector = po_role
	if  case_selector == 'request_recipient':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'initiator':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'creator':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'part_supplier':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'design_supplier':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'design_owner':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'configuration_manager':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'contractor':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'classification_officer':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	else:
		return TRUE
	return TRUE

####################
 # FUNCTION constraints_composite_curve_on_surface #
####################
def constraints_composite_curve_on_surface(c,):
	'''
	:param c
	:type c:composite_curve_on_surface
	'''
	for  k in range(1,n_segments,1):
		if ((( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(c.composite_curve.segments[k].parent_curve)))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_CURVE'  ==  TYPEOF(c.composite_curve.segments[k].parent_curve))))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_CURVE_ON_SURFACE'  ==  TYPEOF(c.composite_curve.segments[k].parent_curve)))):
			return FALSE
	return TRUE

####################
 # FUNCTION default_tolerance_table_cell_wr4 #
####################
def default_tolerance_table_cell_wr4(agg,):
	'''
	:param agg
	:type agg:compound_item_definition
	'''
	# begin/end block
	if ((SIZEOF(None)  ==  1)  or  ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION check_continuous_edges #
####################
def check_continuous_edges(edges,):
	'''
	:param edges
	:type edges:(null)
	'''
	if (SIZEOF(edges)  ==  1):
		return TRUE
	if ((edges[2].edge_start  ==  edges[1].edge_end) XOR (edges[2].edge_start  ==  edges[1].edge_start)):
		next_vertex = edges[2].edge_end
	else:
		if ((edges[2].edge_end  ==  edges[1].edge_end) XOR (edges[2].edge_end  ==  edges[1].edge_start)):
			next_vertex = edges[2].edge_start
		else:
			return FALSE
	if (SIZEOF(edges)  ==  2):
		return TRUE
	for  i in range(3,HIINDEX(edges),1):
		if (edges[i].edge_start  ==  next_vertex):
			next_vertex = edges[i].edge_end
		else:
			if (edges[i].edge_end  ==  next_vertex):
				next_vertex = edges[i].edge_start
			else:
				return FALSE
	return TRUE

####################
 # FUNCTION acyclic_mapped_representation #
####################
def acyclic_mapped_representation(mi,):
	'''
	:param mi
	:type mi:mapped_item
	'''
	rs1 = using_representations(mi)
	rs2 = []
	for  while SIZEOF(rs1)  >  0		for  i in range(1,HIINDEX(rs1),1):
			rms = bag_to_set(USEDIN(rs1[i],'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.REPRESENTATION_MAP.MAPPED_REPRESENTATION'))
			if (SIZEOF(rms)  >  0):
				for  j in range(1,HIINDEX(rms),1):
					mis = bag_to_set(USEDIN(rms[i],'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MAPPED_ITEM.MAPPING_SOURCE'))
					if (SIZEOF(mis)  >  0):
						for  j in range(1,HIINDEX(mis),1):
							if (mis[i]  ==  mi):
								return FALSE
							rs2 = rs2  +  using_representations(mis[i])
		rs1 = rs2
		rs2 = []
	return TRUE

####################
 # FUNCTION get_name_value #
####################
def get_name_value(obj,):
	'''
	:param obj
	:type obj:name_attribute_select
	'''
	if (SIZEOF(name_bag)  ==  1):
		return name_bag[1].attribute_value
	else:
		return  None 

####################
 # FUNCTION validate_countersink_radii #
####################
def validate_countersink_radii(cskhole,):
	'''
	:param cskhole
	:type cskhole:solid_with_stepped_round_hole_and_conical_transitions
	'''
	for  i in range(1,SIZEOF(cskhole.conical_transitions),1):
		if (((cskhole.conical_transitions[i].transition_number  ==  1)  and  (cskhole.conical_transitions[i].cone_apex_angle  <  0)) XOR ((cskhole.conical_transitions[i].transition_number  ==  n)  and  (cskhole.conical_transitions[i].cone_apex_angle  >  0))):
			return FALSE
		else:
			if ((cskhole.conical_transitions[i].transition_number  !=  1)  and  (cskhole.conical_transitions[i].transition_number  !=  n)):
				# begin/end block
				j = cskhole.conical_transitions[i].transition_number
				if (cskhole.solid_with_stepped_round_hole.segment_radii[j]  >  cskhole.solid_with_stepped_round_hole.segment_radii[j - 1]):
					# begin/end block
					if (cskhole.conical_transitions[i].cone_apex_angle  >  0):
						return FALSE
					larger = cskhole.solid_with_stepped_round_hole.segment_radii[j]
					smaller = cskhole.solid_with_stepped_round_hole.segment_radii[j - 1]
				else:
					# begin/end block
					if (cskhole.conical_transitions[i].cone_apex_angle  <  0):
						return FALSE
					larger = cskhole.solid_with_stepped_round_hole.segment_radii[j - 1]
					smaller = cskhole.solid_with_stepped_round_hole.segment_radii[j]
				if ((cskhole.conical_transitions[i].cone_base_radius  >  larger)  or  (cskhole.conical_transitions[i].cone_base_radius  <  smaller)):
					return FALSE
	return TRUE

####################
 # FUNCTION dependently_instantiated #
####################
def dependently_instantiated(set_of_input_instances,set_of_input_types,previous_in_chain,):
	'''
	:param set_of_input_instances
	:type set_of_input_instances:(null)
	:param set_of_input_types
	:type set_of_input_types:(null)
	:param previous_in_chain
	:type previous_in_chain:(null)
	'''
	if (EXISTS(set_of_input_instances)):
		number_of_input_instances = SIZEOF(set_of_input_instances)
		set_of_input_types = set_of_input_types  +  'GENERIC'
		for  i in range(1,number_of_input_instances,1):
			bag_of_referring_instances = USEDIN(set_of_input_instances[i],'')
			if (EXISTS(bag_of_referring_instances)):
				number_of_referring_instances = SIZEOF(bag_of_referring_instances)
				dependently_instantiated_flag = FALSE
				for  j in range(1,number_of_referring_instances,1):
					set_of_types = TYPEOF(bag_of_referring_instances[j])
					if (set_of_types  <=  set_of_input_types):
						if ( not (bag_of_referring_instances[j]  ==  previous_in_chain)):
							previous_in_chain_plus = previous_in_chain  +  set_of_input_instances[i]
							if (dependently_instantiated([bag_of_referring_instances[j]],set_of_input_types,previous_in_chain_plus)):
								dependently_instantiated_flag = TRUE
								break
							else:
								break
					else:
						dependently_instantiated_flag = TRUE
						break
				if ( not dependently_instantiated_flag):
					return FALSE
			else:
				return FALSE
	else:
		return FALSE
	return TRUE

####################
 # FUNCTION check_text_font #
####################
def check_text_font(ct,):
	'''
	:param ct
	:type ct:composite_text
	'''
	for  i in range(1,HIINDEX(ct.collected_text),1):
		f = f  +  [ct.collected_text[i].text_literal.font]
	return SIZEOF(f)  <=  1

####################
 # FUNCTION conditional_reverse #
####################
def conditional_reverse(p,an_item,):
	'''
	:param p
	:type p:BOOLEAN
	:param an_item
	:type an_item:reversible_topology
	'''
	if (p):
		return an_item
	else:
		return topology_reversed(an_item)

####################
 # FUNCTION nmsf_curve_check #
####################
def nmsf_curve_check(cv,):
	'''
	:param cv
	:type cv:representation_item
	'''
	if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOUNDED_CURVE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CONIC','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_REPLICA','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_CURVE_3D']  *  TYPEOF(cv))  >  1):
		return FALSE
	else:
		if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_CURVE'  ==  TYPEOF(cv))  and  (cv.b_spline_curve.self_intersect  ==  FALSE))  or  (cv.b_spline_curve.self_intersect  ==  UNKNOWN)):
			return TRUE
		else:
			if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CONIC','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINE']  *  TYPEOF(cv))  ==  1):
				return TRUE
			else:
				if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_REPLICA'  ==  TYPEOF(cv)):
					return nmsf_curve_check(cv.curve_replica.parent_curve)
				else:
					if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_CURVE_3D'  ==  TYPEOF(cv))  and  ((cv.offset_curve_3d.self_intersect  ==  FALSE)  or  (cv.offset_curve_3d.self_intersect  ==  UNKNOWN)))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE'  ==  TYPEOF(cv.offset_curve_3d.basis_curve)))):
						return nmsf_curve_check(cv.offset_curve_3d.basis_curve)
					else:
						if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(cv)):
							return nmsf_curve_check(cv.pcurve.reference_to_curve.representation.items[1])  and  nmsf_surface_check(cv.pcurve.basis_surface)
						else:
							if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_CURVE'  ==  TYPEOF(cv)):
								if (nmsf_curve_check(cv.surface_curve.curve_3d)):
									for  i in range(1,SIZEOF(cv.surface_curve.associated_geometry),1):
										if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
											if ( not nmsf_surface_check(cv.surface_curve.associated_geometry[i])):
												return FALSE
										else:
											if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
												if ( not nmsf_curve_check(cv.surface_curve.associated_geometry[i])):
													return FALSE
									return TRUE
							else:
								if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE'  ==  TYPEOF(cv)):
									if (SIZEOF(cv.polyline.points)  >=  3):
										return TRUE
	return FALSE

####################
 # FUNCTION valid_measure_value #
####################
def valid_measure_value(m,):
	'''
	:param m
	:type m:measure_value
	'''
	if ('REAL'  ==  TYPEOF(m)):
		return m  >  0
	else:
		if ('INTEGER'  ==  TYPEOF(m)):
			return m  >  0
		else:
			return TRUE

####################
 # FUNCTION gbsf_check_curve #
####################
def gbsf_check_curve(cv,):
	'''
	:param cv
	:type cv:representation_item
	'''
	if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOUNDED_CURVE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CONIC','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_REPLICA','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_CURVE_3D']  *  TYPEOF(cv))  >  1):
		return FALSE
	if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CIRCLE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELLIPSE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TRIMMED_CURVE']  *  TYPEOF(cv))  ==  1):
		return TRUE
	else:
		if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_CURVE'  ==  TYPEOF(cv))  and  (cv.b_spline_curve.self_intersect  ==  FALSE))  or  (cv.b_spline_curve.self_intersect  ==  UNKNOWN)):
			return TRUE
		else:
			if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_CURVE'  ==  TYPEOF(cv))  and  (cv.composite_curve.self_intersect  ==  FALSE))  or  (cv.composite_curve.self_intersect  ==  UNKNOWN)):
				return SIZEOF(None)  ==  0
			else:
				if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_REPLICA'  ==  TYPEOF(cv)):
					return gbsf_check_curve(cv.curve_replica.parent_curve)
				else:
					if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_CURVE_3D'  ==  TYPEOF(cv))  and  ((cv.offset_curve_3d.self_intersect  ==  FALSE)  or  (cv.offset_curve_3d.self_intersect  ==  UNKNOWN)))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE'  ==  TYPEOF(cv.offset_curve_3d.basis_curve)))):
						return gbsf_check_curve(cv.offset_curve_3d.basis_curve)
					else:
						if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(cv)):
							return gbsf_check_curve(cv.pcurve.reference_to_curve.representation.items[1])  and  gbsf_check_surface(cv.pcurve.basis_surface)
						else:
							if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE'  ==  TYPEOF(cv)):
								if (SIZEOF(cv.polyline.points)  >=  3):
									return TRUE
							else:
								if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_CURVE'  ==  TYPEOF(cv)):
									if (gbsf_check_curve(cv.surface_curve.curve_3d)):
										for  i in range(1,SIZEOF(cv.surface_curve.associated_geometry),1):
											if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
												if ( not gbsf_check_surface(cv.surface_curve.associated_geometry[i])):
													return FALSE
											else:
												if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
													if ( not gbsf_check_curve(cv.surface_curve.associated_geometry[i])):
														return FALSE
										return TRUE
	return FALSE

####################
 # FUNCTION base_axis #
####################
def base_axis(dim,axis1,axis2,axis3,):
	'''
	:param dim
	:type dim:INTEGER
	:param axis1
	:type axis1:direction
	:param axis2
	:type axis2:direction
	:param axis3
	:type axis3:direction
	'''
	if (dim  ==  3):
		d1 = NVL(normalise(axis3),dummy_gri  ==  direction([0,0,1]))
		d2 = first_proj_axis(d1,axis1)
		u = [d2,second_proj_axis(d1,d2,axis2),d1]
	else:
		if (EXISTS(axis1)):
			d1 = normalise(axis1)
			u = [d1,orthogonal_complement(d1)]
			if (EXISTS(axis2)):
				factor = dot_product(axis2,u[2])
				if (factor  <  0):
					u[2].direction_ratios[1] = -u[2].direction_ratios[1]
					u[2].direction_ratios[2] = -u[2].direction_ratios[2]
		else:
			if (EXISTS(axis2)):
				d1 = normalise(axis2)
				u = [orthogonal_complement(d1),d1]
				u[1].direction_ratios[1] = -u[1].direction_ratios[1]
				u[1].direction_ratios[2] = -u[1].direction_ratios[2]
			else:
				u = [dummy_gri  ==  direction([1,0]),dummy_gri  ==  direction([0,1])]
	return u

####################
 # FUNCTION get_basis_surface #
####################
def get_basis_surface(c,):
	'''
	:param c
	:type c:curve_on_surface
	'''
	surfs = []
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(c)):
		surfs = [c.pcurve.basis_surface]
	else:
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_CURVE'  ==  TYPEOF(c)):
			n = SIZEOF(c.surface_curve.associated_geometry)
			for  i in range(1,n,1):
				surfs = surfs  +  associated_surface(c.surface_curve.associated_geometry[i])
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_CURVE_ON_SURFACE'  ==  TYPEOF(c)):
		n = SIZEOF(c.composite_curve.segments)
		surfs = get_basis_surface(c.composite_curve.segments[1].parent_curve)
		if (n  >  1):
			for  i in range(2,n,1):
				surfs = surfs  *  get_basis_surface(c.composite_curve.segments[i].parent_curve)
	return surfs

####################
 # FUNCTION list_face_loops #
####################
def list_face_loops(f,):
	'''
	:param f
	:type f:face
	'''
	for  i in range(1,SIZEOF(f.bounds),1):
		loops = loops  +  f.bounds[i].bound
	return loops

####################
 # FUNCTION list_of_topology_reversed #
####################
def list_of_topology_reversed(a_list,):
	'''
	:param a_list
	:type a_list:list_of_reversible_topology_item
	'''
	the_reverse = []
	for  i in range(1,SIZEOF(a_list),1):
		the_reverse = topology_reversed(a_list[i])  +  the_reverse
	return the_reverse

####################
 # FUNCTION msf_curve_check #
####################
def msf_curve_check(cv,):
	'''
	:param cv
	:type cv:representation_item
	'''
	if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOUNDED_CURVE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CONIC','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_REPLICA','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_CURVE_3D']  *  TYPEOF(cv))  >  1):
		return FALSE
	if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_CURVE'  ==  TYPEOF(cv))  and  (cv.b_spline_curve.self_intersect  ==  FALSE))  or  (cv.b_spline_curve.self_intersect  ==  UNKNOWN)):
		return TRUE
	else:
		if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CONIC','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINE']  *  TYPEOF(cv))  ==  1):
			return TRUE
		else:
			if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_REPLICA'  ==  TYPEOF(cv)):
				return msf_curve_check(cv.curve_replica.parent_curve)
			else:
				if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_CURVE_3D'  ==  TYPEOF(cv))  and  ((cv.offset_curve_3d.self_intersect  ==  FALSE)  or  (cv.offset_curve_3d.self_intersect  ==  UNKNOWN)))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE'  ==  TYPEOF(cv.offset_curve_3d.basis_curve)))):
					return msf_curve_check(cv.offset_curve_3d.basis_curve)
				else:
					if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(cv)):
						return msf_curve_check(cv.pcurve.reference_to_curve.representation.items[1])  and  msf_surface_check(cv.pcurve.basis_surface)
					else:
						if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_CURVE'  ==  TYPEOF(cv)):
							if (msf_curve_check(cv.surface_curve.curve_3d)):
								for  i in range(1,SIZEOF(cv.surface_curve.associated_geometry),1):
									if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
										if ( not msf_surface_check(cv.surface_curve.associated_geometry[i])):
											return FALSE
									else:
										if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
											if ( not msf_curve_check(cv.surface_curve.associated_geometry[i])):
												return FALSE
								return TRUE
						else:
							if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE'  ==  TYPEOF(cv)):
								if (SIZEOF(cv.polyline.points)  >=  3):
									return TRUE
	return FALSE

####################
 # FUNCTION shell_reversed #
####################
def shell_reversed(a_shell,):
	'''
	:param a_shell
	:type a_shell:shell
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OPEN_SHELL'  ==  TYPEOF(a_shell)):
		return open_shell_reversed(a_shell)
	else:
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CLOSED_SHELL'  ==  TYPEOF(a_shell)):
			return closed_shell_reversed(a_shell)
		else:
			return  None 

####################
 # FUNCTION topology_reversed #
####################
def topology_reversed(an_item,):
	'''
	:param an_item
	:type an_item:reversible_topology
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.EDGE'  ==  TYPEOF(an_item)):
		return edge_reversed(an_item)
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PATH'  ==  TYPEOF(an_item)):
		return path_reversed(an_item)
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.FACE_BOUND'  ==  TYPEOF(an_item)):
		return face_bound_reversed(an_item)
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.FACE'  ==  TYPEOF(an_item)):
		return face_reversed(an_item)
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SHELL'  ==  TYPEOF(an_item)):
		return shell_reversed(an_item)
	if ('SET'  ==  TYPEOF(an_item)):
		return set_of_topology_reversed(an_item)
	if ('LIST'  ==  TYPEOF(an_item)):
		return list_of_topology_reversed(an_item)
	return  None 

####################
 # FUNCTION first_proj_axis #
####################
def first_proj_axis(z_axis,arg,):
	'''
	:param z_axis
	:type z_axis:direction
	:param arg
	:type arg:direction
	'''
	if ( not EXISTS(z_axis)):
		return  None 
	else:
		z = normalise(z_axis)
		if ( not EXISTS(arg)):
			if ((z.direction_ratios  !=  [1,0,0])  and  (z.direction_ratios  !=  [-1,0,0])):
				v = dummy_gri  ==  direction([1,0,0])
			else:
				v = dummy_gri  ==  direction([0,1,0])
		else:
			if (arg.dim  !=  3):
				return  None 
			if (cross_product(arg,z).magnitude  ==  0):
				return  None 
			else:
				v = normalise(arg)
		x_vec = scalar_times_vector(dot_product(v,z),z)
		x_axis = vector_difference(v,x_vec).orientation
		x_axis = normalise(x_axis)
	return x_axis

####################
 # FUNCTION acyclic_composite_text #
####################
def acyclic_composite_text(start_composite,child_text,):
	'''
	:param start_composite
	:type start_composite:composite_text
	:param child_text
	:type child_text:(null)
	'''
	local_composite_text = None
	if (SIZEOF(local_composite_text)  >  0):
		for  i in range(1,HIINDEX(local_composite_text),1):
			if (start_composite  ==  local_composite_text[i]):
				return FALSE
	local_children = child_text
	if (SIZEOF(local_composite_text)  >  0):
		for  i in range(1,HIINDEX(local_composite_text),1):
			local_children = local_children  +  local_composite_text[i].collected_text
	local_annotation_text = None
	if (SIZEOF(local_annotation_text)  >  0):
		for  i in range(1,HIINDEX(local_annotation_text),1):
			local_children = local_children  +  None
	if (local_children  !=  child_text):
		return acyclic_composite_text(start_composite,local_children)
	else:
		return TRUE

####################
 # FUNCTION get_shape_aspect_property_definition_representations #
####################
def get_shape_aspect_property_definition_representations(s_a_instance,):
	'''
	:param s_a_instance
	:type s_a_instance:shape_aspect
	'''
	pd_set = bag_to_set(USEDIN(s_a_instance,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PROPERTY_DEFINITION.DEFINITION'))
	if (SIZEOF(pd_set)  <  1):
		return pdr_set
	for  i in range(1,HIINDEX(pd_set),1):
		pdr_set = pdr_set  +  None
	return pdr_set

####################
 # FUNCTION orthogonal_complement #
####################
def orthogonal_complement(vec,):
	'''
	:param vec
	:type vec:direction
	'''
	if ((vec.dim  !=  2)  or  ( not EXISTS(vec))):
		return  None 
	else:
		result = dummy_gri  ==  direction([-vec.direction_ratios[2],vec.direction_ratios[1]])
		return result

####################
 # FUNCTION acyclic_representation_relationship #
####################
def acyclic_representation_relationship(relation,relatives,specific_relation,):
	'''
	:param relation
	:type relation:representation_relationship
	:param relatives
	:type relatives:(null)
	:param specific_relation
	:type specific_relation:STRING
	'''
	if (relation.rep_1  ==  relatives):
		return FALSE
	x = None
	for  i in range(1,HIINDEX(x),1):
		if ( not acyclic_representation_relationship(x[i],relatives  +  relation.rep_1,specific_relation)):
			return FALSE
	return TRUE

####################
 # FUNCTION make_array_of_array #
####################
def make_array_of_array(lis,low1,u1,low2,u2,):
	'''
	:param lis
	:type lis:(null)
	:param low1
	:type low1:INTEGER
	:param u1
	:type u1:INTEGER
	:param low2
	:type low2:INTEGER
	:param u2
	:type u2:INTEGER
	'''
	if (((u1 - low1)  +  1)  !=  SIZEOF(lis)):
		return  None 
	if (((u2 - low2)  +  1)  !=  SIZEOF(lis[1])):
		return  None 
	res = [list_to_array(lis[1],low2,u2),(u1 - low1)  +  1]
	for  i in range(2,HIINDEX(lis),1):
		if (((u2 - low2)  +  1)  !=  SIZEOF(lis[i])):
			return  None 
		res[(low1  +  i) - 1] = list_to_array(lis[i],low2,u2)
	return res

####################
 # FUNCTION compute_total_depth #
####################
def compute_total_depth(swsrh,):
	'''
	:param swsrh
	:type swsrh:solid_with_stepped_round_hole
	'''
	if (n  ==  1):
		return td
	else:
		for  i in range(2,n,1):
			td = td  +  swsrh.segment_depths[i]
	return td

####################
 # FUNCTION second_proj_axis #
####################
def second_proj_axis(z_axis,x_axis,arg,):
	'''
	:param z_axis
	:type z_axis:direction
	:param x_axis
	:type x_axis:direction
	:param arg
	:type arg:direction
	'''
	if ( not EXISTS(arg)):
		v = dummy_gri  ==  direction([0,1,0])
	else:
		v = arg
	temp = scalar_times_vector(dot_product(v,z_axis),z_axis)
	y_axis = vector_difference(v,temp)
	temp = scalar_times_vector(dot_product(v,x_axis),x_axis)
	y_axis = vector_difference(y_axis,temp)
	y_axis = normalise(y_axis)
	return y_axis.orientation

####################
 # FUNCTION bag_to_set #
####################
def bag_to_set(the_bag,):
	'''
	:param the_bag
	:type the_bag:(null)
	'''
	if (SIZEOF(the_bag)  >  0):
		for  i in range(1,HIINDEX(the_bag),1):
			the_set = the_set  +  the_bag[i]
	return the_set

####################
 # FUNCTION valid_wireframe_edge_curve #
####################
def valid_wireframe_edge_curve(crv,):
	'''
	:param crv
	:type crv:curve
	'''
	if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CONIC','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_CURVE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE']  *  TYPEOF(crv))  ==  1):
		return TRUE
	else:
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_REPLICA'  ==  TYPEOF(crv)):
			return valid_wireframe_edge_curve(crv.curve_replica.parent_curve)
		else:
			if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_CURVE_3D'  ==  TYPEOF(crv)):
				return valid_wireframe_edge_curve(crv.offset_curve_3d.basis_curve)
	return FALSE

####################
 # FUNCTION surface_weights_positive #
####################
def surface_weights_positive(b,):
	'''
	:param b
	:type b:rational_b_spline_surface
	'''
	for  i in range(0,b.u_upper,1):
		for  j in range(0,b.v_upper,1):
			if (b.weights[i][j]  <=  0):
				result = FALSE
				return result
	return result

####################
 # FUNCTION vector_difference #
####################
def vector_difference(arg1,arg2,):
	'''
	:param arg1
	:type arg1:vector_or_direction
	:param arg2
	:type arg2:vector_or_direction
	'''
	if ((( not EXISTS(arg1))  or  ( not EXISTS(arg2)))  or  (arg1.dim  !=  arg2.dim)):
		return  None 
	else:
		# begin/end block
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VECTOR'  ==  TYPEOF(arg1)):
			mag1 = arg1.magnitude
			vec1 = arg1.vector.orientation
		else:
			mag1 = 1
			vec1 = arg1
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VECTOR'  ==  TYPEOF(arg2)):
			mag2 = arg2.magnitude
			vec2 = arg2.vector.orientation
		else:
			mag2 = 1
			vec2 = arg2
		vec1 = normalise(vec1)
		vec2 = normalise(vec2)
		ndim = SIZEOF(vec1.direction_ratios)
		mag = 0
		res = dummy_gri  ==  direction(vec1.direction_ratios)
		for  i in range(1,ndim,1):
			res.direction_ratios[i] = (mag1  *  vec1.direction_ratios[i]) - (mag2  *  vec2.direction_ratios[i])
			mag = mag  +  (res.direction_ratios[i]  *  res.direction_ratios[i])
		if (mag  >  0):
			result = dummy_gri  ==  vector(res,SQRT(mag))
		else:
			result = dummy_gri  ==  vector(vec1,0)
	return result

####################
 # FUNCTION advanced_face_properties #
####################
def advanced_face_properties(testface,):
	'''
	:param testface
	:type testface:face
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ADVANCED_FACE'  ==  TYPEOF(testface)):
		return TRUE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SUBFACE'  ==  TYPEOF(testface)):
		return advanced_face_properties(testface.subface.parent_face)
	else:
		return FALSE

####################
 # FUNCTION external_version_assignment_is_valid #
####################
def external_version_assignment_is_valid(aia,):
	'''
	:param aia
	:type aia:applied_external_identification_assignment
	'''
	role = aia.role
	if (role.name  ==  'version'):
		for  i in range(LOINDEX(aia.items),HIINDEX(aia.items),1):
			item = aia.items[i]
			if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'EXTERNALLY_VERSIONED_ITEM']  *  TYPEOF(item))  ==  0):
				return FALSE
		return TRUE
	else:
		return TRUE

####################
 # FUNCTION value_range_wr1 #
####################
def value_range_wr1(agg,):
	'''
	:param agg
	:type agg:compound_item_definition
	'''
	# begin/end block
	if ((SIZEOF(agg)  ==  2)  and  ((SIZEOF(None)  ==  2)  or  (SIZEOF(None)  ==  2))):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION value_range_wr3 #
####################
def value_range_wr3(agg,):
	'''
	:param agg
	:type agg:compound_item_definition
	'''
	# begin/end block
	if (SIZEOF(None)  ==  2):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION acyclic_product_definition_relationship #
####################
def acyclic_product_definition_relationship(relation,relatives,specific_relation,):
	'''
	:param relation
	:type relation:product_definition_relationship
	:param relatives
	:type relatives:(null)
	:param specific_relation
	:type specific_relation:STRING
	'''
	if (relation.relating_product_definition  ==  relatives):
		return FALSE
	x = None
	for  i in range(1,HIINDEX(x),1):
		if ( not acyclic_product_definition_relationship(x[i],relatives  +  relation.relating_product_definition,specific_relation)):
			return FALSE
	return TRUE

####################
 # FUNCTION value_range_wr2 #
####################
def value_range_wr2(agg,):
	'''
	:param agg
	:type agg:compound_item_definition
	'''
	# begin/end block
	if ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1)):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION constraints_geometry_shell_based_wireframe_model #
####################
def constraints_geometry_shell_based_wireframe_model(m,):
	'''
	:param m
	:type m:shell_based_wireframe_model
	'''
	for  j in range(1,SIZEOF(m.sbwm_boundary),1):
		if (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.WIRE_SHELL'  ==  TYPEOF(m.sbwm_boundary[j])))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VERTEX_SHELL'  ==  TYPEOF(m.sbwm_boundary[j])))):
			result = FALSE
			return result
	return result

####################
 # FUNCTION list_to_set #
####################
def list_to_set(l,):
	'''
	:param l
	:type l:(null)
	'''
	for  i in range(1,SIZEOF(l),1):
		s = s  +  l[i]
	return s

####################
 # FUNCTION valid_calendar_date #
####################
def valid_calendar_date(date,):
	'''
	:param date
	:type date:calendar_date
	'''
	case_selector = date.month_component
	if  case_selector == 1:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 2:
		# begin/end block
		if (leap_year(date.year_component)):
			return (1  <=  date.day_component)  and  (date.day_component  <=  29)
		else:
			return (1  <=  date.day_component)  and  (date.day_component  <=  28)
	elif case_selector == 3:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 4:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 5:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 6:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 7:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 8:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 9:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 10:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	elif case_selector == 11:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 12:
		return (1  <=  date.day_component)  and  (date.day_component  <=  31)
	return FALSE

####################
 # FUNCTION valid_wireframe_vertex_point #
####################
def valid_wireframe_vertex_point(pnt,):
	'''
	:param pnt
	:type pnt:point
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CARTESIAN_POINT'  ==  TYPEOF(pnt)):
		return TRUE
	else:
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POINT_REPLICA'  ==  TYPEOF(pnt)):
			return valid_wireframe_vertex_point(pnt.point_replica.parent_pt)
	return FALSE

####################
 # FUNCTION list_to_array #
####################
def list_to_array(lis,low,u,):
	'''
	:param lis
	:type lis:(null)
	:param low
	:type low:INTEGER
	:param u
	:type u:INTEGER
	'''
	n = SIZEOF(lis)
	if (n  !=  ((u - low)  +  1)):
		return  None 
	else:
		res = [lis[1],n]
		for  i in range(2,n,1):
			res[(low  +  i) - 1] = lis[i]
		return res

####################
 # FUNCTION using_items #
####################
def using_items(item,checked_items,):
	'''
	:param item
	:type item:founded_item_select
	:param checked_items
	:type checked_items:(null)
	'''
	result_items = []
	new_check_items = checked_items  +  item
	next_items = None
	if (SIZEOF(next_items)  >  0):
		for  i in range(1,HIINDEX(next_items),1):
			if ( not (next_items[i]  ==  new_check_items)):
				result_items = (result_items  +  next_items[i])  +  using_items(next_items[i],new_check_items)
	return result_items

####################
 # FUNCTION valid_basis_curve_in_2d_wireframe #
####################
def valid_basis_curve_in_2d_wireframe(crv,):
	'''
	:param crv
	:type crv:curve
	'''
	if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_CURVE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELLIPSE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CIRCLE']  *  TYPEOF(crv))  ==  1):
		return TRUE
	else:
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TRIMMED_CURVE'  ==  TYPEOF(crv)):
			if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PARABOLA','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.HYPERBOLA']  *  TYPEOF(crv.trimmed_curve.basis_curve))  ==  1):
				return TRUE
			else:
				return valid_basis_curve_in_2d_wireframe(crv.trimmed_curve.basis_curve)
		else:
			if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_CURVE_2D'  ==  TYPEOF(crv)):
				return valid_basis_curve_in_2d_wireframe(crv.offset_curve_2d.basis_curve)
			else:
				if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_REPLICA'  ==  TYPEOF(crv)):
					return valid_basis_curve_in_2d_wireframe(crv.curve_replica.parent_curve)
				else:
					if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_CURVE'  ==  TYPEOF(crv)):
						return SIZEOF(None)  ==  0
	return FALSE

####################
 # FUNCTION constraints_geometry_shell_based_surface_model #
####################
def constraints_geometry_shell_based_surface_model(m,):
	'''
	:param m
	:type m:shell_based_surface_model
	'''
	for  j in range(1,SIZEOF(m.sbsm_boundary),1):
		if (( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OPEN_SHELL'  ==  TYPEOF(m.sbsm_boundary[j])))  and  ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CLOSED_SHELL'  ==  TYPEOF(m.sbsm_boundary[j])))):
			result = FALSE
			return result
	return result

####################
 # FUNCTION face_bound_reversed #
####################
def face_bound_reversed(a_face_bound,):
	'''
	:param a_face_bound
	:type a_face_bound:face_bound
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.FACE_OUTER_BOUND'  ==  TYPEOF(a_face_bound)):
		the_reverse = (dummy_tri  ==  face_bound(a_face_bound.face_bound.bound, not a_face_bound.face_bound.orientation))  ==  face_outer_bound()
	else:
		the_reverse = dummy_tri  ==  face_bound(a_face_bound.bound, not a_face_bound.orientation)
	return the_reverse

####################
 # FUNCTION acyclic #
####################
def acyclic(arg1,arg2,):
	'''
	:param arg1
	:type arg1:generic_expression
	:param arg2
	:type arg2:(null)
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SIMPLE_GENERIC_EXPRESSION'  ==  TYPEOF(arg1)):
		return TRUE
	if (arg1  ==  arg2):
		return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.UNARY_GENERIC_EXPRESSION'  ==  TYPEOF(arg1)):
		return acyclic(arg1.unary_generic_expression.operand,arg2  +  [arg1])
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BINARY_GENERIC_EXPRESSION'  ==  TYPEOF(arg1)):
		return acyclic(arg1.binary_generic_expression.operands[1],arg2  +  [arg1])  and  acyclic(arg1.binary_generic_expression.operands[2],arg2  +  [arg1])
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION'  ==  TYPEOF(arg1)):
		result = TRUE
		for  i in range(1,SIZEOF(arg1.multiple_arity_generic_expression.operands),1):
			result = result  and  acyclic(arg1.multiple_arity_generic_expression.operands[i],arg2  +  [arg1])
		return result
	return result

####################
 # FUNCTION set_of_topology_reversed #
####################
def set_of_topology_reversed(a_set,):
	'''
	:param a_set
	:type a_set:set_of_reversible_topology_item
	'''
	the_reverse = []
	for  i in range(1,SIZEOF(a_set),1):
		the_reverse = the_reverse  +  topology_reversed(a_set[i])
	return the_reverse

####################
 # FUNCTION is_int_expr #
####################
def is_int_expr(arg,):
	'''
	:param arg
	:type arg:numeric_expression
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.INT_LITERAL'  ==  TYPEOF(arg)):
		return TRUE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.REAL_LITERAL'  ==  TYPEOF(arg)):
		return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.INT_NUMERIC_VARIABLE'  ==  TYPEOF(arg)):
		return TRUE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.REAL_NUMERIC_VARIABLE'  ==  TYPEOF(arg)):
		return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ABS_FUNCTION'  ==  TYPEOF(arg)):
		return is_int_expr(arg.unary_numeric_expression.operand)
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MINUS_FUNCTION'  ==  TYPEOF(arg)):
		return is_int_expr(arg.unary_numeric_expression.operand)
	if ((((((((((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SIN_FUNCTION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COS_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TAN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ASIN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ACOS_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ATAN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.EXP_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LOG_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LOG2_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LOG10_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SQUARE_ROOT_FUNCTION'  ==  TYPEOF(arg))):
		return FALSE
	if (((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLUS_EXPRESSION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MULT_EXPRESSION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MAXIMUM_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MINIMUM_FUNCTION'  ==  TYPEOF(arg))):
		for  i in range(1,SIZEOF(arg.multiple_arity_numeric_expression.operands),1):
			if ( not is_int_expr(arg.multiple_arity_numeric_expression.operands[i])):
				return FALSE
		return TRUE
	if (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MINUS_EXPRESSION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POWER_EXPRESSION'  ==  TYPEOF(arg))):
		return is_int_expr(arg.binary_numeric_expression.operands[1])  and  is_int_expr(arg.binary_numeric_expression.operands[2])
	if (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIV_EXPRESSION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MOD_EXPRESSION'  ==  TYPEOF(arg))):
		return TRUE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SLASH_EXPRESSION'  ==  TYPEOF(arg)):
		return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_FUNCTION'  ==  TYPEOF(arg)):
		return TRUE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VALUE_FUNCTION'  ==  TYPEOF(arg)):
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.INT_VALUE_FUNCTION'  ==  TYPEOF(arg)):
			return TRUE
		else:
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.INTEGER_DEFINED_FUNCTION'  ==  TYPEOF(arg)):
		return TRUE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.REAL_DEFINED_FUNCTION'  ==  TYPEOF(arg)):
		return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOOLEAN_DEFINED_FUNCTION'  ==  TYPEOF(arg)):
		return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.STRING_DEFINED_FUNCTION'  ==  TYPEOF(arg)):
		return FALSE
	return FALSE

####################
 # FUNCTION dimension_of #
####################
def dimension_of(item,):
	'''
	:param item
	:type item:geometric_representation_item
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CARTESIAN_POINT'  ==  TYPEOF(item)):
		dim = SIZEOF(item.cartesian_point.coordinates)
		return dim
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIRECTION'  ==  TYPEOF(item)):
		dim = SIZEOF(item.direction.direction_ratios)
		return dim
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VECTOR'  ==  TYPEOF(item)):
		dim = SIZEOF(item.vector.orientation.direction.direction_ratios)
		return dim
	x = using_representations(item)
	y = x[1].context_of_items
	dim = y.geometric_representation_context.coordinate_space_dimension
	return dim

####################
 # FUNCTION scalar_times_vector #
####################
def scalar_times_vector(scalar,vec,):
	'''
	:param scalar
	:type scalar:REAL
	:param vec
	:type vec:vector_or_direction
	'''
	if (( not EXISTS(scalar))  or  ( not EXISTS(vec))):
		return  None 
	else:
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VECTOR'  ==  TYPEOF(vec)):
			v = dummy_gri  ==  direction(vec.vector.orientation.direction_ratios)
			mag = scalar  *  vec.magnitude
		else:
			v = dummy_gri  ==  direction(vec.direction_ratios)
			mag = scalar
		if (mag  <  0):
			for  i in range(1,SIZEOF(v.direction_ratios),1):
				v.direction_ratios[i] = -v.direction_ratios[i]
			mag = -mag
		result = dummy_gri  ==  vector(normalise(v),mag)
	return result

####################
 # FUNCTION dimensions_for_si_unit #
####################
def dimensions_for_si_unit(n,):
	'''
	:param n
	:type n:si_unit_name
	'''
	case_selector = n
	if  case_selector == metre:
		return dimensional_exponents(1,0,0,0,0,0,0)
	elif case_selector == gram:
		return dimensional_exponents(0,1,0,0,0,0,0)
	elif case_selector == second:
		return dimensional_exponents(0,0,1,0,0,0,0)
	elif case_selector == ampere:
		return dimensional_exponents(0,0,0,1,0,0,0)
	elif case_selector == kelvin:
		return dimensional_exponents(0,0,0,0,1,0,0)
	elif case_selector == mole:
		return dimensional_exponents(0,0,0,0,0,1,0)
	elif case_selector == candela:
		return dimensional_exponents(0,0,0,0,0,0,1)
	elif case_selector == radian:
		return dimensional_exponents(0,0,0,0,0,0,0)
	elif case_selector == steradian:
		return dimensional_exponents(0,0,0,0,0,0,0)
	elif case_selector == hertz:
		return dimensional_exponents(0,0,-1,0,0,0,0)
	elif case_selector == newton:
		return dimensional_exponents(1,1,-2,0,0,0,0)
	elif case_selector == pascal:
		return dimensional_exponents(-1,1,-2,0,0,0,0)
	elif case_selector == joule:
		return dimensional_exponents(2,1,-2,0,0,0,0)
	elif case_selector == watt:
		return dimensional_exponents(2,1,-3,0,0,0,0)
	elif case_selector == coulomb:
		return dimensional_exponents(0,0,1,1,0,0,0)
	elif case_selector == volt:
		return dimensional_exponents(2,1,-3,-1,0,0,0)
	elif case_selector == farad:
		return dimensional_exponents(-2,-1,4,1,0,0,0)
	elif case_selector == ohm:
		return dimensional_exponents(2,1,-3,-2,0,0,0)
	elif case_selector == siemens:
		return dimensional_exponents(-2,-1,3,2,0,0,0)
	elif case_selector == weber:
		return dimensional_exponents(2,1,-2,-1,0,0,0)
	elif case_selector == tesla:
		return dimensional_exponents(0,1,-2,-1,0,0,0)
	elif case_selector == henry:
		return dimensional_exponents(2,1,-2,-2,0,0,0)
	elif case_selector == degree_celsius:
		return dimensional_exponents(0,0,0,0,1,0,0)
	elif case_selector == lumen:
		return dimensional_exponents(0,0,0,0,0,0,1)
	elif case_selector == lux:
		return dimensional_exponents(-2,0,0,0,0,0,1)
	elif case_selector == becquerel:
		return dimensional_exponents(0,0,-1,0,0,0,0)
	elif case_selector == gray:
		return dimensional_exponents(2,0,-2,0,0,0,0)
	elif case_selector == sievert:
		return dimensional_exponents(2,0,-2,0,0,0,0)
	else:
		return  None 

####################
 # FUNCTION surface_condition_correlation #
####################
def surface_condition_correlation(pd,rep,):
	'''
	:param pd
	:type pd:property_definition
	:param rep
	:type rep:representation
	'''
	case_selector = pd.name
	if  case_selector == 'visual appearance':
		return pd.name  ==  rep.name
	elif case_selector == 'tactile appearance':
		return pd.name  ==  rep.name
	elif case_selector == 'contact ratio':
		return pd.name  ==  rep.name
	elif case_selector == 'hardness':
		return pd.name  ==  rep.name
	elif case_selector == 'treatment result':
		return pd.name  ==  rep.name
	elif case_selector == 'surface texture':
		return pd.name  ==  rep.name
	else:
		return UNKNOWN

####################
 # FUNCTION open_shell_reversed #
####################
def open_shell_reversed(a_shell,):
	'''
	:param a_shell
	:type a_shell:open_shell
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORIENTED_OPEN_SHELL'  ==  TYPEOF(a_shell)):
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  open_shell())  ==  oriented_open_shell(a_shell.oriented_open_shell.open_shell_element, not a_shell.oriented_open_shell.orientation)
	else:
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  open_shell())  ==  oriented_open_shell(a_shell,FALSE)
	return the_reverse

####################
 # FUNCTION acyclic_surface_replica #
####################
def acyclic_surface_replica(rep,parent,):
	'''
	:param rep
	:type rep:surface_replica
	:param parent
	:type parent:surface
	'''
	if ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_REPLICA'  ==  TYPEOF(parent))):
		return TRUE
	if (parent  ==  rep):
		return FALSE
	else:
		return acyclic_surface_replica(rep,parent.surface_replica.parent_surface)

####################
 # FUNCTION gbsf_check_surface #
####################
def gbsf_check_surface(sf,):
	'''
	:param sf
	:type sf:surface
	'''
	if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_SURFACE'  ==  TYPEOF(sf))  and  (sf.b_spline_surface.self_intersect  ==  FALSE))  or  (sf.b_spline_surface.self_intersect  ==  UNKNOWN)):
		return TRUE
	else:
		if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SPHERICAL_SURFACE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TOROIDAL_SURFACE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_BOUNDED_SURFACE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RECTANGULAR_TRIMMED_SURFACE']  *  TYPEOF(sf))  ==  1):
			return TRUE
		else:
			if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_SURFACE'  ==  TYPEOF(sf))  and  (sf.offset_surface.self_intersect  ==  FALSE))  or  (sf.offset_surface.self_intersect  ==  UNKNOWN)):
				return gbsf_check_surface(sf.offset_surface.basis_surface)
			else:
				if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RECTANGULAR_COMPOSITE_SURFACE'  ==  TYPEOF(sf)):
					for  i in range(1,SIZEOF(sf.rectangular_composite_surface.segments),1):
						for  j in range(1,SIZEOF(sf.rectangular_composite_surface.segments[i]),1):
							if ( not gbsf_check_surface(sf.rectangular_composite_surface.segments[i][j].parent_surface)):
								return FALSE
					return TRUE
				else:
					if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_REPLICA'  ==  TYPEOF(sf)):
						return gbsf_check_surface(sf.surface_replica.parent_surface)
					else:
						if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_OF_REVOLUTION'  ==  TYPEOF(sf)):
							return gbsf_check_curve(sf.swept_surface.swept_curve)
	return FALSE

####################
 # FUNCTION msf_surface_check #
####################
def msf_surface_check(surf,):
	'''
	:param surf
	:type surf:surface
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELEMENTARY_SURFACE'  ==  TYPEOF(surf)):
		return TRUE
	else:
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SWEPT_SURFACE'  ==  TYPEOF(surf)):
			return msf_curve_check(surf.swept_surface.swept_curve)
		else:
			if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_SURFACE'  ==  TYPEOF(surf))  and  (surf.offset_surface.self_intersect  ==  FALSE))  or  (surf.offset_surface.self_intersect  ==  UNKNOWN)):
				return msf_surface_check(surf.offset_surface.basis_surface)
			else:
				if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_REPLICA'  ==  TYPEOF(surf)):
					return msf_surface_check(surf.surface_replica.parent_surface)
				else:
					if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_SURFACE'  ==  TYPEOF(surf))  and  (surf.b_spline_surface.self_intersect  ==  FALSE))  or  (surf.b_spline_surface.self_intersect  ==  UNKNOWN)):
						return TRUE
	return FALSE

####################
 # FUNCTION normalise #
####################
def normalise(arg,):
	'''
	:param arg
	:type arg:vector_or_direction
	'''
	if ( not EXISTS(arg)):
		result =  None 
	else:
		ndim = arg.dim
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VECTOR'  ==  TYPEOF(arg)):
			# begin/end block
			v = dummy_gri  ==  direction(arg.vector.orientation.direction_ratios)
			if (arg.magnitude  ==  0):
				return  None 
			else:
				vec = dummy_gri  ==  vector(v,1)
		else:
			v = dummy_gri  ==  direction(arg.direction_ratios)
		mag = 0
		for  i in range(1,ndim,1):
			mag = mag  +  (v.direction_ratios[i]  *  v.direction_ratios[i])
		if (mag  >  0):
			mag = SQRT(mag)
			for  i in range(1,ndim,1):
				v.direction_ratios[i] = v.direction_ratios[i] / mag
			if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VECTOR'  ==  TYPEOF(arg)):
				vec.orientation = v
				result = vec
			else:
				result = v
		else:
			return  None 
	return result

####################
 # FUNCTION msb_shells #
####################
def msb_shells(brep,):
	'''
	:param brep
	:type brep:manifold_solid_brep
	'''
	if (SIZEOF(None)  >=  1):
		return_set = return_set  +  brep.brep_with_voids.voids
	return return_set

####################
 # FUNCTION nmsf_surface_check #
####################
def nmsf_surface_check(surf,):
	'''
	:param surf
	:type surf:surface
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELEMENTARY_SURFACE'  ==  TYPEOF(surf)):
		return TRUE
	else:
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SWEPT_SURFACE'  ==  TYPEOF(surf)):
			return nmsf_curve_check(surf.swept_surface.swept_curve)
		else:
			if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_SURFACE'  ==  TYPEOF(surf))  and  (surf.offset_surface.self_intersect  ==  FALSE))  or  (surf.offset_surface.self_intersect  ==  UNKNOWN)):
				return nmsf_surface_check(surf.offset_surface.basis_surface)
			else:
				if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SURFACE_REPLICA'  ==  TYPEOF(surf)):
					return nmsf_surface_check(surf.surface_replica.parent_surface)
				else:
					if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_SURFACE'  ==  TYPEOF(surf))  and  (surf.b_spline_surface.self_intersect  ==  FALSE))  or  (surf.b_spline_surface.self_intersect  ==  UNKNOWN)):
						return TRUE
	return FALSE

####################
 # FUNCTION mixed_loop_type_set #
####################
def mixed_loop_type_set(l,):
	'''
	:param l
	:type l:(null)
	'''
	if (SIZEOF(l)  <=  1):
		return FALSE
	poly_loop_type = 'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLY_LOOP'  ==  TYPEOF(l[1])
	for  i in range(2,SIZEOF(l),1):
		if (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLY_LOOP'  ==  TYPEOF(l[i]))  !=  poly_loop_type):
			return TRUE
	return FALSE

####################
 # FUNCTION derive_dimensional_exponents #
####################
def derive_dimensional_exponents(x,):
	'''
	:param x
	:type x:unit
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DERIVED_UNIT'  ==  TYPEOF(x)):
		for  i in range(LOINDEX(x.derived_unit.elements),HIINDEX(x.derived_unit.elements),1):
			result.length_exponent = result.length_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.length_exponent)
			result.mass_exponent = result.mass_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.mass_exponent)
			result.time_exponent = result.time_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.time_exponent)
			result.electric_current_exponent = result.electric_current_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.electric_current_exponent)
			result.thermodynamic_temperature_exponent = result.thermodynamic_temperature_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.thermodynamic_temperature_exponent)
			result.amount_of_substance_exponent = result.amount_of_substance_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.amount_of_substance_exponent)
			result.luminous_intensity_exponent = result.luminous_intensity_exponent  +  (x.derived_unit.elements[i].derived_unit_element.exponent  *  x.derived_unit.elements[i].derived_unit_element.unit.named_unit.dimensions.luminous_intensity_exponent)
	else:
		result = x.named_unit.dimensions
	return result

####################
 # FUNCTION curve_weights_positive #
####################
def curve_weights_positive(b,):
	'''
	:param b
	:type b:rational_b_spline_curve
	'''
	for  i in range(0,b.upper_index_on_control_points,1):
		if (b.weights[i]  <=  0):
			result = FALSE
			return result
	return result

####################
 # FUNCTION type_check_function #
####################
def type_check_function(the_type,sub_names,criterion,):
	'''
	:param the_type
	:type the_type:(null)
	:param sub_names
	:type sub_names:(null)
	:param criterion
	:type criterion:INTEGER
	'''
	if ((( not EXISTS(the_type))  or  ( not ((0  <=  criterion)  and  (criterion  <=  3))))  or  (SIZEOF(sub_names)  ==  0)):
		return UNKNOWN
	else:
		case_selector = criterion
		if  case_selector == 0:
			return SIZEOF(sub_names  *  TYPEOF(the_type))  >  0
		elif case_selector == 1:
			return SIZEOF(sub_names  *  TYPEOF(the_type))  ==  0
		elif case_selector == 2:
			return SIZEOF(sub_names  *  TYPEOF(the_type))  ==  1
		elif case_selector == 3:
			return SIZEOF(sub_names  *  TYPEOF(the_type))  <=  1

####################
 # FUNCTION valid_geometrically_bounded_wf_point #
####################
def valid_geometrically_bounded_wf_point(pnt,):
	'''
	:param pnt
	:type pnt:point
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CARTESIAN_POINT'  ==  TYPEOF(pnt)):
		return TRUE
	else:
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POINT_ON_CURVE'  ==  TYPEOF(pnt)):
			return valid_geometrically_bounded_wf_curve(pnt.point_on_curve.basis_curve)
		else:
			if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POINT_REPLICA'  ==  TYPEOF(pnt)):
				return valid_geometrically_bounded_wf_point(pnt.point_replica.parent_pt)
	return FALSE

####################
 # FUNCTION path_head_to_tail #
####################
def path_head_to_tail(a_path,):
	'''
	:param a_path
	:type a_path:path
	'''
	n = SIZEOF(a_path.edge_list)
	for  i in range(2,n,1):
		p = p  and  (a_path.edge_list[i - 1].edge_end  ==  a_path.edge_list[i].edge_start)
	return p

####################
 # FUNCTION path_reversed #
####################
def path_reversed(a_path,):
	'''
	:param a_path
	:type a_path:path
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORIENTED_PATH'  ==  TYPEOF(a_path)):
		the_reverse = (dummy_tri  ==  path(list_of_topology_reversed(a_path.edge_list)))  ==  oriented_path(a_path.oriented_path.path_element, not a_path.oriented_path.orientation)
	else:
		the_reverse = (dummy_tri  ==  path(list_of_topology_reversed(a_path.edge_list)))  ==  oriented_path(a_path,FALSE)
	return the_reverse

####################
 # FUNCTION get_id_value #
####################
def get_id_value(obj,):
	'''
	:param obj
	:type obj:id_attribute_select
	'''
	if (SIZEOF(id_bag)  ==  1):
		return id_bag[1].attribute_value
	else:
		return  None 

####################
 # FUNCTION aspect_ratio #
####################
def aspect_ratio(p,):
	'''
	:param p
	:type p:planar_box
	'''
	if ((p.size_in_x  >  0)  and  (p.size_in_y  >  0)):
		return p.size_in_x / p.size_in_y
	else:
		return  None 

####################
 # FUNCTION is_acyclic #
####################
def is_acyclic(arg,):
	'''
	:param arg
	:type arg:generic_expression
	'''
	return acyclic(arg,[])

####################
 # FUNCTION check_text_alignment #
####################
def check_text_alignment(ct,):
	'''
	:param ct
	:type ct:composite_text
	'''
	for  i in range(1,HIINDEX(ct.collected_text),1):
		a = a  +  [ct.collected_text[i].text_literal.alignment]
	return SIZEOF(a)  ==  1

####################
 # FUNCTION leap_year #
####################
def leap_year(year,):
	'''
	:param year
	:type year:INTEGER
	'''
	if ((((year  %  4)  ==  0)  and  ((year  %  100)  !=  0))  or  ((year  %  400)  ==  0)):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION face_reversed #
####################
def face_reversed(a_face,):
	'''
	:param a_face
	:type a_face:face
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORIENTED_FACE'  ==  TYPEOF(a_face)):
		the_reverse = (dummy_tri  ==  face(set_of_topology_reversed(a_face.bounds)))  ==  oriented_face(a_face.oriented_face.face_element, not a_face.oriented_face.orientation)
	else:
		the_reverse = (dummy_tri  ==  face(set_of_topology_reversed(a_face.bounds)))  ==  oriented_face(a_face,FALSE)
	return the_reverse

####################
 # FUNCTION get_description_value #
####################
def get_description_value(obj,):
	'''
	:param obj
	:type obj:description_attribute_select
	'''
	if (SIZEOF(description_bag)  ==  1):
		return description_bag[1].attribute_value
	else:
		return  None 

####################
 # FUNCTION constraints_param_b_spline #
####################
def constraints_param_b_spline(degree,up_knots,up_cp,knot_mult,knots,):
	'''
	:param degree
	:type degree:INTEGER
	:param up_knots
	:type up_knots:INTEGER
	:param up_cp
	:type up_cp:INTEGER
	:param knot_mult
	:type knot_mult:(null)
	:param knots
	:type knots:(null)
	'''
	sum = knot_mult[1]
	for  i in range(2,up_knots,1):
		sum = sum  +  knot_mult[i]
	if ((((degree  <  1)  or  (up_knots  <  2))  or  (up_cp  <  degree))  or  (sum  !=  ((degree  +  up_cp)  +  2))):
		result = FALSE
		return result
	k = knot_mult[1]
	if ((k  <  1)  or  (k  >  (degree  +  1))):
		result = FALSE
		return result
	for  i in range(2,up_knots,1):
		if ((knot_mult[i]  <  1)  or  (knots[i]  <=  knots[i - 1])):
			result = FALSE
			return result
		k = knot_mult[i]
		if ((i  <  up_knots)  and  (k  >  degree)):
			result = FALSE
			return result
		if ((i  ==  up_knots)  and  (k  >  (degree  +  1))):
			result = FALSE
			return result
	return result

####################
 # FUNCTION value_range_aggregate_rep_item #
####################
def value_range_aggregate_rep_item(agg,):
	'''
	:param agg
	:type agg:(null)
	'''
	# begin/end block
	if (SIZEOF(None)  ==  6):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION acyclic_mapped_item_usage #
####################
def acyclic_mapped_item_usage(rep,):
	'''
	:param rep
	:type rep:representation
	'''
	items = None
	if (SIZEOF(items)  ==  0):
		return FALSE
	else:
		for  i in range(1,HIINDEX(items),1):
			if (items[i].mapped_item.mapping_source.mapped_representation  ==  rep):
				return TRUE
			else:
				return acyclic_mapped_item_usage(items[i].mapped_item.mapping_source.mapped_representation)
		return FALSE

####################
 # FUNCTION class_assignment_is_valid #
####################
def class_assignment_is_valid(aia,):
	'''
	:param aia
	:type aia:applied_classification_assignment
	'''
	role = aia.classification_assignment.role
	if (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'CLASS_SYSTEM')  ==  TYPEOF(aia.classification_assignment.assigned_class)):
		if (role.classification_role.name  !=  'class system membership'):
			return FALSE
		for  i in range(LOINDEX(aia.applied_classification_assignment.items),HIINDEX(aia.applied_classification_assignment.items),1):
			item = aia.applied_classification_assignment.items[i]
			if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'CLASS_SYSTEM_ITEM']  *  TYPEOF(item))  ==  0):
				return FALSE
	if (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'CHARACTERIZED_CLASS')  ==  TYPEOF(aia.classification_assignment.assigned_class)):
		if ( not (role.classification_role.name  ==  ['definitional','non-definitional',''])):
			return FALSE
		for  i in range(LOINDEX(aia.applied_classification_assignment.items),HIINDEX(aia.applied_classification_assignment.items),1):
			item = aia.applied_classification_assignment.items[i]
			if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'CLASSIFIED_ITEM']  *  TYPEOF(item))  ==  0):
				return FALSE
	if (role.classification_role.name  ==  'definitional'):
		if ( not (SIZEOF(None)  ==  0)):
			return FALSE
	return TRUE

####################
 # FUNCTION using_representations #
####################
def using_representations(item,):
	'''
	:param item
	:type item:founded_item_select
	'''
	results = []
	result_bag = USEDIN(item,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.REPRESENTATION.ITEMS')
	if (SIZEOF(result_bag)  >  0):
		for  i in range(1,HIINDEX(result_bag),1):
			results = results  +  result_bag[i]
	intermediate_items = using_items(item,[])
	if (SIZEOF(intermediate_items)  >  0):
		for  i in range(1,HIINDEX(intermediate_items),1):
			result_bag = USEDIN(intermediate_items[i],'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.REPRESENTATION.ITEMS')
			if (SIZEOF(result_bag)  >  0):
				for  j in range(1,HIINDEX(result_bag),1):
					results = results  +  result_bag[j]
	return results

####################
 # FUNCTION control_characters_free #
####################
def control_characters_free(s,):
	'''
	:param s
	:type s:STRING
	'''
	for  i in range(1,LENGTH(s),1):
		ch = s[i]
		if (((ch  ==  '\x9')  or  (ch  ==  '\xA'))  or  (ch  ==  '\xD')):
			return FALSE
	return TRUE

####################
 # FUNCTION associated_surface #
####################
def associated_surface(arg,):
	'''
	:param arg
	:type arg:pcurve_or_surface
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PCURVE'  ==  TYPEOF(arg)):
		surf = arg.pcurve.basis_surface
	else:
		surf = arg
	return surf

####################
 # FUNCTION acyclic_point_replica #
####################
def acyclic_point_replica(rep,parent,):
	'''
	:param rep
	:type rep:point_replica
	:param parent
	:type parent:point
	'''
	if ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POINT_REPLICA'  ==  TYPEOF(parent))):
		return TRUE
	if (parent  ==  rep):
		return FALSE
	else:
		return acyclic_point_replica(rep,parent.point_replica.parent_pt)

####################
 # FUNCTION valid_datum_target_parameters #
####################
def valid_datum_target_parameters(pdf,):
	'''
	:param pdf
	:type pdf:placed_datum_target_feature
	'''
	for  i in range(1,HIINDEX(pdf.representation_associations),1):
		rep_set = rep_set  +  pdf.representation_associations[i].used_representation
	parameter_representations = None
	if (SIZEOF(None)  !=  1):
		return FALSE
	case_selector = pdf.shape_aspect.description
	if  case_selector == 'point':
		return SIZEOF(None)  ==  1
	elif case_selector == 'circle':
		return (SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1)
	elif case_selector == 'line':
		return SIZEOF(None)  ==  1
	elif case_selector == 'rectangle':
		return ((SIZEOF(None)  ==  1)  and  (SIZEOF(None)  ==  1))  and  (SIZEOF(None)  ==  1)
	else:
		return FALSE

####################
 # FUNCTION cross_product #
####################
def cross_product(arg1,arg2,):
	'''
	:param arg1
	:type arg1:direction
	:param arg2
	:type arg2:direction
	'''
	if ((( not EXISTS(arg1))  or  (arg1.dim  ==  2))  or  (( not EXISTS(arg2))  or  (arg2.dim  ==  2))):
		return  None 
	else:
		# begin/end block
		v1 = normalise(arg1).direction_ratios
		v2 = normalise(arg2).direction_ratios
		res = dummy_gri  ==  direction([(v1[2]  *  v2[3]) - (v1[3]  *  v2[2]),(v1[3]  *  v2[1]) - (v1[1]  *  v2[3]),(v1[1]  *  v2[2]) - (v1[2]  *  v2[1])])
		mag = 0
		for  i in range(1,3,1):
			mag = mag  +  (res.direction_ratios[i]  *  res.direction_ratios[i])
		if (mag  >  0):
			result = dummy_gri  ==  vector(res,SQRT(mag))
		else:
			result = dummy_gri  ==  vector(arg1,0)
		return result

####################
 # FUNCTION categories_of_product #
####################
def categories_of_product(obj,):
	'''
	:param obj
	:type obj:product
	'''
	category_assignments = USEDIN(obj,'AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.'  +  'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
	for  i in range(LOINDEX(category_assignments),HIINDEX(category_assignments),1):
		categories = categories  +  category_assignments[i].name
	return categories

####################
 # FUNCTION valid_units #
####################
def valid_units(m,):
	'''
	:param m
	:type m:measure_with_unit
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,0,0,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MASS_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,1,0,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TIME_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,1,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELECTRIC_CURRENT_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,1,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,1,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CELSIUS_TEMPERATURE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,1,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,1,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LUMINOUS_INTENSITY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,1)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLANE_ANGLE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SOLID_ANGLE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.AREA_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,0,0,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VOLUME_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(3,0,0,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RATIO_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POSITIVE_LENGTH_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,0,0,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ACCELERATION_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,0,-2,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CAPACITANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(-2,-1,4,1,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELECTRIC_CHARGE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,1,1,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CONDUCTANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(-2,-1,3,2,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELECTRIC_POTENTIAL_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-3,-1,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ENERGY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-2,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.FORCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,1,-2,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.FREQUENCY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,-1,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ILLUMINANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(-2,0,0,0,0,0,1)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.INDUCTANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-2,-2,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LUMINOUS_FLUX_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,1)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MAGNETIC_FLUX_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-2,-1,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MAGNETIC_FLUX_DENSITY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,1,-2,-1,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POWER_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-3,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PRESSURE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(-1,1,-2,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RESISTANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,1,-3,-2,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VELOCITY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,0,-1,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RADIOACTIVITY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,-1,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ABSORBED_DOSE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,0,-2,0,0,0,0)):
			return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DOSE_EQUIVALENT_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,0,-2,0,0,0,0)):
			return FALSE
	return TRUE

####################
 # FUNCTION valid_selected_instance_representation #
####################
def valid_selected_instance_representation(pd,):
	'''
	:param pd
	:type pd:product_definition_or_assembly_relationship
	'''
	if (SIZEOF(properties)  !=  1):
		return FALSE
	if (SIZEOF(property_definition_representations)  !=  1):
		return FALSE
	selected_representation = property_definition_representations[1].property_definition_representation.used_representation
	if ((SIZEOF(selected_representation.representation.items)  <  1)  or  (SIZEOF(selected_representation.representation.items)  >  2)):
		return FALSE
	if (SIZEOF(None)  !=  1):
		return FALSE
	if (SIZEOF(None)  >  1):
		return FALSE
	if ((SIZEOF(None)  ==  0)  and  (SIZEOF(None)  >  0)):
		return FALSE
	return TRUE

####################
 # FUNCTION constraints_rectangular_composite_surface #
####################
def constraints_rectangular_composite_surface(s,):
	'''
	:param s
	:type s:rectangular_composite_surface
	'''
	for  i in range(1,s.n_u,1):
		for  j in range(1,s.n_v,1):
			if ( not (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_SURFACE'  ==  TYPEOF(s.segments[i][j].parent_surface))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.RECTANGULAR_TRIMMED_SURFACE'  ==  TYPEOF(s.segments[i][j].parent_surface)))):
				return FALSE
	for  i in range(1,s.n_u - 1,1):
		for  j in range(1,s.n_v,1):
			if (s.segments[i][j].u_transition  ==  discontinuous):
				return FALSE
	for  i in range(1,s.n_u,1):
		for  j in range(1,s.n_v - 1,1):
			if (s.segments[i][j].v_transition  ==  discontinuous):
				return FALSE
	return TRUE

####################
 # FUNCTION closed_shell_reversed #
####################
def closed_shell_reversed(a_shell,):
	'''
	:param a_shell
	:type a_shell:closed_shell
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ORIENTED_CLOSED_SHELL'  ==  TYPEOF(a_shell)):
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  closed_shell())  ==  oriented_closed_shell(a_shell.oriented_closed_shell.closed_shell_element, not a_shell.oriented_closed_shell.orientation)
	else:
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  closed_shell())  ==  oriented_closed_shell(a_shell,FALSE)
	return the_reverse

####################
 # FUNCTION boolean_choose #
####################
def boolean_choose(b,choice1,choice2,):
	'''
	:param b
	:type b:BOOLEAN
	:param choice1
	:type choice1:(null)
	:param choice2
	:type choice2:(null)
	'''
	if (b):
		return choice1
	else:
		return choice2

####################
 # FUNCTION valid_time #
####################
def valid_time(time,):
	'''
	:param time
	:type time:local_time
	'''
	if (EXISTS(time.second_component)):
		return EXISTS(time.minute_component)
	else:
		return TRUE

####################
 # FUNCTION is_sql_mappable #
####################
def is_sql_mappable(arg,):
	'''
	:param arg
	:type arg:expression
	'''
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SIMPLE_NUMERIC_EXPRESSION'  ==  TYPEOF(arg)):
		return TRUE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SQL_MAPPABLE_DEFINED_FUNCTION'  ==  TYPEOF(arg)):
		return TRUE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MINUS_FUNCTION'  ==  TYPEOF(arg)):
		return is_sql_mappable(arg.unary_numeric_expression.operand)
	if (((((((((((((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ABS_FUNCTION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SIN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COS_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TAN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ASIN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ACOS_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ATAN_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.EXP_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LOG_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LOG2_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LOG10_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SQUARE_ROOT_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.VALUE_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LENGTH_FUNCTION'  ==  TYPEOF(arg))):
		return FALSE
	if (((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PLUS_EXPRESSION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MULT_EXPRESSION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MAXIMUM_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MINIMUM_FUNCTION'  ==  TYPEOF(arg))):
		for  i in range(1,SIZEOF(arg.multiple_arity_numeric_expression.operands),1):
			if ( not is_sql_mappable(arg.multiple_arity_numeric_expression.operands[i])):
				return FALSE
		return TRUE
	if (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MINUS_EXPRESSION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SLASH_EXPRESSION'  ==  TYPEOF(arg))):
		return is_sql_mappable(arg.binary_numeric_expression.operands[1])  and  is_sql_mappable(arg.binary_numeric_expression.operands[2])
	if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.DIV_EXPRESSION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.MOD_EXPRESSION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POWER_EXPRESSION'  ==  TYPEOF(arg))):
		return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SIMPLE_BOOLEAN_EXPRESSION'  ==  TYPEOF(arg)):
		return TRUE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.NOT_EXPRESSION'  ==  TYPEOF(arg)):
		return is_sql_mappable(arg.unary_generic_expression.operand)
	if (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ODD_FUNCTION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.XOR_EXPRESSION'  ==  TYPEOF(arg))):
		return FALSE
	if (('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.AND_EXPRESSION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OR_EXPRESSION'  ==  TYPEOF(arg))):
		for  i in range(1,SIZEOF(arg.multiple_arity_boolean_expression.operands),1):
			if ( not is_sql_mappable(arg.multiple_arity_boolean_expression.operands[i])):
				return FALSE
		return TRUE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.EQUALS_EXPRESSION'  ==  TYPEOF(arg)):
		return is_sql_mappable(arg.binary_generic_expression.operands[1])  and  is_sql_mappable(arg.binary_generic_expression.operands[2])
	if ((((((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPARISON_EQUAL'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPARISON_GREATER'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPARISON_GREATER_EQUAL'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPARISON_LESS'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPARISON_LESS_EQUAL'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPARISON_NOT_EQUAL'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LIKE_EXPRESSION'  ==  TYPEOF(arg))):
		return is_sql_mappable(arg.comparison_expression.operands[1])  and  is_sql_mappable(arg.comparison_expression.operands[2])
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.INTERVAL_EXPRESSION'  ==  TYPEOF(arg)):
		return (is_sql_mappable(arg.interval_expression.interval_low)  and  is_sql_mappable(arg.interval_expression.interval_high))  and  is_sql_mappable(arg.interval_expression.interval_item)
	if ((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.NUMERIC_DEFINED_FUNCTION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.BOOLEAN_DEFINED_FUNCTION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.STRING_DEFINED_FUNCTION'  ==  TYPEOF(arg))):
		return FALSE
	if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SIMPLE_STRING_EXPRESSION'  ==  TYPEOF(arg)):
		return TRUE
	if (((('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.INDEX_EXPRESSION'  ==  TYPEOF(arg))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.SUBSTRING_EXPRESSION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CONCAT_EXPRESSION'  ==  TYPEOF(arg)))  or  ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.FORMAT_FUNCTION'  ==  TYPEOF(arg))):
		return FALSE
	return FALSE

####################
 # FUNCTION valid_geometrically_bounded_wf_curve #
####################
def valid_geometrically_bounded_wf_curve(crv,):
	'''
	:param crv
	:type crv:curve
	'''
	if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.POLYLINE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.B_SPLINE_CURVE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.ELLIPSE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CIRCLE']  *  TYPEOF(crv))  ==  1):
		return TRUE
	else:
		if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.TRIMMED_CURVE'  ==  TYPEOF(crv)):
			if (SIZEOF(['AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.LINE','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.PARABOLA','AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.HYPERBOLA']  *  TYPEOF(crv.trimmed_curve.basis_curve))  ==  1):
				return TRUE
			else:
				return valid_geometrically_bounded_wf_curve(crv.trimmed_curve.basis_curve)
		else:
			if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.OFFSET_CURVE_3D'  ==  TYPEOF(crv)):
				return valid_geometrically_bounded_wf_curve(crv.offset_curve_3d.basis_curve)
			else:
				if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_REPLICA'  ==  TYPEOF(crv)):
					return valid_geometrically_bounded_wf_curve(crv.curve_replica.parent_curve)
				else:
					if ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.COMPOSITE_CURVE'  ==  TYPEOF(crv)):
						return SIZEOF(None)  ==  0
	return FALSE

####################
 # FUNCTION dot_product #
####################
def dot_product(arg1,arg2,):
	'''
	:param arg1
	:type arg1:direction
	:param arg2
	:type arg2:direction
	'''
	if (( not EXISTS(arg1))  or  ( not EXISTS(arg2))):
		scalar =  None 
	else:
		if (arg1.dim  !=  arg2.dim):
			scalar =  None 
		else:
			# begin/end block
			vec1 = normalise(arg1)
			vec2 = normalise(arg2)
			ndim = arg1.dim
			scalar = 0
			for  i in range(1,ndim,1):
				scalar = scalar  +  (vec1.direction_ratios[i]  *  vec2.direction_ratios[i])
	return scalar

####################
 # FUNCTION get_role #
####################
def get_role(obj,):
	'''
	:param obj
	:type obj:role_select
	'''
	if (SIZEOF(role_bag)  ==  1):
		return role_bag[1].role
	else:
		return  None 

####################
 # FUNCTION acyclic_curve_replica #
####################
def acyclic_curve_replica(rep,parent,):
	'''
	:param rep
	:type rep:curve_replica
	:param parent
	:type parent:curve
	'''
	if ( not ('AP203_CONFIGURATION_CONTROLLED_3D_DESIGN_OF_MECHANICAL_PARTS_AND_ASSEMBLIES_MIM_LF.CURVE_REPLICA'  ==  TYPEOF(parent))):
		return TRUE
	if (parent  ==  rep):
		return FALSE
	else:
		return acyclic_curve_replica(rep,parent.curve_replica.parent_curve)

####################
 # RULE draughting_model_items_constraint #
####################
draughting_model_items_constraint = Rule()

####################
 # RULE restrict_product_definitions_for_part_definition_relationship #
####################
restrict_product_definitions_for_part_definition_relationship = Rule()

####################
 # RULE restrict_product_definitions_for_base_element #
####################
restrict_product_definitions_for_base_element = Rule()

####################
 # RULE restrict_configuration_design_for_design_constraint #
####################
restrict_configuration_design_for_design_constraint = Rule()

####################
 # RULE compatible_dimension #
####################
compatible_dimension = Rule()

####################
 # RULE restrict_alternative_definition #
####################
restrict_alternative_definition = Rule()

####################
 # RULE restrict_group_relationship_for_classification_hierarchy #
####################
restrict_group_relationship_for_classification_hierarchy = Rule()

####################
 # RULE subtype_exclusiveness_geometric_tolerance #
####################
subtype_exclusiveness_geometric_tolerance = Rule()

####################
 # RULE alternative_solution_requires_solution_definition #
####################
alternative_solution_requires_solution_definition = Rule()

####################
 # RULE restrict_centre_of_mass_representation #
####################
restrict_centre_of_mass_representation = Rule()

####################
 # RULE selected_instance_usage_requires_representation #
####################
selected_instance_usage_requires_representation = Rule()

####################
 # RULE external_version_assignments_are_valid #
####################
external_version_assignments_are_valid = Rule()

####################
 # RULE application_protocol_definition_required #
####################
application_protocol_definition_required = Rule()

####################
 # RULE thickness_laminate_table_component_select #
####################
thickness_laminate_table_component_select = Rule()

####################
 # RULE consistent_uncertainty #
####################
consistent_uncertainty = Rule()

####################
 # RULE ply_reference #
####################
ply_reference = Rule()

####################
 # RULE breakdown_element_requires_product_definition #
####################
breakdown_element_requires_product_definition = Rule()

####################
 # RULE product_definition_replacement_requires_effectivity_assignment #
####################
product_definition_replacement_requires_effectivity_assignment = Rule()

####################
 # RULE component_class_for_assembly_select #
####################
component_class_for_assembly_select = Rule()

####################
 # RULE restrict_configuration_design_for_class_breakdown_association #
####################
restrict_configuration_design_for_class_breakdown_association = Rule()

####################
 # RULE solution_definition_requires_solution_category #
####################
solution_definition_requires_solution_category = Rule()

####################
 # RULE restrict_product_definitions_for_collection #
####################
restrict_product_definitions_for_collection = Rule()

####################
 # RULE restrict_treatment_result #
####################
restrict_treatment_result = Rule()

####################
 # RULE restrict_concept_feature_operator #
####################
restrict_concept_feature_operator = Rule()

####################
 # RULE restrict_part_occurrence #
####################
restrict_part_occurrence = Rule()

####################
 # RULE constraint_definition_requires_constraint_category #
####################
constraint_definition_requires_constraint_category = Rule()

####################
 # RULE design_constraint_requires_product_definition #
####################
design_constraint_requires_product_definition = Rule()

####################
 # RULE restrict_product_definitions_for_definition_usage #
####################
restrict_product_definitions_for_definition_usage = Rule()

####################
 # RULE plib_property_reference_requires_name_scope #
####################
plib_property_reference_requires_name_scope = Rule()

####################
 # RULE ply_stock_material_select #
####################
ply_stock_material_select = Rule()

####################
 # RULE styled_curve #
####################
styled_curve = Rule()

####################
 # RULE subtype_exclusiveness_representation_item #
####################
subtype_exclusiveness_representation_item = Rule()

####################
 # RULE text_font_usage #
####################
text_font_usage = Rule()

####################
 # RULE restrict_classification_assignments #
####################
restrict_classification_assignments = Rule()

####################
 # RULE restrict_language_assignment_per_attribute #
####################
restrict_language_assignment_per_attribute = Rule()

####################
 # RULE stock_material_reference #
####################
stock_material_reference = Rule()

####################
 # RULE restrict_group_relationship_for_specification_category #
####################
restrict_group_relationship_for_specification_category = Rule()

####################
 # RULE restrict_representation_for_surface_condition #
####################
restrict_representation_for_surface_condition = Rule()

####################
 # RULE material_for_coating_layer #
####################
material_for_coating_layer = Rule()

####################
 # RULE restrict_product_definitions_for_design_constraint_association #
####################
restrict_product_definitions_for_design_constraint_association = Rule()

####################
 # RULE restrict_part_occurrence_category #
####################
restrict_part_occurrence_category = Rule()

####################
 # RULE subtype_mandatory_geometric_tolerance #
####################
subtype_mandatory_geometric_tolerance = Rule()

####################
 # RULE product_concept_feature_requires_category #
####################
product_concept_feature_requires_category = Rule()

####################
 # RULE restrict_assembly_category #
####################
restrict_assembly_category = Rule()

####################
 # RULE restrict_collection_category #
####################
restrict_collection_category = Rule()

####################
 # RULE plib_property_reference_requires_version #
####################
plib_property_reference_requires_version = Rule()

####################
 # RULE validate_dependently_instantiable_entity_data_types #
####################
validate_dependently_instantiable_entity_data_types = Rule()
