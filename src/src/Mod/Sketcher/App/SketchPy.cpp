
// This file is generated by src/Tools/generateTemplates/templateClassPyExport.py out of the .XML file
// Every change you make here gets lost in the next full rebuild!
// This File is normally built as an include in SketchPyImp.cpp! It's not intended to be in a project!

#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <CXX/Objects.hxx>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

using Base::streq;
using namespace Sketcher;

#if defined(__GNUC__)
#pragma GCC diagnostic push
// Ignore -Wmissing-field-initializers (GCC only):
// - C++20 guarantees omitted fields are zero-initialized.
// - Python C API changes fields across versions.
// - Clang does not warn; GCC does unnecessarily.
// See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96868
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#endif // __GNUC__
/// Type structure of SketchPy
PyTypeObject SketchPy::Type = {
    .ob_base = PyVarObject_HEAD_INIT(&PyType_Type,0)
    .tp_name = "Sketcher.Sketch",
    .tp_basicsize = sizeof(SketchPy),
    .tp_itemsize = 0,
    /* methods */
    .tp_dealloc = PyDestructor,
    .tp_repr = __repr,
    .tp_getattro = __getattro,
    .tp_setattro = __setattro,
    /* --- Flags to define presence of optional/expanded features */
    .tp_flags = Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT,
    .tp_doc = "With this objects you can handle constraint sketches",
    .tp_methods = Sketcher::SketchPy::Methods,
    .tp_getset = Sketcher::SketchPy::GetterSetter,
    .tp_base = &Base::PersistencePy::Type,
    .tp_init = __PyInit,
    .tp_new = Sketcher::SketchPy::PyMake
};
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif // __GNUC__

/// Methods structure of SketchPy
PyMethodDef SketchPy::Methods[] = {
    {"solve",
        reinterpret_cast<PyCFunction>( staticCallback_solve ),
        METH_VARARGS,
        "Solve the actual set of geometry and constraints"
    },
    {"addGeometry",
        reinterpret_cast<PyCFunction>( staticCallback_addGeometry ),
        METH_VARARGS,
        "Add a geometric object to the sketch"
    },
    {"addConstraint",
        reinterpret_cast<PyCFunction>( staticCallback_addConstraint ),
        METH_VARARGS,
        "Add an constraint object to the sketch"
    },
    {"clear",
        reinterpret_cast<PyCFunction>( staticCallback_clear ),
        METH_VARARGS,
        "Clear the sketch"
    },
    {"moveGeometry",
        reinterpret_cast<PyCFunction>( staticCallback_moveGeometry ),
        METH_VARARGS,
        "moveGeometry(GeoIndex,PointPos,Vector,[relative]) - move a given point (or curve)\n"
        "to another location.\n"
        "It moves the specified point (or curve) to the given location by adding some\n"
        "temporary weak constraints and solve the sketch.\n"
        "This method is mostly used to allow the user to drag some portions of the sketch\n"
        "in real time by e.g. the mouse and it works only for underconstrained portions of\n"
        "the sketch.\n"
        "The argument 'relative', if present, states if the new location is given\n"
        "relatively to the current one."
    },
    {nullptr, nullptr, 0, nullptr}		/* Sentinel */
};



/// Attribute structure of SketchPy
PyGetSetDef SketchPy::GetterSetter[] = {
    {"Constraint",
        (getter) staticCallback_getConstraint,
        (setter) staticCallback_setConstraint,
        "0: exactly constraint, -1 under-constraint, 1 over-constraint",
        nullptr
    },
    {"Conflicts",
        (getter) staticCallback_getConflicts,
        (setter) staticCallback_setConflicts,
        "Tuple of conflicting constraints",
        nullptr
    },
    {"Redundancies",
        (getter) staticCallback_getRedundancies,
        (setter) staticCallback_setRedundancies,
        "Tuple of redundant constraints",
        nullptr
    },
    {"Geometries",
        (getter) staticCallback_getGeometries,
        (setter) staticCallback_setGeometries,
        "Tuple of all geometric elements in this sketch",
        nullptr
    },
    {"Shape",
        (getter) staticCallback_getShape,
        (setter) staticCallback_setShape,
        "Resulting shape from the sketch geometry",
        nullptr
    },
    {nullptr, nullptr, nullptr, nullptr, nullptr}		/* Sentinel */
};

// solve() callback and implementer
// PyObject*  SketchPy::solve(PyObject *args){};
// has to be implemented in SketchPyImp.cpp
PyObject * SketchPy::staticCallback_solve (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'solve' of 'Sketcher.Sketch' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<SketchPy*>(self)->solve(args);
        if (ret != nullptr)
            static_cast<SketchPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addGeometry() callback and implementer
// PyObject*  SketchPy::addGeometry(PyObject *args){};
// has to be implemented in SketchPyImp.cpp
PyObject * SketchPy::staticCallback_addGeometry (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addGeometry' of 'Sketcher.Sketch' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<SketchPy*>(self)->addGeometry(args);
        if (ret != nullptr)
            static_cast<SketchPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addConstraint() callback and implementer
// PyObject*  SketchPy::addConstraint(PyObject *args){};
// has to be implemented in SketchPyImp.cpp
PyObject * SketchPy::staticCallback_addConstraint (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addConstraint' of 'Sketcher.Sketch' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<SketchPy*>(self)->addConstraint(args);
        if (ret != nullptr)
            static_cast<SketchPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// clear() callback and implementer
// PyObject*  SketchPy::clear(PyObject *args){};
// has to be implemented in SketchPyImp.cpp
PyObject * SketchPy::staticCallback_clear (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'clear' of 'Sketcher.Sketch' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<SketchPy*>(self)->clear(args);
        if (ret != nullptr)
            static_cast<SketchPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// moveGeometry() callback and implementer
// PyObject*  SketchPy::moveGeometry(PyObject *args){};
// has to be implemented in SketchPyImp.cpp
PyObject * SketchPy::staticCallback_moveGeometry (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'moveGeometry' of 'Sketcher.Sketch' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<SketchPy*>(self)->moveGeometry(args);
        if (ret != nullptr)
            static_cast<SketchPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// Constraint() callback and implementer
// PyObject*  SketchPy::Constraint(PyObject *args){};
// has to be implemented in SketchPyImp.cpp
PyObject * SketchPy::staticCallback_getConstraint (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<SketchPy*>(self)->getConstraint());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Constraint' of object 'Sketch'");
        return nullptr;
    }
}

int SketchPy::staticCallback_setConstraint (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Constraint' of object 'Sketch' is read-only");
    return -1;
}

// Conflicts() callback and implementer
// PyObject*  SketchPy::Conflicts(PyObject *args){};
// has to be implemented in SketchPyImp.cpp
PyObject * SketchPy::staticCallback_getConflicts (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<SketchPy*>(self)->getConflicts());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Conflicts' of object 'Sketch'");
        return nullptr;
    }
}

int SketchPy::staticCallback_setConflicts (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Conflicts' of object 'Sketch' is read-only");
    return -1;
}

// Redundancies() callback and implementer
// PyObject*  SketchPy::Redundancies(PyObject *args){};
// has to be implemented in SketchPyImp.cpp
PyObject * SketchPy::staticCallback_getRedundancies (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<SketchPy*>(self)->getRedundancies());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Redundancies' of object 'Sketch'");
        return nullptr;
    }
}

int SketchPy::staticCallback_setRedundancies (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Redundancies' of object 'Sketch' is read-only");
    return -1;
}

// Geometries() callback and implementer
// PyObject*  SketchPy::Geometries(PyObject *args){};
// has to be implemented in SketchPyImp.cpp
PyObject * SketchPy::staticCallback_getGeometries (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<SketchPy*>(self)->getGeometries());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Geometries' of object 'Sketch'");
        return nullptr;
    }
}

int SketchPy::staticCallback_setGeometries (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Geometries' of object 'Sketch' is read-only");
    return -1;
}

// Shape() callback and implementer
// PyObject*  SketchPy::Shape(PyObject *args){};
// has to be implemented in SketchPyImp.cpp
PyObject * SketchPy::staticCallback_getShape (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<SketchPy*>(self)->getShape());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Shape' of object 'Sketch'");
        return nullptr;
    }
}

int SketchPy::staticCallback_setShape (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Shape' of object 'Sketch' is read-only");
    return -1;
}




//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
SketchPy::SketchPy(Sketch *pcObject, PyTypeObject *T)
    : PersistencePy(static_cast<PersistencePy::PointerType>(pcObject), T)
{
}


//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
SketchPy::~SketchPy()                                // Everything handled in parent
{
}

//--------------------------------------------------------------------------
// SketchPy representation
//--------------------------------------------------------------------------
PyObject *SketchPy::_repr()
{
    return Py_BuildValue("s", representation().c_str());
}

//--------------------------------------------------------------------------
// SketchPy Attributes
//--------------------------------------------------------------------------
PyObject *SketchPy::_getattr(const char *attr)			// __getattr__ function: note only need to handle new state
{
    try {
        // getter method for special Attributes (e.g. dynamic ones)
        PyObject *r = getCustomAttributes(attr);
        if(r) return r;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError,"Unknown C++ exception");
        return nullptr;
    }
#endif

    PyMethodDef *ml = Methods;
    for (; ml->ml_name != nullptr; ml++) {
        if (attr[0] == ml->ml_name[0] &&
            strcmp(attr+1, ml->ml_name+1) == 0)
            return PyCFunction_New(ml, this);
    }

    PyErr_Clear();
    return PersistencePy::_getattr(attr);
}

int SketchPy::_setattr(const char *attr, PyObject *value) // __setattr__ function: note only need to handle new state
{
    try {
        // setter for special Attributes (e.g. dynamic ones)
        int r = setCustomAttributes(attr, value);
        // r = 1: handled
        // r = -1: error
        // r = 0: ignore
        if (r == 1)
            return 0;
        else if (r == -1)
            return -1;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return -1;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return -1;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return -1;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return -1;
    }
#endif

    return PersistencePy::_setattr(attr, value);
}

Sketch *SketchPy::getSketchPtr() const
{
    return static_cast<Sketch *>(_pcTwinPointer);
}

#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#if 0
/* From here on come the methods you have to implement, but NOT in this module. Implement in SketchPyImp.cpp! This prototypes
 * are just for convenience when you add a new method.
 */

PyObject *SketchPy::PyMake(PyTypeObject* /*type*/, PyObject* /*args*/, PyObject* /*kwds*/)
{
    // create a new instance of SketchPy and the Twin object
    return new SketchPy(new Sketch);
}

// constructor method
int SketchPy::PyInit(PyObject* /*args*/, PyObject* /*kwd*/)
{
    return 0;
}


// returns a string which represents the object e.g. when printed in python
std::string SketchPy::representation() const
{
    return {"<Sketch object>"};
}

PyObject* SketchPy::solve(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* SketchPy::addGeometry(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* SketchPy::addConstraint(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* SketchPy::clear(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* SketchPy::moveGeometry(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}



Py::Long SketchPy::getConstraint() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Tuple SketchPy::getConflicts() const
{
    //return Py::Tuple();
    throw Py::AttributeError("Not yet implemented");
}

Py::Tuple SketchPy::getRedundancies() const
{
    //return Py::Tuple();
    throw Py::AttributeError("Not yet implemented");
}

Py::Tuple SketchPy::getGeometries() const
{
    //return Py::Tuple();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object SketchPy::getShape() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

PyObject *SketchPy::getCustomAttributes(const char* /*attr*/) const
{
    return nullptr;
}

int SketchPy::setCustomAttributes(const char* /*attr*/, PyObject* /*obj*/)
{
    return 0;
}


#endif



