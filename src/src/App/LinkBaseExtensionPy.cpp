
// This file is generated by src/Tools/generateTemplates/templateClassPyExport.py out of the .XML file
// Every change you make here gets lost in the next full rebuild!
// This File is normally built as an include in LinkBaseExtensionPyImp.cpp! It's not intended to be in a project!

#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <CXX/Objects.hxx>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

using Base::streq;
using namespace App;

#if defined(__GNUC__)
#pragma GCC diagnostic push
// Ignore -Wmissing-field-initializers (GCC only):
// - C++20 guarantees omitted fields are zero-initialized.
// - Python C API changes fields across versions.
// - Clang does not warn; GCC does unnecessarily.
// See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96868
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#endif // __GNUC__
/// Type structure of LinkBaseExtensionPy
PyTypeObject LinkBaseExtensionPy::Type = {
    .ob_base = PyVarObject_HEAD_INIT(&PyType_Type,0)
    .tp_name = "App.LinkBaseExtension",
    .tp_basicsize = sizeof(LinkBaseExtensionPy),
    .tp_itemsize = 0,
    /* methods */
    .tp_dealloc = PyDestructor,
    .tp_repr = __repr,
    .tp_getattro = __getattro,
    .tp_setattro = __setattro,
    /* --- Flags to define presence of optional/expanded features */
    .tp_flags = Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT,
    .tp_doc = "Link extension base class",
    .tp_methods = App::LinkBaseExtensionPy::Methods,
    .tp_getset = App::LinkBaseExtensionPy::GetterSetter,
    .tp_base = &App::DocumentObjectExtensionPy::Type,
    .tp_init = __PyInit,
    .tp_new = App::LinkBaseExtensionPy::PyMake
};
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif // __GNUC__

/// Methods structure of LinkBaseExtensionPy
PyMethodDef LinkBaseExtensionPy::Methods[] = {
    {"configLinkProperty",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_configLinkProperty )),
        METH_VARARGS|METH_KEYWORDS,
        "configLinkProperty(key=val,...): property configuration\n"
        "configLinkProperty(key,...): property configuration with default name\n"
        "\n"
        "This methode is here to implement what I called Property Design\n"
        "Pattern. The extension operates on a predefined set of properties,\n"
        "but it relies on the extended object to supply the actual property by\n"
        "calling this methode. You can choose a sub set of functionality of\n"
        "this extension by supplying only some of the supported properties.\n"
        "\n"
        "The 'key' are names used to refer to properties supported by this\n"
        "extension, and 'val' is the actual name of the property of your\n"
        "object. You can obtain the key names and expected types using\n"
        "getLinkPropertyInfo().  You can use property of derived type when\n"
        "calling configLinkProperty().  Other types will cause exception to\n"
        "ben thrown. The actual properties supported may be different\n"
        "depending on the actual extension object underlying this python\n"
        "object.\n"
        "\n"
        "If 'val' is omitted, i.e. calling configLinkProperty(key,...), then\n"
        "it is assumed that the actual property name is the same as 'key'"
    },
    {"getLinkExtProperty",
        reinterpret_cast<PyCFunction>( staticCallback_getLinkExtProperty ),
        METH_VARARGS,
        "getLinkExtProperty(name): return the property value by its predefined name"
    },
    {"getLinkExtPropertyName",
        reinterpret_cast<PyCFunction>( staticCallback_getLinkExtPropertyName ),
        METH_VARARGS,
        "getLinkExtPropertyName(name): lookup the property name by its predefined name"
    },
    {"getLinkPropertyInfo",
        reinterpret_cast<PyCFunction>( staticCallback_getLinkPropertyInfo ),
        METH_VARARGS,
        "getLinkPropertyInfo(): return a tuple of (name,type,doc) for all supported properties.\n"
        "\n"
        "getLinkPropertyInfo(index): return (name,type,doc) of a specific property\n"
        "\n"
        "getLinkPropertyInfo(name): return (type,doc) of a specific property"
    },
    {"setLink",
        reinterpret_cast<PyCFunction>( staticCallback_setLink ),
        METH_VARARGS,
        "setLink(obj,subName=None,subElements=None): Set link object.\n"
        "\n"
        "setLink([obj,...]),\n"
        "setLink([(obj,subName,subElements),...]),\n"
        "setLink({index:obj,...}),\n"
        "setLink({index:(obj,subName,subElements),...}): set link element of a link group.\n"
        "\n"
        "obj (DocumentObject): the object to link to. If this is None, then the link is cleared\n"
        "\n"
        "subName (String): Dot separated object path.\n"
        "\n"
        "subElements (String|tuple(String)): non-object sub-elements, e.g. Face1, Edge2."
    },
    {"cacheChildLabel",
        reinterpret_cast<PyCFunction>( staticCallback_cacheChildLabel ),
        METH_VARARGS,
        "cacheChildLabel(enable=True): enable/disable child label cache\n"
        "\n"
        "The cache is not updated on child label change for performance reason. You must\n"
        "call this function on any child label change"
    },
    {"flattenSubname",
        reinterpret_cast<PyCFunction>( staticCallback_flattenSubname ),
        METH_VARARGS,
        "flattenSubname(subname) -> string\n"
        "\n"
        "Return a flattened subname in case it references an object inside a linked plain group"
    },
    {"expandSubname",
        reinterpret_cast<PyCFunction>( staticCallback_expandSubname ),
        METH_VARARGS,
        "expandSubname(subname) -> string\n"
        "\n"
        "Return an expanded subname in case it references an object inside a linked plain group"
    },
    {nullptr, nullptr, 0, nullptr}		/* Sentinel */
};



/// Attribute structure of LinkBaseExtensionPy
PyGetSetDef LinkBaseExtensionPy::GetterSetter[] = {
    {"LinkedChildren",
        (getter) staticCallback_getLinkedChildren,
        (setter) staticCallback_setLinkedChildren,
        "Return a flattened (in case grouped by plain group) list of linked children",
        nullptr
    },
    {nullptr, nullptr, nullptr, nullptr, nullptr}		/* Sentinel */
};

// configLinkProperty() callback and implementer
// PyObject*  LinkBaseExtensionPy::configLinkProperty(PyObject *args){};
// has to be implemented in LinkBaseExtensionPyImp.cpp
PyObject * LinkBaseExtensionPy::staticCallback_configLinkProperty (PyObject *self, PyObject *args, PyObject * kwd)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'configLinkProperty' of 'App.LinkBaseExtension' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkBaseExtensionPy*>(self)->configLinkProperty(args, kwd);
        if (ret != nullptr)
            static_cast<LinkBaseExtensionPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getLinkExtProperty() callback and implementer
// PyObject*  LinkBaseExtensionPy::getLinkExtProperty(PyObject *args){};
// has to be implemented in LinkBaseExtensionPyImp.cpp
PyObject * LinkBaseExtensionPy::staticCallback_getLinkExtProperty (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getLinkExtProperty' of 'App.LinkBaseExtension' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkBaseExtensionPy*>(self)->getLinkExtProperty(args);
        if (ret != nullptr)
            static_cast<LinkBaseExtensionPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getLinkExtPropertyName() callback and implementer
// PyObject*  LinkBaseExtensionPy::getLinkExtPropertyName(PyObject *args){};
// has to be implemented in LinkBaseExtensionPyImp.cpp
PyObject * LinkBaseExtensionPy::staticCallback_getLinkExtPropertyName (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getLinkExtPropertyName' of 'App.LinkBaseExtension' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkBaseExtensionPy*>(self)->getLinkExtPropertyName(args);
        if (ret != nullptr)
            static_cast<LinkBaseExtensionPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getLinkPropertyInfo() callback and implementer
// PyObject*  LinkBaseExtensionPy::getLinkPropertyInfo(PyObject *args){};
// has to be implemented in LinkBaseExtensionPyImp.cpp
PyObject * LinkBaseExtensionPy::staticCallback_getLinkPropertyInfo (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getLinkPropertyInfo' of 'App.LinkBaseExtension' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkBaseExtensionPy*>(self)->getLinkPropertyInfo(args);
        if (ret != nullptr)
            static_cast<LinkBaseExtensionPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setLink() callback and implementer
// PyObject*  LinkBaseExtensionPy::setLink(PyObject *args){};
// has to be implemented in LinkBaseExtensionPyImp.cpp
PyObject * LinkBaseExtensionPy::staticCallback_setLink (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setLink' of 'App.LinkBaseExtension' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkBaseExtensionPy*>(self)->setLink(args);
        if (ret != nullptr)
            static_cast<LinkBaseExtensionPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// cacheChildLabel() callback and implementer
// PyObject*  LinkBaseExtensionPy::cacheChildLabel(PyObject *args){};
// has to be implemented in LinkBaseExtensionPyImp.cpp
PyObject * LinkBaseExtensionPy::staticCallback_cacheChildLabel (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'cacheChildLabel' of 'App.LinkBaseExtension' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkBaseExtensionPy*>(self)->cacheChildLabel(args);
        if (ret != nullptr)
            static_cast<LinkBaseExtensionPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// flattenSubname() callback and implementer
// PyObject*  LinkBaseExtensionPy::flattenSubname(PyObject *args){};
// has to be implemented in LinkBaseExtensionPyImp.cpp
PyObject * LinkBaseExtensionPy::staticCallback_flattenSubname (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'flattenSubname' of 'App.LinkBaseExtension' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkBaseExtensionPy*>(self)->flattenSubname(args);
        if (ret != nullptr)
            static_cast<LinkBaseExtensionPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// expandSubname() callback and implementer
// PyObject*  LinkBaseExtensionPy::expandSubname(PyObject *args){};
// has to be implemented in LinkBaseExtensionPyImp.cpp
PyObject * LinkBaseExtensionPy::staticCallback_expandSubname (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'expandSubname' of 'App.LinkBaseExtension' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkBaseExtensionPy*>(self)->expandSubname(args);
        if (ret != nullptr)
            static_cast<LinkBaseExtensionPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// LinkedChildren() callback and implementer
// PyObject*  LinkBaseExtensionPy::LinkedChildren(PyObject *args){};
// has to be implemented in LinkBaseExtensionPyImp.cpp
PyObject * LinkBaseExtensionPy::staticCallback_getLinkedChildren (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<LinkBaseExtensionPy*>(self)->getLinkedChildren());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'LinkedChildren' of object 'LinkBaseExtension'");
        return nullptr;
    }
}

int LinkBaseExtensionPy::staticCallback_setLinkedChildren (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'LinkedChildren' of object 'LinkBaseExtension' is read-only");
    return -1;
}




//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
LinkBaseExtensionPy::LinkBaseExtensionPy(LinkBaseExtension *pcObject, PyTypeObject *T)
    : DocumentObjectExtensionPy(static_cast<DocumentObjectExtensionPy::PointerType>(pcObject), T)
{
}

PyObject *LinkBaseExtensionPy::PyMake(PyTypeObject* /*type*/, PyObject* /*args*/, PyObject* /*kwds*/)
{
    // never create such objects with the constructor
    PyErr_SetString(PyExc_RuntimeError, "You cannot create directly an instance of 'LinkBaseExtensionPy'.");

    return nullptr;
}

int LinkBaseExtensionPy::PyInit(PyObject* /*args*/, PyObject* /*kwd*/)
{
    return 0;
}

//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
LinkBaseExtensionPy::~LinkBaseExtensionPy()                                // Everything handled in parent
{
}

//--------------------------------------------------------------------------
// LinkBaseExtensionPy representation
//--------------------------------------------------------------------------
PyObject *LinkBaseExtensionPy::_repr()
{
    return Py_BuildValue("s", representation().c_str());
}

//--------------------------------------------------------------------------
// LinkBaseExtensionPy Attributes
//--------------------------------------------------------------------------
PyObject *LinkBaseExtensionPy::_getattr(const char *attr)			// __getattr__ function: note only need to handle new state
{
    try {
        // getter method for special Attributes (e.g. dynamic ones)
        PyObject *r = getCustomAttributes(attr);
        if(r) return r;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError,"Unknown C++ exception");
        return nullptr;
    }
#endif

    PyMethodDef *ml = Methods;
    for (; ml->ml_name != nullptr; ml++) {
        if (attr[0] == ml->ml_name[0] &&
            strcmp(attr+1, ml->ml_name+1) == 0)
            return PyCFunction_New(ml, this);
    }

    PyErr_Clear();
    return DocumentObjectExtensionPy::_getattr(attr);
}

int LinkBaseExtensionPy::_setattr(const char *attr, PyObject *value) // __setattr__ function: note only need to handle new state
{
    try {
        // setter for special Attributes (e.g. dynamic ones)
        int r = setCustomAttributes(attr, value);
        // r = 1: handled
        // r = -1: error
        // r = 0: ignore
        if (r == 1)
            return 0;
        else if (r == -1)
            return -1;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return -1;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return -1;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return -1;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return -1;
    }
#endif

    return DocumentObjectExtensionPy::_setattr(attr, value);
}

LinkBaseExtension *LinkBaseExtensionPy::getLinkBaseExtensionPtr() const
{
    return static_cast<LinkBaseExtension *>(_pcTwinPointer);
}

#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#if 0
/* From here on come the methods you have to implement, but NOT in this module. Implement in LinkBaseExtensionPyImp.cpp! This prototypes
 * are just for convenience when you add a new method.
 */



// returns a string which represents the object e.g. when printed in python
std::string LinkBaseExtensionPy::representation() const
{
    return {"<LinkBaseExtension object>"};
}

PyObject* LinkBaseExtensionPy::configLinkProperty(PyObject *args, PyObject *kwds)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkBaseExtensionPy::getLinkExtProperty(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkBaseExtensionPy::getLinkExtPropertyName(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkBaseExtensionPy::getLinkPropertyInfo(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkBaseExtensionPy::setLink(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkBaseExtensionPy::cacheChildLabel(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkBaseExtensionPy::flattenSubname(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkBaseExtensionPy::expandSubname(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}



Py::List LinkBaseExtensionPy::getLinkedChildren() const
{
    //return Py::List();
    throw Py::AttributeError("Not yet implemented");
}

PyObject *LinkBaseExtensionPy::getCustomAttributes(const char* /*attr*/) const
{
    return nullptr;
}

int LinkBaseExtensionPy::setCustomAttributes(const char* /*attr*/, PyObject* /*obj*/)
{
    return 0;
}


#endif



