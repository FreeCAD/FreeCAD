
// This file is generated by src/Tools/generateTemplates/templateClassPyExport.py out of the .XML file
// Every change you make here gets lost in the next full rebuild!
// This File is normally built as an include in DocumentObjectPyImp.cpp! It's not intended to be in a project!

#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <CXX/Objects.hxx>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

using Base::streq;
using namespace App;

#if defined(__GNUC__)
#pragma GCC diagnostic push
// Ignore -Wmissing-field-initializers (GCC only):
// - C++20 guarantees omitted fields are zero-initialized.
// - Python C API changes fields across versions.
// - Clang does not warn; GCC does unnecessarily.
// See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96868
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#endif // __GNUC__
/// Type structure of DocumentObjectPy
PyTypeObject DocumentObjectPy::Type = {
    .ob_base = PyVarObject_HEAD_INIT(&PyType_Type,0)
    .tp_name = "App.DocumentObject",
    .tp_basicsize = sizeof(DocumentObjectPy),
    .tp_itemsize = 0,
    /* methods */
    .tp_dealloc = PyDestructor,
    .tp_repr = __repr,
    .tp_getattro = __getattro,
    .tp_setattro = __setattro,
    /* --- Flags to define presence of optional/expanded features */
    .tp_flags = Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT,
    .tp_doc = "This is the father of all classes handled by the document",
    .tp_methods = App::DocumentObjectPy::Methods,
    .tp_getset = App::DocumentObjectPy::GetterSetter,
    .tp_base = &App::ExtensionContainerPy::Type,
    .tp_init = __PyInit,
    .tp_new = App::DocumentObjectPy::PyMake
};
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif // __GNUC__

/// Methods structure of DocumentObjectPy
PyMethodDef DocumentObjectPy::Methods[] = {
    {"addProperty",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_addProperty )),
        METH_VARARGS|METH_KEYWORDS,
        "addProperty(type: string, name: string, group=\"\", doc=\"\", attr=0, read_only=False, hidden=False, locked = False, enum_vals=[]) -- Add a generic property."
    },
    {"removeProperty",
        reinterpret_cast<PyCFunction>( staticCallback_removeProperty ),
        METH_VARARGS,
        "removeProperty(string) -- Remove a generic property.\n"
        "\n"
        "Note, you can only remove user-defined properties but not built-in ones."
    },
    {"supportedProperties",
        reinterpret_cast<PyCFunction>( staticCallback_supportedProperties ),
        METH_VARARGS,
        "A list of supported property types"
    },
    {"touch",
        reinterpret_cast<PyCFunction>( staticCallback_touch ),
        METH_VARARGS,
        "Mark the object as changed (touched)"
    },
    {"purgeTouched",
        reinterpret_cast<PyCFunction>( staticCallback_purgeTouched ),
        METH_VARARGS,
        "Mark the object as unchanged"
    },
    {"enforceRecompute",
        reinterpret_cast<PyCFunction>( staticCallback_enforceRecompute ),
        METH_VARARGS,
        "Mark the object for recompute"
    },
    {"setExpression",
        reinterpret_cast<PyCFunction>( staticCallback_setExpression ),
        METH_VARARGS,
        "Register an expression for a property"
    },
    {"clearExpression",
        reinterpret_cast<PyCFunction>( staticCallback_clearExpression ),
        METH_VARARGS,
        "Clear the expression for a property"
    },
    {"evalExpression",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_evalExpression )),
        METH_VARARGS|METH_CLASS,
        "Evaluate an expression"
    },
    {"recompute",
        reinterpret_cast<PyCFunction>( staticCallback_recompute ),
        METH_VARARGS,
        "recompute(recursive=False): Recomputes this object"
    },
    {"getStatusString",
        reinterpret_cast<PyCFunction>( staticCallback_getStatusString ),
        METH_VARARGS,
        "Returns the status of the object as string.\n"
        "If the object is invalid its error description will be returned.\n"
        "If the object is valid but touched then 'Touched' will be returned,\n"
        "'Valid' otherwise."
    },
    {"isValid",
        reinterpret_cast<PyCFunction>( staticCallback_isValid ),
        METH_VARARGS,
        "Returns True if the object is valid, False otherwise"
    },
    {"getSubObject",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_getSubObject )),
        METH_VARARGS|METH_KEYWORDS,
        "getSubObject(subname, retType=0, matrix=None, transform=True, depth=0)\n"
        "\n"
        "* subname(string|list|tuple): dot separated string or sequence of strings\n"
        "referencing subobject.\n"
        "\n"
        "* retType: return type, 0=PyObject, 1=DocObject, 2=DocAndPyObject, 3=Placement\n"
        "\n"
        "    PyObject: return a python binding object for the (sub)object referenced in\n"
        "    each 'subname' The actual type of 'PyObject' is implementation dependent.\n"
        "    For Part::Feature compatible objects, this will be of type TopoShapePy and\n"
        "    pre-transformed by accumulated transformation matrix along the object path.\n"
        "\n"
        "    DocObject:  return the document object referenced in subname, if 'matrix' is\n"
        "    None. Or, return a tuple (object, matrix) for each 'subname' and 'matrix' is\n"
        "    the accumulated transformation matrix for the sub object.\n"
        "\n"
        "    DocAndPyObject: return a tuple (object, matrix, pyobj) for each subname\n"
        "\n"
        "    Placement: return a transformed placement of the sub-object\n"
        "\n"
        "* matrix: the initial transformation to be applied to the sub object.\n"
        "\n"
        "* transform: whether to transform the sub object using this object's placement\n"
        "\n"
        "* depth: current recursive depth"
    },
    {"getSubObjectList",
        reinterpret_cast<PyCFunction>( staticCallback_getSubObjectList ),
        METH_VARARGS,
        "getSubObjectList(subname)\n"
        "\n"
        "Return a list of objects referenced by a given subname including this object"
    },
    {"getSubObjects",
        reinterpret_cast<PyCFunction>( staticCallback_getSubObjects ),
        METH_VARARGS,
        "getSubObjects(reason=0): Return subname reference of all sub-objects"
    },
    {"getLinkedObject",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_getLinkedObject )),
        METH_VARARGS|METH_KEYWORDS,
        "getLinkedObject(recursive=True, matrix=None, transform=True, depth=0)\n"
        "Returns the linked object if there is one, or else return itself\n"
        "\n"
        "* recursive: whether to recursively resolve the links\n"
        "\n"
        "* transform: whether to transform the sub object using this object's placement\n"
        "\n"
        "* matrix: If not none, this specifies the initial transformation to be applied\n"
        "to the sub object. And cause the method to return a tuple (object, matrix)\n"
        "containing the accumulated transformation matrix\n"
        "\n"
        "* depth: current recursive depth"
    },
    {"setElementVisible",
        reinterpret_cast<PyCFunction>( staticCallback_setElementVisible ),
        METH_VARARGS,
        "setElementVisible(element,visible): Set the visibility of a child element\n"
        "Return -1 if element visibility is not supported, 0 if element not found, 1 if success"
    },
    {"isElementVisible",
        reinterpret_cast<PyCFunction>( staticCallback_isElementVisible ),
        METH_VARARGS,
        "isElementVisible(element): Check if a child element is visible\n"
        "Return -1 if element visibility is not supported or element not found, 0 if invisible, or else 1"
    },
    {"hasChildElement",
        reinterpret_cast<PyCFunction>( staticCallback_hasChildElement ),
        METH_VARARGS,
        "Return true to indicate the object having child elements"
    },
    {"getParentGroup",
        reinterpret_cast<PyCFunction>( staticCallback_getParentGroup ),
        METH_VARARGS,
        "Returns the group the object is in or None if it is not part of a group.\n"
        "\n"
        "Note that an object can only be in a single group, hence only a single return value."
    },
    {"getParentGeoFeatureGroup",
        reinterpret_cast<PyCFunction>( staticCallback_getParentGeoFeatureGroup ),
        METH_VARARGS,
        "Returns the GeoFeatureGroup, and hence the local coordinate system, the object\n"
        "is in or None if it is not part of a group.\n"
        "\n"
        "Note that an object can only be in a single group, hence only a single return value."
    },
    {"getParent",
        reinterpret_cast<PyCFunction>( staticCallback_getParent ),
        METH_VARARGS,
        "Returns the group the object is in or None if it is not part of a group.\n"
        "\n"
        "Note that an object can only be in a single group, hence only a single return value.\n"
        "The parent can be a simple group as with getParentGroup() or a GeoFeature group as\n"
        "with getParentGeoFeatureGroup()."
    },
    {"getPathsByOutList",
        reinterpret_cast<PyCFunction>( staticCallback_getPathsByOutList ),
        METH_VARARGS,
        "Get all paths from this object to another object following the OutList."
    },
    {"resolve",
        reinterpret_cast<PyCFunction>( staticCallback_resolve ),
        METH_VARARGS,
        "resolve(subname) -- resolve the sub object\n"
        "\n"
        "Returns a tuple (subobj,parent,elementName,subElement), where 'subobj' is the\n"
        "last object referenced in 'subname', and 'parent' is the direct parent of\n"
        "'subobj', and 'elementName' is the name of the subobj, which can be used\n"
        "to call parent.isElementVisible/setElementVisible(). 'subElement' is the\n"
        "non-object sub-element name if any."
    },
    {"resolveSubElement",
        reinterpret_cast<PyCFunction>( staticCallback_resolveSubElement ),
        METH_VARARGS,
        "resolveSubElement(subname,append,type) -- resolve both new and old style sub element\n"
        "\n"
        "subname: subname reference containing object hierarchy\n"
        "append: Whether to append object hierarchy prefix inside subname to returned element name\n"
        "type: 0: normal, 1: for import, 2: for export\n"
        "\n"
        "Return tuple(obj,newElementName,oldElementName)"
    },
    {"adjustRelativeLinks",
        reinterpret_cast<PyCFunction>( staticCallback_adjustRelativeLinks ),
        METH_VARARGS,
        "adjustRelativeLinks(parent,recursive=True) -- auto correct potential cyclic dependencies"
    },
    {"getElementMapVersion",
        reinterpret_cast<PyCFunction>( staticCallback_getElementMapVersion ),
        METH_VARARGS,
        "getElementMapVersion(property_name): return element map version of a given geometry property"
    },
    {"isAttachedToDocument",
        reinterpret_cast<PyCFunction>( staticCallback_isAttachedToDocument ),
        METH_VARARGS,
        "isAttachedToDocument() -> bool\n"
        "\n"
        "Return true if the object is part of a document, false otherwise."
    },
    {nullptr, nullptr, 0, nullptr}		/* Sentinel */
};



/// Attribute structure of DocumentObjectPy
PyGetSetDef DocumentObjectPy::GetterSetter[] = {
    {"OutList",
        (getter) staticCallback_getOutList,
        (setter) staticCallback_setOutList,
        "A list of all objects this object links to.",
        nullptr
    },
    {"OutListRecursive",
        (getter) staticCallback_getOutListRecursive,
        (setter) staticCallback_setOutListRecursive,
        "A list of all objects this object links to recursively.",
        nullptr
    },
    {"InList",
        (getter) staticCallback_getInList,
        (setter) staticCallback_setInList,
        "A list of all objects which link to this object.",
        nullptr
    },
    {"InListRecursive",
        (getter) staticCallback_getInListRecursive,
        (setter) staticCallback_setInListRecursive,
        "A list of all objects which link to this object recursively.",
        nullptr
    },
    {"FullName",
        (getter) staticCallback_getFullName,
        (setter) staticCallback_setFullName,
        "Return the document name and internal name of this object",
        nullptr
    },
    {"Name",
        (getter) staticCallback_getName,
        (setter) staticCallback_setName,
        "Return the internal name of this object",
        nullptr
    },
    {"Document",
        (getter) staticCallback_getDocument,
        (setter) staticCallback_setDocument,
        "Return the document this object is part of",
        nullptr
    },
    {"State",
        (getter) staticCallback_getState,
        (setter) staticCallback_setState,
        "State of the object in the document",
        nullptr
    },
    {"ViewObject",
        (getter) staticCallback_getViewObject,
        (setter) staticCallback_setViewObject,
        "If the GUI is loaded the associated view provider is returned\n"
        "or None if the GUI is not up",
        nullptr
    },
    {"MustExecute",
        (getter) staticCallback_getMustExecute,
        (setter) staticCallback_setMustExecute,
        "Check if the object must be recomputed",
        nullptr
    },
    {"ID",
        (getter) staticCallback_getID,
        (setter) staticCallback_setID,
        "The unique identifier (among its document) of this object",
        nullptr
    },
    {"Removing",
        (getter) staticCallback_getRemoving,
        (setter) staticCallback_setRemoving,
        "Indicate if the object is being removed",
        nullptr
    },
    {"Parents",
        (getter) staticCallback_getParents,
        (setter) staticCallback_setParents,
        "A List of tuple(parent,subname) holding all parents to this object",
        nullptr
    },
    {"OldLabel",
        (getter) staticCallback_getOldLabel,
        (setter) staticCallback_setOldLabel,
        "Contains the old label before change",
        nullptr
    },
    {"NoTouch",
        (getter) staticCallback_getNoTouch,
        (setter) staticCallback_setNoTouch,
        "Enable/disable no touch on any property change",
        nullptr
    },
    {nullptr, nullptr, nullptr, nullptr, nullptr}		/* Sentinel */
};

// addProperty() callback and implementer
// PyObject*  DocumentObjectPy::addProperty(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_addProperty (PyObject *self, PyObject *args, PyObject * kwd)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addProperty' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->addProperty(args, kwd);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeProperty() callback and implementer
// PyObject*  DocumentObjectPy::removeProperty(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_removeProperty (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeProperty' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->removeProperty(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// supportedProperties() callback and implementer
// PyObject*  DocumentObjectPy::supportedProperties(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_supportedProperties (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'supportedProperties' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->supportedProperties(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// touch() callback and implementer
// PyObject*  DocumentObjectPy::touch(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_touch (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'touch' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->touch(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// purgeTouched() callback and implementer
// PyObject*  DocumentObjectPy::purgeTouched(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_purgeTouched (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'purgeTouched' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->purgeTouched(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// enforceRecompute() callback and implementer
// PyObject*  DocumentObjectPy::enforceRecompute(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_enforceRecompute (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'enforceRecompute' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->enforceRecompute(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setExpression() callback and implementer
// PyObject*  DocumentObjectPy::setExpression(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_setExpression (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setExpression' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->setExpression(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// clearExpression() callback and implementer
// PyObject*  DocumentObjectPy::clearExpression(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_clearExpression (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'clearExpression' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->clearExpression(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// evalExpression() callback and implementer
// PyObject*  DocumentObjectPy::evalExpression(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_evalExpression (PyObject *self, PyObject *args)
{
    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = DocumentObjectPy::evalExpression(self, args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// recompute() callback and implementer
// PyObject*  DocumentObjectPy::recompute(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_recompute (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'recompute' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->recompute(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getStatusString() callback and implementer
// PyObject*  DocumentObjectPy::getStatusString(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getStatusString (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getStatusString' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->getStatusString(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// isValid() callback and implementer
// PyObject*  DocumentObjectPy::isValid(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_isValid (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'isValid' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->isValid(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getSubObject() callback and implementer
// PyObject*  DocumentObjectPy::getSubObject(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getSubObject (PyObject *self, PyObject *args, PyObject * kwd)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getSubObject' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->getSubObject(args, kwd);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getSubObjectList() callback and implementer
// PyObject*  DocumentObjectPy::getSubObjectList(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getSubObjectList (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getSubObjectList' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->getSubObjectList(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getSubObjects() callback and implementer
// PyObject*  DocumentObjectPy::getSubObjects(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getSubObjects (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getSubObjects' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->getSubObjects(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getLinkedObject() callback and implementer
// PyObject*  DocumentObjectPy::getLinkedObject(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getLinkedObject (PyObject *self, PyObject *args, PyObject * kwd)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getLinkedObject' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->getLinkedObject(args, kwd);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setElementVisible() callback and implementer
// PyObject*  DocumentObjectPy::setElementVisible(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_setElementVisible (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setElementVisible' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->setElementVisible(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// isElementVisible() callback and implementer
// PyObject*  DocumentObjectPy::isElementVisible(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_isElementVisible (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'isElementVisible' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->isElementVisible(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// hasChildElement() callback and implementer
// PyObject*  DocumentObjectPy::hasChildElement(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_hasChildElement (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'hasChildElement' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->hasChildElement(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getParentGroup() callback and implementer
// PyObject*  DocumentObjectPy::getParentGroup(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getParentGroup (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getParentGroup' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->getParentGroup(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getParentGeoFeatureGroup() callback and implementer
// PyObject*  DocumentObjectPy::getParentGeoFeatureGroup(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getParentGeoFeatureGroup (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getParentGeoFeatureGroup' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->getParentGeoFeatureGroup(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getParent() callback and implementer
// PyObject*  DocumentObjectPy::getParent(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getParent (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getParent' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->getParent(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getPathsByOutList() callback and implementer
// PyObject*  DocumentObjectPy::getPathsByOutList(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getPathsByOutList (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getPathsByOutList' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->getPathsByOutList(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// resolve() callback and implementer
// PyObject*  DocumentObjectPy::resolve(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_resolve (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'resolve' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->resolve(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// resolveSubElement() callback and implementer
// PyObject*  DocumentObjectPy::resolveSubElement(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_resolveSubElement (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'resolveSubElement' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->resolveSubElement(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// adjustRelativeLinks() callback and implementer
// PyObject*  DocumentObjectPy::adjustRelativeLinks(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_adjustRelativeLinks (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'adjustRelativeLinks' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->adjustRelativeLinks(args);
        if (ret != nullptr)
            static_cast<DocumentObjectPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getElementMapVersion() callback and implementer
// PyObject*  DocumentObjectPy::getElementMapVersion(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getElementMapVersion (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getElementMapVersion' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->getElementMapVersion(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// isAttachedToDocument() callback and implementer
// PyObject*  DocumentObjectPy::isAttachedToDocument(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_isAttachedToDocument (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'isAttachedToDocument' of 'App.DocumentObject' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<DocumentObjectPy*>(self)->isAttachedToDocument(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// OutList() callback and implementer
// PyObject*  DocumentObjectPy::OutList(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getOutList (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getOutList());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'OutList' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setOutList (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'OutList' of object 'DocumentObject' is read-only");
    return -1;
}

// OutListRecursive() callback and implementer
// PyObject*  DocumentObjectPy::OutListRecursive(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getOutListRecursive (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getOutListRecursive());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'OutListRecursive' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setOutListRecursive (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'OutListRecursive' of object 'DocumentObject' is read-only");
    return -1;
}

// InList() callback and implementer
// PyObject*  DocumentObjectPy::InList(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getInList (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getInList());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'InList' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setInList (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'InList' of object 'DocumentObject' is read-only");
    return -1;
}

// InListRecursive() callback and implementer
// PyObject*  DocumentObjectPy::InListRecursive(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getInListRecursive (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getInListRecursive());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'InListRecursive' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setInListRecursive (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'InListRecursive' of object 'DocumentObject' is read-only");
    return -1;
}

// FullName() callback and implementer
// PyObject*  DocumentObjectPy::FullName(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getFullName (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getFullName());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FullName' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setFullName (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'FullName' of object 'DocumentObject' is read-only");
    return -1;
}

// Name() callback and implementer
// PyObject*  DocumentObjectPy::Name(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getName (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getName());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Name' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setName (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Name' of object 'DocumentObject' is read-only");
    return -1;
}

// Document() callback and implementer
// PyObject*  DocumentObjectPy::Document(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getDocument (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getDocument());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Document' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setDocument (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Document' of object 'DocumentObject' is read-only");
    return -1;
}

// State() callback and implementer
// PyObject*  DocumentObjectPy::State(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getState (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getState());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'State' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setState (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'State' of object 'DocumentObject' is read-only");
    return -1;
}

// ViewObject() callback and implementer
// PyObject*  DocumentObjectPy::ViewObject(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getViewObject (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getViewObject());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'ViewObject' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setViewObject (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'ViewObject' of object 'DocumentObject' is read-only");
    return -1;
}

// MustExecute() callback and implementer
// PyObject*  DocumentObjectPy::MustExecute(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getMustExecute (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getMustExecute());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'MustExecute' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setMustExecute (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'MustExecute' of object 'DocumentObject' is read-only");
    return -1;
}

// ID() callback and implementer
// PyObject*  DocumentObjectPy::ID(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getID (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getID());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'ID' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setID (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'ID' of object 'DocumentObject' is read-only");
    return -1;
}

// Removing() callback and implementer
// PyObject*  DocumentObjectPy::Removing(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getRemoving (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getRemoving());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Removing' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setRemoving (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Removing' of object 'DocumentObject' is read-only");
    return -1;
}

// Parents() callback and implementer
// PyObject*  DocumentObjectPy::Parents(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getParents (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getParents());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Parents' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setParents (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Parents' of object 'DocumentObject' is read-only");
    return -1;
}

// OldLabel() callback and implementer
// PyObject*  DocumentObjectPy::OldLabel(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getOldLabel (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getOldLabel());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'OldLabel' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setOldLabel (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'OldLabel' of object 'DocumentObject' is read-only");
    return -1;
}

// NoTouch() callback and implementer
// PyObject*  DocumentObjectPy::NoTouch(PyObject *args){};
// has to be implemented in DocumentObjectPyImp.cpp
PyObject * DocumentObjectPy::staticCallback_getNoTouch (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<DocumentObjectPy*>(self)->getNoTouch());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'NoTouch' of object 'DocumentObject'");
        return nullptr;
    }
}

int DocumentObjectPy::staticCallback_setNoTouch (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<DocumentObjectPy*>(self)->setNoTouch(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'NoTouch' of object 'DocumentObject'");
        return -1;
    }
}




//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
DocumentObjectPy::DocumentObjectPy(DocumentObject *pcObject, PyTypeObject *T)
    : ExtensionContainerPy(static_cast<ExtensionContainerPy::PointerType>(pcObject), T)
{
}

PyObject *DocumentObjectPy::PyMake(PyTypeObject* /*type*/, PyObject* /*args*/, PyObject* /*kwds*/)
{
    // never create such objects with the constructor
    PyErr_SetString(PyExc_RuntimeError, "You cannot create directly an instance of 'DocumentObjectPy'.");

    return nullptr;
}

int DocumentObjectPy::PyInit(PyObject* /*args*/, PyObject* /*kwd*/)
{
    return 0;
}

//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
DocumentObjectPy::~DocumentObjectPy()                                // Everything handled in parent
{
}

//--------------------------------------------------------------------------
// DocumentObjectPy representation
//--------------------------------------------------------------------------
PyObject *DocumentObjectPy::_repr()
{
    return Py_BuildValue("s", representation().c_str());
}

//--------------------------------------------------------------------------
// DocumentObjectPy Attributes
//--------------------------------------------------------------------------
PyObject *DocumentObjectPy::_getattr(const char *attr)			// __getattr__ function: note only need to handle new state
{
    try {
        // getter method for special Attributes (e.g. dynamic ones)
        PyObject *r = getCustomAttributes(attr);
        if(r) return r;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError,"Unknown C++ exception");
        return nullptr;
    }
#endif

    PyMethodDef *ml = Methods;
    for (; ml->ml_name != nullptr; ml++) {
        if (attr[0] == ml->ml_name[0] &&
            strcmp(attr+1, ml->ml_name+1) == 0)
            return PyCFunction_New(ml, this);
    }

    PyErr_Clear();
    return ExtensionContainerPy::_getattr(attr);
}

int DocumentObjectPy::_setattr(const char *attr, PyObject *value) // __setattr__ function: note only need to handle new state
{
    try {
        // setter for special Attributes (e.g. dynamic ones)
        int r = setCustomAttributes(attr, value);
        // r = 1: handled
        // r = -1: error
        // r = 0: ignore
        if (r == 1)
            return 0;
        else if (r == -1)
            return -1;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return -1;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return -1;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return -1;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return -1;
    }
#endif

    return ExtensionContainerPy::_setattr(attr, value);
}

DocumentObject *DocumentObjectPy::getDocumentObjectPtr() const
{
    return static_cast<DocumentObject *>(_pcTwinPointer);
}

#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#if 0
/* From here on come the methods you have to implement, but NOT in this module. Implement in DocumentObjectPyImp.cpp! This prototypes
 * are just for convenience when you add a new method.
 */



// returns a string which represents the object e.g. when printed in python
std::string DocumentObjectPy::representation() const
{
    return {"<DocumentObject object>"};
}

PyObject* DocumentObjectPy::addProperty(PyObject *args, PyObject *kwds)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::removeProperty(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::supportedProperties(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::touch(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::purgeTouched(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::enforceRecompute(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::setExpression(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::clearExpression(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::evalExpression(PyObject *self, PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::recompute(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::getStatusString(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::isValid(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::getSubObject(PyObject *args, PyObject *kwds)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::getSubObjectList(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::getSubObjects(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::getLinkedObject(PyObject *args, PyObject *kwds)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::setElementVisible(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::isElementVisible(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::hasChildElement(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::getParentGroup(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::getParentGeoFeatureGroup(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::getParent(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::getPathsByOutList(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::resolve(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::resolveSubElement(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::adjustRelativeLinks(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::getElementMapVersion(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* DocumentObjectPy::isAttachedToDocument(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}



Py::List DocumentObjectPy::getOutList() const
{
    //return Py::List();
    throw Py::AttributeError("Not yet implemented");
}

Py::List DocumentObjectPy::getOutListRecursive() const
{
    //return Py::List();
    throw Py::AttributeError("Not yet implemented");
}

Py::List DocumentObjectPy::getInList() const
{
    //return Py::List();
    throw Py::AttributeError("Not yet implemented");
}

Py::List DocumentObjectPy::getInListRecursive() const
{
    //return Py::List();
    throw Py::AttributeError("Not yet implemented");
}

Py::String DocumentObjectPy::getFullName() const
{
    //return Py::String();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object DocumentObjectPy::getName() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object DocumentObjectPy::getDocument() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

Py::List DocumentObjectPy::getState() const
{
    //return Py::List();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object DocumentObjectPy::getViewObject() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean DocumentObjectPy::getMustExecute() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long DocumentObjectPy::getID() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean DocumentObjectPy::getRemoving() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

Py::List DocumentObjectPy::getParents() const
{
    //return Py::List();
    throw Py::AttributeError("Not yet implemented");
}

Py::String DocumentObjectPy::getOldLabel() const
{
    //return Py::String();
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean DocumentObjectPy::getNoTouch() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  DocumentObjectPy::setNoTouch(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

PyObject *DocumentObjectPy::getCustomAttributes(const char* /*attr*/) const
{
    return nullptr;
}

int DocumentObjectPy::setCustomAttributes(const char* /*attr*/, PyObject* /*obj*/)
{
    return 0;
}


#endif



