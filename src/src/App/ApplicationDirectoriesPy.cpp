
// This file is generated by src/Tools/generateTemplates/templateClassPyExport.py out of the .XML file
// Every change you make here gets lost in the next full rebuild!
// This File is normally built as an include in ApplicationDirectoriesPyImp.cpp! It's not intended to be in a project!

#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <CXX/Objects.hxx>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

using Base::streq;
using namespace App;

#if defined(__GNUC__)
#pragma GCC diagnostic push
// Ignore -Wmissing-field-initializers (GCC only):
// - C++20 guarantees omitted fields are zero-initialized.
// - Python C API changes fields across versions.
// - Clang does not warn; GCC does unnecessarily.
// See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96868
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#endif // __GNUC__
/// Type structure of ApplicationDirectoriesPy
PyTypeObject ApplicationDirectoriesPy::Type = {
    .ob_base = PyVarObject_HEAD_INIT(&PyType_Type,0)
    .tp_name = "App.ApplicationDirectories",
    .tp_basicsize = sizeof(ApplicationDirectoriesPy),
    .tp_itemsize = 0,
    /* methods */
    .tp_dealloc = PyDestructor,
    .tp_repr = __repr,
    .tp_getattro = __getattro,
    .tp_setattro = __setattro,
    /* --- Flags to define presence of optional/expanded features */
    .tp_flags = Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT,
    .tp_doc = "App.ApplicationDirectories class.\n"
    "\n"
    "For the time being this class only provides access to the directory versioning methods of its\n"
    "C++ counterpart. These are all static methods, so no instance is needed. The main methods of\n"
    "this class are migrateAllPaths(), usingCurrentVersionConfig(), and versionStringForPath().",
    .tp_methods = App::ApplicationDirectoriesPy::Methods,
    .tp_getset = App::ApplicationDirectoriesPy::GetterSetter,
    .tp_base = &Base::PyObjectBase::Type,
    .tp_init = __PyInit,
    .tp_new = App::ApplicationDirectoriesPy::PyMake
};
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif // __GNUC__

/// Methods structure of ApplicationDirectoriesPy
PyMethodDef ApplicationDirectoriesPy::Methods[] = {
    {"usingCurrentVersionConfig",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_usingCurrentVersionConfig )),
        METH_VARARGS|METH_STATIC,
        "usingCurrentVersionConfig(path)\n"
        "\n"
        "Determine if a given config path is for the current version of the program\n"
        "\n"
        "path  : the path to check"
    },
    {"migrateAllPaths",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_migrateAllPaths )),
        METH_VARARGS|METH_STATIC,
        "migrateAllPaths(paths)\n"
        "\n"
        "Migrate a set of versionable configuration directories from the given paths to a new\n"
        "version. The new version's directories cannot exist yet, and the old ones *must* exist.\n"
        "If the old paths are themselves versioned, then the new paths will be placed at the same\n"
        "level in the directory structure (e.g., they will be siblings of each entry in paths).\n"
        "If paths are NOT versioned, the new (versioned) copies will be placed *inside* the\n"
        "original paths.\n"
        "\n"
        "If the list contains the same path multiple times, the duplicates are ignored, so it is safe\n"
        "to pass the same path multiple times.\n"
        "\n"
        "Examples:\n"
        "    Running FreeCAD 1.1, /usr/share/FreeCAD/Config/ -> /usr/share/FreeCAD/Config/v1-1/\n"
        "    Running FreeCAD 1.1, /usr/share/FreeCAD/Config/v1-1 -> raises exception, path exists\n"
        "    Running FreeCAD 1.2, /usr/share/FreeCAD/Config/v1-1/ -> /usr/share/FreeCAD/Config/v1-2/"
    },
    {"versionStringForPath",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_versionStringForPath )),
        METH_VARARGS|METH_STATIC,
        "versionStringForPath(major, minor) -> str\n"
        "\n"
        "Given a major and minor version number, return a string that can be used as the name for a\n"
        "versioned subdirectory. Only returns the version string, not the full path."
    },
    {"isVersionedPath",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_isVersionedPath )),
        METH_VARARGS|METH_STATIC,
        "isVersionedPath(startingPath) -> bool\n"
        "\n"
        "Determine if a given path is versioned (that is, if its last component contains\n"
        "something that this class would have created as a versioned subdirectory). Returns true\n"
        "for any path that the *current* version of FreeCAD would recognized as versioned, and false\n"
        "for either something that is not versioned, or something that is versioned but for a later\n"
        "version of FreeCAD."
    },
    {"mostRecentAvailableConfigVersion",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_mostRecentAvailableConfigVersion )),
        METH_VARARGS|METH_STATIC,
        "mostRecentAvailableConfigVersion(startingPath) -> str\n"
        "\n"
        "Given a base path that is expected to contain versioned subdirectories, locate the\n"
        "directory name (*not* the path, only the final component, the version string itself)\n"
        "corresponding to the most recent version of the software, up to and including the current\n"
        "running version, but NOT exceeding it -- any *later* version whose directories exist\n"
        "in the path is ignored. See also mostRecentConfigFromBase()."
    },
    {"mostRecentConfigFromBase",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_mostRecentConfigFromBase )),
        METH_VARARGS|METH_STATIC,
        "mostRecentConfigFromBase(startingPath) -> str\n"
        "\n"
        "Given a base path that is expected to contained versioned subdirectories, locate the\n"
        "directory corresponding to the most recent version of the software, up to and including\n"
        "the current version, but NOT exceeding it. Returns the complete path, not just the final\n"
        "component. See also mostRecentAvailableConfigVersion()."
    },
    {"migrateConfig",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_migrateConfig )),
        METH_VARARGS|METH_STATIC,
        "migrateConfig(oldPath, newPath) -> None\n"
        "\n"
        "A utility method to copy all files and directories from oldPath to newPath, handling the\n"
        "case where newPath might itself be a subdirectory of oldPath (and *not* attempting that\n"
        "otherwise-recursive copy)."
    },
    {nullptr, nullptr, 0, nullptr}		/* Sentinel */
};



/// Attribute structure of ApplicationDirectoriesPy
PyGetSetDef ApplicationDirectoriesPy::GetterSetter[] = {
    {nullptr, nullptr, nullptr, nullptr, nullptr}		/* Sentinel */
};

// usingCurrentVersionConfig() callback and implementer
// PyObject*  ApplicationDirectoriesPy::usingCurrentVersionConfig(PyObject *args){};
// has to be implemented in ApplicationDirectoriesPyImp.cpp
PyObject * ApplicationDirectoriesPy::staticCallback_usingCurrentVersionConfig (PyObject *self, PyObject *args)
{
    try { // catches all exceptions coming up from c++ and generate a python exception
        (void)self;
        PyObject* ret = ApplicationDirectoriesPy::usingCurrentVersionConfig(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// migrateAllPaths() callback and implementer
// PyObject*  ApplicationDirectoriesPy::migrateAllPaths(PyObject *args){};
// has to be implemented in ApplicationDirectoriesPyImp.cpp
PyObject * ApplicationDirectoriesPy::staticCallback_migrateAllPaths (PyObject *self, PyObject *args)
{
    try { // catches all exceptions coming up from c++ and generate a python exception
        (void)self;
        PyObject* ret = ApplicationDirectoriesPy::migrateAllPaths(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// versionStringForPath() callback and implementer
// PyObject*  ApplicationDirectoriesPy::versionStringForPath(PyObject *args){};
// has to be implemented in ApplicationDirectoriesPyImp.cpp
PyObject * ApplicationDirectoriesPy::staticCallback_versionStringForPath (PyObject *self, PyObject *args)
{
    try { // catches all exceptions coming up from c++ and generate a python exception
        (void)self;
        PyObject* ret = ApplicationDirectoriesPy::versionStringForPath(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// isVersionedPath() callback and implementer
// PyObject*  ApplicationDirectoriesPy::isVersionedPath(PyObject *args){};
// has to be implemented in ApplicationDirectoriesPyImp.cpp
PyObject * ApplicationDirectoriesPy::staticCallback_isVersionedPath (PyObject *self, PyObject *args)
{
    try { // catches all exceptions coming up from c++ and generate a python exception
        (void)self;
        PyObject* ret = ApplicationDirectoriesPy::isVersionedPath(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// mostRecentAvailableConfigVersion() callback and implementer
// PyObject*  ApplicationDirectoriesPy::mostRecentAvailableConfigVersion(PyObject *args){};
// has to be implemented in ApplicationDirectoriesPyImp.cpp
PyObject * ApplicationDirectoriesPy::staticCallback_mostRecentAvailableConfigVersion (PyObject *self, PyObject *args)
{
    try { // catches all exceptions coming up from c++ and generate a python exception
        (void)self;
        PyObject* ret = ApplicationDirectoriesPy::mostRecentAvailableConfigVersion(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// mostRecentConfigFromBase() callback and implementer
// PyObject*  ApplicationDirectoriesPy::mostRecentConfigFromBase(PyObject *args){};
// has to be implemented in ApplicationDirectoriesPyImp.cpp
PyObject * ApplicationDirectoriesPy::staticCallback_mostRecentConfigFromBase (PyObject *self, PyObject *args)
{
    try { // catches all exceptions coming up from c++ and generate a python exception
        (void)self;
        PyObject* ret = ApplicationDirectoriesPy::mostRecentConfigFromBase(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// migrateConfig() callback and implementer
// PyObject*  ApplicationDirectoriesPy::migrateConfig(PyObject *args){};
// has to be implemented in ApplicationDirectoriesPyImp.cpp
PyObject * ApplicationDirectoriesPy::staticCallback_migrateConfig (PyObject *self, PyObject *args)
{
    try { // catches all exceptions coming up from c++ and generate a python exception
        (void)self;
        PyObject* ret = ApplicationDirectoriesPy::migrateConfig(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}




//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
ApplicationDirectoriesPy::ApplicationDirectoriesPy(ApplicationDirectories *pcObject, PyTypeObject *T)
    : PyObjectBase(static_cast<PyObjectBase::PointerType>(pcObject), T)
{
}

PyObject *ApplicationDirectoriesPy::PyMake(PyTypeObject* /*type*/, PyObject* /*args*/, PyObject* /*kwds*/)
{
    // never create such objects with the constructor
    PyErr_SetString(PyExc_RuntimeError, "You cannot create directly an instance of 'ApplicationDirectoriesPy'.");

    return nullptr;
}

int ApplicationDirectoriesPy::PyInit(PyObject* /*args*/, PyObject* /*kwd*/)
{
    return 0;
}

//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
ApplicationDirectoriesPy::~ApplicationDirectoriesPy()                                // Everything handled in parent
{
}

//--------------------------------------------------------------------------
// ApplicationDirectoriesPy representation
//--------------------------------------------------------------------------
PyObject *ApplicationDirectoriesPy::_repr()
{
    return Py_BuildValue("s", representation().c_str());
}

//--------------------------------------------------------------------------
// ApplicationDirectoriesPy Attributes
//--------------------------------------------------------------------------
PyObject *ApplicationDirectoriesPy::_getattr(const char *attr)			// __getattr__ function: note only need to handle new state
{
    try {
        // getter method for special Attributes (e.g. dynamic ones)
        PyObject *r = getCustomAttributes(attr);
        if(r) return r;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return nullptr;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError,"Unknown C++ exception");
        return nullptr;
    }
#endif

    PyMethodDef *ml = Methods;
    for (; ml->ml_name != nullptr; ml++) {
        if (attr[0] == ml->ml_name[0] &&
            strcmp(attr+1, ml->ml_name+1) == 0)
            return PyCFunction_New(ml, this);
    }

    PyErr_Clear();
    return PyObjectBase::_getattr(attr);
}

int ApplicationDirectoriesPy::_setattr(const char *attr, PyObject *value) // __setattr__ function: note only need to handle new state
{
    try {
        // setter for special Attributes (e.g. dynamic ones)
        int r = setCustomAttributes(attr, value);
        // r = 1: handled
        // r = -1: error
        // r = 0: ignore
        if (r == 1)
            return 0;
        else if (r == -1)
            return -1;
    } // Please sync the following catch implementation with PY_CATCH
    catch(const Base::Exception& e)
    {
        e.setPyException();
        return -1;
    }
    catch(const std::exception& e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return -1;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return -1;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return -1;
    }
#endif

    return PyObjectBase::_setattr(attr, value);
}

ApplicationDirectories *ApplicationDirectoriesPy::getApplicationDirectoriesPtr() const
{
    return static_cast<ApplicationDirectories *>(_pcTwinPointer);
}

#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#if 0
/* From here on come the methods you have to implement, but NOT in this module. Implement in ApplicationDirectoriesPyImp.cpp! This prototypes
 * are just for convenience when you add a new method.
 */



// returns a string which represents the object e.g. when printed in python
std::string ApplicationDirectoriesPy::representation() const
{
    return {"<ApplicationDirectories object>"};
}

PyObject* ApplicationDirectoriesPy::usingCurrentVersionConfig(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ApplicationDirectoriesPy::migrateAllPaths(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ApplicationDirectoriesPy::versionStringForPath(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ApplicationDirectoriesPy::isVersionedPath(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ApplicationDirectoriesPy::mostRecentAvailableConfigVersion(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ApplicationDirectoriesPy::mostRecentConfigFromBase(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ApplicationDirectoriesPy::migrateConfig(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}



PyObject *ApplicationDirectoriesPy::getCustomAttributes(const char* /*attr*/) const
{
    return nullptr;
}

int ApplicationDirectoriesPy::setCustomAttributes(const char* /*attr*/, PyObject* /*obj*/)
{
    return 0;
}


#endif



