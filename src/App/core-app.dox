/**
 * @defgroup APP App
 * @ingroup CORE
 * @brief The part of FreeCAD that works without GUI (console or server mode)
 *
 * @htmlonly
 * <div class="textblock">
 * @endhtmlonly
 *
 * @details It contains the App namespace and defines core concepts such as
 * @ref ApplicationGroup "Application", @ref DocumentGroup "Document", @ref
 * DocumentObjectGroup "DocumentObject", @ref PropertyFramework "Property
 * Framework", @ref ExpressionFramework "Expression Framework", and the @ref
 * ExtensionFramework "Extension Framework".
 *
 * The largest difference between the functionality in @ref BASE "Base"
 * compared to %App is that %App introduces the notion of properties, both used
 * in @ref App::Document "Document" and @ref App::DocumentObject
 * "DocumentObject".  In addition, %App has a representation of the running
 * @ref App::Application "Application".
 *
 * @htmlonly
 * </div>
 * @endhtmlonly
 */

/**
 * @defgroup ApplicationGroup Application
 * @ingroup APP
 * @brief The class that represents the running FreeCAD application.
 *
 * The App::Application class is a singleton class that represents the running
 * FreeCAD application.  It can be obtained by App::GetApplication().  It
 * manages the opened documents and provides various forms of functionality
 * that are briefly discussed below.
 *
 * @section SecApplicationInitialization Initialization and Configuration
 *
 * On application start, the FreeCAD type system is initialized and the command
 * line arguments are processed, possible opening FreeCAD files or executing
 * FreeCAD macros.  The internal configuration that contains various paths is
 * set up and after that the `user.cfg` and `system.cfg` file are parsed and
 * made available by @ref App::Application::GetUserParameter()
 * "GetUserParameter()" and @ref App::Application::GetSystemParameter()
 * "GetSystemParameter()".
 *
 * FreeCAD obtains various resources from different paths that can be accessed
 * by means of functions such as @ref App::Application::GetHomePath()
 * "GetHomePath" or the more generic function @ref
 * App::Application::directories "directories()" that provides an @ref
 * App::ApplicationDirectories "ApplicationDirectories" class.
 *
 * @section SecApplicationDocuments Document management
 *
 * An important role is managing FreeCAD documents.  The application class
 * allows opening and closing documents, creating unique and valid names and
 * labels for the files, and setting or opening a file as the active file.
 *
 * Moreover, there is support for special files such as temporary files that
 * may or may not be hidden in the tree or partially loaded files where not all
 * objects are loaded.
 *
 * FreeCAD has a wide range of file formats that it can import and export.  It
 * is possible to install a file type filter together with a module name that
 * then becomes responsible for importing or exporting the file types of the
 * filter.  An example of a filter is @c "STEP with colors (*.step *.STEP *.stp
 * *.STP)" and the file types that will be associated with this filter are
 * represented by the extensions and will be @c "step" and @c "stp" (matching
 * is case-insensitive).
 *
 * @section SecApplicationTransactions Application-wide transactions
 *
 * In @ref SecUndoRedo "Documents" we explain more about the transaction
 * system.  Although transactions are mainly a feature of documents and
 * document objects, there is also applicaton-wide functionality that allows
 * creating transactions in multiple documents sharing the same transaction ID.
 *
 * @section SecApplicationLinks Links between document objects
 *
 * Although links occur between document objects and are as such more a topic
 * of @ref GroupDocumentObject "DocumentObjects", App::Application provides
 * functions to check for cyclic dependencies and obtaining links to a document
 * object.
 *
 * @section SecApplicationSignals Signals
 *
 * The application class has various signals that can be connected to.  There
 * are various categories of signals:
 * - on the level of the application, such as with new or deleted documents or
 *   transactions,
 * - on the level of documents, such as with changed properties of documents or
 *   document objects, or with newly added objects,
 * - on the level of objects, such as newly added properties,
 * - on the level of extensions, such as newly added extensions.
 *
 * Many of the signals are also available on the document level and typically
 * the application class has slots that connect to these document signals when
 * a document is opened.
 */

/**
 * @defgroup DocumentGroup Document
 * @ingroup APP
 * @brief The class that represents a FreeCAD document.
 *
 * This (besides the App::Application class) is the most important class in
 * FreeCAD.  It contains all the data of the opened, saved, or newly created
 * FreeCAD %Document.  The App::Document class manages the undo and redo
 * mechanism and linking of documents.
 *
 * Note: Documents are not freestanding objects. They are completely handled by the
 * App::Application class. Only the application can open or destroy a document.
 *
 * @section SecDocumentProperties Documents as property containers
 *
 * The main role of a document is being a container of @ref DocumentObjectGroup
 * "DocumentObjects".  Both a @ref DocumentObjectGroup "DocumentObject" and a
 * @ref App::Document "Document" are @ref PropertyFramework
 * "PropertyContainers" and can hold properties.
 *
 * However, there is a crucial difference between the properties in a document
 * and in a document object.  The properties in a document cannot be the target
 * of expressions and they do not take part in the dependency check mechanism.
 * This means that if a document object references a property of a document and
 * the document property is changed, the document object that references the
 * document property will not be marked to be recomputed.  As such, the
 * properties in a document should be regarded as simple properties for
 * file-related information.
 *
 * @section SecObjectManagement Object management
 *
 * As mentioned above, a document is a container of document objects.  Document
 * objects can only exist inside a document and the document provides
 * functionality to create, remove, and access document objects.  For example,
 * it is possible to get objects of a specific type or with a specific
 * extension.
 *
 * The document also manages the names and labels document objects, ensuring
 * that names are unique and that labels are unique if configured to have
 * unique labels.
 *
 * @section DependencyGraph Dependencies between document objects
 *
 * Objects can link to other objects in the same document or in other documents
 * and as such dependencies between document objects come into existence.  The
 * document is responsible for recomputing document objects if some property of
 * a document object changes.  The dependencies between document objects
 * determine in which order the objects must be recomputed.
 *
 * To compute the objects in the right order, the document computes a
 * dependency graph based on the information contained in the OutLists and
 * InLists of the document objects.  For more information on OutLists and
 * InLists, see @ref SecDocumentObjectRecompute "Document Objects".  Given the
 * dependency graph, the document computes the list of objects in topological
 * order (not to be confused with topological naming) which means that the
 * objects without dependencies come first and then the objects that depend on
 * these objects, etc.
 *
 * The document will check for each object in the list whether the object is
 * "touched", which means that it is marked to be recomputed.  If so, the
 * object is recomputed and the objects in the InList of that object are
 * touched as well.  Because of the topological order, these objects will come
 * in a later iteration.
 *
 * This mechanism allows FreeCAD to recompute only the objects that need to be
 * recomputed and in only one pass over the list of objects.  However, it is
 * important that the dependency graph does not contain cycles and is a
 * "Directed Acyclic Graph" or DAG.  As such, cyclic dependencies are not
 * allowed in FreeCAD.
 *
 * @section SecUndoRedo Undo Redo and Transactions
 *
 * Another important responsbility of documents is to manage undo and redo
 * actions.  The information to support undo and redo is captured in
 * transactions.  It is important to understand that transactions are a feature
 * of document objects and not of documents.  This means that a change of a
 * property inside a document (as opposed to inside a document object) is not
 * captured by the transaction system (similar to the fact that document
 * properties do not support expressions).
 *
 * The transaction system is quite complex and acts on various levels.
 * Although the transactions themselves only capture changes regarding document
 * objects, the transactions are managed in the document.  Although the
 * transactions are managed inside a document, it is possible to support
 * transactions that affect multiple documents.  This is managed by the GUI and
 * if a change affects multiple documents, then all documents will store
 * transactions that change its document and they will all have the same
 * transaction ID.
 *
 * The mechanisms for undo and redo are part of the @ref APP "App" level, but
 * the GUI defines the transactions (where to open a transaction, where to
 * commit or abort) and it initiates the undo and redo actions.
 *
 * The transaction system makes use of classes with very similar names which
 * can be confusing.  Here is a short overview:
 *
 * - A @ref App::TransactionalObject "TransactionalObject" is a base class that
 *   provides the functionality to support transactions.  It is inherited by
 *   @ref App::DocumentObject "DocumentObject".
 * - A @ref App::TransactionObject "TransactionObject" is a class that
 *   represents a single action and can express adding a new object, removing
 *   an object or changing an object.  Subclasses of the transaction object are
 *   @ref App::TransactionDocumentObject "TransactionDocumentObject" and
 *   @ref Gui::TransactionViewProvider "Gui::TransactionViewProvider".
 * - A @ref App::Transaction "Transaction" captures a single undo or redo
 *   action and consists of multiple @ref App::TransactionObject
 *   "TransactionObjects" associated with their @ref App::TransactionalObject
 *   "TransactionalObject", often a @ref App::DocumentObject "DocumentObject".
 */

/**
 * @defgroup DocumentObjectGroup DocumentObject
 * @ingroup APP
 * @brief %Base class of all objects handled in the @ref App::Document "Document".
 *
 * A DocumentObject is the base class of all objects that can be contained in a
 * FreeCAD @ref App::Document "Document".  Document objects can represent any
 * object that can be created in a FreeCAD Document, such as features:
 * Part::Feature, Mesh::Feature, Sketcher::SketchObject, but also other objects
 * such as App::Link, App::DocumentObjectGroup, App::VarSet, or
 * SpreadSheet::Sheet that do not necessary represent geometry.
 *
 * Document objects provide the functionality to handle properties (it extends
 * @ref App::PropertyContainer "PropertyContainer"), transactions (it extends
 * @ref App::TransactionalObject "TransactionalObject") and extensions (it
 * extends @ref App::ExtensionContainer "ExtensionContainer"), and expressions.
 * Expressions are managed by the property @ref
 * App::DocumentObject::ExpressionEngine "ExpressionEngine", which is a special
 * type of a link property that contains expressions that may link to other
 * document objects.
 *
 * @section SecDocumentObjectRecompute Recomputing Document Objects
 *
 * Objects can be recomputed, which means that the properties of the object are
 * recomputed.  Since properties may depend on other document objects, for
 * example because of the @ref App::DocumentObject::ExpressionEngine
 * "ExpressionEngine" property, these document objects have to be computed
 * first.  For more information on the role of expressions in recomputing
 * document objects, see topic @ref SecExpressionsDocumentObjectRecompute
 * "Expressions Framework".
 *
 * Managing the order of recomputation is managed by the @ref
 * App::Document "Document" which calls the @ref
 * App::DocumentObject::recompute() "recompute()" on the document object.  To
 * signal that a document object needs to be recomputed, the document object
 * can be touched (see @ref App::DocumentObject::touch() "touch()" and @ref
 * App::DocumentObject::isTouched() "isTouched()").
 *
 * As part of recomputation, the document object can also be executed or
 * "invoked", (see @ref App::DocumentObject::execute() "execute()") which
 * results in recomputing the output properties of the object.
 *
 * Although recomputation is mostly orchestrated by the @ref App::Document
 * "Document", document objects play an important role in capturing the
 * dependencies between document objects in terms of OutLists and InLists.
 *
 * Dependencies between document objects come into existence because of links
 * and if a document object `A` links to another document object `B`, then `B`
 * is in the OutList of `A` and `A` is in the InList of `B`.  The InList for an
 * object `Obj` represents the document objects that are dependent on it.  The
 * outlist of an object `Obj` represent the dependencies of it.  So, to
 * recompute `Obj`, first the objects in the outlist need to be recomputed.
 * Vice versa, if a property of an object is changed, the InList indicates
 * which other objects depend on it and need to be recomputed.
 *
 * So, as mentioned above, links define dependencies between document objects.
 * These dependencies are recorded by means of setting the value of a @ref
 * App::PropertyLink "PropertyLink" (and similar properties) in a document
 * object `Obj` to a document object `Value`.  Within @ref
 * App::PropertyLink::setValue() "PropertyLink::setValue()" (and similar
 * methods for other link properties), the (internal) methods _addBackLink() or
 * _removeBackLink() will be called on `Value` with as argument the container
 * of the property link `Obj`, indicating that `Obj` depends on `Value`.  With
 * this methodology, each document object will build up its own InList that can
 * be used during recomputation to query which other document objects need to
 * be computed.
 *
 * The OutList and InList can be accessed by the methods @ref
 * App::DocumentObject::getOutList() "getOutList()" and @ref
 * App::DocumentObject::getInList() "getInList()".
 *
 * @section SecDocumentObjectProperties Properties
 *
 * The document object introduces three properties:
 *
 * - @ref App::DocumentObject::Label "Label" which is a string that identifies
 *   the object in the document and is used to display the object in the GUI.
 * - @ref App::DocumentObject::Label2 "Label2" which is a string that contains
 *   additional information about the object and is used for the description of
 *   the object.
 * - @ref App::DocumentObject::ExpressionEngine "ExpressionEngine" which
 *   contains a mapping from @ref App::ObjectIdentifier "ObjectIdentifier" to
 *   @ref App::Expression "Expression".  The object identifier defines the
 *   properties that store the result of the expression.
 * - @ref App::DocumentObject::Visibility "Visibility" which is a boolean
 *   that indicates whether the object is visible in App namespace.
 *
 * @section SecDocumentObjectSignals Signals
 *
 * A document object has three signals that can be connected to:
 *
 * - @ref App::DocumentObject::signalBeforeChange "signalBeforeChange" which is
 *   emitted before a property of the document object is changed.  This signal
 *   can be used to prepare for changes to the document object.
 * - @ref App::DocumentObject::signalChanged "signalChanged" which is emitted
 *   after a property of the document object has changed.
 * - @ref App::DocumentObject::signalEarlyChanged "signalEarlyChanged" which
 *   is also emitted after a property has changed but emitted right before
 *   "signalChanged".
 *
 * Note that at the @ref App::Document "Document" level, there are also similar
 * signals.
 *
 * @section SecDocumentObjectSeparation Separation App/Gui
 *
 * In FreeCAD there is a strict separation between the App and Gui parts.  A
 * @ref App::DocumentObject "DocumentObject" typically has a Gui::ViewProvider
 * class associated with it.  The method @ref
 * App::DocumentObject::getViewProviderName() "getViewProviderName()" defines
 * what the type of the class of the view provider is, allowing the Gui to
 * retrieve the type and construct a view provider.
 *
 * Another intresting aspect of the separation is that the property @ref
 * App::DocumentObject::Visibility "Visibility" is defined both in
 * App::DocumentObject and in @ref Gui::ViewProviderDocumentObject::Visibility
 * "Gui::ViewProviderDocumentObject".
 */

/**
 * @defgroup PropertyFramework Property framework
 * @ingroup APP
 * @brief System to access object properties.
 *
 * @section propframe_intro Introduction
 *
 * The property framework introduces an intricate system to access properties
 * of objects.  It provides the ability to:
 * 1. define properties in a class and access them by name,
 * 2. add properties to a class at runtime and access them by name, and
 * 3. access properties of a class by name without knowing the class type.
 *
 * The first two points are similar to what the dynamic reflection framework of
 * C# or Java offer.  The third point allows FreeCAD to have App::Property as a
 * generic interface to access properties.  This is similar to the way that
 * Python allows to access properties of a class by name.
 *
 * This ability is introduced by the @ref App::PropertyContainer
 * "PropertyContainer" class and can be used by all derived classes.  In
 * particular, there are two classes that inherit from @ref
 * App::PropertyContainer "PropertyContainer" which are @ref App::Document
 * "Document" and @ref App::DocumentObject "DocumentObject".  These two classes
 * serve different purposes but are both able to hold properties.  @ref
 * App::PropertyContainer "PropertyContainer" contains the shared logic to do
 * so.
 *
 * @section propframe_static_dynamic_props Static/Dynamic Properties
 *
 * In C++, it is possible to define properties as part of the class.  These can
 * be considered "static" properties but this term is typically not used within
 * FreeCAD.  Properties created in a class cannot be removed from a @ref
 * App::PropertyContainer "PropertyContainer".
 *
 * However, it is also possible to add properties to a @ref
 * App::PropertyContainer "PropertyContainer" at runtime.  These properties are
 * called "dynamic properties" and these properties can be freely added and
 * removed by users.  In Python, all properties are dynamic properties.
 *
 * @section propframe_mechanisms Mechanisms
 *
 * The macros `PROPERTY_HEADER` and `PROPERTY_SOURCE` (and variants) are used
 * to define a private static PropertyData member in the class.  This data
 * structure contains a multi index that maps 1) the property name to the
 * property specifications @ref App::PropertyData::PropertySpec "PropertySpec",
 * allowing access of properties by name, and 2) maps the offset of a property
 * with respect to its container, allowing access to property specifications.
 *
 * The static function @ref App::PropertyContainer::getPropertyDataPtr()
 * "PropertyContainer::getPropertyDataPtr()" is used to access the class-wide
 * static @ref App::PropertyData "PropertyData" structure shared by all
 * instances of the class.  The virtual function @ref
 * App::PropertyContainer::getPropertyData()
 * "PropertyContainer::getPropertyData()" allows access to the class-level
 * static PropertyData based on the dynamic type of the object, even when
 * downcasted.  This allows for example a @ref App::PropertyInteger
 * "PropertyInteger*" downcasted to @ref App::Property "Property*" to access
 * all its properties.
 *
 * Since the @ref App::PropertyData "PropertyData" structure is static in the
 * class and maintains static information of properties, such as the group and
 * documentation, we need to be able to access a specific instance given a
 * property name.  This is achieved by looking up the @ref
 * App::PropertyData::PropertySpec "PropertySpec" in the index based on the
 * property name.  The property specification stores an offset to the property
 * address given an @ref App::PropertyData::OffsetBase "OffsetBase" which wraps
 * the address of a @ref App::PropertyContainer "PropertyContainer".  See @ref
 * App::PropertyData::findProperty() "PropertyData::findProperty()" and @ref
 * App::PropertyData::OffsetBase::getOffsetTo() "OffsetBase::getOffsetTo()".
 * The offset of the property relative to the offset base gives us the address
 * of the property in the instance.  Note that different values for properties
 * across property containers are stored in the @ref App::Property "Property" instances.
 *
 * The reverse is also needed: Given a property in a property container, it is
 * possible to compute the offset relative to the base of the property
 * container.  The index in @ref App::PropertyData "PropertyData" allows us to
 * acquire the property spec and provides us with the static data associated
 * with the property.
 *
 * Dynamic properties are stored in their own @ref App::DynamicProperty
 * "DynamicProperty" container.  It can be added with the function @ref
 * App::PropertyContainer::addDynamicProperty()
 * "PropertyContainer::addDynamicProperty()" and removed with @ref
 * App::PropertyContainer::removeDynamicProperty()
 * "PropertyContainer::removeDynamicProperty()".  The rest of the interface of
 * dynamic properties is virtually the same.  In general, in FreeCAD, it is
 * difficult for users to know whether a property is dynamic or static and they
 * typically do not need to be concerned with this distinction.
 *
 * @section Locking Dynamic Properties
 *
 * Since in Python all properties are dynamic properties, it is difficult to
 * understand whether properties are part of a Python class and are necessary
 * for the functioning of the class, or whether a user has added these
 * properties.  Therefore, it is possible to indicate that a property is
 * "locked":
 *
 * @code
 * prop->setStatus(Property::LockDynamic, true);
 * @endcode
 *
 * In Python, this can be indicated in the `addProperty()` function:
 *
 * @code
 * addProperty(type: string, name: string, group="", doc="",
 *             attr=0, read_only=False, hidden=False,
 *             locked=False, enum_vals=[])
 * @endcode
 *
 * The Property Framework makes it possible in the first place to make an
 * automatic mapping to python (e.g. in App::FeaturePy) and abstract editing
 * properties in Gui::PropertyEditor.
 *
 * @section Examples
 *
 * Here some little examples how to use the property framework:
 *
 * @code
 * // Acquire a property by name and return the value as a Python object.
 * Property *prop = feature->getPropertyByName(nameProperty);
 * if (prop) {
 *   return prop->getPyObject();
 * }
 * @endcode
 *
 * or:
 *
 * @code
 * // Restore properties from a reader.
 * void PropertyContainer::Restore(Base::Reader &reader)
 * {
 *   reader.readElement("Properties");
 *   int Cnt = reader.getAttributeAsInteger("Count");
 *
 *   for(int i=0 ;i<Cnt ;i++) {
 *     reader.readElement("Property");
 *     string PropName = reader.getAttribute("name");
 *     Property* prop = getPropertyByName(PropName.c_str());
 *     if(prop) {
 *       prop->Restore(reader);
 *     }
 *
 *     reader.readEndElement("Property");
 *   }
 *   reader.readEndElement("Properties");
 * }
 * @endcode
 */

/**
 * @defgroup ExpressionFramework Expressions framework
 * @ingroup APP
 * @brief A system that allows users to write expressions and formulas that produce values.
 *
 * One of the differences between @ref DocumentObjectGroup "DocumentObjects"
 * and @ref DocumentGroup "Documents" as @ref PropertyFramework
 * "PropertyContainers" is that document objects support expressions whereas
 * documents do not.  %Document objects have a special hidden property called
 * @ref App::DocumentObject::ExpressionEngine "ExpressionEngine" of type @ref
 * App::PropertyExpressionEngine "PropertyExpressionEngine" that contains a
 * mapping from @ref App::ObjectIdentifier "ObjectIdentifier" to @ref
 * App::Expression "Expression".  An object identifier defines the property
 * inside the document object that will hold the result of the expression.  We
 * can also say that the expression is bound to the property that the object
 * identifier identifies.
 *
 * Expressions can be as simple as `2 + 3`, but typically they reference other
 * document objects and their properties, such as `Box001.Length` or even
 * document objects in other documents such as `myDocument#Box001.Length`.
 *
 * Since expressions can reference other document objects, they effectively
 * link to other document objects, potentially in other documents, and as such,
 * a @ref App::PropertyExpressionEngine "PropertyExpressionEngine" inherits
 * from the property external link container @ref App::PropertyXLinkContainer
 * "PropertyXLinkContainer".
 *
 * @section SecExpressionsDocumentObjectRecompute The role of expressions in recomputing Documents
 *
 * For a high level overview of how document objects recompute, see topics @ref
 * DependencyGraph "Document" and @ref SecDocumentObjectRecompute "Document
 * Objects".  On a recompute of a document object, the expressions in the
 * expression engine are first evaluated by calling the @ref
 * App::PropertyExpressionEngine::execute "PropertyExpressionEngine::execute()"
 * function.  This function obtains the values of the properties it references
 * and evaluates the expression to a value that is stored in the property to
 * which the expression is bound to.
 *
 * Now that the properties of the document objects have been updated according
 * to the expressions, the document object can call @ref
 * App::DocumentObject::execute "DocumentObject::execute()" to update its
 * internal properties.
 *
 * After this execute of the document objects, the expression engine is
 * executed again, but now only for the output properties ensuring that
 * expressions that depend on properties of the document object itself that are
 * set by @ref App::DocumentObject::execute "DocumentObject::execute()" are
 * also updated.
 *
 * This process makes clear why it is important that there is a well-defined
 * dependency graph and a topological order of document objects in terms of
 * their dependencies as was discussed in topic @ref DependencyGraph
 * "Document": If a document object is executed and references a property of
 * another document object, we need to make sure that that document object has
 * fully recomputed as we would compute a stale value of the property
 * otherwise.  Similarly, objects that refer to properties of a recently
 * recomputed document object, need to be certain that the properties of this
 * object have the latest value.  As such, it is not possible to have a cyclic
 * dependency between document objects as they would continuously update
 * themselves.
 *
 * @section SecExpressionVisitors Expression Visitors
 *
 * Some actions require that expressions are updated.  For example, when a document
 * is relabeled, expressions that refer to the old name must be updated to
 * refer to the new name.
 *
 * For this purpose, the visitor pattern is used.  An expression visitor is derived
 * from @ref App::ExpressionVisitor "ExpressionVisitor" and implements the
 * virtual function @ref App::ExpressionVisitor::visit "visit()".  This
 * function is called for each node in the expression tree.
 *
 * There are two types of visitors: ones that gather information, for example a
 * list of object identifiers in the expression, and ones that modify the
 * expression, for example in case a document is relabeled.
 */

/**
 * @defgroup ExtensionFramework Extension framework
 * @ingroup APP
 * @brief The extension system provides a way to extend the functionality of @ref DocumentObjectGroup "DocumentObjects".
 *
 * The concept of extensions provides a way to extend the functionality of
 * objects in FreeCAD despite Python's limitations with multiple inheritance
 * (see below for an explanation).  Extensions are FreeCAD objects that act
 * like regular objects in the sense that they have properties and class
 * methods to define their functionality.  However, extensions are not exposed
 * as individual usable entities but are used to extend other objects.  An
 * extended object obtains all the properties and methods of the extension.
 *
 * As such, it is like C++ multiple inheritance, which is indeed used to
 * achieve this on C++ side, but it provides a few important additional
 * functionalities as well:
 *
 * - Property persistence is handled: save and restore work out of the box.
 * - The objects Python API gets extended too with the extension Python API.
 * - Extensions can be added from C++ and Python, even from both together.
 *
 * The interoperability with Python is highly important since in FreeCAD, all
 * functionality should be easily accessible from both Python and C++.  To
 * ensure this -- as already noted -- extensions can be added to an object from
 * Python.
 *
 * However, this means that it is not clear from the C++ object type whether an
 * extension was added or not:  If added from C++, it becomes clear in the type
 * due to the use of multiple inheritance.  If added from Python, it is a
 * runtime extension and not visible from the type.  Hence, querying existing
 * extensions of an object and accessing its methods works not by type casting
 * but by the interface provided in ExtensionContainer.  The default workflow
 * is to query whether an extension exists and then to get the extension
 * object.  This interface always works the same, no matter if added from
 * Python or C++.
 *
 * @code
 * if (object->hasExtension(GroupExtension::getClassTypeId())) {
 *     App::GroupExtension* group = object->getExtensionByType<GroupExtension>();
 *     group->hasObject(...);
 * }
 * @endcode
 *
 * To add an extension to an object, it must comply to a single restriction: it
 * must be derived from ExtensionContainer.  This is important to allow adding
 * extensions from Python and also to access the universal extension API. As
 * DocumentObject itself derives from ExtensionContainer, this should be the
 * case automatically in most circumstances.
 *
 * Note that two small boilerplate changes are needed in addition to the
 * multiple inheritance when adding extensions from C++.
 *
 * 1. It must be ensured that the property and type registration is aware of
 *    the extensions by using special macros.
 * 2. The extensions need to be initialised in the constructor.
 *
 * Here is a working example:
 * @code{.cpp}
 * class AppExport Part : public App::DocumentObject
 *                      , public App::FirstExtension
 *                      , public App::SecondExtension
 * {
 *     PROPERTY_HEADER_WITH_EXTENSIONS(App::Part);
 * };
 *
 * PROPERTY_SOURCE_WITH_EXTENSIONS(App::Part, App::DocumentObject)
 *
 * Part::Part(void)
 * {
 *   FirstExtension::initExtension(this);
 *   SecondExtension::initExtension(this);
 * }
 * @endcode
 *
 * From Python, adding an extension is easier: It must be simply registered to
 * a document object at object initialisation like done with properties.  Note
 * that the special Python extension objects need to be added, not the C++
 * objects.  Normally the only difference in name is the additional "Python" at
 * the end of the extension name.
 *
 * @code{.py}
 * class Test():
 *   __init(self)__:
 *     registerExtension("App::FirstExtensionPython", self)
 *     registerExtension("App::SecondExtensionPython", self)
 * @endcode
 *
 * Extensions can provide methods that should be overridden by the extended
 * object for customisation of the extension behaviour. In C++ this is as
 * simple as overriding the provided virtual functions. In Python a class
 * method must be provided which has the same name as the method to override.
 * This method must not necessarily be in the object that is extended, it must
 * be in the object which is provided to the "registerExtension" call as second
 * argument.  This second argument is used as a proxy and queried if the method
 * to override exists in this proxy before calling it.
 *
 * @section SecExtensionFrameworkCreateExtension Create an Extension
 *
 * An Extension is like every other FreeCAD object and is based on properties.
 * All information storage and persistence should be achieved by use of these
 * properties.  Additionally, any number of methods can be added to provide
 * functionality related to the properties. There are three small differences
 * to normal objects:
 *
 * 1. They must be derived from this Extension class,
 * 2. Properties must be handled with special extension macros.
 * 3. Extensions must be initialised.
 *
 * The following code illustrates the basic setup of an extension:
 *
 * @code
 * class MyExtension : public Extension
 * {
 *   EXTENSION_PROPERTY_HEADER(MyExtension);
 *   PropertyInt MyProp;
 *   virtual bool overridableMethod(DocumentObject* obj) {};
 * };
 *
 * EXTENSION_PROPERTY_SOURCE(App::MyExtension, App::Extension)
 * MyExtension::MyExtension()
 * {
 *     EXTENSION_ADD_PROPERTY(MyProp, (0))
 *     initExtensionType(MyExtension::getExtensionClassTypeId());
 * }
 *
 * using MyExtensionPython = ExtensionPythonT<MyExtension>;
 * @endcode
 *
 * The special Python extension type created above is important, as only those Python extensions
 * can be added to an object from Python. It does not work to add the C++ version directly there.
 *
 * Note that every method of the extension becomes part of the extended object when added from C++.
 * This means one should carefully design the API and make only necessary methods public or protected.
 * Every internal method should be private.
 *
 * The automatic availability of methods in the class does not hold for the
 * Python interface, only for C++ classes.  This is common in the rest of
 * FreeCAD as well: there is no automatic creation of Python API from C++
 * classes.
 *
 * Hence, the extension creator must also create a custom Python object of its
 * extension, which is the same for the normal FreeCAD Python object workflow.
 * There is nothing special at all for Python extension objects: the normal
 * `.pyi` and `PyImp.cpp` approach is used but note that it is important that
 * the object's father is the correct extension base class.  Additionally, make
 * sure the extension returns the correct Python object in its
 * getExtensionPyObject() call.
 *
 * Every method that is created in the extension's Python counterpart will be
 * later added to the extended object.  This happens automatically for both the
 * C++ and Python extension if getExtensionPyObject() returns the correct
 * Python object.  This does not require extra work.
 *
 * A special case that needs to be handled for extensions is the possibility of
 * overridden methods.  Often, it is desired to customise extension behaviour
 * by allowing the user to override methods provided by the extension.  On the
 * C++ side, this is trivial: such methods are simply marked as "virtual" and
 * can then be overridden in any derived class.  This is more involved for the
 * Python interface and here special care needs to be taken.
 *
 * As already shown above, one needs to create a special `ExtensionPythonT<>`
 * object for extension from Python.  This is done exactly for the purpose of
 * allowing to have overridable methods.  The ExtensionPythonT wrapper adds a
 * proxy property that holds a PyObject which itself will contain the
 * implementations for the overridden methods.  This design is equal to the
 * ObjectPythonT<> design of normal document objects.  As this wrapper inherits
 * the C++ extension class it, can also override the virtual functions the user
 * designed to be overridden.  What it should do at a call of the virtual
 * method is to check if this method is implemented in the proxy object and if
 * so, call it, and if not, call the normal C++ version.  It is the extension
 * creator's responsibility to implement this check and call behaviour for
 * every overridable method.  This is done by creating a custom wrapper just
 * like ExtensionPythonT<> and overriding all virtual methods.
 *
 * @code
 * template<typename ExtensionT> class MyExtensionPythonT : public ExtensionT {
 * public:
 *
 *   MyExtensionPythonT() {}
 *   virtual ~MyExtensionPythonT() {}
 *
 *   virtual bool overridableMethod(DocumentObject* obj)  override {
 *       Py::Object pyobj = Py::asObject(obj->getPyObject());
 *       EXTENSION_PROXY_ONEARG(allowObject, pyobj);
 *
 *       if(result.isNone())
 *           ExtensionT::allowObject(obj);
 *
 *       if(result.isBoolean())
 *           return result.isTrue();
 *
 *       return false;
 *   };
 * };
 * @endcode
 *
 * @note As seen in the code there are multiple helper macros to ease the
 * repetitive work of querying and calling methods of the proxy object. See the
 * macro documentation for how to use them.
 *
 * To ensure that your wrapper is used when a extension is created from Python
 * the extension type must be exposed as follows:
 *
 * @code
 * using MyExtensionPython = ExtensionPythonT<MyExtensionPythonT<MyExtension>>;
 * @endcode
 *
 * This boilerplate is absolutely necessary to allow overridable methods in
 * Python and it is the extension creator's responsibility to ensure full
 * implementation.
 *
 * @section SecExtensionLimitiationsPython Limitations of Python
 *
 * Without this extension system, it would be challenging to extend
 * functionality in FreeCAD.  Although C++ supports multiple inheritance, it is
 * not possible to use it in FreeCAD because it should be possible to expose
 * all objects to Python.
 *
 * However, using multiple parent classes in Python is currently not possible
 * with the default object approach.  Moreover, it is basically impossible to
 * handle multiple inheritance in the C-API for Python extensions.
 */

/**
 * @defgroup LinksGroup Links
 * @ingroup APP
 * @brief Links determine relations between document objects and documents.
 *
 * App::Link document objects are special document objects that create links to
 * other document objects, potentially in other documents.  Links are special
 * document objects that inherit most properties from the object they are
 * linked to, but they can override some properties as well, such as the
 * placement, color, or scale.  More precisely, the properties that can be
 * overridden typically apply simple transforms on the shape of the linked
 * object.
 *
 * The most visible part of links to users is App::Link.  It inherits from @ref
 * App::DocumentObject "DocumentObject" and from @ref App::LinkExtension
 * "LinkExtension" which gives it the functionality to link to other document
 * objects.  @ref App::LinkExtension "LinkExtension" inherits from @ref
 * App::LinkBaseExtension "LinkBaseExtension" and gets most of its
 * functionality from that class.
 *
 * There are two other classes that inherit from @ref App::LinkBaseExtension
 * "LinkBaseExtension", namely @ref App::LinkGroup "LinkGroup" and @ref
 * App::LinkElement "LinkElement".  A %LinkGroup is a group of document objects
 * or links with, for example, a common placement.
 *
 * A @ref App::LinkElement "LinkElement" is a container for link elements to
 * form a special kind of group based on only one link.  This can be achieved
 * by creating an App::Link to an object and increase the element count to
 * greater than 0.  Each link is then represented by a @ref App::LinkElement
 * "LinkElement".
 *
 * Links are very cheap in the sense that there is no copy of the object it
 * links to, although it does have its own shape.  The view provider of the
 * link also simply makes use the document objects in the original linked
 * object.  Changing a property in the link (unless it is one of the overridden
 * ones) will typically also affect the original linked object.
 *
 * @section SecCopyOnChange Copy-on-change links
 *
 * Links can be created as "copy-on-change" links.  To create copy-on-change
 * links, the source object needs to have a property that is marked as
 * "copy-on-change".  Creating an App::Link from this source objects creates a
 * normal link where the property `LinkedObject` points to the source object.
 *
 * The user can then change the property `LinkCopyOnChange` to `Enabled` which
 * provides the user with copy-on-link behavior although the link is still a
 * regular link.  What is special, is that the link adopts the copy-on-change
 * property from the source object in order for users to change the value in
 * the link.  As soon as the adopted copy-on-change property is changed, a
 * special hidden document object is created inside the link will contain a
 * copy of the source object.  The link's `LinkedObject` property is then
 * changed to point to this hidden object, the changed property is applied on
 * this hidden object and the link is now a variant of the original source
 * object.
 *
 * Instead of changing the property `LinkCopyOnChange` to `Enabled`, the user
 * can also set it to `Tracking` which means that changes in the original
 * object are tracked and applied on the copy.
 */

/**
 * @defgroup ElementMapping Element Mapping for Topological naming.
 * @ingroup APP
 * @brief Element mapping system for topological naming
 *
 * Since the names of vertices, edges, and faces that we obtain from
 * OpenCascade are not stable under modifications of the shape, FreeCAD
 * implements a system called "topological naming" to provide stable names for
 * these elements.
 *
 * A shape in FreeCAD is represented by Part::TopoShape, a subclass of
 * Data::ComplexGeoData that contains much of the logic for element mapping.
 * This logic mainly resides in package Data.
 *
 * A @ref Data::ComplexGeoData "ComplexGeoData" object contains a @ref
 * Data::ComplexGeoData::Tag "Tag" that uniquely identifies the shape in the
 * document.  A @ref Data::ComplexGeoData "ComplexGeoData" object also contains
 * a @ref Data::ElementMap "ElementMap" that maintains a mapping from an @ref
 * Data::IndexedName "IndexedName" to a @ref Data::MappedName "MappedName".
 *
 * An indexed name, is a name that we obtain from the shapes from OpenCascade.
 * A mapped name is a name that is formed by means of topological relations.  A
 * mapped name consists of an immutable base name (called the "data") while the
 * second part is appended on operations on the shape.  This is called the
 * "postfix" of the mapped name.  For a selection of used postfix tags, see
 * the @ref ElementNameConstants "Element name constants" section in Data.
 *
 * An example of a mapped name is
 * `Pocket.;g2;SKT;:H7cf,E;:G;XTR;:H7cf:7,F;:M;CUT;:H-7d0:7,F.Face8` which
 * roughly means that the selected face `Face8` was modified `M` with a `CUT`
 * operation.  The `T` or `H` tags provide the tag of the shape in decimal and
 * hexadecimal respectively.
 *
 * Because multiple operations can result in long mapped names, FreeCAD makes
 * use of a string hasher that creates short hashes out of the long mapped
 * names.  An example of the hashed name for the above mapped name is:
 * `Pocket.;#20:2;:M;CUT;:H-e61:7,F.Face8`.
 */

/**
 * @namespace App
 * @ingroup APP
 * @brief The namespace for the part of FreeCAD that works without GUI.
 * @details This namespace includes %Application services of FreeCAD that such as:
 *   - The Application class
 *   - The Document class
 *   - The DocumentObject classes
 *   - The Expression classes
 *   - The Property classes
 *
 * For a more high-level discussion see the topic @ref APP "App".
 */

/**
 * @namespace Data
 * @ingroup ElementMapping
 * @brief The namespace for element names
 *
 */

