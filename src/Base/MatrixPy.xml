<?xml version="1.0" encoding="UTF-8"?>
<GenerateModel xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="generateMetaModel_Module.xsd">
  <PythonExport
        Father="PyObjectBase"
        Name="MatrixPy"
        Twin="Matrix"
        TwinPointer="Matrix4D"
        Include="Base/Matrix.h"
        FatherInclude="Base/PyObjectBase.h"
        Namespace="Base"
        Constructor="true"
        Delete="true"
        NumberProtocol="true"
        RichCompare="true"
        FatherNamespace="Base">
    <Documentation>
      <Author Licence="LGPL" Name="Juergen Riegel" EMail="FreeCAD@juergen-riegel.net" />
      <DeveloperDocu>This is the Matrix export class</DeveloperDocu>
      <UserDocu>Base.Matrix class.

A 4x4 Matrix.
In particular, this matrix can represent an affine transformation, that is,
given a 3D vector `x`, apply the transformation y = M*x + b, where the matrix
`M` is a linear map and the vector `b` is a translation.
`y` can be obtained using a linear transformation represented by the 4x4 matrix
`A` conformed by the augmented 3x4 matrix (M|b), augmented by row with
(0,0,0,1), therefore: (y, 1) = A*(x, 1).

The following constructors are supported:

Matrix()
Empty constructor.

Matrix(matrix)
Copy constructor.
matrix : Base.Matrix.

Matrix(*coef)
Define from 16 coefficients of the 4x4 matrix.
coef : sequence of float
    The sequence can have up to 16 elements which complete the matrix by rows.

Matrix(vector1, vector2, vector3, vector4)
Define from four 3D vectors which represent the columns of the 3x4 submatrix,
useful to represent an affine transformation. The fourth row is made up by
(0,0,0,1).
vector1 : Base.Vector
vector2 : Base.Vector
vector3 : Base.Vector
vector4 : Base.Vector
    Default to (0,0,0). Optional.</UserDocu>
    </Documentation>
    <Methode Name="move">
      <Documentation>
        <UserDocu>move(vector) -> None
move(x, y, z) -> None

Move the matrix along a vector, equivalent to left multiply the matrix
by a pure translation transformation.

vector : Base.Vector, tuple
x : float
    `x` translation.
y : float
    `y` translation.
z : float
    `z` translation.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="scale">
      <Documentation>
        <UserDocu>scale(vector) -> None
scale(x, y, z) -> None
scale(factor) -> None

Scale the first three rows of the matrix.

vector : Base.Vector
x : float
    First row factor scale.
y : float
    Second row factor scale.
z : float
    Third row factor scale.
factor : float
    global factor scale.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="hasScale" Const="true">
      <Documentation>
        <UserDocu>hasScale(tol=0) -> ScaleType

Return an enum value of ScaleType. Possible values are:
Uniform, NonUniformLeft, NonUniformRight, NoScaling or Other
if it's not a scale matrix.

tol : float</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="decompose" Const="true">
      <Documentation>
        <UserDocu>decompose() -> Base.Matrix, Base.Matrix, Base.Matrix, Base.Matrix\n
Return a tuple of matrices representing shear, scale, rotation and move.
So that matrix = move * rotation * scale * shear.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="nullify" NoArgs="true">
      <Documentation>
        <UserDocu>nullify() -> None

Make this the null matrix.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="isNull" Const="true" NoArgs="true">
      <Documentation>
        <UserDocu>isNull() -> bool

Check if this is the null matrix.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="unity" NoArgs="true">
      <Documentation>
        <UserDocu>unity() -> None

Make this matrix to unity (4D identity matrix).</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="isUnity" Const="true" NoArgs="true">
      <Documentation>
        <UserDocu>isUnity() -> bool

Check if this is the unit matrix (4D identity matrix).</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="transform">
      <Documentation>
        <UserDocu>transform(vector, matrix2) -> None

Transform the matrix around a given point.
Equivalent to left multiply the matrix by T*M*T_inv, where M is `matrix2`, T the
translation generated by `vector` and T_inv the inverse translation.
For example, if `matrix2` is a rotation, the result is the transformation generated
by the current matrix followed by a rotation around the point represented by `vector`.

vector : Base.Vector
matrix2 : Base.Matrix</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="col" Const="true">
      <Documentation>
        <UserDocu>col(index) -> Base.Vector

Return the vector of a column, that is, the vector generated by the three
first elements of the specified column.

index : int
    Required column index.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="setCol">
      <Documentation>
        <UserDocu>setCol(index, vector) -> None

Set the vector of a column, that is, the three first elements of the specified
column by index.

index : int
    Required column index.
vector : Base.Vector</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="row" Const="true">
      <Documentation>
        <UserDocu>row(index) -> Base.Vector

Return the vector of a row, that is, the vector generated by the three
first elements of the specified row.

index : int
    Required row index.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="setRow">
      <Documentation>
        <UserDocu>setRow(index, vector) -> None

Set the vector of a row, that is, the three first elements of the specified
row by index.

index : int
    Required row index.
vector : Base.Vector</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="diagonal" Const="true" NoArgs="true">
      <Documentation>
        <UserDocu>diagonal() -> Base.Vector

Return the diagonal of the 3x3 leading principal submatrix as vector.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="setDiagonal">
      <Documentation>
        <UserDocu>setDiagonal(vector) -> None

Set the diagonal of the 3x3 leading principal submatrix.

vector : Base.Vector</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="rotateX">
      <Documentation>
        <UserDocu>rotateX(angle) -> None

Rotate around X axis.

angle : float
    Angle in radians.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="rotateY">
      <Documentation>
        <UserDocu>rotateY(angle) -> None

Rotate around Y axis.

angle : float
    Angle in radians.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="rotateZ">
      <Documentation>
        <UserDocu>rotateZ(angle) -> None

Rotate around Z axis.

angle : float
    Angle in radians.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="multiply" Const="true">
      <Documentation>
        <UserDocu>multiply(matrix) -> Base.Matrix
multiply(vector) -> Base.Vector

Right multiply the matrix by the given object.
If the argument is a vector, this is augmented to the 4D vector (`vector`, 1).

matrix : Base.Matrix
vector : Base.Vector</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="multVec" Const="true">
      <Documentation>
        <UserDocu>multVec(vector) -> Base.Vector

Compute the transformed vector using the matrix.

vector : Base.Vector</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="invert" NoArgs="true">
      <Documentation>
        <UserDocu>invert() -> None

Compute the inverse matrix in-place, if possible.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="inverse" Const="true" NoArgs="true">
      <Documentation><UserDocu>inverse() -> Base.Matrix

Compute the inverse matrix, if possible.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="transpose" NoArgs="true">
      <Documentation>
        <UserDocu>transpose() -> None

Transpose the matrix in-place.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="transposed" Const="true" NoArgs="true">
      <Documentation>
        <UserDocu>transposed() -> Base.Matrix

Returns a transposed copy of this matrix.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="determinant" Const="true" NoArgs="true">
      <Documentation>
        <UserDocu>determinant() -> float

Compute the determinant of the matrix.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="isOrthogonal" Const="true">
      <Documentation>
        <UserDocu>isOrthogonal(tol=1e-6) -> float

Checks if the matrix is orthogonal, i.e. M * M^T = k*I and returns
the multiple of the identity matrix. If it's not orthogonal 0 is returned.

tol : float
    Tolerance used to check orthogonality.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="submatrix" Const="true">
      <Documentation>
        <UserDocu>submatrix(dim) -> Base.Matrix

Get the leading principal submatrix of the given dimension.
The (4 - `dim`) remaining dimensions are completed with the
corresponding identity matrix.

dim : int
    Dimension parameter must be in the range [1,4].</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="analyze" Const="true" NoArgs="true">
      <Documentation>
        <UserDocu>analyze() -> str

Analyzes the type of transformation.</UserDocu>
      </Documentation>
    </Methode>
    <Attribute Name="A11" ReadOnly="false">
      <Documentation>
        <UserDocu>The (1,1) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A11" Type="Float" />
    </Attribute>
    <Attribute Name="A12" ReadOnly="false">
      <Documentation>
        <UserDocu>The (1,2) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A12" Type="Float" />
    </Attribute>
    <Attribute Name="A13" ReadOnly="false">
      <Documentation>
        <UserDocu>The (1,3) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A13" Type="Float" />
    </Attribute>
    <Attribute Name="A14" ReadOnly="false">
      <Documentation>
        <UserDocu>The (1,4) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A14" Type="Float" />
    </Attribute>
    <Attribute Name="A21" ReadOnly="false">
      <Documentation>
        <UserDocu>The (2,1) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A21" Type="Float" />
    </Attribute>
    <Attribute Name="A22" ReadOnly="false">
      <Documentation>
        <UserDocu>The (2,2) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A22" Type="Float" />
    </Attribute>
    <Attribute Name="A23" ReadOnly="false">
      <Documentation>
        <UserDocu>The (2,3) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A23" Type="Float" />
    </Attribute>
    <Attribute Name="A24" ReadOnly="false">
      <Documentation>
        <UserDocu>The (2,4) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A24" Type="Float" />
    </Attribute>
    <Attribute Name="A31" ReadOnly="false">
      <Documentation>
        <UserDocu>The (3,1) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A31" Type="Float" />
    </Attribute>
    <Attribute Name="A32" ReadOnly="false">
      <Documentation>
        <UserDocu>The (3,2) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A32" Type="Float" />
    </Attribute>
    <Attribute Name="A33" ReadOnly="false">
      <Documentation>
        <UserDocu>The (3,3) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A33" Type="Float" />
    </Attribute>
    <Attribute Name="A34" ReadOnly="false">
      <Documentation>
        <UserDocu>The (3,4) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A34" Type="Float" />
    </Attribute>
    <Attribute Name="A41" ReadOnly="false">
      <Documentation>
        <UserDocu>The (4,1) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A41" Type="Float" />
    </Attribute>
    <Attribute Name="A42" ReadOnly="false">
      <Documentation>
        <UserDocu>The (4,2) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A42" Type="Float" />
    </Attribute>
    <Attribute Name="A43" ReadOnly="false">
      <Documentation>
        <UserDocu>The (4,3) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A43" Type="Float" />
    </Attribute>
    <Attribute Name="A44" ReadOnly="false">
      <Documentation>
        <UserDocu>The (4,4) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A44" Type="Float" />
    </Attribute>
    <Attribute Name="A" ReadOnly="false">
      <Documentation>
        <UserDocu>The matrix elements.</UserDocu>
      </Documentation>
      <Parameter Name="A" Type="Sequence" />
    </Attribute>
    <ClassDeclarations>public:
      MatrixPy(const Matrix4D &amp; mat, PyTypeObject *T = &amp;Type)
      :PyObjectBase(new Matrix4D(mat),T){}
      Matrix4D value() const
      { return *(getMatrixPtr()); }
    </ClassDeclarations>
  </PythonExport>
</GenerateModel>
