<?xml version="1.0" encoding="UTF-8"?>
<GenerateModel xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="generateMetaModel_Module.xsd">
  <PythonExport
		Father="PyObjectBase"
		Name="MatrixPy"
		Twin="Matrix"
		TwinPointer="Matrix4D"
		Include="Base/Matrix.h"
		FatherInclude="Base/PyObjectBase.h"
		Namespace="Base"
		Constructor="true"
		Delete="true"
		NumberProtocol="true"
 		RichCompare="true"
		FatherNamespace="Base">
    <Documentation>
      <Author Licence="LGPL" Name="Juergen Riegel" EMail="FreeCAD@juergen-riegel.net" />
      <DeveloperDocu>This is the Matrix export class</DeveloperDocu>
      <UserDocu>Base.Matrix class.\n
A 4x4 Matrix.
In particular, this matrix can represent an affine transformation, that is, given a
3D vector `x`, apply the transformation y = M*x + b, where the matrix `M` is a linear
map and the vector `b` is a translation.
`y` can be obtained using a linear transformation represented by the 4x4 matrix `A`
conformed by the augmented 3x4 matrix (M|b), augmented by row with (0,0,0,1), therefore:
(y, 1) = A*(x, 1).\n
The following constructors are supported:\n
Matrix()
Empty constructor.\n
Matrix(matrix)
Copy constructor.
matrix : Base.Matrix.\n
Matrix(*coef)
Define from 16 coefficients of the 4x4 matrix.
coef : sequence of float\n    The sequence can have up to 16 elements which complete the matrix by rows.\n
Matrix(vector1, vector2, vector3, vector4)
Define from four 3D vectors which represent the columns of the 3x4 submatrix, useful
to represent an affine transformation. The fourth row is made up by (0,0,0,1).
vector1 : Base.Vector
vector2 : Base.Vector
vector3 : Base.Vector
vector4 : Base.Vector\n    Default to (0,0,0). Optional.</UserDocu>
    </Documentation>
    <Methode Name="move">
      <Documentation>
        <UserDocu>move(vector) -> None
move(x, y, z) -> None\n
Move the matrix along a vector, equivalent to left multiply the matrix
by a pure translation transformation.\n
vector : Base.Vector, tuple
x : float\n    `x` translation.
y : float\n    `y` translation.
z : float\n    `z` translation.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="scale">
      <Documentation>
        <UserDocu>scale(vector) -> None
scale(x, y, z) -> None
scale(factor) -> None\n
Scale the first three rows of the matrix.\n
vector : Base.Vector
x : float\n    First row factor scale.
y : float\n    Second row factor scale.
z : float\n    Third row factor scale.
factor : float\n    global factor scale.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="hasScale" Const="true">
      <Documentation>
        <UserDocu>hasScale(tol=0) -> ScaleType\n
Return an enum value of ScaleType. Possible values are:
Uniform, NonUniformLeft, NonUniformRight, NoScaling or Other
if it's not a scale matrix.\n
tol : float</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="nullify">
      <Documentation>
        <UserDocu>nullify() -> None\n
Make this the null matrix.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="isNull" Const="true">
      <Documentation>
        <UserDocu>isNull() -> bool\n
Check if this is the null matrix.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="unity">
      <Documentation>
        <UserDocu>unity() -> None\n
Make this matrix to unity (4D identity matrix).</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="isUnity" Const="true">
      <Documentation>
        <UserDocu>isUnity() -> bool\n
Check if this is the unit matrix (4D identity matrix).</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="transform">
      <Documentation>
        <UserDocu>transform(vector, matrix2) -> None\n
Transform the matrix around a given point.
Equivalent to left multiply the matrix by T*M*T_inv, where M is `matrix2`, T the
translation generated by `vector` and T_inv the inverse translation.
For example, if `matrix2` is a rotation, the result is the transformation generated
by the current matrix followed by a rotation around the point represented by `vector`.\n
vector : Base.Vector
matrix2 : Base.Matrix</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="col" Const="true">
      <Documentation>
        <UserDocu>col(index) -> Base.Vector\n
Return the vector of a column, that is, the vector generated by the three
first elements of the specified column.
index : int\n    Required column index.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="setCol">
      <Documentation>
        <UserDocu>setCol(index, vector) -> None\n
Set the vector of a column, that is, the three first elements of the specified
column by index.\n
index : int\n    Required column index.
vector : Base.Vector</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="row" Const="true">
      <Documentation>
        <UserDocu>row(index) -> Base.Vector\n
Return the vector of a row, that is, the vector generated by the three
first elements of the specified row.\n
index : int\n    Required row index.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="setRow">
      <Documentation>
        <UserDocu>setRow(index, vector) -> None\n
Set the vector of a row, that is, the three first elements of the specified
row by index.\n
index : int\n    Required row index.
vector : Base.Vector</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="trace" Const="true">
      <Documentation>
        <UserDocu>trace() -> Base.Vector\n
Return the diagonal of the 3x3 leading principal submatrix as vector.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="setTrace">
      <Documentation>
        <UserDocu>setTrace(vector) -> None\n
Set the diagonal of the 3x3 leading principal submatrix.\n
vector : Base.Vector</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="rotateX">
      <Documentation>
        <UserDocu>rotateX(angle) -> None\n
Rotate around X axis.
angle : float\n    Angle in radians.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="rotateY">
      <Documentation>
        <UserDocu>rotateY(angle) -> None\n
Rotate around Y axis.
angle : float\n    Angle in radians.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="rotateZ">
      <Documentation>
        <UserDocu>rotateZ(angle) -> None\n
Rotate around Z axis.
angle : float\n    Angle in radians.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="multiply">
      <Documentation>
        <UserDocu>multiply(matrix) -> Base.Matrix
multiply(vector) -> Base.Vector\n
Right multiply the matrix by the given object.
If the argument is a vector, this is augmented to the 4D vector (`vector`, 1).\n
matrix : Base.Matrix
vector : Base.Vector</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="multVec" Const="true">
      <Documentation>
        <UserDocu>multVec(vector) -> Base.Vector\n
Compute the transformed vector using the matrix.
vector : Base.Vector</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="invert">
      <Documentation>
        <UserDocu>invert() -> None\n
Compute the inverse matrix in-place, if possible.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="inverse">
      <Documentation><UserDocu>inverse() -> Base.Matrix\n
Compute the inverse matrix, if possible.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="transpose">
      <Documentation>
        <UserDocu>transpose() -> None\n
Transpose the matrix in-place.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="transposed" Const="true">
      <Documentation>
        <UserDocu>transposed() -> Base.Matrix\n
Returns a transposed copy of this matrix.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="determinant">
      <Documentation>
        <UserDocu>determinant() -> float\n
Compute the determinant of the matrix.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="isOrthogonal">
      <Documentation>
        <UserDocu>isOrthogonal(tol=1e-6) -> float\n
Checks if the matrix is orthogonal, i.e. M * M^T = k*I and returns
the multiple of the identity matrix. If it's not orthogonal 0 is returned.\n
tol : float\n    Tolerance used to check orthogonality.</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="submatrix">
      <Documentation>
        <UserDocu>submatrix(dim) -> Base.Matrix\n
Get the leading principal submatrix of the given dimension.
The (4 - `dim`) remaining dimensions are completed with the
corresponding identity matrix.\n
dim : int\n    Dimension parameter must be in the range [1,4].</UserDocu>
      </Documentation>
    </Methode>
    <Methode Name="analyze">
      <Documentation>
        <UserDocu>analyze() -> str\n
Analyzes the type of transformation.</UserDocu>
      </Documentation>
    </Methode>
    <Attribute Name="A11" ReadOnly="false">
      <Documentation>
        <UserDocu>The (1,1) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A11" Type="Float" />
    </Attribute>
    <Attribute Name="A12" ReadOnly="false">
      <Documentation>
        <UserDocu>The (1,2) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A12" Type="Float" />
    </Attribute>
    <Attribute Name="A13" ReadOnly="false">
      <Documentation>
        <UserDocu>The (1,3) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A13" Type="Float" />
    </Attribute>
    <Attribute Name="A14" ReadOnly="false">
      <Documentation>
        <UserDocu>The (1,4) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A14" Type="Float" />
    </Attribute>
    <Attribute Name="A21" ReadOnly="false">
      <Documentation>
        <UserDocu>The (2,1) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A21" Type="Float" />
    </Attribute>
    <Attribute Name="A22" ReadOnly="false">
      <Documentation>
        <UserDocu>The (2,2) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A22" Type="Float" />
    </Attribute>
    <Attribute Name="A23" ReadOnly="false">
      <Documentation>
        <UserDocu>The (2,3) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A23" Type="Float" />
    </Attribute>
    <Attribute Name="A24" ReadOnly="false">
      <Documentation>
        <UserDocu>The (2,4) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A24" Type="Float" />
    </Attribute>
    <Attribute Name="A31" ReadOnly="false">
      <Documentation>
        <UserDocu>The (3,1) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A31" Type="Float" />
    </Attribute>
    <Attribute Name="A32" ReadOnly="false">
      <Documentation>
        <UserDocu>The (3,2) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A32" Type="Float" />
    </Attribute>
    <Attribute Name="A33" ReadOnly="false">
      <Documentation>
        <UserDocu>The (3,3) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A33" Type="Float" />
    </Attribute>
    <Attribute Name="A34" ReadOnly="false">
      <Documentation>
        <UserDocu>The (3,4) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A34" Type="Float" />
    </Attribute>
    <Attribute Name="A41" ReadOnly="false">
      <Documentation>
        <UserDocu>The (4,1) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A41" Type="Float" />
    </Attribute>
    <Attribute Name="A42" ReadOnly="false">
      <Documentation>
        <UserDocu>The (4,2) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A42" Type="Float" />
    </Attribute>
    <Attribute Name="A43" ReadOnly="false">
      <Documentation>
        <UserDocu>The (4,3) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A43" Type="Float" />
    </Attribute>
    <Attribute Name="A44" ReadOnly="false">
      <Documentation>
        <UserDocu>The (4,4) matrix element.</UserDocu>
      </Documentation>
      <Parameter Name="A44" Type="Float" />
    </Attribute>
    <Attribute Name="A" ReadOnly="false">
      <Documentation>
        <UserDocu>The matrix elements.</UserDocu>
      </Documentation>
      <Parameter Name="A" Type="Sequence" />
    </Attribute>
    <ClassDeclarations>public:
      MatrixPy(const Matrix4D &amp; mat, PyTypeObject *T = &amp;Type)
      :PyObjectBase(new Matrix4D(mat),T){}
      Matrix4D value() const
      { return *(getMatrixPtr()); }
    </ClassDeclarations>
  </PythonExport>
</GenerateModel>
