<?xml version="1.0" encoding="UTF-8"?>
<GenerateModel xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="generateMetaModel_Module.xsd">
	<PythonExport 
		Father="PyObjectBase" 
		Name="VectorPy" 
		Twin="Vector" 
		TwinPointer="Vector3d" 
		Include="Base/Vector3D.h" 
		FatherInclude="Base/PyObjectBase.h" 
		Namespace="Base" 
		Constructor="true"
		Delete="true"
		NumberProtocol="true"
		RichCompare="true"
		FatherNamespace="Base">
	<Documentation>
		<Author Licence="LGPL" Name="Juergen Riegel" EMail="FreeCAD@juergen-riegel.net" />
		<DeveloperDocu>This is the Vector export class</DeveloperDocu>
		<UserDocu>Base.Vector class.\n
This class represents a 3D float vector.
Useful to represent points in the 3D space.\n
The following constructors are supported:\n
Vector(x=0, y=0, z=0)
x : float
y : float
z : float\n
Vector(vector)
Copy constructor.
vector : Base.Vector\n
Vector(seq)
Define from a sequence of float.
seq : sequence of float.</UserDocu>
	</Documentation>
    <Methode Name="__reduce__" Const="true">
        <Documentation>
            <UserDocu>__reduce__() -> tuple\n
Serialization of Vector objects.</UserDocu>
        </Documentation>
    </Methode>
        <Methode Name="add" Const="true">
			<Documentation>
				<UserDocu>add(vector2) -> Base.Vector\n
Returns the sum of this vector and `vector2`.\n
vector2 : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="sub" Const="true">
			<Documentation>
				<UserDocu>sub(vector2) -> Base.Vector\n
Returns the difference of this vector and `vector2`.\n
vector2 : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
        <Methode Name="negative" Const="true">
			<Documentation>
				<UserDocu>negative() -> Base.Vector\n
Returns the negative (opposite) of this vector.</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="scale">
			<Documentation>
				<UserDocu>scale(x, y, z) -> Base.Vector\n
Scales in-place this vector by the given factor in each component.\n
x : float\n    x-component factor scale.
y : float\n    y-component factor scale.
z : float\n    z-component factor scale.</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="multiply">
			<Documentation>
				<UserDocu>multiply(factor) -> Base.Vector\n
Multiplies in-place each component of this vector by a single factor.
Equivalent to scale(factor, factor, factor).\n
factor : float</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="dot" Const="true">
			<Documentation>
				<UserDocu>dot(vector2) -> float\n
Returns the scalar product (dot product) between this vector and `vector2`.\n
vector2 : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="cross" Const="true">
			<Documentation>
				<UserDocu>cross(vector2) -> Base.Vector\n
Returns the vector product (cross product) between this vector and `vector2`.\n
vector2 : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="isOnLineSegment" Const="true">
			<Documentation>
				<UserDocu>isOnLineSegment(vector1, vector2) -> bool\n
Checks if this vector is on the line segment generated by `vector1` and `vector2`.\n
vector1 : Base.Vector
vector2 : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="getAngle" Const="true">
			<Documentation>
				<UserDocu>getAngle(vector2) -> float\n
Returns the angle in radians between this vector and `vector2`.\n
vector2 : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="normalize">
			<Documentation>
				<UserDocu>normalize() -> Base.Vector\n
Normalizes in-place this vector to the length of 1.0.</UserDocu>
			</Documentation>
		</Methode>
        <Methode Name="isEqual">
            <Documentation>
                <UserDocu>isEqual(vector2, tol=0) -> bool\n
Checks if the distance between the points represented by this vector
and `vector2` is less or equal to the given tolerance.\n
vector2 : Base.Vector
tol : float</UserDocu>
            </Documentation>
        </Methode>
        <Methode Name="projectToLine">
			<Documentation>
				<UserDocu>projectToLine(point, dir) -> Base.Vector\n
Projects `point` on a line that goes through the origin with the direction `dir`.
The result is the vector from `point` to the projected point.
The operation is equivalent to dir_n.cross(dir_n.cross(point)), where `dir_n` is
the vector `dir` normalized. 
The method modifies this vector instance according to result and does not
depend on the vector itself.\n
point : Base.Vector
dir : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="projectToPlane">
			<Documentation>
				<UserDocu>projectToPlane(base, normal) -> Base.Vector\n
Projects in-place this vector on a plane defined by a base point
represented by `base` and a normal defined by `normal`.\n
base : Base.Vector
normal : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="distanceToPoint" Const="true">
			<Documentation>
				<UserDocu>distanceToPoint(point2) -> float\n
Returns the distance to another point represented by `point2`.\n.
point : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="distanceToLine" Const="true">
			<Documentation>
				<UserDocu>distanceToLine(base, dir) -> float\n
Returns the distance between the point represented by this vector
and a line defined by a base point represented by `base` and a
direction `dir`.\n
base : Base.Vector
dir : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="distanceToLineSegment" Const="true">
			<Documentation>
				<UserDocu>distanceToLineSegment(point1, point2) -> Base.Vector\n
Returns the vector between the point represented by this vector and the point
on the line segment with the shortest distance. The line segment is defined by
`point1` and `point2`.\n
point1 : Base.Vector
point2 : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
		<Methode Name="distanceToPlane" Const="true">
			<Documentation>
				<UserDocu>distanceToPlane(base, normal) -> float\n
Returns the distance between this vector and a plane defined by a
base point represented by `base` and a normal defined by `normal`.\n
base : Base.Vector
normal : Base.Vector</UserDocu>
			</Documentation>
		</Methode>
		<Attribute Name="Length" ReadOnly="false">
			<Documentation>
				<UserDocu>Gets or sets the length of this vector.</UserDocu>
			</Documentation>
			<Parameter Name="Type" Type="Float" />
		</Attribute>
		<Attribute Name="x" ReadOnly="false">
			<Documentation>
				<UserDocu>Gets or sets the X component of this vector.</UserDocu>
			</Documentation>
			<Parameter Name="x" Type="Float"/>
		</Attribute>
		<Attribute Name="y" ReadOnly="false">
			<Documentation>
				<UserDocu>Gets or sets the Y component of this vector.</UserDocu>
			</Documentation>
			<Parameter Name="y" Type="Float"/>
		</Attribute>
		<Attribute Name="z" ReadOnly="false">
			<Documentation>
				<UserDocu>Gets or sets the Z component of this vector.</UserDocu>
			</Documentation>
			<Parameter Name="z" Type="Float"/>
		</Attribute>
		<Sequence
			sq_length="true"
			sq_concat="false"
			sq_repeat="false"
			sq_item="true"
			mp_subscript="true"
			sq_ass_item="true"
			mp_ass_subscript="false"
			sq_contains="false"
			sq_inplace_concat="false"
			sq_inplace_repeat="false">
		</Sequence>
		<ClassDeclarations>public:
    VectorPy(const Vector3d &amp; vec, PyTypeObject *T = &amp;Type)
    :PyObjectBase(new Vector3d(vec),T){}
    VectorPy(const Vector3f &amp; vec, PyTypeObject *T = &amp;Type)
    :PyObjectBase(new Vector3d(vec.x,vec.y,vec.z),T){}
    Vector3d value() const
    { return *(getVectorPtr()); }
		</ClassDeclarations>
	</PythonExport>
</GenerateModel>
