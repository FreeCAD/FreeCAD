name: Build Release
on:
  release:
    types: [created]
  schedule:
   - cron: "0 0 * * 3"
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  upload_src:
    runs-on: ubuntu-latest
    outputs:
      build_tag: ${{ steps.get_tag.outputs.build_tag }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@df199fb7be9f65074067a9eb93f12bb4c5547cf2 # v2.13.3
        with:
          egress-policy: audit

      - name: Checkout Source
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ github.sha }}
          fetch-depth: 2
          fetch-tags: true
          submodules: 'recursive'

      - name: get tag and create release if weekly
        id: get_tag
        shell: bash -l {0}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            export BUILD_TAG="${{ github.event.release.tag_name }}"
          else
            export BUILD_TAG=weekly-$(date "+%Y.%m.%d")
            gh release create ${BUILD_TAG} --title "Development Build ${BUILD_TAG}" -F .github/workflows/weekly-build-notes.md --prerelease || true
          fi
          echo "BUILD_TAG=${BUILD_TAG}" >> "$GITHUB_ENV"
          echo "build_tag=${BUILD_TAG}" >> "$GITHUB_OUTPUT"

      - name: Trigger notes updater workflow (only for weekly)
        if: startsWith(steps.get_tag.outputs.build_tag, 'weekly-')
        uses: actions/github-script@v7
        env:
          WEEKLY_TAG: ${{ steps.get_tag.outputs.build_tag }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // Reusable/dispatchable updater workflow file in .github/workflows/
            const workflow_id = 'weekly-compare-link.yml';

            // Use the default branch so the workflow file is available
            const ref = (context.payload?.repository?.default_branch) || 'main';
            const current_tag = process.env.WEEKLY_TAG || '';

            await github.rest.actions.createWorkflowDispatch({
              owner, repo, workflow_id, ref,
              inputs: { current_tag }
            });

            core.info(`Dispatched ${workflow_id} on ${ref} with current_tag='${current_tag}'.`)

      - name: Upload Source
        id: upload_source
        shell: bash -l {0}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          python3 package/scripts/write_version_info.py ../freecad_version.txt
          git archive HEAD -o freecad_source_${BUILD_TAG}.tar
          git submodule foreach --recursive \
            "git archive HEAD --prefix=\$path/ -o \$sha1.tar && \
             tar -A -f \$toplevel/freecad_source_${BUILD_TAG}.tar \$sha1.tar && \
             rm \$sha1.tar"
          gzip freecad_source_${BUILD_TAG}.tar
          sha256sum freecad_source_${BUILD_TAG}.tar.gz > freecad_source_${BUILD_TAG}.tar.gz-SHA256.txt
          gh release upload --clobber ${BUILD_TAG} "freecad_source_${BUILD_TAG}.tar.gz" "freecad_source_${BUILD_TAG}.tar.gz-SHA256.txt"

  build:
    needs: upload_src
    strategy:
      matrix:
        include:
          - { target: linux-64, os: ubuntu-22.04 }
          - { target: linux-arm64, os: ubuntu-22.04-arm }
          - { target: osx-64, os: macos-15-intel }
          - { target: osx-arm64, os: macos-latest }
          - { target: win-64, os: windows-latest }
      fail-fast: false

    runs-on: ${{ matrix.os }}
    environment: weekly-build
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@df199fb7be9f65074067a9eb93f12bb4c5547cf2 # v2.13.3
        with:
          egress-policy: audit

      # prevent running out of disk space on Ubuntu runners.
      - name: Maximize build space
        if: runner.os == 'Linux'
        uses: AdityaGarg8/remove-unwanted-software@90e01b21170618765a73370fcc3abbd1684a7793 # v5
        with:
          verbose: 'true'
          remove-android: 'true'      # (frees ~9 GB)
          remove-cached-tools: 'true' # (frees ~8.3 GB)

      - name: Checkout Source
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ github.sha }}
          fetch-depth: 2
          fetch-tags: true
          submodules: 'recursive'

      - name: setup
        id: setup
        shell: bash -l {0}
        env:
          ES_USERNAME: ${{ secrets.ES_USERNAME }}
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
        run: |
          OS_DIR=$(bash package/rattler-build/scripts/get_os_dir.bash)
          echo "OS_DIR=$OS_DIR" >> "$GITHUB_ENV"
          if [[ $OS_DIR == 'windows' ]]; then
            echo 'PIXI_CACHE_DIR=D:\rattler' >> "$GITHUB_ENV"
            echo 'RATTLER_CACHE_DIR=D:\rattler' >> "$GITHUB_ENV"
            if [ -n "$ES_USERNAME" ]; then
              echo "has_esign=true" >> $GITHUB_OUTPUT
            fi
          fi
          if [ -n "$BUILD_CERTIFICATE_BASE64" ]; then
            echo "has_apple_cert=true" >> $GITHUB_OUTPUT
          fi

      - uses: prefix-dev/setup-pixi@82d477f15f3a381dbcc8adc1206ce643fe110fb7 # v0.9.3
        with:
          pixi-version: v0.59.0
          cache: false

      - name: Install the Apple certificate and provisioning profile
        if: ${{ runner.os == 'macOS' && steps.setup.outputs.has_apple_cert }}
        env:
          APP_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          BUILD_PROVISION_PROFILE_BASE64: ${{ secrets.BUILD_PROVISION_PROFILE_BASE64 }}
          DEVELOPER_TEAM_ID: ${{ secrets.DEVELOPER_TEAM_ID }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        run: |
          # create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          PP_PATH=$RUNNER_TEMP/FreeCAD_bundle.provisionprofile
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          export KEYCHAIN_PASSWORD=$(openssl rand -base64 8)

          # import certificate and provisioning profile from secrets
          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
          echo -n "$BUILD_PROVISION_PROFILE_BASE64" | base64 --decode -o $PP_PATH

          # create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # import certificate to keychain
          security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # apply provisioning profile
          mkdir -p ~/Library/Provisioning\ Profiles
          cp $PP_PATH ~/Library/Provisioning\ Profiles

          xcrun notarytool store-credentials "FreeCAD" --keychain "$KEYCHAIN_PATH" --apple-id "${APPLE_ID}" --password "${APP_SPECIFIC_PASSWORD}" --team-id "${DEVELOPER_TEAM_ID}"

      - name: Build freecad
        shell: bash
        run: |
          python3 package/scripts/write_version_info.py ../freecad_version.txt
          cd package/rattler-build
          pixi install
          if [ ${OS_DIR} == "windows" ]; then
            mkdir windows/.bin_to_sign
            cp .pixi/envs/default/Library/bin/{freecad.exe,freecadcmd.exe} windows/.bin_to_sign
          fi

      - name: Sign windows binaries
        if: ${{ runner.os == 'Windows' && steps.setup.outputs.has_esign }}
        uses: sslcom/esigner-codesign@b7f8ff36fc0de8690fbbab8e5b4421d29802f747
        with:
          command: batch_sign
          username: ${{ secrets.ES_USERNAME }}
          password: ${{ secrets.ES_PASSWORD }}
          credential_id: ${{ secrets.ES_CREDENTIAL_ID }}
          totp_secret: ${{ secrets.ES_TOTP_SECRET }}
          dir_path: ${GITHUB_WORKSPACE}/package/rattler-build/windows/.bin_to_sign
          output_path: ${GITHUB_WORKSPACE}/package/rattler-build/windows/.bin_signed

      - name: Build bundles
        id: bundle
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}
          SIGN_MAC_RELEASE: ${{ steps.setup.outputs.has_apple_cert }}
          TARGET_PLATFORM: ${{ matrix.target }}
          MAKE_INSTALLER: "true"
          BUILD_TAG: ${{ needs.upload_src.outputs.build_tag }}
        run: |
          cd package/rattler-build
          if [ ${OS_DIR} == "windows" ]; then
            mv -f windows/.bin_signed/* .pixi/envs/default/Library/bin
          fi
          pixi run -e package create_bundle
          source ${OS_DIR}/.bundle-vars
          echo "installer_path=${INSTALLER_PATH}" >> $GITHUB_OUTPUT

      - name: Sign windows installer
        if: ${{ runner.os == 'Windows' && steps.setup.outputs.has_esign }}
        uses: sslcom/esigner-codesign@b7f8ff36fc0de8690fbbab8e5b4421d29802f747
        with:
          command: sign
          username: ${{ secrets.ES_USERNAME }}
          password: ${{ secrets.ES_PASSWORD }}
          credential_id: ${{ secrets.ES_CREDENTIAL_ID }}
          totp_secret: ${{ secrets.ES_TOTP_SECRET }}
          file_path: ${{ steps.bundle.outputs.installer_path }}
          override: true

      - name: Upload bundles
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          cd package/rattler-build
          pixi run -e package upload_bundle

      ## Needed if running on a self-hosted runner:
      # - name: Clean up keychain and provisioning profile
      #   if: ${{ always() }}
      #   run: |
      #     security delete-keychain $RUNNER_TEMP/app-signing.keychain-db
      #     rm ~/Library/MobileDevice/Provisioning\ Profiles/build_pp.mobileprovision
