
// This file is generated by src/Tools/generateTemplates/templateClassPyExport.py out of the .XML file
// Every change you make here gets lost in the next full rebuild!
// This File is normally built as an include in FemMeshPyImp.cpp! It's not intended to be in a project!

#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/exception.hpp>
#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <CXX/Objects.hxx>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

using Base::streq;
using namespace Fem;

/// Type structure of FemMeshPy
PyTypeObject FemMeshPy::Type = {
    PyVarObject_HEAD_INIT(&PyType_Type,0)
    "Fem.FemMesh",     /*tp_name*/
    sizeof(FemMeshPy),                       /*tp_basicsize*/
    0,                                                /*tp_itemsize*/
    /* methods */
    PyDestructor,                                     /*tp_dealloc*/
#if PY_VERSION_HEX >= 0x03080000
    0,                                                /*tp_vectorcall_offset*/
#else
    nullptr,                                          /*tp_print*/
#endif
    nullptr,                                          /*tp_getattr*/
    nullptr,                                          /*tp_setattr*/
    nullptr,                                          /*tp_compare*/
    __repr,                                           /*tp_repr*/
    nullptr,                                          /*tp_as_number*/
    nullptr,                                          /*tp_as_sequence*/
    nullptr,                                          /*tp_as_mapping*/
    nullptr,                                          /*tp_hash*/
    nullptr,                                          /*tp_call */
    nullptr,                                          /*tp_str  */
    __getattro,                                       /*tp_getattro*/
    __setattro,                                       /*tp_setattro*/
    /* --- Functions to access object as input/output buffer ---------*/
    nullptr,                                          /* tp_as_buffer */
    /* --- Flags to define presence of optional/expanded features */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT,        /*tp_flags */
    "FemMesh class",           /*tp_doc */
    nullptr,                                          /*tp_traverse */
    nullptr,                                          /*tp_clear */
    nullptr,                                          /*tp_richcompare */
    0,                                                /*tp_weaklistoffset */
    nullptr,                                          /*tp_iter */
    nullptr,                                          /*tp_iternext */
    Fem::FemMeshPy::Methods,                     /*tp_methods */
    nullptr,                                          /*tp_members */
    Fem::FemMeshPy::GetterSetter,                     /*tp_getset */
    &Data::ComplexGeoDataPy::Type,                        /*tp_base */
    nullptr,                                          /*tp_dict */
    nullptr,                                          /*tp_descr_get */
    nullptr,                                          /*tp_descr_set */
    0,                                                /*tp_dictoffset */
    __PyInit,                                         /*tp_init */
    nullptr,                                          /*tp_alloc */
    Fem::FemMeshPy::PyMake,/*tp_new */
    nullptr,                                          /*tp_free   Low-level free-memory routine */
    nullptr,                                          /*tp_is_gc  For PyObject_IS_GC */
    nullptr,                                          /*tp_bases */
    nullptr,                                          /*tp_mro    method resolution order */
    nullptr,                                          /*tp_cache */
    nullptr,                                          /*tp_subclasses */
    nullptr,                                          /*tp_weaklist */
    nullptr,                                          /*tp_del */
    0,                                                /*tp_version_tag */
    nullptr                                           /*tp_finalize */
#if PY_VERSION_HEX >= 0x03090000
    ,nullptr                                          /*tp_vectorcall */
#if PY_VERSION_HEX >= 0x030c0000
    ,0                                                /*tp_watched */
#endif
#elif PY_VERSION_HEX >= 0x03080000
    ,nullptr                                          /*tp_vectorcall */
    /* bpo-37250: kept for backwards compatibility in CPython 3.8 only */
    ,nullptr                                          /*tp_print */
#endif
};

/// Methods structure of FemMeshPy
PyMethodDef FemMeshPy::Methods[] = {
    {"setShape",
        reinterpret_cast<PyCFunction>( staticCallback_setShape ),
        METH_VARARGS,
        "Set the Part shape to mesh"
    },
    {"compute",
        reinterpret_cast<PyCFunction>( staticCallback_compute ),
        METH_VARARGS,
        "Update the internal mesh structure"
    },
    {"addHypothesis",
        reinterpret_cast<PyCFunction>( staticCallback_addHypothesis ),
        METH_VARARGS,
        "Add hypothesis"
    },
    {"setStandardHypotheses",
        reinterpret_cast<PyCFunction>( staticCallback_setStandardHypotheses ),
        METH_VARARGS,
        "Set some standard hypotheses for the whole shape"
    },
    {"addNode",
        reinterpret_cast<PyCFunction>( staticCallback_addNode ),
        METH_VARARGS,
        "Add a node by setting (x,y,z)."
    },
    {"addEdge",
        reinterpret_cast<PyCFunction>( staticCallback_addEdge ),
        METH_VARARGS,
        "Add an edge by setting two node indices."
    },
    {"addEdgeList",
        reinterpret_cast<PyCFunction>( staticCallback_addEdgeList ),
        METH_VARARGS,
        "Add list of edges by list of node indices and list of nodes per edge."
    },
    {"addFace",
        reinterpret_cast<PyCFunction>( staticCallback_addFace ),
        METH_VARARGS,
        "Add a face by setting three node indices."
    },
    {"addFaceList",
        reinterpret_cast<PyCFunction>( staticCallback_addFaceList ),
        METH_VARARGS,
        "Add list of faces by list of node indices and list of nodes per face."
    },
    {"addQuad",
        reinterpret_cast<PyCFunction>( staticCallback_addQuad ),
        METH_VARARGS,
        "Add a quad by setting four node indices."
    },
    {"addVolume",
        reinterpret_cast<PyCFunction>( staticCallback_addVolume ),
        METH_VARARGS,
        "Add a volume by setting an arbitrary number of node indices."
    },
    {"addVolumeList",
        reinterpret_cast<PyCFunction>( staticCallback_addVolumeList ),
        METH_VARARGS,
        "Add list of volumes by list of node indices and list of nodes per volume."
    },
    {"read",
        reinterpret_cast<PyCFunction>( staticCallback_read ),
        METH_VARARGS,
        "Read in a various FEM mesh file formats.\n"
        "                    read(file.endingToExportTo)\n"
        "                    supported formats: DAT, INP, MED, STL, UNV, VTK, Z88"
    },
    {"write",
        reinterpret_cast<PyCFunction>( staticCallback_write ),
        METH_VARARGS,
        "Write out various FEM mesh file formats.\n"
        "                    write(file.endingToExportTo)\n"
        "                    supported formats: BDF, DAT, INP, MED, STL, UNV, VTK, Z88"
    },
    {"writeABAQUS",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_writeABAQUS )),
        METH_VARARGS|METH_KEYWORDS,
        "Write out as ABAQUS inp\n"
        "                    writeABAQUS(file, int elemParam, bool groupParam, str volVariant, str faceVariant, str edgeVariant)\n"
        "\n"
        "                    elemParam:\n"
        "                        0: All elements\n"
        "                        1: Highest elements only\n"
        "                        2: FEM elements only (only edges not belonging to faces and faces not belonging to volumes)\n"
        "\n"
        "                    groupParam:\n"
        "                        True: Write group data\n"
        "                        False: Do not write group data\n"
        "\n"
        "                    volVariant: Volume elements\n"
        "                        \"standard\": Tetra4 -> C3D4, Penta6 -> C3D6, Hexa8 -> C3D8, Tetra10 -> C3D10, Penta15 -> C3D15, Hexa20 -> C3D20\n"
        "                        \"reduced\": Hexa8 -> C3D8R, Hexa20 -> C3D20R\n"
        "                        \"incompatible\": Hexa8 -> C3D8I\n"
        "                        \"modified\": Tetra10 -> C3D10T\n"
        "                        \"fluid\": Tetra4 -> F3D4, Penta6 -> F3D6, Hexa8  -> F3D8\n"
        "\n"
        "                    faceVariant: Face elements\n"
        "                        \"shell\": Tria3 -> S3, Quad4 -> S4, Tria6 -> S6, Quad8 -> S8\n"
        "                        \"shell reduced\": Tria3 -> S3, Quad4 -> S4R, Tria6 -> S6, Quad8 -> S8R\n"
        "                        \"membrane\": Tria3 -> M3D3, Quad4 -> M3D4, Tria6 -> M3D6, Quad8 -> M3D8\n"
        "                        \"membrane reduced\": Tria3 -> M3D3, Quad4 -> M3D4R, Tria6 -> M3D6, Quad8 -> M3D8R\n"
        "                        \"stress\": Tria3 -> CPS3, Quad4 -> CPS4, Tria6 -> CPS6, Quad8 -> CPS8\n"
        "                        \"stress reduced\": Tria3 -> CPS3, Quad4 -> CPS4R, Tria6 -> CPS6, Quad8 -> CPS8R\n"
        "                        \"strain\": Tria3 -> CPE3, Quad4 -> CPE4, Tria6 -> CPE6, Quad8 -> CPE8\n"
        "                        \"strain reduced\": Tria3 -> CPE3, Quad4 -> CPE4R, Tria6 -> CPE6, Quad8 -> CPE8R\n"
        "                        \"axisymmetric\": Tria3 -> CAX3, Quad4 -> CAX4, Tria6 -> CAX6, Quad8 -> CAX8\n"
        "                        \"axisymmetric reduced\": Tria3 -> CAX3, Quad4 -> CAX4R, Tria6 -> CAX6, Quad8 -> CAX8R\n"
        "\n"
        "                    edgeVariant: Edge elements\n"
        "                        \"beam\": Seg2 -> B31, Seg3 -> B32\n"
        "                        \"beam reduced\": Seg2 -> B31R, Seg3 -> B32R\n"
        "                        \"truss\": Seg2 -> T3D2, eg3 -> T3D3\n"
        "                        \"network\": Seg3 -> D\n"
        "\n"
        "                    Elements are selected according to CalculiX availability.\n"
        "                    For example if volume variant \"modified\" is selected, Tetra10 mesh\n"
        "                    elements are assigned to C3D10T and remain elements uses \"standard\".\n"
        "                    Axisymmetric, plane strain and plane stress elements expect nodes in the plane z=0."
    },
    {"setTransform",
        reinterpret_cast<PyCFunction>( staticCallback_setTransform ),
        METH_VARARGS,
        "Use a Placement object to perform a translation or rotation"
    },
    {"copy",
        reinterpret_cast<PyCFunction>( staticCallback_copy ),
        METH_VARARGS,
        "Make a copy of this FEM mesh."
    },
    {"getFacesByFace",
        reinterpret_cast<PyCFunction>( staticCallback_getFacesByFace ),
        METH_VARARGS,
        "Return a list of face IDs which belong to a TopoFace"
    },
    {"getEdgesByEdge",
        reinterpret_cast<PyCFunction>( staticCallback_getEdgesByEdge ),
        METH_VARARGS,
        "Return a list of edge IDs which belong to a TopoEdge"
    },
    {"getVolumesByFace",
        reinterpret_cast<PyCFunction>( staticCallback_getVolumesByFace ),
        METH_VARARGS,
        "Return a dict of volume IDs and face IDs which belong to a TopoFace"
    },
    {"getccxVolumesByFace",
        reinterpret_cast<PyCFunction>( staticCallback_getccxVolumesByFace ),
        METH_VARARGS,
        "Return a dict of volume IDs and ccx face numbers which belong to a TopoFace"
    },
    {"getNodeById",
        reinterpret_cast<PyCFunction>( staticCallback_getNodeById ),
        METH_VARARGS,
        "Get the node position vector by a Node-ID"
    },
    {"getNodesBySolid",
        reinterpret_cast<PyCFunction>( staticCallback_getNodesBySolid ),
        METH_VARARGS,
        "Return a list of node IDs which belong to a TopoSolid"
    },
    {"getNodesByFace",
        reinterpret_cast<PyCFunction>( staticCallback_getNodesByFace ),
        METH_VARARGS,
        "Return a list of node IDs which belong to a TopoFace"
    },
    {"getNodesByEdge",
        reinterpret_cast<PyCFunction>( staticCallback_getNodesByEdge ),
        METH_VARARGS,
        "Return a list of node IDs which belong to a TopoEdge"
    },
    {"getNodesByVertex",
        reinterpret_cast<PyCFunction>( staticCallback_getNodesByVertex ),
        METH_VARARGS,
        "Return a list of node IDs which belong to a TopoVertex"
    },
    {"getElementNodes",
        reinterpret_cast<PyCFunction>( staticCallback_getElementNodes ),
        METH_VARARGS,
        "Return a tuple of node IDs to a given element ID"
    },
    {"getNodeElements",
        reinterpret_cast<PyCFunction>( staticCallback_getNodeElements ),
        METH_VARARGS,
        "Return a tuple of specific element IDs associated to a given node ID"
    },
    {"getGroupName",
        reinterpret_cast<PyCFunction>( staticCallback_getGroupName ),
        METH_VARARGS,
        "Return a string of group name to a given group ID"
    },
    {"getGroupElementType",
        reinterpret_cast<PyCFunction>( staticCallback_getGroupElementType ),
        METH_VARARGS,
        "Return a string of group element type to a given group ID"
    },
    {"getGroupElements",
        reinterpret_cast<PyCFunction>( staticCallback_getGroupElements ),
        METH_VARARGS,
        "Return a tuple of ElementIDs to a given group ID"
    },
    {"addGroup",
        reinterpret_cast<PyCFunction>( staticCallback_addGroup ),
        METH_VARARGS,
        "Add a group to mesh with specific name and type\n"
        "                    addGroup(name, typestring, [id])\n"
        "                    name: string\n"
        "                    typestring: \"All\", \"Node\", \"Edge\", \"Face\", \"Volume\", \"0DElement\", \"Ball\"\n"
        "                    id: int\n"
        "                    Optional id is used to force specific id for group, but does\n"
        "                    not work, yet."
    },
    {"addGroupElements",
        reinterpret_cast<PyCFunction>( staticCallback_addGroupElements ),
        METH_VARARGS,
        "Add a tuple of ElementIDs to a given group ID\n"
        "                    addGroupElements(groupid, list_of_elements)\n"
        "                    groupid: int\n"
        "                    list_of_elements: list of int\n"
        "                    Notice that the elements have to be in the mesh."
    },
    {"removeGroup",
        reinterpret_cast<PyCFunction>( staticCallback_removeGroup ),
        METH_VARARGS,
        "Remove a group with a given group ID\n"
        "                    removeGroup(groupid)\n"
        "                    groupid: int\n"
        "                    Returns boolean."
    },
    {"getElementType",
        reinterpret_cast<PyCFunction>( staticCallback_getElementType ),
        METH_VARARGS,
        "Return the element type of a given ID"
    },
    {"getIdByElementType",
        reinterpret_cast<PyCFunction>( staticCallback_getIdByElementType ),
        METH_VARARGS,
        "Return a tuple of IDs to a given element type"
    },
    {nullptr, nullptr, 0, nullptr}		/* Sentinel */
};



/// Attribute structure of FemMeshPy
PyGetSetDef FemMeshPy::GetterSetter[] = {
    {"Nodes",
        (getter) staticCallback_getNodes,
        (setter) staticCallback_setNodes,
        "Dictionary of Nodes by ID (int ID:Vector())",
        nullptr
    },
    {"NodeCount",
        (getter) staticCallback_getNodeCount,
        (setter) staticCallback_setNodeCount,
        "Number of nodes in the Mesh.",
        nullptr
    },
    {"Edges",
        (getter) staticCallback_getEdges,
        (setter) staticCallback_setEdges,
        "Tuple of edge IDs",
        nullptr
    },
    {"EdgesOnly",
        (getter) staticCallback_getEdgesOnly,
        (setter) staticCallback_setEdgesOnly,
        "Tuple of edge IDs which does not belong to any face (and thus not belong to any volume too)",
        nullptr
    },
    {"EdgeCount",
        (getter) staticCallback_getEdgeCount,
        (setter) staticCallback_setEdgeCount,
        "Number of edges in the Mesh.",
        nullptr
    },
    {"Faces",
        (getter) staticCallback_getFaces,
        (setter) staticCallback_setFaces,
        "Tuple of face IDs",
        nullptr
    },
    {"FacesOnly",
        (getter) staticCallback_getFacesOnly,
        (setter) staticCallback_setFacesOnly,
        "Tuple of face IDs which does not belong to any volume",
        nullptr
    },
    {"FaceCount",
        (getter) staticCallback_getFaceCount,
        (setter) staticCallback_setFaceCount,
        "Number of Faces in the Mesh.",
        nullptr
    },
    {"TriangleCount",
        (getter) staticCallback_getTriangleCount,
        (setter) staticCallback_setTriangleCount,
        "Number of Triangles in the Mesh.",
        nullptr
    },
    {"QuadrangleCount",
        (getter) staticCallback_getQuadrangleCount,
        (setter) staticCallback_setQuadrangleCount,
        "Number of Quadrangles in the Mesh.",
        nullptr
    },
    {"PolygonCount",
        (getter) staticCallback_getPolygonCount,
        (setter) staticCallback_setPolygonCount,
        "Number of Quadrangles in the Mesh.",
        nullptr
    },
    {"Volumes",
        (getter) staticCallback_getVolumes,
        (setter) staticCallback_setVolumes,
        "Tuple of volume IDs",
        nullptr
    },
    {"VolumeCount",
        (getter) staticCallback_getVolumeCount,
        (setter) staticCallback_setVolumeCount,
        "Number of Volumes in the Mesh.",
        nullptr
    },
    {"TetraCount",
        (getter) staticCallback_getTetraCount,
        (setter) staticCallback_setTetraCount,
        "Number of Tetras in the Mesh.",
        nullptr
    },
    {"HexaCount",
        (getter) staticCallback_getHexaCount,
        (setter) staticCallback_setHexaCount,
        "Number of Hexas in the Mesh.",
        nullptr
    },
    {"PyramidCount",
        (getter) staticCallback_getPyramidCount,
        (setter) staticCallback_setPyramidCount,
        "Number of Pyramids in the Mesh.",
        nullptr
    },
    {"PrismCount",
        (getter) staticCallback_getPrismCount,
        (setter) staticCallback_setPrismCount,
        "Number of Prisms in the Mesh.",
        nullptr
    },
    {"PolyhedronCount",
        (getter) staticCallback_getPolyhedronCount,
        (setter) staticCallback_setPolyhedronCount,
        "Number of Polyhedrons in the Mesh.",
        nullptr
    },
    {"SubMeshCount",
        (getter) staticCallback_getSubMeshCount,
        (setter) staticCallback_setSubMeshCount,
        "Number of SubMeshs in the Mesh.",
        nullptr
    },
    {"GroupCount",
        (getter) staticCallback_getGroupCount,
        (setter) staticCallback_setGroupCount,
        "Number of Groups in the Mesh.",
        nullptr
    },
    {"Groups",
        (getter) staticCallback_getGroups,
        (setter) staticCallback_setGroups,
        "Tuple of Group IDs.",
        nullptr
    },
    {"Volume",
        (getter) staticCallback_getVolume,
        (setter) staticCallback_setVolume,
        "Volume of the mesh.",
        nullptr
    },
    {nullptr, nullptr, nullptr, nullptr, nullptr}		/* Sentinel */
};

// setShape() callback and implementer
// PyObject*  FemMeshPy::setShape(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_setShape (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setShape' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->setShape(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// compute() callback and implementer
// PyObject*  FemMeshPy::compute(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_compute (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'compute' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->compute(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addHypothesis() callback and implementer
// PyObject*  FemMeshPy::addHypothesis(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_addHypothesis (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addHypothesis' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->addHypothesis(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setStandardHypotheses() callback and implementer
// PyObject*  FemMeshPy::setStandardHypotheses(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_setStandardHypotheses (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setStandardHypotheses' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->setStandardHypotheses(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addNode() callback and implementer
// PyObject*  FemMeshPy::addNode(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_addNode (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addNode' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->addNode(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addEdge() callback and implementer
// PyObject*  FemMeshPy::addEdge(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_addEdge (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addEdge' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->addEdge(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addEdgeList() callback and implementer
// PyObject*  FemMeshPy::addEdgeList(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_addEdgeList (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addEdgeList' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->addEdgeList(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addFace() callback and implementer
// PyObject*  FemMeshPy::addFace(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_addFace (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addFace' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->addFace(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addFaceList() callback and implementer
// PyObject*  FemMeshPy::addFaceList(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_addFaceList (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addFaceList' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->addFaceList(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addQuad() callback and implementer
// PyObject*  FemMeshPy::addQuad(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_addQuad (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addQuad' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->addQuad(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addVolume() callback and implementer
// PyObject*  FemMeshPy::addVolume(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_addVolume (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addVolume' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->addVolume(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addVolumeList() callback and implementer
// PyObject*  FemMeshPy::addVolumeList(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_addVolumeList (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addVolumeList' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->addVolumeList(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// read() callback and implementer
// PyObject*  FemMeshPy::read(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_read (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'read' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->read(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// write() callback and implementer
// PyObject*  FemMeshPy::write(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_write (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'write' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->write(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// writeABAQUS() callback and implementer
// PyObject*  FemMeshPy::writeABAQUS(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_writeABAQUS (PyObject *self, PyObject *args, PyObject * kwd)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'writeABAQUS' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->writeABAQUS(args, kwd);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setTransform() callback and implementer
// PyObject*  FemMeshPy::setTransform(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_setTransform (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setTransform' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->setTransform(args);
        if (ret != nullptr)
            static_cast<FemMeshPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// copy() callback and implementer
// PyObject*  FemMeshPy::copy(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_copy (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'copy' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->copy(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getFacesByFace() callback and implementer
// PyObject*  FemMeshPy::getFacesByFace(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getFacesByFace (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getFacesByFace' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getFacesByFace(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getEdgesByEdge() callback and implementer
// PyObject*  FemMeshPy::getEdgesByEdge(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getEdgesByEdge (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getEdgesByEdge' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getEdgesByEdge(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getVolumesByFace() callback and implementer
// PyObject*  FemMeshPy::getVolumesByFace(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getVolumesByFace (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getVolumesByFace' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getVolumesByFace(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getccxVolumesByFace() callback and implementer
// PyObject*  FemMeshPy::getccxVolumesByFace(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getccxVolumesByFace (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getccxVolumesByFace' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getccxVolumesByFace(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getNodeById() callback and implementer
// PyObject*  FemMeshPy::getNodeById(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getNodeById (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getNodeById' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getNodeById(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getNodesBySolid() callback and implementer
// PyObject*  FemMeshPy::getNodesBySolid(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getNodesBySolid (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getNodesBySolid' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getNodesBySolid(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getNodesByFace() callback and implementer
// PyObject*  FemMeshPy::getNodesByFace(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getNodesByFace (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getNodesByFace' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getNodesByFace(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getNodesByEdge() callback and implementer
// PyObject*  FemMeshPy::getNodesByEdge(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getNodesByEdge (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getNodesByEdge' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getNodesByEdge(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getNodesByVertex() callback and implementer
// PyObject*  FemMeshPy::getNodesByVertex(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getNodesByVertex (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getNodesByVertex' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getNodesByVertex(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getElementNodes() callback and implementer
// PyObject*  FemMeshPy::getElementNodes(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getElementNodes (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getElementNodes' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getElementNodes(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getNodeElements() callback and implementer
// PyObject*  FemMeshPy::getNodeElements(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getNodeElements (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getNodeElements' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getNodeElements(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getGroupName() callback and implementer
// PyObject*  FemMeshPy::getGroupName(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getGroupName (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getGroupName' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getGroupName(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getGroupElementType() callback and implementer
// PyObject*  FemMeshPy::getGroupElementType(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getGroupElementType (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getGroupElementType' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getGroupElementType(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getGroupElements() callback and implementer
// PyObject*  FemMeshPy::getGroupElements(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getGroupElements (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getGroupElements' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getGroupElements(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addGroup() callback and implementer
// PyObject*  FemMeshPy::addGroup(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_addGroup (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addGroup' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->addGroup(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addGroupElements() callback and implementer
// PyObject*  FemMeshPy::addGroupElements(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_addGroupElements (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addGroupElements' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->addGroupElements(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeGroup() callback and implementer
// PyObject*  FemMeshPy::removeGroup(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_removeGroup (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeGroup' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->removeGroup(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getElementType() callback and implementer
// PyObject*  FemMeshPy::getElementType(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getElementType (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getElementType' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getElementType(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getIdByElementType() callback and implementer
// PyObject*  FemMeshPy::getIdByElementType(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getIdByElementType (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getIdByElementType' of 'Fem.FemMesh' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<FemMeshPy*>(self)->getIdByElementType(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// Nodes() callback and implementer
// PyObject*  FemMeshPy::Nodes(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getNodes (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getNodes());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Nodes' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setNodes (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Nodes' of object 'FemMesh' is read-only");
    return -1;
}

// NodeCount() callback and implementer
// PyObject*  FemMeshPy::NodeCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getNodeCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getNodeCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'NodeCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setNodeCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'NodeCount' of object 'FemMesh' is read-only");
    return -1;
}

// Edges() callback and implementer
// PyObject*  FemMeshPy::Edges(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getEdges (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getEdges());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Edges' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setEdges (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Edges' of object 'FemMesh' is read-only");
    return -1;
}

// EdgesOnly() callback and implementer
// PyObject*  FemMeshPy::EdgesOnly(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getEdgesOnly (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getEdgesOnly());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'EdgesOnly' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setEdgesOnly (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'EdgesOnly' of object 'FemMesh' is read-only");
    return -1;
}

// EdgeCount() callback and implementer
// PyObject*  FemMeshPy::EdgeCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getEdgeCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getEdgeCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'EdgeCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setEdgeCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'EdgeCount' of object 'FemMesh' is read-only");
    return -1;
}

// Faces() callback and implementer
// PyObject*  FemMeshPy::Faces(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getFaces (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getFaces());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Faces' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setFaces (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Faces' of object 'FemMesh' is read-only");
    return -1;
}

// FacesOnly() callback and implementer
// PyObject*  FemMeshPy::FacesOnly(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getFacesOnly (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getFacesOnly());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FacesOnly' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setFacesOnly (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'FacesOnly' of object 'FemMesh' is read-only");
    return -1;
}

// FaceCount() callback and implementer
// PyObject*  FemMeshPy::FaceCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getFaceCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getFaceCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FaceCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setFaceCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'FaceCount' of object 'FemMesh' is read-only");
    return -1;
}

// TriangleCount() callback and implementer
// PyObject*  FemMeshPy::TriangleCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getTriangleCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getTriangleCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'TriangleCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setTriangleCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'TriangleCount' of object 'FemMesh' is read-only");
    return -1;
}

// QuadrangleCount() callback and implementer
// PyObject*  FemMeshPy::QuadrangleCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getQuadrangleCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getQuadrangleCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'QuadrangleCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setQuadrangleCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'QuadrangleCount' of object 'FemMesh' is read-only");
    return -1;
}

// PolygonCount() callback and implementer
// PyObject*  FemMeshPy::PolygonCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getPolygonCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getPolygonCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'PolygonCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setPolygonCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'PolygonCount' of object 'FemMesh' is read-only");
    return -1;
}

// Volumes() callback and implementer
// PyObject*  FemMeshPy::Volumes(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getVolumes (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getVolumes());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Volumes' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setVolumes (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Volumes' of object 'FemMesh' is read-only");
    return -1;
}

// VolumeCount() callback and implementer
// PyObject*  FemMeshPy::VolumeCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getVolumeCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getVolumeCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'VolumeCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setVolumeCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'VolumeCount' of object 'FemMesh' is read-only");
    return -1;
}

// TetraCount() callback and implementer
// PyObject*  FemMeshPy::TetraCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getTetraCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getTetraCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'TetraCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setTetraCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'TetraCount' of object 'FemMesh' is read-only");
    return -1;
}

// HexaCount() callback and implementer
// PyObject*  FemMeshPy::HexaCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getHexaCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getHexaCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'HexaCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setHexaCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'HexaCount' of object 'FemMesh' is read-only");
    return -1;
}

// PyramidCount() callback and implementer
// PyObject*  FemMeshPy::PyramidCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getPyramidCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getPyramidCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'PyramidCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setPyramidCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'PyramidCount' of object 'FemMesh' is read-only");
    return -1;
}

// PrismCount() callback and implementer
// PyObject*  FemMeshPy::PrismCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getPrismCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getPrismCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'PrismCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setPrismCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'PrismCount' of object 'FemMesh' is read-only");
    return -1;
}

// PolyhedronCount() callback and implementer
// PyObject*  FemMeshPy::PolyhedronCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getPolyhedronCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getPolyhedronCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'PolyhedronCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setPolyhedronCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'PolyhedronCount' of object 'FemMesh' is read-only");
    return -1;
}

// SubMeshCount() callback and implementer
// PyObject*  FemMeshPy::SubMeshCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getSubMeshCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getSubMeshCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'SubMeshCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setSubMeshCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'SubMeshCount' of object 'FemMesh' is read-only");
    return -1;
}

// GroupCount() callback and implementer
// PyObject*  FemMeshPy::GroupCount(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getGroupCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getGroupCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'GroupCount' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setGroupCount (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'GroupCount' of object 'FemMesh' is read-only");
    return -1;
}

// Groups() callback and implementer
// PyObject*  FemMeshPy::Groups(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getGroups (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getGroups());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Groups' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setGroups (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Groups' of object 'FemMesh' is read-only");
    return -1;
}

// Volume() callback and implementer
// PyObject*  FemMeshPy::Volume(PyObject *args){};
// has to be implemented in FemMeshPyImp.cpp
PyObject * FemMeshPy::staticCallback_getVolume (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<FemMeshPy*>(self)->getVolume());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Volume' of object 'FemMesh'");
        return nullptr;
    }
}

int FemMeshPy::staticCallback_setVolume (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Volume' of object 'FemMesh' is read-only");
    return -1;
}




//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
FemMeshPy::FemMeshPy(FemMesh *pcObject, PyTypeObject *T)
    : ComplexGeoDataPy(static_cast<ComplexGeoDataPy::PointerType>(pcObject), T)
{
}


//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
FemMeshPy::~FemMeshPy()                                // Everything handled in parent
{
}

//--------------------------------------------------------------------------
// FemMeshPy representation
//--------------------------------------------------------------------------
PyObject *FemMeshPy::_repr()
{
    return Py_BuildValue("s", representation().c_str());
}

//--------------------------------------------------------------------------
// FemMeshPy Attributes
//--------------------------------------------------------------------------
PyObject *FemMeshPy::_getattr(const char *attr)			// __getattr__ function: note only need to handle new state
{
    try {
        // getter method for special Attributes (e.g. dynamic ones)
        PyObject *r = getCustomAttributes(attr);
        if(r) return r;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError,"Unknown C++ exception");
        return nullptr;
    }
#endif

    PyMethodDef *ml = Methods;
    for (; ml->ml_name != nullptr; ml++) {
        if (attr[0] == ml->ml_name[0] &&
            strcmp(attr+1, ml->ml_name+1) == 0)
            return PyCFunction_New(ml, this);
    }

    PyErr_Clear();
    return ComplexGeoDataPy::_getattr(attr);
}

int FemMeshPy::_setattr(const char *attr, PyObject *value) // __setattr__ function: note only need to handle new state
{
    try {
        // setter for special Attributes (e.g. dynamic ones)
        int r = setCustomAttributes(attr, value);
        // r = 1: handled
        // r = -1: error
        // r = 0: ignore
        if (r == 1)
            return 0;
        else if (r == -1)
            return -1;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return -1;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return -1;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return -1;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return -1;
    }
#endif

    return ComplexGeoDataPy::_setattr(attr, value);
}

FemMesh *FemMeshPy::getFemMeshPtr() const
{
    return static_cast<FemMesh *>(_pcTwinPointer);
}

#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#if 0
/* From here on come the methods you have to implement, but NOT in this module. Implement in FemMeshPyImp.cpp! This prototypes
 * are just for convenience when you add a new method.
 */

PyObject *FemMeshPy::PyMake(PyTypeObject* /*type*/, PyObject* /*args*/, PyObject* /*kwds*/)
{
    // create a new instance of FemMeshPy and the Twin object
    return new FemMeshPy(new FemMesh);
}

// constructor method
int FemMeshPy::PyInit(PyObject* /*args*/, PyObject* /*kwd*/)
{
    return 0;
}


// returns a string which represents the object e.g. when printed in python
std::string FemMeshPy::representation() const
{
    return {"<FemMesh object>"};
}

PyObject* FemMeshPy::setShape(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::compute(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::addHypothesis(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::setStandardHypotheses(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::addNode(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::addEdge(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::addEdgeList(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::addFace(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::addFaceList(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::addQuad(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::addVolume(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::addVolumeList(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::read(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::write(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::writeABAQUS(PyObject *args, PyObject *kwds)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::setTransform(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::copy(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getFacesByFace(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getEdgesByEdge(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getVolumesByFace(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getccxVolumesByFace(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getNodeById(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getNodesBySolid(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getNodesByFace(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getNodesByEdge(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getNodesByVertex(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getElementNodes(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getNodeElements(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getGroupName(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getGroupElementType(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getGroupElements(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::addGroup(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::addGroupElements(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::removeGroup(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getElementType(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* FemMeshPy::getIdByElementType(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}



Py::Dict FemMeshPy::getNodes() const
{
    //return Py::Dict();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getNodeCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Tuple FemMeshPy::getEdges() const
{
    //return Py::Tuple();
    throw Py::AttributeError("Not yet implemented");
}

Py::Tuple FemMeshPy::getEdgesOnly() const
{
    //return Py::Tuple();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getEdgeCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Tuple FemMeshPy::getFaces() const
{
    //return Py::Tuple();
    throw Py::AttributeError("Not yet implemented");
}

Py::Tuple FemMeshPy::getFacesOnly() const
{
    //return Py::Tuple();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getFaceCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getTriangleCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getQuadrangleCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getPolygonCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Tuple FemMeshPy::getVolumes() const
{
    //return Py::Tuple();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getVolumeCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getTetraCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getHexaCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getPyramidCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getPrismCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getPolyhedronCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getSubMeshCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long FemMeshPy::getGroupCount() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Tuple FemMeshPy::getGroups() const
{
    //return Py::Tuple();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object FemMeshPy::getVolume() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

PyObject *FemMeshPy::getCustomAttributes(const char* /*attr*/) const
{
    return nullptr;
}

int FemMeshPy::setCustomAttributes(const char* /*attr*/, PyObject* /*obj*/)
{
    return 0;
}


#endif



