
// This file is generated by src/Tools/generateTemplates/templateClassPyExport.py out of the .XML file
// Every change you make here gets lost in the next full rebuild!
// This File is normally built as an include in BSplineCurvePyImp.cpp! It's not intended to be in a project!

#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/exception.hpp>
#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <CXX/Objects.hxx>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

using Base::streq;
using namespace Part;

/// Type structure of BSplineCurvePy
PyTypeObject BSplineCurvePy::Type = {
    PyVarObject_HEAD_INIT(&PyType_Type,0)
    "Part.BSplineCurve",     /*tp_name*/
    sizeof(BSplineCurvePy),                       /*tp_basicsize*/
    0,                                                /*tp_itemsize*/
    /* methods */
    PyDestructor,                                     /*tp_dealloc*/
#if PY_VERSION_HEX >= 0x03080000
    0,                                                /*tp_vectorcall_offset*/
#else
    nullptr,                                          /*tp_print*/
#endif
    nullptr,                                          /*tp_getattr*/
    nullptr,                                          /*tp_setattr*/
    nullptr,                                          /*tp_compare*/
    __repr,                                           /*tp_repr*/
    nullptr,                                          /*tp_as_number*/
    nullptr,                                          /*tp_as_sequence*/
    nullptr,                                          /*tp_as_mapping*/
    nullptr,                                          /*tp_hash*/
    nullptr,                                          /*tp_call */
    nullptr,                                          /*tp_str  */
    __getattro,                                       /*tp_getattro*/
    __setattro,                                       /*tp_setattro*/
    /* --- Functions to access object as input/output buffer ---------*/
    nullptr,                                          /* tp_as_buffer */
    /* --- Flags to define presence of optional/expanded features */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT,        /*tp_flags */
    "Describes a B-Spline curve in 3D space",           /*tp_doc */
    nullptr,                                          /*tp_traverse */
    nullptr,                                          /*tp_clear */
    nullptr,                                          /*tp_richcompare */
    0,                                                /*tp_weaklistoffset */
    nullptr,                                          /*tp_iter */
    nullptr,                                          /*tp_iternext */
    Part::BSplineCurvePy::Methods,                     /*tp_methods */
    nullptr,                                          /*tp_members */
    Part::BSplineCurvePy::GetterSetter,                     /*tp_getset */
    &Part::BoundedCurvePy::Type,                        /*tp_base */
    nullptr,                                          /*tp_dict */
    nullptr,                                          /*tp_descr_get */
    nullptr,                                          /*tp_descr_set */
    0,                                                /*tp_dictoffset */
    __PyInit,                                         /*tp_init */
    nullptr,                                          /*tp_alloc */
    Part::BSplineCurvePy::PyMake,/*tp_new */
    nullptr,                                          /*tp_free   Low-level free-memory routine */
    nullptr,                                          /*tp_is_gc  For PyObject_IS_GC */
    nullptr,                                          /*tp_bases */
    nullptr,                                          /*tp_mro    method resolution order */
    nullptr,                                          /*tp_cache */
    nullptr,                                          /*tp_subclasses */
    nullptr,                                          /*tp_weaklist */
    nullptr,                                          /*tp_del */
    0,                                                /*tp_version_tag */
    nullptr                                           /*tp_finalize */
#if PY_VERSION_HEX >= 0x03090000
    ,nullptr                                          /*tp_vectorcall */
#if PY_VERSION_HEX >= 0x030c0000
    ,0                                                /*tp_watched */
#endif
#elif PY_VERSION_HEX >= 0x03080000
    ,nullptr                                          /*tp_vectorcall */
    /* bpo-37250: kept for backwards compatibility in CPython 3.8 only */
    ,nullptr                                          /*tp_print */
#endif
};

/// Methods structure of BSplineCurvePy
PyMethodDef BSplineCurvePy::Methods[] = {
    {"__reduce__",
        reinterpret_cast<PyCFunction>( staticCallback___reduce__ ),
        METH_VARARGS,
        "__reduce__()\n"
        "Serialization of Part.BSplineCurve objects"
    },
    {"isRational",
        reinterpret_cast<PyCFunction>( staticCallback_isRational ),
        METH_VARARGS,
        "Returns true if this B-Spline curve is rational.\n"
        "                    A B-Spline curve is rational if, at the time of construction,\n"
        "                    the weight table has been initialized."
    },
    {"isPeriodic",
        reinterpret_cast<PyCFunction>( staticCallback_isPeriodic ),
        METH_VARARGS,
        "Returns true if this BSpline curve is periodic."
    },
    {"isClosed",
        reinterpret_cast<PyCFunction>( staticCallback_isClosed ),
        METH_VARARGS,
        "Returns true if the distance between the start point and end point of\n"
        "                    this B-Spline curve is less than or equal to gp::Resolution()."
    },
    {"increaseDegree",
        reinterpret_cast<PyCFunction>( staticCallback_increaseDegree ),
        METH_VARARGS,
        "increase(Int=Degree)\n"
        "Increases the degree of this B-Spline curve to Degree.\n"
        "As a result, the poles, weights and multiplicities tables\n"
        "are modified; the knots table is not changed. Nothing is\n"
        "done if Degree is less than or equal to the current degree."
    },
    {"increaseMultiplicity",
        reinterpret_cast<PyCFunction>( staticCallback_increaseMultiplicity ),
        METH_VARARGS,
        "increaseMultiplicity(int index, int mult)\n"
        "                increaseMultiplicity(int start, int end, int mult)\n"
        "                Increases multiplicity of knots up to mult.\n"
        "\n"
        "                index: the index of a knot to modify (1-based)\n"
        "                start, end: index range of knots to modify.\n"
        "                If mult is lower or equal to the current multiplicity nothing is done. If mult is higher than the degree the degree is used."
    },
    {"incrementMultiplicity",
        reinterpret_cast<PyCFunction>( staticCallback_incrementMultiplicity ),
        METH_VARARGS,
        "incrementMultiplicity(int start, int end, int mult)\n"
        "                Raises multiplicity of knots by mult.\n"
        "\n"
        "                start, end: index range of knots to modify."
    },
    {"insertKnot",
        reinterpret_cast<PyCFunction>( staticCallback_insertKnot ),
        METH_VARARGS,
        "insertKnot(u, mult = 1, tol = 0.0)\n"
        "                Inserts a knot value in the sequence of knots. If u is an existing knot the\n"
        "                multiplicity is increased by mult."
    },
    {"insertKnots",
        reinterpret_cast<PyCFunction>( staticCallback_insertKnots ),
        METH_VARARGS,
        "insertKnots(list_of_floats, list_of_ints, tol = 0.0, bool_add = True)\n"
        "                Inserts a set of knots values in the sequence of knots.\n"
        "\n"
        "                For each u = list_of_floats[i], mult = list_of_ints[i]\n"
        "\n"
        "                If u is an existing knot the multiplicity is increased by mult if bool_add is\n"
        "                True, otherwise increased to mult.\n"
        "\n"
        "                If u is not on the parameter range nothing is done.\n"
        "\n"
        "                If the multiplicity is negative or null nothing is done. The new multiplicity\n"
        "                is limited to the degree.\n"
        "\n"
        "                The tolerance criterion for knots equality is the max of Epsilon(U) and ParametricTolerance."
    },
    {"removeKnot",
        reinterpret_cast<PyCFunction>( staticCallback_removeKnot ),
        METH_VARARGS,
        "removeKnot(Index, M, tol)\n"
        "\n"
        "                    Reduces the multiplicity of the knot of index Index to M.\n"
        "                    If M is equal to 0, the knot is removed.\n"
        "                    With a modification of this type, the array of poles is also modified.\n"
        "                    Two different algorithms are systematically used to compute the new\n"
        "                    poles of the curve. If, for each pole, the distance between the pole\n"
        "                    calculated using the first algorithm and the same pole calculated using\n"
        "                    the second algorithm, is less than Tolerance, this ensures that the curve\n"
        "                    is not modified by more than Tolerance. Under these conditions, true is\n"
        "                    returned; otherwise, false is returned.\n"
        "\n"
        "                    A low tolerance is used to prevent modification of the curve.\n"
        "                    A high tolerance is used to 'smooth' the curve."
    },
    {"segment",
        reinterpret_cast<PyCFunction>( staticCallback_segment ),
        METH_VARARGS,
        "segment(u1,u2)\n"
        "                    Modifies this B-Spline curve by segmenting it."
    },
    {"setKnot",
        reinterpret_cast<PyCFunction>( staticCallback_setKnot ),
        METH_VARARGS,
        "Set a knot of the B-Spline curve."
    },
    {"getKnot",
        reinterpret_cast<PyCFunction>( staticCallback_getKnot ),
        METH_VARARGS,
        "Get a knot of the B-Spline curve."
    },
    {"setKnots",
        reinterpret_cast<PyCFunction>( staticCallback_setKnots ),
        METH_VARARGS,
        "Set knots of the B-Spline curve."
    },
    {"getKnots",
        reinterpret_cast<PyCFunction>( staticCallback_getKnots ),
        METH_VARARGS,
        "Get all knots of the B-Spline curve."
    },
    {"setPole",
        reinterpret_cast<PyCFunction>( staticCallback_setPole ),
        METH_VARARGS,
        "Modifies this B-Spline curve by assigning P\n"
        "to the pole of index Index in the poles table."
    },
    {"getPole",
        reinterpret_cast<PyCFunction>( staticCallback_getPole ),
        METH_VARARGS,
        "Get a pole of the B-Spline curve."
    },
    {"getPoles",
        reinterpret_cast<PyCFunction>( staticCallback_getPoles ),
        METH_VARARGS,
        "Get all poles of the B-Spline curve."
    },
    {"setWeight",
        reinterpret_cast<PyCFunction>( staticCallback_setWeight ),
        METH_VARARGS,
        "Set a weight of the B-Spline curve."
    },
    {"getWeight",
        reinterpret_cast<PyCFunction>( staticCallback_getWeight ),
        METH_VARARGS,
        "Get a weight of the B-Spline curve."
    },
    {"getWeights",
        reinterpret_cast<PyCFunction>( staticCallback_getWeights ),
        METH_VARARGS,
        "Get all weights of the B-Spline curve."
    },
    {"getPolesAndWeights",
        reinterpret_cast<PyCFunction>( staticCallback_getPolesAndWeights ),
        METH_VARARGS,
        "Returns the table of poles and weights in homogeneous coordinates."
    },
    {"getResolution",
        reinterpret_cast<PyCFunction>( staticCallback_getResolution ),
        METH_VARARGS,
        "Computes for this B-Spline curve the parametric tolerance (UTolerance)\n"
        "for a given 3D tolerance (Tolerance3D).\n"
        "If f(t) is the equation of this B-Spline curve, the parametric tolerance\n"
        "ensures that:\n"
        "|t1-t0| < UTolerance =\"\"==> |f(t1)-f(t0)| < Tolerance3D"
    },
    {"movePoint",
        reinterpret_cast<PyCFunction>( staticCallback_movePoint ),
        METH_VARARGS,
        "movePoint(U, P, Index1, Index2)\n"
        "                Moves the point of parameter U of this B-Spline curve to P.\n"
        "Index1 and Index2 are the indexes in the table of poles of this B-Spline curve\n"
        "of the first and last poles designated to be moved.\n"
        "\n"
        "Returns: (FirstModifiedPole, LastModifiedPole). They are the indexes of the\n"
        "first and last poles which are effectively modified."
    },
    {"setNotPeriodic",
        reinterpret_cast<PyCFunction>( staticCallback_setNotPeriodic ),
        METH_VARARGS,
        "Changes this B-Spline curve into a non-periodic curve.\n"
        "If this curve is already non-periodic, it is not modified."
    },
    {"setPeriodic",
        reinterpret_cast<PyCFunction>( staticCallback_setPeriodic ),
        METH_VARARGS,
        "Changes this B-Spline curve into a periodic curve."
    },
    {"setOrigin",
        reinterpret_cast<PyCFunction>( staticCallback_setOrigin ),
        METH_VARARGS,
        "Assigns the knot of index Index in the knots table\n"
        "as the origin of this periodic B-Spline curve. As a consequence,\n"
        "the knots and poles tables are modified."
    },
    {"getMultiplicity",
        reinterpret_cast<PyCFunction>( staticCallback_getMultiplicity ),
        METH_VARARGS,
        "Returns the multiplicity of the knot of index\n"
        "from the knots table of this B-Spline curve."
    },
    {"getMultiplicities",
        reinterpret_cast<PyCFunction>( staticCallback_getMultiplicities ),
        METH_VARARGS,
        "Returns the multiplicities table M of the knots of this B-Spline curve."
    },
    {"approximate",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_approximate )),
        METH_VARARGS|METH_KEYWORDS,
        "Replaces this B-Spline curve by approximating a set of points.\n"
        "                    The function accepts keywords as arguments.\n"
        "\n"
        "                    approximate(Points = list_of_points)\n"
        "\n"
        "                    Optional arguments :\n"
        "\n"
        "                    DegMin = integer (3) : Minimum degree of the curve.\n"
        "                    DegMax = integer (8) : Maximum degree of the curve.\n"
        "                    Tolerance = float (1e-3) : approximating tolerance.\n"
        "                    Continuity = string ('C2') : Desired continuity of the curve.\n"
        "                    Possible values : 'C0','G1','C1','G2','C2','C3','CN'\n"
        "\n"
        "                    LengthWeight = float, CurvatureWeight = float, TorsionWeight = float\n"
        "                    If one of these arguments is not null, the functions approximates the\n"
        "                    points using variational smoothing algorithm, which tries to minimize\n"
        "                    additional criterium:\n"
        "                    LengthWeight*CurveLength + CurvatureWeight*Curvature + TorsionWeight*Torsion\n"
        "                                        Continuity must be C0, C1(with DegMax >= 3) or C2(with DegMax >= 5).\n"
        "\n"
        "                    Parameters = list of floats : knot sequence of the approximated points.\n"
        "                    This argument is only used if the weights above are all null.\n"
        "\n"
        "                    ParamType = string ('Uniform','Centripetal' or 'ChordLength')\n"
        "                    Parameterization type. Only used if weights and Parameters above aren't specified.\n"
        "\n"
        "                    Note : Continuity of the spline defaults to C2. However, it may not be applied if\n"
        "                    it conflicts with other parameters ( especially DegMax )."
    },
    {"getCardinalSplineTangents",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_getCardinalSplineTangents )),
        METH_VARARGS|METH_KEYWORDS,
        "Compute the tangents for a Cardinal spline"
    },
    {"interpolate",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_interpolate )),
        METH_VARARGS|METH_KEYWORDS,
        "Replaces this B-Spline curve by interpolating a set of points.\n"
        "                    The function accepts keywords as arguments.\n"
        "\n"
        "                    interpolate(Points = list_of_points)\n"
        "\n"
        "                    Optional arguments :\n"
        "\n"
        "                    PeriodicFlag = bool (False) : Sets the curve closed or opened.\n"
        "                    Tolerance = float (1e-6) : interpolating tolerance\n"
        "\n"
        "                    Parameters : knot sequence of the interpolated points.\n"
        "                    If not supplied, the function defaults to chord-length parameterization.\n"
        "                    If PeriodicFlag == True, one extra parameter must be appended.\n"
        "\n"
        "                    EndPoint Tangent constraints :\n"
        "\n"
        "                    InitialTangent = vector, FinalTangent = vector\n"
        "                    specify tangent vectors for starting and ending points\n"
        "                    of the BSpline. Either none, or both must be specified.\n"
        "\n"
        "                    Full Tangent constraints :\n"
        "\n"
        "                    Tangents = list_of_vectors, TangentFlags = list_of_bools\n"
        "                    Both lists must have the same length as Points list.\n"
        "                    Tangents specifies the tangent vector of each point in Points list.\n"
        "                    TangentFlags (bool) activates or deactivates the corresponding tangent.\n"
        "                    These arguments will be ignored if EndPoint Tangents (above) are also defined.\n"
        "\n"
        "                    Note : Continuity of the spline defaults to C2. However, if periodic, or tangents\n"
        "                    are supplied, the continuity will drop to C1."
    },
    {"buildFromPoles",
        reinterpret_cast<PyCFunction>( staticCallback_buildFromPoles ),
        METH_VARARGS,
        "Builds a B-Spline by a list of poles.\n"
        "                    arguments: poles (sequence of Base.Vector), [periodic (default is False), degree (default is 3), interpolate (default is False)]\n"
        "\n"
        "                    Examples:\n"
        "                    from FreeCAD import Base\n"
        "                    import Part\n"
        "                    V = Base.Vector\n"
        "                    poles = [V(-2, 2, 0),V(0, 2, 1),V(2, 2, 0),V(2, -2, 0),V(0, -2, 1),V(-2, -2, 0)]\n"
        "\n"
        "                    # non-periodic spline\n"
        "                    n=Part.BSplineCurve()\n"
        "                    n.buildFromPoles(poles)\n"
        "                    Part.show(n.toShape())\n"
        "\n"
        "                    # periodic spline\n"
        "                    n=Part.BSplineCurve()\n"
        "                    n.buildFromPoles(poles, True)\n"
        "                    Part.show(n.toShape())"
    },
    {"buildFromPolesMultsKnots",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_buildFromPolesMultsKnots )),
        METH_VARARGS|METH_KEYWORDS,
        "Builds a B-Spline by a lists of Poles, Mults, Knots.\n"
        "                arguments: poles (sequence of Base.Vector), [mults , knots, periodic, degree, weights (sequence of float), CheckRational]\n"
        "\n"
        "                Examples:\n"
        "                from FreeCAD import Base\n"
        "                import Part\n"
        "                V=Base.Vector\n"
        "                poles=[V(-10,-10),V(10,-10),V(10,10),V(-10,10)]\n"
        "\n"
        "                # non-periodic spline\n"
        "                n=Part.BSplineCurve()\n"
        "                n.buildFromPolesMultsKnots(poles,(3,1,3),(0,0.5,1),False,2)\n"
        "                Part.show(n.toShape())\n"
        "\n"
        "                # periodic spline\n"
        "                p=Part.BSplineCurve()\n"
        "                p.buildFromPolesMultsKnots(poles,(1,1,1,1,1),(0,0.25,0.5,0.75,1),True,2)\n"
        "                Part.show(p.toShape())\n"
        "\n"
        "                # periodic and rational spline\n"
        "                r=Part.BSplineCurve()\n"
        "                r.buildFromPolesMultsKnots(poles,(1,1,1,1,1),(0,0.25,0.5,0.75,1),True,2,(1,0.8,0.7,0.2))\n"
        "                Part.show(r.toShape())"
    },
    {"toBezier",
        reinterpret_cast<PyCFunction>( staticCallback_toBezier ),
        METH_VARARGS,
        "Build a list of Bezier splines."
    },
    {"toBiArcs",
        reinterpret_cast<PyCFunction>( staticCallback_toBiArcs ),
        METH_VARARGS,
        "Build a list of arcs and lines to approximate the B-spline.\n"
        "                    toBiArcs(tolerance) -> list."
    },
    {"join",
        reinterpret_cast<PyCFunction>( staticCallback_join ),
        METH_VARARGS,
        "Build a new spline by joining this and a second spline."
    },
    {"makeC1Continuous",
        reinterpret_cast<PyCFunction>( staticCallback_makeC1Continuous ),
        METH_VARARGS,
        "makeC1Continuous(tol = 1e-6, ang_tol = 1e-7)\n"
        "                    Reduces as far as possible the multiplicities of the knots of this BSpline\n"
        "                    (keeping the geometry). It returns a new BSpline, which could still be C0.\n"
        "                    tol is a geometrical tolerance.\n"
        "                    The tol_ang is angular tolerance, in radians. It sets tolerable angle mismatch\n"
        "                    of the tangents on the left and on the right to decide if the curve is G1 or\n"
        "                    not at a given point."
    },
    {"scaleKnotsToBounds",
        reinterpret_cast<PyCFunction>( staticCallback_scaleKnotsToBounds ),
        METH_VARARGS,
        "Scales the knots list to fit the specified bounds.\n"
        "                    The shape of the curve is not modified.\n"
        "                    bspline_curve.scaleKnotsToBounds(u0, u1)\n"
        "                    Default arguments are (0.0, 1.0)"
    },
    {nullptr, nullptr, 0, nullptr}		/* Sentinel */
};



/// Attribute structure of BSplineCurvePy
PyGetSetDef BSplineCurvePy::GetterSetter[] = {
    {"Degree",
        (getter) staticCallback_getDegree,
        (setter) staticCallback_setDegree,
        "Returns the polynomial degree of this B-Spline curve.",
        nullptr
    },
    {"MaxDegree",
        (getter) staticCallback_getMaxDegree,
        (setter) staticCallback_setMaxDegree,
        "Returns the value of the maximum polynomial degree of any\n"
        "B-Spline curve curve. This value is 25.",
        nullptr
    },
    {"NbPoles",
        (getter) staticCallback_getNbPoles,
        (setter) staticCallback_setNbPoles,
        "Returns the number of poles of this B-Spline curve.",
        nullptr
    },
    {"NbKnots",
        (getter) staticCallback_getNbKnots,
        (setter) staticCallback_setNbKnots,
        "Returns the number of knots of this B-Spline curve.",
        nullptr
    },
    {"StartPoint",
        (getter) staticCallback_getStartPoint,
        (setter) staticCallback_setStartPoint,
        "Returns the start point of this B-Spline curve.",
        nullptr
    },
    {"EndPoint",
        (getter) staticCallback_getEndPoint,
        (setter) staticCallback_setEndPoint,
        "Returns the end point of this B-Spline curve.",
        nullptr
    },
    {"FirstUKnotIndex",
        (getter) staticCallback_getFirstUKnotIndex,
        (setter) staticCallback_setFirstUKnotIndex,
        "Returns the index in the knot array of the knot\n"
        "corresponding to the first or last parameter\n"
        "of this B-Spline curve.",
        nullptr
    },
    {"LastUKnotIndex",
        (getter) staticCallback_getLastUKnotIndex,
        (setter) staticCallback_setLastUKnotIndex,
        "Returns the index in the knot array of the knot\n"
        "corresponding to the first or last parameter\n"
        "of this B-Spline curve.",
        nullptr
    },
    {"KnotSequence",
        (getter) staticCallback_getKnotSequence,
        (setter) staticCallback_setKnotSequence,
        "Returns the knots sequence of this B-Spline curve.",
        nullptr
    },
    {nullptr, nullptr, nullptr, nullptr, nullptr}		/* Sentinel */
};

// __reduce__() callback and implementer
// PyObject*  BSplineCurvePy::__reduce__(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback___reduce__ (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor '__reduce__' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->__reduce__(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// isRational() callback and implementer
// PyObject*  BSplineCurvePy::isRational(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_isRational (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'isRational' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->isRational(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// isPeriodic() callback and implementer
// PyObject*  BSplineCurvePy::isPeriodic(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_isPeriodic (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'isPeriodic' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->isPeriodic(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// isClosed() callback and implementer
// PyObject*  BSplineCurvePy::isClosed(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_isClosed (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'isClosed' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->isClosed(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// increaseDegree() callback and implementer
// PyObject*  BSplineCurvePy::increaseDegree(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_increaseDegree (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'increaseDegree' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->increaseDegree(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// increaseMultiplicity() callback and implementer
// PyObject*  BSplineCurvePy::increaseMultiplicity(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_increaseMultiplicity (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'increaseMultiplicity' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->increaseMultiplicity(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// incrementMultiplicity() callback and implementer
// PyObject*  BSplineCurvePy::incrementMultiplicity(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_incrementMultiplicity (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'incrementMultiplicity' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->incrementMultiplicity(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// insertKnot() callback and implementer
// PyObject*  BSplineCurvePy::insertKnot(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_insertKnot (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'insertKnot' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->insertKnot(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// insertKnots() callback and implementer
// PyObject*  BSplineCurvePy::insertKnots(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_insertKnots (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'insertKnots' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->insertKnots(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeKnot() callback and implementer
// PyObject*  BSplineCurvePy::removeKnot(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_removeKnot (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeKnot' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->removeKnot(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// segment() callback and implementer
// PyObject*  BSplineCurvePy::segment(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_segment (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'segment' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->segment(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setKnot() callback and implementer
// PyObject*  BSplineCurvePy::setKnot(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_setKnot (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setKnot' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->setKnot(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getKnot() callback and implementer
// PyObject*  BSplineCurvePy::getKnot(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getKnot (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getKnot' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->getKnot(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setKnots() callback and implementer
// PyObject*  BSplineCurvePy::setKnots(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_setKnots (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setKnots' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->setKnots(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getKnots() callback and implementer
// PyObject*  BSplineCurvePy::getKnots(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getKnots (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getKnots' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->getKnots(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setPole() callback and implementer
// PyObject*  BSplineCurvePy::setPole(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_setPole (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setPole' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->setPole(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getPole() callback and implementer
// PyObject*  BSplineCurvePy::getPole(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getPole (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getPole' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->getPole(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getPoles() callback and implementer
// PyObject*  BSplineCurvePy::getPoles(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getPoles (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getPoles' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->getPoles(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setWeight() callback and implementer
// PyObject*  BSplineCurvePy::setWeight(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_setWeight (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setWeight' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->setWeight(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getWeight() callback and implementer
// PyObject*  BSplineCurvePy::getWeight(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getWeight (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getWeight' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->getWeight(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getWeights() callback and implementer
// PyObject*  BSplineCurvePy::getWeights(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getWeights (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getWeights' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->getWeights(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getPolesAndWeights() callback and implementer
// PyObject*  BSplineCurvePy::getPolesAndWeights(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getPolesAndWeights (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getPolesAndWeights' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->getPolesAndWeights(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getResolution() callback and implementer
// PyObject*  BSplineCurvePy::getResolution(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getResolution (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getResolution' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->getResolution(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// movePoint() callback and implementer
// PyObject*  BSplineCurvePy::movePoint(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_movePoint (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'movePoint' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->movePoint(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setNotPeriodic() callback and implementer
// PyObject*  BSplineCurvePy::setNotPeriodic(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_setNotPeriodic (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setNotPeriodic' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->setNotPeriodic(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setPeriodic() callback and implementer
// PyObject*  BSplineCurvePy::setPeriodic(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_setPeriodic (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setPeriodic' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->setPeriodic(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setOrigin() callback and implementer
// PyObject*  BSplineCurvePy::setOrigin(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_setOrigin (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setOrigin' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->setOrigin(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getMultiplicity() callback and implementer
// PyObject*  BSplineCurvePy::getMultiplicity(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getMultiplicity (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getMultiplicity' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->getMultiplicity(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getMultiplicities() callback and implementer
// PyObject*  BSplineCurvePy::getMultiplicities(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getMultiplicities (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getMultiplicities' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->getMultiplicities(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// approximate() callback and implementer
// PyObject*  BSplineCurvePy::approximate(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_approximate (PyObject *self, PyObject *args, PyObject * kwd)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'approximate' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->approximate(args, kwd);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getCardinalSplineTangents() callback and implementer
// PyObject*  BSplineCurvePy::getCardinalSplineTangents(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getCardinalSplineTangents (PyObject *self, PyObject *args, PyObject * kwd)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getCardinalSplineTangents' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->getCardinalSplineTangents(args, kwd);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// interpolate() callback and implementer
// PyObject*  BSplineCurvePy::interpolate(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_interpolate (PyObject *self, PyObject *args, PyObject * kwd)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'interpolate' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->interpolate(args, kwd);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// buildFromPoles() callback and implementer
// PyObject*  BSplineCurvePy::buildFromPoles(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_buildFromPoles (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'buildFromPoles' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->buildFromPoles(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// buildFromPolesMultsKnots() callback and implementer
// PyObject*  BSplineCurvePy::buildFromPolesMultsKnots(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_buildFromPolesMultsKnots (PyObject *self, PyObject *args, PyObject * kwd)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'buildFromPolesMultsKnots' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->buildFromPolesMultsKnots(args, kwd);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// toBezier() callback and implementer
// PyObject*  BSplineCurvePy::toBezier(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_toBezier (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'toBezier' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->toBezier(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// toBiArcs() callback and implementer
// PyObject*  BSplineCurvePy::toBiArcs(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_toBiArcs (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'toBiArcs' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->toBiArcs(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// join() callback and implementer
// PyObject*  BSplineCurvePy::join(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_join (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'join' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->join(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// makeC1Continuous() callback and implementer
// PyObject*  BSplineCurvePy::makeC1Continuous(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_makeC1Continuous (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'makeC1Continuous' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->makeC1Continuous(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// scaleKnotsToBounds() callback and implementer
// PyObject*  BSplineCurvePy::scaleKnotsToBounds(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_scaleKnotsToBounds (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'scaleKnotsToBounds' of 'Part.GeomBSplineCurve' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<BSplineCurvePy*>(self)->scaleKnotsToBounds(args);
        if (ret != nullptr)
            static_cast<BSplineCurvePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// Degree() callback and implementer
// PyObject*  BSplineCurvePy::Degree(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getDegree (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<BSplineCurvePy*>(self)->getDegree());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Degree' of object 'GeomBSplineCurve'");
        return nullptr;
    }
}

int BSplineCurvePy::staticCallback_setDegree (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'Degree' of object 'GeomBSplineCurve' is read-only");
    return -1;
}

// MaxDegree() callback and implementer
// PyObject*  BSplineCurvePy::MaxDegree(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getMaxDegree (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<BSplineCurvePy*>(self)->getMaxDegree());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'MaxDegree' of object 'GeomBSplineCurve'");
        return nullptr;
    }
}

int BSplineCurvePy::staticCallback_setMaxDegree (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'MaxDegree' of object 'GeomBSplineCurve' is read-only");
    return -1;
}

// NbPoles() callback and implementer
// PyObject*  BSplineCurvePy::NbPoles(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getNbPoles (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<BSplineCurvePy*>(self)->getNbPoles());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'NbPoles' of object 'GeomBSplineCurve'");
        return nullptr;
    }
}

int BSplineCurvePy::staticCallback_setNbPoles (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'NbPoles' of object 'GeomBSplineCurve' is read-only");
    return -1;
}

// NbKnots() callback and implementer
// PyObject*  BSplineCurvePy::NbKnots(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getNbKnots (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<BSplineCurvePy*>(self)->getNbKnots());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'NbKnots' of object 'GeomBSplineCurve'");
        return nullptr;
    }
}

int BSplineCurvePy::staticCallback_setNbKnots (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'NbKnots' of object 'GeomBSplineCurve' is read-only");
    return -1;
}

// StartPoint() callback and implementer
// PyObject*  BSplineCurvePy::StartPoint(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getStartPoint (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<BSplineCurvePy*>(self)->getStartPoint());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'StartPoint' of object 'GeomBSplineCurve'");
        return nullptr;
    }
}

int BSplineCurvePy::staticCallback_setStartPoint (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'StartPoint' of object 'GeomBSplineCurve' is read-only");
    return -1;
}

// EndPoint() callback and implementer
// PyObject*  BSplineCurvePy::EndPoint(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getEndPoint (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<BSplineCurvePy*>(self)->getEndPoint());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'EndPoint' of object 'GeomBSplineCurve'");
        return nullptr;
    }
}

int BSplineCurvePy::staticCallback_setEndPoint (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'EndPoint' of object 'GeomBSplineCurve' is read-only");
    return -1;
}

// FirstUKnotIndex() callback and implementer
// PyObject*  BSplineCurvePy::FirstUKnotIndex(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getFirstUKnotIndex (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<BSplineCurvePy*>(self)->getFirstUKnotIndex());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FirstUKnotIndex' of object 'GeomBSplineCurve'");
        return nullptr;
    }
}

int BSplineCurvePy::staticCallback_setFirstUKnotIndex (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'FirstUKnotIndex' of object 'GeomBSplineCurve' is read-only");
    return -1;
}

// LastUKnotIndex() callback and implementer
// PyObject*  BSplineCurvePy::LastUKnotIndex(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getLastUKnotIndex (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<BSplineCurvePy*>(self)->getLastUKnotIndex());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'LastUKnotIndex' of object 'GeomBSplineCurve'");
        return nullptr;
    }
}

int BSplineCurvePy::staticCallback_setLastUKnotIndex (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'LastUKnotIndex' of object 'GeomBSplineCurve' is read-only");
    return -1;
}

// KnotSequence() callback and implementer
// PyObject*  BSplineCurvePy::KnotSequence(PyObject *args){};
// has to be implemented in BSplineCurvePyImp.cpp
PyObject * BSplineCurvePy::staticCallback_getKnotSequence (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<BSplineCurvePy*>(self)->getKnotSequence());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'KnotSequence' of object 'GeomBSplineCurve'");
        return nullptr;
    }
}

int BSplineCurvePy::staticCallback_setKnotSequence (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'KnotSequence' of object 'GeomBSplineCurve' is read-only");
    return -1;
}




//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
BSplineCurvePy::BSplineCurvePy(GeomBSplineCurve *pcObject, PyTypeObject *T)
    : BoundedCurvePy(static_cast<BoundedCurvePy::PointerType>(pcObject), T)
{
}


//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
BSplineCurvePy::~BSplineCurvePy()                                // Everything handled in parent
{
}

//--------------------------------------------------------------------------
// BSplineCurvePy representation
//--------------------------------------------------------------------------
PyObject *BSplineCurvePy::_repr()
{
    return Py_BuildValue("s", representation().c_str());
}

//--------------------------------------------------------------------------
// BSplineCurvePy Attributes
//--------------------------------------------------------------------------
PyObject *BSplineCurvePy::_getattr(const char *attr)			// __getattr__ function: note only need to handle new state
{
    try {
        // getter method for special Attributes (e.g. dynamic ones)
        PyObject *r = getCustomAttributes(attr);
        if(r) return r;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError,"Unknown C++ exception");
        return nullptr;
    }
#endif

    PyMethodDef *ml = Methods;
    for (; ml->ml_name != nullptr; ml++) {
        if (attr[0] == ml->ml_name[0] &&
            strcmp(attr+1, ml->ml_name+1) == 0)
            return PyCFunction_New(ml, this);
    }

    PyErr_Clear();
    return BoundedCurvePy::_getattr(attr);
}

int BSplineCurvePy::_setattr(const char *attr, PyObject *value) // __setattr__ function: note only need to handle new state
{
    try {
        // setter for special Attributes (e.g. dynamic ones)
        int r = setCustomAttributes(attr, value);
        // r = 1: handled
        // r = -1: error
        // r = 0: ignore
        if (r == 1)
            return 0;
        else if (r == -1)
            return -1;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return -1;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return -1;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return -1;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return -1;
    }
#endif

    return BoundedCurvePy::_setattr(attr, value);
}

GeomBSplineCurve *BSplineCurvePy::getGeomBSplineCurvePtr() const
{
    return static_cast<GeomBSplineCurve *>(_pcTwinPointer);
}

#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#if 0
/* From here on come the methods you have to implement, but NOT in this module. Implement in BSplineCurvePyImp.cpp! This prototypes
 * are just for convenience when you add a new method.
 */

PyObject *BSplineCurvePy::PyMake(PyTypeObject* /*type*/, PyObject* /*args*/, PyObject* /*kwds*/)
{
    // create a new instance of BSplineCurvePy and the Twin object
    return new BSplineCurvePy(new GeomBSplineCurve);
}

// constructor method
int BSplineCurvePy::PyInit(PyObject* /*args*/, PyObject* /*kwd*/)
{
    return 0;
}


// returns a string which represents the object e.g. when printed in python
std::string BSplineCurvePy::representation() const
{
    return {"<GeomBSplineCurve object>"};
}

PyObject* BSplineCurvePy::__reduce__(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::isRational(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::isPeriodic(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::isClosed(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::increaseDegree(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::increaseMultiplicity(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::incrementMultiplicity(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::insertKnot(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::insertKnots(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::removeKnot(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::segment(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::setKnot(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::getKnot(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::setKnots(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::getKnots(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::setPole(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::getPole(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::getPoles(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::setWeight(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::getWeight(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::getWeights(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::getPolesAndWeights(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::getResolution(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::movePoint(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::setNotPeriodic(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::setPeriodic(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::setOrigin(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::getMultiplicity(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::getMultiplicities(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::approximate(PyObject *args, PyObject *kwds)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::getCardinalSplineTangents(PyObject *args, PyObject *kwds)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::interpolate(PyObject *args, PyObject *kwds)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::buildFromPoles(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::buildFromPolesMultsKnots(PyObject *args, PyObject *kwds)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::toBezier(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::toBiArcs(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::join(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::makeC1Continuous(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* BSplineCurvePy::scaleKnotsToBounds(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}



Py::Long BSplineCurvePy::getDegree() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long BSplineCurvePy::getMaxDegree() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long BSplineCurvePy::getNbPoles() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Long BSplineCurvePy::getNbKnots() const
{
    //return Py::Long();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object BSplineCurvePy::getStartPoint() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object BSplineCurvePy::getEndPoint() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object BSplineCurvePy::getFirstUKnotIndex() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object BSplineCurvePy::getLastUKnotIndex() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

Py::List BSplineCurvePy::getKnotSequence() const
{
    //return Py::List();
    throw Py::AttributeError("Not yet implemented");
}

PyObject *BSplineCurvePy::getCustomAttributes(const char* /*attr*/) const
{
    return nullptr;
}

int BSplineCurvePy::setCustomAttributes(const char* /*attr*/, PyObject* /*obj*/)
{
    return 0;
}


#endif



