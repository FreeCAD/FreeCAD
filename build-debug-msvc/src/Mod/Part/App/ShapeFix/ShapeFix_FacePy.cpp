
// This file is generated by src/Tools/generateTemplates/templateClassPyExport.py out of the .XML file
// Every change you make here gets lost in the next full rebuild!
// This File is normally built as an include in ShapeFix_FacePyImp.cpp! It's not intended to be in a project!

#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/exception.hpp>
#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <CXX/Objects.hxx>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

using Base::streq;
using namespace Part;

/// Type structure of ShapeFix_FacePy
PyTypeObject ShapeFix_FacePy::Type = {
    PyVarObject_HEAD_INIT(&PyType_Type,0)
    "Part.ShapeFix.Face",     /*tp_name*/
    sizeof(ShapeFix_FacePy),                       /*tp_basicsize*/
    0,                                                /*tp_itemsize*/
    /* methods */
    PyDestructor,                                     /*tp_dealloc*/
#if PY_VERSION_HEX >= 0x03080000
    0,                                                /*tp_vectorcall_offset*/
#else
    nullptr,                                          /*tp_print*/
#endif
    nullptr,                                          /*tp_getattr*/
    nullptr,                                          /*tp_setattr*/
    nullptr,                                          /*tp_compare*/
    __repr,                                           /*tp_repr*/
    nullptr,                                          /*tp_as_number*/
    nullptr,                                          /*tp_as_sequence*/
    nullptr,                                          /*tp_as_mapping*/
    nullptr,                                          /*tp_hash*/
    nullptr,                                          /*tp_call */
    nullptr,                                          /*tp_str  */
    __getattro,                                       /*tp_getattro*/
    __setattro,                                       /*tp_setattro*/
    /* --- Functions to access object as input/output buffer ---------*/
    nullptr,                                          /* tp_as_buffer */
    /* --- Flags to define presence of optional/expanded features */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT,        /*tp_flags */
    "Class for fixing operations on faces",           /*tp_doc */
    nullptr,                                          /*tp_traverse */
    nullptr,                                          /*tp_clear */
    nullptr,                                          /*tp_richcompare */
    0,                                                /*tp_weaklistoffset */
    nullptr,                                          /*tp_iter */
    nullptr,                                          /*tp_iternext */
    Part::ShapeFix_FacePy::Methods,                     /*tp_methods */
    nullptr,                                          /*tp_members */
    Part::ShapeFix_FacePy::GetterSetter,                     /*tp_getset */
    &Part::ShapeFix_RootPy::Type,                        /*tp_base */
    nullptr,                                          /*tp_dict */
    nullptr,                                          /*tp_descr_get */
    nullptr,                                          /*tp_descr_set */
    0,                                                /*tp_dictoffset */
    __PyInit,                                         /*tp_init */
    nullptr,                                          /*tp_alloc */
    Part::ShapeFix_FacePy::PyMake,/*tp_new */
    nullptr,                                          /*tp_free   Low-level free-memory routine */
    nullptr,                                          /*tp_is_gc  For PyObject_IS_GC */
    nullptr,                                          /*tp_bases */
    nullptr,                                          /*tp_mro    method resolution order */
    nullptr,                                          /*tp_cache */
    nullptr,                                          /*tp_subclasses */
    nullptr,                                          /*tp_weaklist */
    nullptr,                                          /*tp_del */
    0,                                                /*tp_version_tag */
    nullptr                                           /*tp_finalize */
#if PY_VERSION_HEX >= 0x03090000
    ,nullptr                                          /*tp_vectorcall */
#if PY_VERSION_HEX >= 0x030c0000
    ,0                                                /*tp_watched */
#endif
#elif PY_VERSION_HEX >= 0x03080000
    ,nullptr                                          /*tp_vectorcall */
    /* bpo-37250: kept for backwards compatibility in CPython 3.8 only */
    ,nullptr                                          /*tp_print */
#endif
};

/// Methods structure of ShapeFix_FacePy
PyMethodDef ShapeFix_FacePy::Methods[] = {
    {"init",
        reinterpret_cast<PyCFunction>( staticCallback_init ),
        METH_VARARGS,
        "Initializes by face"
    },
    {"fixWireTool",
        reinterpret_cast<PyCFunction>( staticCallback_fixWireTool ),
        METH_VARARGS,
        "Returns tool for fixing wires"
    },
    {"clearModes",
        reinterpret_cast<PyCFunction>( staticCallback_clearModes ),
        METH_VARARGS,
        "Sets all modes to default"
    },
    {"add",
        reinterpret_cast<PyCFunction>( staticCallback_add ),
        METH_VARARGS,
        "Add a wire to current face using BRep_Builder.\n"
        "Wire is added without taking into account orientation of face\n"
        "(as if face were FORWARD)"
    },
    {"fixOrientation",
        reinterpret_cast<PyCFunction>( staticCallback_fixOrientation ),
        METH_VARARGS,
        "Fixes orientation of wires on the face\n"
        "It tries to make all wires lie outside all others (according\n"
        "to orientation) by reversing orientation of some of them.\n"
        "If face lying on sphere or torus has single wire and\n"
        "AddNaturalBoundMode is True, that wire is not reversed in\n"
        "any case (supposing that natural bound will be added).\n"
        "Returns True if wires were reversed"
    },
    {"fixAddNaturalBound",
        reinterpret_cast<PyCFunction>( staticCallback_fixAddNaturalBound ),
        METH_VARARGS,
        "Adds natural boundary on face if it is missing.\n"
        "Two cases are supported:\n"
        " - face has no wires\n"
        " - face lies on geometrically double-closed surface\n"
        "(sphere or torus) and none of wires is left-oriented\n"
        "Returns True if natural boundary was added"
    },
    {"fixMissingSeam",
        reinterpret_cast<PyCFunction>( staticCallback_fixMissingSeam ),
        METH_VARARGS,
        "Detects and fixes the special case when face on a closed\n"
        "surface is given by two wires closed in 3d but with gap in 2d.\n"
        "In that case it creates a new wire from the two, and adds a\n"
        "missing seam edge\n"
        "Returns True if missing seam was added"
    },
    {"fixSmallAreaWire",
        reinterpret_cast<PyCFunction>( staticCallback_fixSmallAreaWire ),
        METH_VARARGS,
        "Detects wires with small area (that is less than\n"
        "100*Precision.PConfusion(). Removes these wires if they are internal.\n"
        "Returns True if at least one small wire removed, False nothing is done."
    },
    {"fixLoopWire",
        reinterpret_cast<PyCFunction>( staticCallback_fixLoopWire ),
        METH_VARARGS,
        "Detects if wire has a loop and fixes this situation by splitting on the few parts."
    },
    {"fixIntersectingWires",
        reinterpret_cast<PyCFunction>( staticCallback_fixIntersectingWires ),
        METH_VARARGS,
        "Detects and fixes the special case when face has more than one wire\n"
        "and this wires have intersection point"
    },
    {"fixWiresTwoCoincidentEdges",
        reinterpret_cast<PyCFunction>( staticCallback_fixWiresTwoCoincidentEdges ),
        METH_VARARGS,
        "If wire contains two coincidence edges it must be removed"
    },
    {"fixPeriodicDegenerated",
        reinterpret_cast<PyCFunction>( staticCallback_fixPeriodicDegenerated ),
        METH_VARARGS,
        "Fixes topology for a specific case when face is composed\n"
        "by a single wire belting a periodic surface. In that case\n"
        "a degenerated edge is reconstructed in the degenerated pole\n"
        "of the surface. Initial wire gets consistent orientation.\n"
        "Must be used in couple and before FixMissingSeam routine"
    },
    {"perform",
        reinterpret_cast<PyCFunction>( staticCallback_perform ),
        METH_VARARGS,
        "Iterates on subshapes and performs fixes"
    },
    {"face",
        reinterpret_cast<PyCFunction>( staticCallback_face ),
        METH_VARARGS,
        "Returns a face which corresponds to the current state"
    },
    {"result",
        reinterpret_cast<PyCFunction>( staticCallback_result ),
        METH_VARARGS,
        "Returns resulting shape (Face or Shell if split)\n"
        "To be used instead of face() if FixMissingSeam involved"
    },
    {nullptr, nullptr, 0, nullptr}		/* Sentinel */
};



/// Attribute structure of ShapeFix_FacePy
PyGetSetDef ShapeFix_FacePy::GetterSetter[] = {
    {"FixWireMode",
        (getter) staticCallback_getFixWireMode,
        (setter) staticCallback_setFixWireMode,
        "Mode for applying fixes of ShapeFix_Wire",
        nullptr
    },
    {"FixOrientationMode",
        (getter) staticCallback_getFixOrientationMode,
        (setter) staticCallback_setFixOrientationMode,
        "Mode for applying fixes of orientation\n"
        "If True, wires oriented to border limited square",
        nullptr
    },
    {"FixAddNaturalBoundMode",
        (getter) staticCallback_getFixAddNaturalBoundMode,
        (setter) staticCallback_setFixAddNaturalBoundMode,
        "If true, natural boundary is added on faces that miss them.\n"
        "Default is False for faces with single wire (they are\n"
        "handled by FixOrientation in that case) and True for others.",
        nullptr
    },
    {"FixMissingSeamMode",
        (getter) staticCallback_getFixMissingSeamMode,
        (setter) staticCallback_setFixMissingSeamMode,
        "If True, tries to insert seam if missing",
        nullptr
    },
    {"FixSmallAreaWireMode",
        (getter) staticCallback_getFixSmallAreaWireMode,
        (setter) staticCallback_setFixSmallAreaWireMode,
        "If True, drops small wires",
        nullptr
    },
    {"RemoveSmallAreaFaceMode",
        (getter) staticCallback_getRemoveSmallAreaFaceMode,
        (setter) staticCallback_setRemoveSmallAreaFaceMode,
        "If True, drops small wires",
        nullptr
    },
    {"FixIntersectingWiresMode",
        (getter) staticCallback_getFixIntersectingWiresMode,
        (setter) staticCallback_setFixIntersectingWiresMode,
        "Mode for applying fixes of intersecting wires",
        nullptr
    },
    {"FixLoopWiresMode",
        (getter) staticCallback_getFixLoopWiresMode,
        (setter) staticCallback_setFixLoopWiresMode,
        "Mode for applying fixes of loop wires",
        nullptr
    },
    {"FixSplitFaceMode",
        (getter) staticCallback_getFixSplitFaceMode,
        (setter) staticCallback_setFixSplitFaceMode,
        "Mode for applying fixes of split face",
        nullptr
    },
    {"AutoCorrectPrecisionMode",
        (getter) staticCallback_getAutoCorrectPrecisionMode,
        (setter) staticCallback_setAutoCorrectPrecisionMode,
        "Mode for applying auto-corrected precision",
        nullptr
    },
    {"FixPeriodicDegeneratedMode",
        (getter) staticCallback_getFixPeriodicDegeneratedMode,
        (setter) staticCallback_setFixPeriodicDegeneratedMode,
        "Mode for applying periodic degeneration",
        nullptr
    },
    {nullptr, nullptr, nullptr, nullptr, nullptr}		/* Sentinel */
};

// init() callback and implementer
// PyObject*  ShapeFix_FacePy::init(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_init (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'init' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->init(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixWireTool() callback and implementer
// PyObject*  ShapeFix_FacePy::fixWireTool(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_fixWireTool (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixWireTool' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->fixWireTool(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// clearModes() callback and implementer
// PyObject*  ShapeFix_FacePy::clearModes(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_clearModes (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'clearModes' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->clearModes(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// add() callback and implementer
// PyObject*  ShapeFix_FacePy::add(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_add (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'add' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->add(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixOrientation() callback and implementer
// PyObject*  ShapeFix_FacePy::fixOrientation(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_fixOrientation (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixOrientation' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->fixOrientation(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixAddNaturalBound() callback and implementer
// PyObject*  ShapeFix_FacePy::fixAddNaturalBound(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_fixAddNaturalBound (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixAddNaturalBound' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->fixAddNaturalBound(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixMissingSeam() callback and implementer
// PyObject*  ShapeFix_FacePy::fixMissingSeam(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_fixMissingSeam (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixMissingSeam' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->fixMissingSeam(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixSmallAreaWire() callback and implementer
// PyObject*  ShapeFix_FacePy::fixSmallAreaWire(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_fixSmallAreaWire (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixSmallAreaWire' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->fixSmallAreaWire(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixLoopWire() callback and implementer
// PyObject*  ShapeFix_FacePy::fixLoopWire(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_fixLoopWire (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixLoopWire' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->fixLoopWire(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixIntersectingWires() callback and implementer
// PyObject*  ShapeFix_FacePy::fixIntersectingWires(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_fixIntersectingWires (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixIntersectingWires' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->fixIntersectingWires(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixWiresTwoCoincidentEdges() callback and implementer
// PyObject*  ShapeFix_FacePy::fixWiresTwoCoincidentEdges(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_fixWiresTwoCoincidentEdges (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixWiresTwoCoincidentEdges' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->fixWiresTwoCoincidentEdges(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixPeriodicDegenerated() callback and implementer
// PyObject*  ShapeFix_FacePy::fixPeriodicDegenerated(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_fixPeriodicDegenerated (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixPeriodicDegenerated' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->fixPeriodicDegenerated(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// perform() callback and implementer
// PyObject*  ShapeFix_FacePy::perform(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_perform (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'perform' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->perform(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// face() callback and implementer
// PyObject*  ShapeFix_FacePy::face(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_face (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'face' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->face(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// result() callback and implementer
// PyObject*  ShapeFix_FacePy::result(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_result (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'result' of 'Part.ShapeFix_Face' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_FacePy*>(self)->result(args);
        if (ret != nullptr)
            static_cast<ShapeFix_FacePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// FixWireMode() callback and implementer
// PyObject*  ShapeFix_FacePy::FixWireMode(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_getFixWireMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_FacePy*>(self)->getFixWireMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixWireMode' of object 'ShapeFix_Face'");
        return nullptr;
    }
}

int ShapeFix_FacePy::staticCallback_setFixWireMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_FacePy*>(self)->setFixWireMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixWireMode' of object 'ShapeFix_Face'");
        return -1;
    }
}

// FixOrientationMode() callback and implementer
// PyObject*  ShapeFix_FacePy::FixOrientationMode(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_getFixOrientationMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_FacePy*>(self)->getFixOrientationMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixOrientationMode' of object 'ShapeFix_Face'");
        return nullptr;
    }
}

int ShapeFix_FacePy::staticCallback_setFixOrientationMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_FacePy*>(self)->setFixOrientationMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixOrientationMode' of object 'ShapeFix_Face'");
        return -1;
    }
}

// FixAddNaturalBoundMode() callback and implementer
// PyObject*  ShapeFix_FacePy::FixAddNaturalBoundMode(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_getFixAddNaturalBoundMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_FacePy*>(self)->getFixAddNaturalBoundMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixAddNaturalBoundMode' of object 'ShapeFix_Face'");
        return nullptr;
    }
}

int ShapeFix_FacePy::staticCallback_setFixAddNaturalBoundMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_FacePy*>(self)->setFixAddNaturalBoundMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixAddNaturalBoundMode' of object 'ShapeFix_Face'");
        return -1;
    }
}

// FixMissingSeamMode() callback and implementer
// PyObject*  ShapeFix_FacePy::FixMissingSeamMode(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_getFixMissingSeamMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_FacePy*>(self)->getFixMissingSeamMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixMissingSeamMode' of object 'ShapeFix_Face'");
        return nullptr;
    }
}

int ShapeFix_FacePy::staticCallback_setFixMissingSeamMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_FacePy*>(self)->setFixMissingSeamMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixMissingSeamMode' of object 'ShapeFix_Face'");
        return -1;
    }
}

// FixSmallAreaWireMode() callback and implementer
// PyObject*  ShapeFix_FacePy::FixSmallAreaWireMode(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_getFixSmallAreaWireMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_FacePy*>(self)->getFixSmallAreaWireMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixSmallAreaWireMode' of object 'ShapeFix_Face'");
        return nullptr;
    }
}

int ShapeFix_FacePy::staticCallback_setFixSmallAreaWireMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_FacePy*>(self)->setFixSmallAreaWireMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixSmallAreaWireMode' of object 'ShapeFix_Face'");
        return -1;
    }
}

// RemoveSmallAreaFaceMode() callback and implementer
// PyObject*  ShapeFix_FacePy::RemoveSmallAreaFaceMode(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_getRemoveSmallAreaFaceMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_FacePy*>(self)->getRemoveSmallAreaFaceMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'RemoveSmallAreaFaceMode' of object 'ShapeFix_Face'");
        return nullptr;
    }
}

int ShapeFix_FacePy::staticCallback_setRemoveSmallAreaFaceMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_FacePy*>(self)->setRemoveSmallAreaFaceMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'RemoveSmallAreaFaceMode' of object 'ShapeFix_Face'");
        return -1;
    }
}

// FixIntersectingWiresMode() callback and implementer
// PyObject*  ShapeFix_FacePy::FixIntersectingWiresMode(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_getFixIntersectingWiresMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_FacePy*>(self)->getFixIntersectingWiresMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixIntersectingWiresMode' of object 'ShapeFix_Face'");
        return nullptr;
    }
}

int ShapeFix_FacePy::staticCallback_setFixIntersectingWiresMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_FacePy*>(self)->setFixIntersectingWiresMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixIntersectingWiresMode' of object 'ShapeFix_Face'");
        return -1;
    }
}

// FixLoopWiresMode() callback and implementer
// PyObject*  ShapeFix_FacePy::FixLoopWiresMode(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_getFixLoopWiresMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_FacePy*>(self)->getFixLoopWiresMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixLoopWiresMode' of object 'ShapeFix_Face'");
        return nullptr;
    }
}

int ShapeFix_FacePy::staticCallback_setFixLoopWiresMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_FacePy*>(self)->setFixLoopWiresMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixLoopWiresMode' of object 'ShapeFix_Face'");
        return -1;
    }
}

// FixSplitFaceMode() callback and implementer
// PyObject*  ShapeFix_FacePy::FixSplitFaceMode(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_getFixSplitFaceMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_FacePy*>(self)->getFixSplitFaceMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixSplitFaceMode' of object 'ShapeFix_Face'");
        return nullptr;
    }
}

int ShapeFix_FacePy::staticCallback_setFixSplitFaceMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_FacePy*>(self)->setFixSplitFaceMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixSplitFaceMode' of object 'ShapeFix_Face'");
        return -1;
    }
}

// AutoCorrectPrecisionMode() callback and implementer
// PyObject*  ShapeFix_FacePy::AutoCorrectPrecisionMode(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_getAutoCorrectPrecisionMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_FacePy*>(self)->getAutoCorrectPrecisionMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'AutoCorrectPrecisionMode' of object 'ShapeFix_Face'");
        return nullptr;
    }
}

int ShapeFix_FacePy::staticCallback_setAutoCorrectPrecisionMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_FacePy*>(self)->setAutoCorrectPrecisionMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'AutoCorrectPrecisionMode' of object 'ShapeFix_Face'");
        return -1;
    }
}

// FixPeriodicDegeneratedMode() callback and implementer
// PyObject*  ShapeFix_FacePy::FixPeriodicDegeneratedMode(PyObject *args){};
// has to be implemented in ShapeFix_FacePyImp.cpp
PyObject * ShapeFix_FacePy::staticCallback_getFixPeriodicDegeneratedMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_FacePy*>(self)->getFixPeriodicDegeneratedMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixPeriodicDegeneratedMode' of object 'ShapeFix_Face'");
        return nullptr;
    }
}

int ShapeFix_FacePy::staticCallback_setFixPeriodicDegeneratedMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_FacePy*>(self)->setFixPeriodicDegeneratedMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixPeriodicDegeneratedMode' of object 'ShapeFix_Face'");
        return -1;
    }
}




//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
ShapeFix_FacePy::ShapeFix_FacePy(ShapeFix_Face *pcObject, PyTypeObject *T)
    : ShapeFix_RootPy(static_cast<ShapeFix_RootPy::PointerType>(pcObject), T)
{
}


//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
ShapeFix_FacePy::~ShapeFix_FacePy()                                // Everything handled in parent
{
}

//--------------------------------------------------------------------------
// ShapeFix_FacePy representation
//--------------------------------------------------------------------------
PyObject *ShapeFix_FacePy::_repr()
{
    return Py_BuildValue("s", representation().c_str());
}

//--------------------------------------------------------------------------
// ShapeFix_FacePy Attributes
//--------------------------------------------------------------------------
PyObject *ShapeFix_FacePy::_getattr(const char *attr)			// __getattr__ function: note only need to handle new state
{
    try {
        // getter method for special Attributes (e.g. dynamic ones)
        PyObject *r = getCustomAttributes(attr);
        if(r) return r;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError,"Unknown C++ exception");
        return nullptr;
    }
#endif

    PyMethodDef *ml = Methods;
    for (; ml->ml_name != nullptr; ml++) {
        if (attr[0] == ml->ml_name[0] &&
            strcmp(attr+1, ml->ml_name+1) == 0)
            return PyCFunction_New(ml, this);
    }

    PyErr_Clear();
    return ShapeFix_RootPy::_getattr(attr);
}

int ShapeFix_FacePy::_setattr(const char *attr, PyObject *value) // __setattr__ function: note only need to handle new state
{
    try {
        // setter for special Attributes (e.g. dynamic ones)
        int r = setCustomAttributes(attr, value);
        // r = 1: handled
        // r = -1: error
        // r = 0: ignore
        if (r == 1)
            return 0;
        else if (r == -1)
            return -1;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return -1;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return -1;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return -1;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return -1;
    }
#endif

    return ShapeFix_RootPy::_setattr(attr, value);
}

ShapeFix_Face *ShapeFix_FacePy::getShapeFix_FacePtr() const
{
    return static_cast<ShapeFix_Face *>(_pcTwinPointer);
}

#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#if 0
/* From here on come the methods you have to implement, but NOT in this module. Implement in ShapeFix_FacePyImp.cpp! This prototypes
 * are just for convenience when you add a new method.
 */

PyObject *ShapeFix_FacePy::PyMake(PyTypeObject* /*type*/, PyObject* /*args*/, PyObject* /*kwds*/)
{
    // create a new instance of ShapeFix_FacePy and the Twin object
    return new ShapeFix_FacePy(new ShapeFix_Face);
}

// constructor method
int ShapeFix_FacePy::PyInit(PyObject* /*args*/, PyObject* /*kwd*/)
{
    return 0;
}


// returns a string which represents the object e.g. when printed in python
std::string ShapeFix_FacePy::representation() const
{
    return {"<ShapeFix_Face object>"};
}

PyObject* ShapeFix_FacePy::init(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::fixWireTool(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::clearModes(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::add(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::fixOrientation(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::fixAddNaturalBound(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::fixMissingSeam(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::fixSmallAreaWire(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::fixLoopWire(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::fixIntersectingWires(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::fixWiresTwoCoincidentEdges(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::fixPeriodicDegenerated(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::perform(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::face(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_FacePy::result(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}



Py::Boolean ShapeFix_FacePy::getFixWireMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_FacePy::setFixWireMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_FacePy::getFixOrientationMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_FacePy::setFixOrientationMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_FacePy::getFixAddNaturalBoundMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_FacePy::setFixAddNaturalBoundMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_FacePy::getFixMissingSeamMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_FacePy::setFixMissingSeamMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_FacePy::getFixSmallAreaWireMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_FacePy::setFixSmallAreaWireMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_FacePy::getRemoveSmallAreaFaceMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_FacePy::setRemoveSmallAreaFaceMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_FacePy::getFixIntersectingWiresMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_FacePy::setFixIntersectingWiresMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_FacePy::getFixLoopWiresMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_FacePy::setFixLoopWiresMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_FacePy::getFixSplitFaceMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_FacePy::setFixSplitFaceMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_FacePy::getAutoCorrectPrecisionMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_FacePy::setAutoCorrectPrecisionMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_FacePy::getFixPeriodicDegeneratedMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_FacePy::setFixPeriodicDegeneratedMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

PyObject *ShapeFix_FacePy::getCustomAttributes(const char* /*attr*/) const
{
    return nullptr;
}

int ShapeFix_FacePy::setCustomAttributes(const char* /*attr*/, PyObject* /*obj*/)
{
    return 0;
}


#endif



