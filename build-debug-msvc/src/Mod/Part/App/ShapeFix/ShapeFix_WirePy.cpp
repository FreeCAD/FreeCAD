
// This file is generated by src/Tools/generateTemplates/templateClassPyExport.py out of the .XML file
// Every change you make here gets lost in the next full rebuild!
// This File is normally built as an include in ShapeFix_WirePyImp.cpp! It's not intended to be in a project!

#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/exception.hpp>
#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <CXX/Objects.hxx>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

using Base::streq;
using namespace Part;

/// Type structure of ShapeFix_WirePy
PyTypeObject ShapeFix_WirePy::Type = {
    PyVarObject_HEAD_INIT(&PyType_Type,0)
    "Part.ShapeFix.Wire",     /*tp_name*/
    sizeof(ShapeFix_WirePy),                       /*tp_basicsize*/
    0,                                                /*tp_itemsize*/
    /* methods */
    PyDestructor,                                     /*tp_dealloc*/
#if PY_VERSION_HEX >= 0x03080000
    0,                                                /*tp_vectorcall_offset*/
#else
    nullptr,                                          /*tp_print*/
#endif
    nullptr,                                          /*tp_getattr*/
    nullptr,                                          /*tp_setattr*/
    nullptr,                                          /*tp_compare*/
    __repr,                                           /*tp_repr*/
    nullptr,                                          /*tp_as_number*/
    nullptr,                                          /*tp_as_sequence*/
    nullptr,                                          /*tp_as_mapping*/
    nullptr,                                          /*tp_hash*/
    nullptr,                                          /*tp_call */
    nullptr,                                          /*tp_str  */
    __getattro,                                       /*tp_getattro*/
    __setattro,                                       /*tp_setattro*/
    /* --- Functions to access object as input/output buffer ---------*/
    nullptr,                                          /* tp_as_buffer */
    /* --- Flags to define presence of optional/expanded features */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT,        /*tp_flags */
    "Class for fixing operations on wires",           /*tp_doc */
    nullptr,                                          /*tp_traverse */
    nullptr,                                          /*tp_clear */
    nullptr,                                          /*tp_richcompare */
    0,                                                /*tp_weaklistoffset */
    nullptr,                                          /*tp_iter */
    nullptr,                                          /*tp_iternext */
    Part::ShapeFix_WirePy::Methods,                     /*tp_methods */
    nullptr,                                          /*tp_members */
    Part::ShapeFix_WirePy::GetterSetter,                     /*tp_getset */
    &Part::ShapeFix_RootPy::Type,                        /*tp_base */
    nullptr,                                          /*tp_dict */
    nullptr,                                          /*tp_descr_get */
    nullptr,                                          /*tp_descr_set */
    0,                                                /*tp_dictoffset */
    __PyInit,                                         /*tp_init */
    nullptr,                                          /*tp_alloc */
    Part::ShapeFix_WirePy::PyMake,/*tp_new */
    nullptr,                                          /*tp_free   Low-level free-memory routine */
    nullptr,                                          /*tp_is_gc  For PyObject_IS_GC */
    nullptr,                                          /*tp_bases */
    nullptr,                                          /*tp_mro    method resolution order */
    nullptr,                                          /*tp_cache */
    nullptr,                                          /*tp_subclasses */
    nullptr,                                          /*tp_weaklist */
    nullptr,                                          /*tp_del */
    0,                                                /*tp_version_tag */
    nullptr                                           /*tp_finalize */
#if PY_VERSION_HEX >= 0x03090000
    ,nullptr                                          /*tp_vectorcall */
#if PY_VERSION_HEX >= 0x030c0000
    ,0                                                /*tp_watched */
#endif
#elif PY_VERSION_HEX >= 0x03080000
    ,nullptr                                          /*tp_vectorcall */
    /* bpo-37250: kept for backwards compatibility in CPython 3.8 only */
    ,nullptr                                          /*tp_print */
#endif
};

/// Methods structure of ShapeFix_WirePy
PyMethodDef ShapeFix_WirePy::Methods[] = {
    {"init",
        reinterpret_cast<PyCFunction>( staticCallback_init ),
        METH_VARARGS,
        "Initializes by wire, face, precision"
    },
    {"fixEdgeTool",
        reinterpret_cast<PyCFunction>( staticCallback_fixEdgeTool ),
        METH_VARARGS,
        "Returns tool for fixing wires"
    },
    {"clearModes",
        reinterpret_cast<PyCFunction>( staticCallback_clearModes ),
        METH_VARARGS,
        "Sets all modes to default"
    },
    {"clearStatuses",
        reinterpret_cast<PyCFunction>( staticCallback_clearStatuses ),
        METH_VARARGS,
        "Clears all statuses"
    },
    {"load",
        reinterpret_cast<PyCFunction>( staticCallback_load ),
        METH_VARARGS,
        "Load data for the wire, and drops all fixing statuses"
    },
    {"setFace",
        reinterpret_cast<PyCFunction>( staticCallback_setFace ),
        METH_VARARGS,
        "Set working face for the wire"
    },
    {"setSurface",
        reinterpret_cast<PyCFunction>( staticCallback_setSurface ),
        METH_VARARGS,
        "setSurface(surface, [Placement])\n"
        "Set surface for the wire"
    },
    {"setMaxTailAngle",
        reinterpret_cast<PyCFunction>( staticCallback_setMaxTailAngle ),
        METH_VARARGS,
        "Sets the maximal allowed angle of the tails in radians"
    },
    {"setMaxTailWidth",
        reinterpret_cast<PyCFunction>( staticCallback_setMaxTailWidth ),
        METH_VARARGS,
        "Sets the maximal allowed width of the tails"
    },
    {"isLoaded",
        reinterpret_cast<PyCFunction>( staticCallback_isLoaded ),
        METH_VARARGS,
        "Tells if the wire is loaded"
    },
    {"isReady",
        reinterpret_cast<PyCFunction>( staticCallback_isReady ),
        METH_VARARGS,
        "Tells if the wire and face are loaded"
    },
    {"numberOfEdges",
        reinterpret_cast<PyCFunction>( staticCallback_numberOfEdges ),
        METH_VARARGS,
        "Returns number of edges in the working wire"
    },
    {"wire",
        reinterpret_cast<PyCFunction>( staticCallback_wire ),
        METH_VARARGS,
        "Makes the resulting Wire (by basic Brep_Builder)"
    },
    {"wireAPIMake",
        reinterpret_cast<PyCFunction>( staticCallback_wireAPIMake ),
        METH_VARARGS,
        "Makes the resulting Wire (by BRepAPI_MakeWire)"
    },
    {"face",
        reinterpret_cast<PyCFunction>( staticCallback_face ),
        METH_VARARGS,
        "Returns working face"
    },
    {"perform",
        reinterpret_cast<PyCFunction>( staticCallback_perform ),
        METH_VARARGS,
        "Iterates on subshapes and performs fixes"
    },
    {"fixReorder",
        reinterpret_cast<PyCFunction>( staticCallback_fixReorder ),
        METH_VARARGS,
        "Performs an analysis and reorders edges in the wire"
    },
    {"fixSmall",
        reinterpret_cast<PyCFunction>( staticCallback_fixSmall ),
        METH_VARARGS,
        "Applies fixSmall(...) to all edges in the wire"
    },
    {"fixConnected",
        reinterpret_cast<PyCFunction>( staticCallback_fixConnected ),
        METH_VARARGS,
        "Applies fixConnected(num) to all edges in the wire\n"
        "Connection between first and last edges is treated only if\n"
        "flag ClosedMode is True\n"
        "If prec is -1 then maxTolerance() is taken."
    },
    {"fixEdgeCurves",
        reinterpret_cast<PyCFunction>( staticCallback_fixEdgeCurves ),
        METH_VARARGS,
        "Groups the fixes dealing with 3d and pcurves of the edges"
    },
    {"fixDegenerated",
        reinterpret_cast<PyCFunction>( staticCallback_fixDegenerated ),
        METH_VARARGS,
        "Applies fixDegenerated(...) to all edges in the wire"
    },
    {"fixSelfIntersection",
        reinterpret_cast<PyCFunction>( staticCallback_fixSelfIntersection ),
        METH_VARARGS,
        "Applies FixSelfIntersectingEdge(num) and\n"
        " FixIntersectingEdges(num) to all edges in the wire and\n"
        " FixIntersectingEdges(num1, num2) for all pairs num1 and num2\n"
        " and removes wrong edges if any"
    },
    {"fixLacking",
        reinterpret_cast<PyCFunction>( staticCallback_fixLacking ),
        METH_VARARGS,
        "Applies FixLacking(num) to all edges in the wire\n"
        "  Connection between first and last edges is treated only if\n"
        "  flag ClosedMode is True\n"
        "  If 'force' is False (default), test for connectness is done with\n"
        "  precision of vertex between edges, else it is done with minimal\n"
        "  value of vertex tolerance and Analyzer.Precision().\n"
        "  Hence, 'force' will lead to inserting lacking edges in replacement\n"
        "  of vertices which have big tolerances."
    },
    {"fixClosed",
        reinterpret_cast<PyCFunction>( staticCallback_fixClosed ),
        METH_VARARGS,
        "Fixes a wire to be well closed"
    },
    {"fixGaps3d",
        reinterpret_cast<PyCFunction>( staticCallback_fixGaps3d ),
        METH_VARARGS,
        "Fixes gaps between ends of 3d curves on adjacent edges"
    },
    {"fixGaps2d",
        reinterpret_cast<PyCFunction>( staticCallback_fixGaps2d ),
        METH_VARARGS,
        "Fixes gaps between ends of pcurves on adjacent edges"
    },
    {"fixSeam",
        reinterpret_cast<PyCFunction>( staticCallback_fixSeam ),
        METH_VARARGS,
        "Fixes seam edges"
    },
    {"fixShifted",
        reinterpret_cast<PyCFunction>( staticCallback_fixShifted ),
        METH_VARARGS,
        "Fixes edges which have pcurves shifted by whole parameter\n"
        "range on the closed surface"
    },
    {"fixNotchedEdges",
        reinterpret_cast<PyCFunction>( staticCallback_fixNotchedEdges ),
        METH_VARARGS,
        "Fixes Notch edges.Check if there are notch edges in 2d and fix it"
    },
    {"fixGap3d",
        reinterpret_cast<PyCFunction>( staticCallback_fixGap3d ),
        METH_VARARGS,
        "Fixes gap between ends of 3d curves on num-1 and num-th edges"
    },
    {"fixGap2d",
        reinterpret_cast<PyCFunction>( staticCallback_fixGap2d ),
        METH_VARARGS,
        "Fixes gap between ends of pcurves on num-1 and num-th edges"
    },
    {"fixTails",
        reinterpret_cast<PyCFunction>( staticCallback_fixTails ),
        METH_VARARGS,
        "Fixes issues related to 'tails' in the geometry.\n"
        "      Tails are typically small, undesired protrusions or deviations in the curves or edges that need correction.\n"
        "      This method examines the geometry and applies corrective actions to eliminate or reduce the presence of tails."
    },
    {nullptr, nullptr, 0, nullptr}		/* Sentinel */
};



/// Attribute structure of ShapeFix_WirePy
PyGetSetDef ShapeFix_WirePy::GetterSetter[] = {
    {"ModifyTopologyMode",
        (getter) staticCallback_getModifyTopologyMode,
        (setter) staticCallback_setModifyTopologyMode,
        "Mode for modifying topology of the wire",
        nullptr
    },
    {"ModifyGeometryMode",
        (getter) staticCallback_getModifyGeometryMode,
        (setter) staticCallback_setModifyGeometryMode,
        "Mode for modifying geometry of vertexes and edges",
        nullptr
    },
    {"ModifyRemoveLoopMode",
        (getter) staticCallback_getModifyRemoveLoopMode,
        (setter) staticCallback_setModifyRemoveLoopMode,
        "Mode for modifying edges",
        nullptr
    },
    {"ClosedWireMode",
        (getter) staticCallback_getClosedWireMode,
        (setter) staticCallback_setClosedWireMode,
        "Mode which defines whether the wire\n"
        "is to be closed (by calling methods like fixDegenerated()\n"
        "and fixConnected() for last and first edges)",
        nullptr
    },
    {"PreferencePCurveMode",
        (getter) staticCallback_getPreferencePCurveMode,
        (setter) staticCallback_setPreferencePCurveMode,
        "Mode which defines whether the 2d 'True'\n"
        "representation of the wire is preferable over 3d one in the\n"
        "case of ambiguity in FixEdgeCurves",
        nullptr
    },
    {"FixGapsByRangesMode",
        (getter) staticCallback_getFixGapsByRangesMode,
        (setter) staticCallback_setFixGapsByRangesMode,
        "Mode which defines whether tool\n"
        "tries to fix gaps first by changing curves ranges (i.e.\n"
        "using intersection, extrema, projections) or not",
        nullptr
    },
    {"FixReorderMode",
        (getter) staticCallback_getFixReorderMode,
        (setter) staticCallback_setFixReorderMode,
        "Mode which performs an analysis and reorders edges in the wire using class WireOrder.\n"
        "Flag 'theModeBoth' determines the use of miscible mode if necessary.",
        nullptr
    },
    {"FixSmallMode",
        (getter) staticCallback_getFixSmallMode,
        (setter) staticCallback_setFixSmallMode,
        "Mode which applies FixSmall(num) to all edges in the wire",
        nullptr
    },
    {"FixConnectedMode",
        (getter) staticCallback_getFixConnectedMode,
        (setter) staticCallback_setFixConnectedMode,
        "Mode which applies FixConnected(num) to all edges in the wire\n"
        " Connection between first and last edges is treated only if\n"
        " flag ClosedMode is True\n"
        " If 'prec' is -1 then MaxTolerance() is taken.",
        nullptr
    },
    {"FixEdgeCurvesMode",
        (getter) staticCallback_getFixEdgeCurvesMode,
        (setter) staticCallback_setFixEdgeCurvesMode,
        "Mode which groups the fixes dealing with 3d and pcurves of the edges.\n"
        "  The order of the fixes and the default behaviour are:\n"
        "  ShapeFix_Edge::FixReversed2d\n"
        "  ShapeFix_Edge::FixRemovePCurve (only if forced)\n"
        "  ShapeFix_Edge::FixAddPCurve\n"
        "  ShapeFix_Edge::FixRemoveCurve3d (only if forced)\n"
        "  ShapeFix_Edge::FixAddCurve3d\n"
        "  FixSeam,\n"
        "  FixShifted,\n"
        "  ShapeFix_Edge::FixSameParameter",
        nullptr
    },
    {"FixDegeneratedMode",
        (getter) staticCallback_getFixDegeneratedMode,
        (setter) staticCallback_setFixDegeneratedMode,
        "Mode which applies FixDegenerated(num) to all edges in the wire\n"
        "  Connection between first and last edges is treated only if\n"
        "  flag ClosedMode is True",
        nullptr
    },
    {"FixSelfIntersectionMode",
        (getter) staticCallback_getFixSelfIntersectionMode,
        (setter) staticCallback_setFixSelfIntersectionMode,
        "Mode which applies FixSelfIntersectingEdge(num) and\n"
        "  FixIntersectingEdges(num) to all edges in the wire and\n"
        "  FixIntersectingEdges(num1, num2) for all pairs num1 and num2\n"
        "  and removes wrong edges if any",
        nullptr
    },
    {"FixLackingMode",
        (getter) staticCallback_getFixLackingMode,
        (setter) staticCallback_setFixLackingMode,
        "Mode which applies FixLacking(num) to all edges in the wire\n"
        "  Connection between first and last edges is treated only if\n"
        "  flag ClosedMode is True\n"
        "  If 'force' is False (default), test for connectness is done with\n"
        "  precision of vertex between edges, else it is done with minimal\n"
        "  value of vertex tolerance and Analyzer.Precision().\n"
        "  Hence, 'force' will lead to inserting lacking edges in replacement\n"
        "  of vertices which have big tolerances.",
        nullptr
    },
    {"FixGaps3dMode",
        (getter) staticCallback_getFixGaps3dMode,
        (setter) staticCallback_setFixGaps3dMode,
        "Mode which fixes gaps between ends of 3d curves on adjacent edges\n"
        "  myPrecision is used to detect the gaps.",
        nullptr
    },
    {"FixGaps2dMode",
        (getter) staticCallback_getFixGaps2dMode,
        (setter) staticCallback_setFixGaps2dMode,
        "Mode whixh fixes gaps between ends of pcurves on adjacent edges\n"
        "  myPrecision is used to detect the gaps.",
        nullptr
    },
    {"FixReversed2dMode",
        (getter) staticCallback_getFixReversed2dMode,
        (setter) staticCallback_setFixReversed2dMode,
        "Mode which fixes the reversed in 2d",
        nullptr
    },
    {"FixRemovePCurveMode",
        (getter) staticCallback_getFixRemovePCurveMode,
        (setter) staticCallback_setFixRemovePCurveMode,
        "Mode which removePCurve in 2d",
        nullptr
    },
    {"FixAddPCurveMode",
        (getter) staticCallback_getFixAddPCurveMode,
        (setter) staticCallback_setFixAddPCurveMode,
        "Mode which fixes addCurve in 2d",
        nullptr
    },
    {"FixRemoveCurve3dMode",
        (getter) staticCallback_getFixRemoveCurve3dMode,
        (setter) staticCallback_setFixRemoveCurve3dMode,
        "Mode which fixes removeCurve in 3d",
        nullptr
    },
    {"FixAddCurve3dMode",
        (getter) staticCallback_getFixAddCurve3dMode,
        (setter) staticCallback_setFixAddCurve3dMode,
        "Mode which fixes addCurve in 3d",
        nullptr
    },
    {"FixSeamMode",
        (getter) staticCallback_getFixSeamMode,
        (setter) staticCallback_setFixSeamMode,
        "Mode which fixes Seam",
        nullptr
    },
    {"FixShiftedMode",
        (getter) staticCallback_getFixShiftedMode,
        (setter) staticCallback_setFixShiftedMode,
        "Mode which fixes Shifted",
        nullptr
    },
    {"FixSameParameterMode",
        (getter) staticCallback_getFixSameParameterMode,
        (setter) staticCallback_setFixSameParameterMode,
        "Mode which fixes sameParameter in 2d",
        nullptr
    },
    {"FixVertexToleranceMode",
        (getter) staticCallback_getFixVertexToleranceMode,
        (setter) staticCallback_setFixVertexToleranceMode,
        "Mode which fixes VertexTolerence in 2d",
        nullptr
    },
    {"FixNotchedEdgesMode",
        (getter) staticCallback_getFixNotchedEdgesMode,
        (setter) staticCallback_setFixNotchedEdgesMode,
        "Mode which fixes NotchedEdges in 2d",
        nullptr
    },
    {"FixSelfIntersectingEdgeMode",
        (getter) staticCallback_getFixSelfIntersectingEdgeMode,
        (setter) staticCallback_setFixSelfIntersectingEdgeMode,
        "Mode which fixes SelfIntersectionEdge in 2d",
        nullptr
    },
    {"FixIntersectingEdgesMode",
        (getter) staticCallback_getFixIntersectingEdgesMode,
        (setter) staticCallback_setFixIntersectingEdgesMode,
        "Mode which fixes IntersectingEdges in 2d",
        nullptr
    },
    {"FixNonAdjacentIntersectingEdgesMode",
        (getter) staticCallback_getFixNonAdjacentIntersectingEdgesMode,
        (setter) staticCallback_setFixNonAdjacentIntersectingEdgesMode,
        "Mode which fixes NonAdjacentIntersectingEdges in 2d",
        nullptr
    },
    {"FixTailMode",
        (getter) staticCallback_getFixTailMode,
        (setter) staticCallback_setFixTailMode,
        "Mode which fixes Tails in 2d",
        nullptr
    },
    {nullptr, nullptr, nullptr, nullptr, nullptr}		/* Sentinel */
};

// init() callback and implementer
// PyObject*  ShapeFix_WirePy::init(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_init (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'init' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->init(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixEdgeTool() callback and implementer
// PyObject*  ShapeFix_WirePy::fixEdgeTool(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixEdgeTool (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixEdgeTool' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixEdgeTool(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// clearModes() callback and implementer
// PyObject*  ShapeFix_WirePy::clearModes(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_clearModes (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'clearModes' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->clearModes(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// clearStatuses() callback and implementer
// PyObject*  ShapeFix_WirePy::clearStatuses(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_clearStatuses (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'clearStatuses' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->clearStatuses(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// load() callback and implementer
// PyObject*  ShapeFix_WirePy::load(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_load (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'load' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->load(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setFace() callback and implementer
// PyObject*  ShapeFix_WirePy::setFace(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_setFace (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setFace' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->setFace(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setSurface() callback and implementer
// PyObject*  ShapeFix_WirePy::setSurface(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_setSurface (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setSurface' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->setSurface(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setMaxTailAngle() callback and implementer
// PyObject*  ShapeFix_WirePy::setMaxTailAngle(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_setMaxTailAngle (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setMaxTailAngle' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->setMaxTailAngle(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setMaxTailWidth() callback and implementer
// PyObject*  ShapeFix_WirePy::setMaxTailWidth(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_setMaxTailWidth (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setMaxTailWidth' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->setMaxTailWidth(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// isLoaded() callback and implementer
// PyObject*  ShapeFix_WirePy::isLoaded(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_isLoaded (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'isLoaded' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->isLoaded(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// isReady() callback and implementer
// PyObject*  ShapeFix_WirePy::isReady(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_isReady (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'isReady' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->isReady(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// numberOfEdges() callback and implementer
// PyObject*  ShapeFix_WirePy::numberOfEdges(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_numberOfEdges (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'numberOfEdges' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->numberOfEdges(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// wire() callback and implementer
// PyObject*  ShapeFix_WirePy::wire(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_wire (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'wire' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->wire(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// wireAPIMake() callback and implementer
// PyObject*  ShapeFix_WirePy::wireAPIMake(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_wireAPIMake (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'wireAPIMake' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->wireAPIMake(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// face() callback and implementer
// PyObject*  ShapeFix_WirePy::face(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_face (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'face' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->face(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// perform() callback and implementer
// PyObject*  ShapeFix_WirePy::perform(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_perform (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'perform' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->perform(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixReorder() callback and implementer
// PyObject*  ShapeFix_WirePy::fixReorder(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixReorder (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixReorder' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixReorder(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixSmall() callback and implementer
// PyObject*  ShapeFix_WirePy::fixSmall(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixSmall (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixSmall' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixSmall(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixConnected() callback and implementer
// PyObject*  ShapeFix_WirePy::fixConnected(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixConnected (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixConnected' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixConnected(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixEdgeCurves() callback and implementer
// PyObject*  ShapeFix_WirePy::fixEdgeCurves(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixEdgeCurves (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixEdgeCurves' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixEdgeCurves(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixDegenerated() callback and implementer
// PyObject*  ShapeFix_WirePy::fixDegenerated(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixDegenerated (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixDegenerated' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixDegenerated(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixSelfIntersection() callback and implementer
// PyObject*  ShapeFix_WirePy::fixSelfIntersection(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixSelfIntersection (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixSelfIntersection' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixSelfIntersection(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixLacking() callback and implementer
// PyObject*  ShapeFix_WirePy::fixLacking(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixLacking (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixLacking' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixLacking(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixClosed() callback and implementer
// PyObject*  ShapeFix_WirePy::fixClosed(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixClosed (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixClosed' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixClosed(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixGaps3d() callback and implementer
// PyObject*  ShapeFix_WirePy::fixGaps3d(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixGaps3d (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixGaps3d' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixGaps3d(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixGaps2d() callback and implementer
// PyObject*  ShapeFix_WirePy::fixGaps2d(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixGaps2d (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixGaps2d' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixGaps2d(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixSeam() callback and implementer
// PyObject*  ShapeFix_WirePy::fixSeam(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixSeam (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixSeam' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixSeam(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixShifted() callback and implementer
// PyObject*  ShapeFix_WirePy::fixShifted(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixShifted (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixShifted' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixShifted(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixNotchedEdges() callback and implementer
// PyObject*  ShapeFix_WirePy::fixNotchedEdges(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixNotchedEdges (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixNotchedEdges' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixNotchedEdges(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixGap3d() callback and implementer
// PyObject*  ShapeFix_WirePy::fixGap3d(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixGap3d (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixGap3d' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixGap3d(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixGap2d() callback and implementer
// PyObject*  ShapeFix_WirePy::fixGap2d(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixGap2d (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixGap2d' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixGap2d(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// fixTails() callback and implementer
// PyObject*  ShapeFix_WirePy::fixTails(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_fixTails (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'fixTails' of 'Part.ShapeFix_Wire' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<ShapeFix_WirePy*>(self)->fixTails(args);
        if (ret != nullptr)
            static_cast<ShapeFix_WirePy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// ModifyTopologyMode() callback and implementer
// PyObject*  ShapeFix_WirePy::ModifyTopologyMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getModifyTopologyMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getModifyTopologyMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'ModifyTopologyMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setModifyTopologyMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setModifyTopologyMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'ModifyTopologyMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// ModifyGeometryMode() callback and implementer
// PyObject*  ShapeFix_WirePy::ModifyGeometryMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getModifyGeometryMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getModifyGeometryMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'ModifyGeometryMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setModifyGeometryMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setModifyGeometryMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'ModifyGeometryMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// ModifyRemoveLoopMode() callback and implementer
// PyObject*  ShapeFix_WirePy::ModifyRemoveLoopMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getModifyRemoveLoopMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getModifyRemoveLoopMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'ModifyRemoveLoopMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setModifyRemoveLoopMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setModifyRemoveLoopMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'ModifyRemoveLoopMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// ClosedWireMode() callback and implementer
// PyObject*  ShapeFix_WirePy::ClosedWireMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getClosedWireMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getClosedWireMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'ClosedWireMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setClosedWireMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setClosedWireMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'ClosedWireMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// PreferencePCurveMode() callback and implementer
// PyObject*  ShapeFix_WirePy::PreferencePCurveMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getPreferencePCurveMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getPreferencePCurveMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'PreferencePCurveMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setPreferencePCurveMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setPreferencePCurveMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'PreferencePCurveMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixGapsByRangesMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixGapsByRangesMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixGapsByRangesMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixGapsByRangesMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixGapsByRangesMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixGapsByRangesMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixGapsByRangesMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixGapsByRangesMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixReorderMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixReorderMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixReorderMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixReorderMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixReorderMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixReorderMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixReorderMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixReorderMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixSmallMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixSmallMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixSmallMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixSmallMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixSmallMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixSmallMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixSmallMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixSmallMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixConnectedMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixConnectedMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixConnectedMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixConnectedMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixConnectedMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixConnectedMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixConnectedMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixConnectedMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixEdgeCurvesMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixEdgeCurvesMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixEdgeCurvesMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixEdgeCurvesMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixEdgeCurvesMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixEdgeCurvesMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixEdgeCurvesMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixEdgeCurvesMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixDegeneratedMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixDegeneratedMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixDegeneratedMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixDegeneratedMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixDegeneratedMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixDegeneratedMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixDegeneratedMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixDegeneratedMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixSelfIntersectionMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixSelfIntersectionMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixSelfIntersectionMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixSelfIntersectionMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixSelfIntersectionMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixSelfIntersectionMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixSelfIntersectionMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixSelfIntersectionMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixLackingMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixLackingMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixLackingMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixLackingMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixLackingMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixLackingMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixLackingMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixLackingMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixGaps3dMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixGaps3dMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixGaps3dMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixGaps3dMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixGaps3dMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixGaps3dMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixGaps3dMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixGaps3dMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixGaps2dMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixGaps2dMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixGaps2dMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixGaps2dMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixGaps2dMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixGaps2dMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixGaps2dMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixGaps2dMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixReversed2dMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixReversed2dMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixReversed2dMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixReversed2dMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixReversed2dMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixReversed2dMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixReversed2dMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixReversed2dMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixRemovePCurveMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixRemovePCurveMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixRemovePCurveMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixRemovePCurveMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixRemovePCurveMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixRemovePCurveMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixRemovePCurveMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixRemovePCurveMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixAddPCurveMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixAddPCurveMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixAddPCurveMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixAddPCurveMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixAddPCurveMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixAddPCurveMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixAddPCurveMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixAddPCurveMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixRemoveCurve3dMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixRemoveCurve3dMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixRemoveCurve3dMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixRemoveCurve3dMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixRemoveCurve3dMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixRemoveCurve3dMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixRemoveCurve3dMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixRemoveCurve3dMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixAddCurve3dMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixAddCurve3dMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixAddCurve3dMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixAddCurve3dMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixAddCurve3dMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixAddCurve3dMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixAddCurve3dMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixAddCurve3dMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixSeamMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixSeamMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixSeamMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixSeamMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixSeamMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixSeamMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixSeamMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixSeamMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixShiftedMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixShiftedMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixShiftedMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixShiftedMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixShiftedMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixShiftedMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixShiftedMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixShiftedMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixSameParameterMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixSameParameterMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixSameParameterMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixSameParameterMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixSameParameterMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixSameParameterMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixSameParameterMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixSameParameterMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixVertexToleranceMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixVertexToleranceMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixVertexToleranceMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixVertexToleranceMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixVertexToleranceMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixVertexToleranceMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixVertexToleranceMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixVertexToleranceMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixNotchedEdgesMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixNotchedEdgesMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixNotchedEdgesMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixNotchedEdgesMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixNotchedEdgesMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixNotchedEdgesMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixNotchedEdgesMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixNotchedEdgesMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixSelfIntersectingEdgeMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixSelfIntersectingEdgeMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixSelfIntersectingEdgeMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixSelfIntersectingEdgeMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixSelfIntersectingEdgeMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixSelfIntersectingEdgeMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixSelfIntersectingEdgeMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixSelfIntersectingEdgeMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixIntersectingEdgesMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixIntersectingEdgesMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixIntersectingEdgesMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixIntersectingEdgesMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixIntersectingEdgesMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixIntersectingEdgesMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixIntersectingEdgesMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixIntersectingEdgesMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixNonAdjacentIntersectingEdgesMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixNonAdjacentIntersectingEdgesMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixNonAdjacentIntersectingEdgesMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixNonAdjacentIntersectingEdgesMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixNonAdjacentIntersectingEdgesMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixNonAdjacentIntersectingEdgesMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixNonAdjacentIntersectingEdgesMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixNonAdjacentIntersectingEdgesMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}

// FixTailMode() callback and implementer
// PyObject*  ShapeFix_WirePy::FixTailMode(PyObject *args){};
// has to be implemented in ShapeFix_WirePyImp.cpp
PyObject * ShapeFix_WirePy::staticCallback_getFixTailMode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<ShapeFix_WirePy*>(self)->getFixTailMode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FixTailMode' of object 'ShapeFix_Wire'");
        return nullptr;
    }
}

int ShapeFix_WirePy::staticCallback_setFixTailMode (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<ShapeFix_WirePy*>(self)->setFixTailMode(Py::Boolean(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FixTailMode' of object 'ShapeFix_Wire'");
        return -1;
    }
}




//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
ShapeFix_WirePy::ShapeFix_WirePy(ShapeFix_Wire *pcObject, PyTypeObject *T)
    : ShapeFix_RootPy(static_cast<ShapeFix_RootPy::PointerType>(pcObject), T)
{
}


//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
ShapeFix_WirePy::~ShapeFix_WirePy()                                // Everything handled in parent
{
}

//--------------------------------------------------------------------------
// ShapeFix_WirePy representation
//--------------------------------------------------------------------------
PyObject *ShapeFix_WirePy::_repr()
{
    return Py_BuildValue("s", representation().c_str());
}

//--------------------------------------------------------------------------
// ShapeFix_WirePy Attributes
//--------------------------------------------------------------------------
PyObject *ShapeFix_WirePy::_getattr(const char *attr)			// __getattr__ function: note only need to handle new state
{
    try {
        // getter method for special Attributes (e.g. dynamic ones)
        PyObject *r = getCustomAttributes(attr);
        if(r) return r;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError,"Unknown C++ exception");
        return nullptr;
    }
#endif

    PyMethodDef *ml = Methods;
    for (; ml->ml_name != nullptr; ml++) {
        if (attr[0] == ml->ml_name[0] &&
            strcmp(attr+1, ml->ml_name+1) == 0)
            return PyCFunction_New(ml, this);
    }

    PyErr_Clear();
    return ShapeFix_RootPy::_getattr(attr);
}

int ShapeFix_WirePy::_setattr(const char *attr, PyObject *value) // __setattr__ function: note only need to handle new state
{
    try {
        // setter for special Attributes (e.g. dynamic ones)
        int r = setCustomAttributes(attr, value);
        // r = 1: handled
        // r = -1: error
        // r = 0: ignore
        if (r == 1)
            return 0;
        else if (r == -1)
            return -1;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return -1;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return -1;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return -1;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return -1;
    }
#endif

    return ShapeFix_RootPy::_setattr(attr, value);
}

ShapeFix_Wire *ShapeFix_WirePy::getShapeFix_WirePtr() const
{
    return static_cast<ShapeFix_Wire *>(_pcTwinPointer);
}

#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#if 0
/* From here on come the methods you have to implement, but NOT in this module. Implement in ShapeFix_WirePyImp.cpp! This prototypes
 * are just for convenience when you add a new method.
 */

PyObject *ShapeFix_WirePy::PyMake(PyTypeObject* /*type*/, PyObject* /*args*/, PyObject* /*kwds*/)
{
    // create a new instance of ShapeFix_WirePy and the Twin object
    return new ShapeFix_WirePy(new ShapeFix_Wire);
}

// constructor method
int ShapeFix_WirePy::PyInit(PyObject* /*args*/, PyObject* /*kwd*/)
{
    return 0;
}


// returns a string which represents the object e.g. when printed in python
std::string ShapeFix_WirePy::representation() const
{
    return {"<ShapeFix_Wire object>"};
}

PyObject* ShapeFix_WirePy::init(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixEdgeTool(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::clearModes(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::clearStatuses(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::load(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::setFace(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::setSurface(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::setMaxTailAngle(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::setMaxTailWidth(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::isLoaded(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::isReady(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::numberOfEdges(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::wire(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::wireAPIMake(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::face(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::perform(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixReorder(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixSmall(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixConnected(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixEdgeCurves(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixDegenerated(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixSelfIntersection(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixLacking(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixClosed(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixGaps3d(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixGaps2d(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixSeam(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixShifted(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixNotchedEdges(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixGap3d(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixGap2d(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* ShapeFix_WirePy::fixTails(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}



Py::Boolean ShapeFix_WirePy::getModifyTopologyMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setModifyTopologyMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getModifyGeometryMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setModifyGeometryMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getModifyRemoveLoopMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setModifyRemoveLoopMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getClosedWireMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setClosedWireMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getPreferencePCurveMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setPreferencePCurveMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixGapsByRangesMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixGapsByRangesMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixReorderMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixReorderMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixSmallMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixSmallMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixConnectedMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixConnectedMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixEdgeCurvesMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixEdgeCurvesMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixDegeneratedMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixDegeneratedMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixSelfIntersectionMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixSelfIntersectionMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixLackingMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixLackingMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixGaps3dMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixGaps3dMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixGaps2dMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixGaps2dMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixReversed2dMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixReversed2dMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixRemovePCurveMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixRemovePCurveMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixAddPCurveMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixAddPCurveMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixRemoveCurve3dMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixRemoveCurve3dMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixAddCurve3dMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixAddCurve3dMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixSeamMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixSeamMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixShiftedMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixShiftedMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixSameParameterMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixSameParameterMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixVertexToleranceMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixVertexToleranceMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixNotchedEdgesMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixNotchedEdgesMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixSelfIntersectingEdgeMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixSelfIntersectingEdgeMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixIntersectingEdgesMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixIntersectingEdgesMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixNonAdjacentIntersectingEdgesMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixNonAdjacentIntersectingEdgesMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Boolean ShapeFix_WirePy::getFixTailMode() const
{
    //return Py::Boolean();
    throw Py::AttributeError("Not yet implemented");
}

void  ShapeFix_WirePy::setFixTailMode(Py::Boolean arg)
{
    throw Py::AttributeError("Not yet implemented");
}

PyObject *ShapeFix_WirePy::getCustomAttributes(const char* /*attr*/) const
{
    return nullptr;
}

int ShapeFix_WirePy::setCustomAttributes(const char* /*attr*/, PyObject* /*obj*/)
{
    return 0;
}


#endif



