
// This file is generated by src/Tools/generateTemplates/templateClassPyExport.py out of the .XML file
// Every change you make here gets lost in the next full rebuild!
// This File is normally built as an include in LinkViewPyImp.cpp! It's not intended to be in a project!

#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/exception.hpp>
#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <CXX/Objects.hxx>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

using Base::streq;
using namespace Gui;

/// Type structure of LinkViewPy
PyTypeObject LinkViewPy::Type = {
    PyVarObject_HEAD_INIT(&PyType_Type,0)
    "Gui.LinkView",     /*tp_name*/
    sizeof(LinkViewPy),                       /*tp_basicsize*/
    0,                                                /*tp_itemsize*/
    /* methods */
    PyDestructor,                                     /*tp_dealloc*/
#if PY_VERSION_HEX >= 0x03080000
    0,                                                /*tp_vectorcall_offset*/
#else
    nullptr,                                          /*tp_print*/
#endif
    nullptr,                                          /*tp_getattr*/
    nullptr,                                          /*tp_setattr*/
    nullptr,                                          /*tp_compare*/
    __repr,                                           /*tp_repr*/
    nullptr,                                          /*tp_as_number*/
    nullptr,                                          /*tp_as_sequence*/
    nullptr,                                          /*tp_as_mapping*/
    nullptr,                                          /*tp_hash*/
    nullptr,                                          /*tp_call */
    nullptr,                                          /*tp_str  */
    __getattro,                                       /*tp_getattro*/
    __setattro,                                       /*tp_setattro*/
    /* --- Functions to access object as input/output buffer ---------*/
    nullptr,                                          /* tp_as_buffer */
    /* --- Flags to define presence of optional/expanded features */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT,        /*tp_flags */
    "Helper class to link to a view object",           /*tp_doc */
    nullptr,                                          /*tp_traverse */
    nullptr,                                          /*tp_clear */
    nullptr,                                          /*tp_richcompare */
    0,                                                /*tp_weaklistoffset */
    nullptr,                                          /*tp_iter */
    nullptr,                                          /*tp_iternext */
    Gui::LinkViewPy::Methods,                     /*tp_methods */
    nullptr,                                          /*tp_members */
    Gui::LinkViewPy::GetterSetter,                     /*tp_getset */
    &Base::BaseClassPy::Type,                        /*tp_base */
    nullptr,                                          /*tp_dict */
    nullptr,                                          /*tp_descr_get */
    nullptr,                                          /*tp_descr_set */
    0,                                                /*tp_dictoffset */
    __PyInit,                                         /*tp_init */
    nullptr,                                          /*tp_alloc */
    Gui::LinkViewPy::PyMake,/*tp_new */
    nullptr,                                          /*tp_free   Low-level free-memory routine */
    nullptr,                                          /*tp_is_gc  For PyObject_IS_GC */
    nullptr,                                          /*tp_bases */
    nullptr,                                          /*tp_mro    method resolution order */
    nullptr,                                          /*tp_cache */
    nullptr,                                          /*tp_subclasses */
    nullptr,                                          /*tp_weaklist */
    nullptr,                                          /*tp_del */
    0,                                                /*tp_version_tag */
    nullptr                                           /*tp_finalize */
#if PY_VERSION_HEX >= 0x03090000
    ,nullptr                                          /*tp_vectorcall */
#if PY_VERSION_HEX >= 0x030c0000
    ,0                                                /*tp_watched */
#endif
#elif PY_VERSION_HEX >= 0x03080000
    ,nullptr                                          /*tp_vectorcall */
    /* bpo-37250: kept for backwards compatibility in CPython 3.8 only */
    ,nullptr                                          /*tp_print */
#endif
};

/// Methods structure of LinkViewPy
PyMethodDef LinkViewPy::Methods[] = {
    {"reset",
        reinterpret_cast<PyCFunction>( staticCallback_reset ),
        METH_VARARGS,
        "Reset the link view and clear the links"
    },
    {"setMaterial",
        reinterpret_cast<PyCFunction>( staticCallback_setMaterial ),
        METH_VARARGS,
        "setMaterial(Material): set the override material of the entire linked object\n"
        "\n"
        "setMaterial([Material,...]): set the materials for the elements of the link\n"
        "                             array/group.\n"
        "\n"
        "setMaterial({Int:Material,...}): set the material for the elements of the\n"
        "                                 link array/group by index.\n"
        "\n"
        "If material is None, then the material is unset. If the material of an element\n"
        "is unset, it defaults to the override material of the linked object, if there\n"
        "is one"
    },
    {"setType",
        reinterpret_cast<PyCFunction>( staticCallback_setType ),
        METH_VARARGS,
        "setType(type, sublink=True): set the link type.\n"
        "\n"
        "type=0:  override transformation and visibility\n"
        "type=1:  override visibility\n"
        "type=2:  no override\n"
        "type=-1: sub-object link with override visibility\n"
        "type=-2: sub-object link with override transformation and visibility\n"
        "\n"
        "sublink: auto delegate to the sub-object references in the link, if there is\n"
        "         one and only one."
    },
    {"setTransform",
        reinterpret_cast<PyCFunction>( staticCallback_setTransform ),
        METH_VARARGS,
        "setTransform(matrix): set transformation of the linked object\n"
        "\n"
        "setTransform([matrix,...]): set transformation for the elements of the link\n"
        "                            array/group\n"
        "\n"
        "setTransform({index:matrix,...}): set transformation for elements of the link\n"
        "                                  array/group by index"
    },
    {"setChildren",
        reinterpret_cast<PyCFunction>( staticCallback_setChildren ),
        METH_VARARGS,
        "setChildren([obj...],vis=[],type=0)\n"
        "Group a list of children objects. Note, this mode of operation is incompatible\n"
        "with link array. Calling this function will deactivate link array. And calling\n"
        "setSize() will reset all linked children.\n"
        "\n"
        "vis: initial visibility status of the children\n"
        "\n"
        "type: children linking type,\n"
        "   0: override transformation and visibility,\n"
        "   1: override visibility,\n"
        "   2: override none."
    },
    {"setLink",
        reinterpret_cast<PyCFunction>( staticCallback_setLink ),
        METH_VARARGS,
        "setLink(object): Set the link\n"
        "\n"
        "setLink(object, subname): Set the link with a sub-object reference\n"
        "\n"
        "setLink(object, [subname,...]): Set the link with a list of sub object references\n"
        "\n"
        "object: The linked document object or its view object\n"
        "\n"
        "subname: a string or tuple/list of strings sub-name references to sub object\n"
        "         or sub elements (e.g. Face1, Edge2) belonging to the linked object.\n"
        "         The sub-name must end with a '.' if it is referencing an sub-object,\n"
        "         or else it is considered a sub-element reference."
    },
    {"getDetailPath",
        reinterpret_cast<PyCFunction>( staticCallback_getDetailPath ),
        METH_VARARGS,
        "getDetailPath(element): get the 3d path an detail of an element.\n"
        "\n"
        "Return a tuple(path,detail) for the coin3D SoPath and SoDetail of the element"
    },
    {"getElementPicked",
        reinterpret_cast<PyCFunction>( staticCallback_getElementPicked ),
        METH_VARARGS,
        "getElementPicked(pickPoint): get the element under a 3d pick point."
    },
    {"getBoundBox",
        reinterpret_cast<PyCFunction>( staticCallback_getBoundBox ),
        METH_VARARGS,
        "getBoundBox(vobj=None): get the bounding box."
    },
    {"getChildren",
        reinterpret_cast<PyCFunction>( staticCallback_getChildren ),
        METH_VARARGS,
        "Get children view objects"
    },
    {nullptr, nullptr, 0, nullptr}		/* Sentinel */
};



/// Attribute structure of LinkViewPy
PyGetSetDef LinkViewPy::GetterSetter[] = {
    {"LinkedView",
        (getter) staticCallback_getLinkedView,
        (setter) staticCallback_setLinkedView,
        "The linked view object",
        nullptr
    },
    {"SubNames",
        (getter) staticCallback_getSubNames,
        (setter) staticCallback_setSubNames,
        "The sub-object reference of the link",
        nullptr
    },
    {"RootNode",
        (getter) staticCallback_getRootNode,
        (setter) staticCallback_setRootNode,
        "A pivy node holding the cloned representation of the linked view object",
        nullptr
    },
    {"Owner",
        (getter) staticCallback_getOwner,
        (setter) staticCallback_setOwner,
        "The owner view object of this link handle",
        nullptr
    },
    {"Visibilities",
        (getter) staticCallback_getVisibilities,
        (setter) staticCallback_setVisibilities,
        "Get/set the child element visibility",
        nullptr
    },
    {"Count",
        (getter) staticCallback_getCount,
        (setter) staticCallback_setCount,
        "Set the element size to create an array of linked object",
        nullptr
    },
    {nullptr, nullptr, nullptr, nullptr, nullptr}		/* Sentinel */
};

// reset() callback and implementer
// PyObject*  LinkViewPy::reset(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_reset (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'reset' of 'Gui.LinkView' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkViewPy*>(self)->reset(args);
        if (ret != nullptr)
            static_cast<LinkViewPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setMaterial() callback and implementer
// PyObject*  LinkViewPy::setMaterial(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_setMaterial (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setMaterial' of 'Gui.LinkView' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkViewPy*>(self)->setMaterial(args);
        if (ret != nullptr)
            static_cast<LinkViewPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setType() callback and implementer
// PyObject*  LinkViewPy::setType(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_setType (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setType' of 'Gui.LinkView' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkViewPy*>(self)->setType(args);
        if (ret != nullptr)
            static_cast<LinkViewPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setTransform() callback and implementer
// PyObject*  LinkViewPy::setTransform(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_setTransform (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setTransform' of 'Gui.LinkView' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkViewPy*>(self)->setTransform(args);
        if (ret != nullptr)
            static_cast<LinkViewPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setChildren() callback and implementer
// PyObject*  LinkViewPy::setChildren(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_setChildren (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setChildren' of 'Gui.LinkView' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkViewPy*>(self)->setChildren(args);
        if (ret != nullptr)
            static_cast<LinkViewPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setLink() callback and implementer
// PyObject*  LinkViewPy::setLink(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_setLink (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setLink' of 'Gui.LinkView' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkViewPy*>(self)->setLink(args);
        if (ret != nullptr)
            static_cast<LinkViewPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getDetailPath() callback and implementer
// PyObject*  LinkViewPy::getDetailPath(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_getDetailPath (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getDetailPath' of 'Gui.LinkView' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkViewPy*>(self)->getDetailPath(args);
        if (ret != nullptr)
            static_cast<LinkViewPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getElementPicked() callback and implementer
// PyObject*  LinkViewPy::getElementPicked(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_getElementPicked (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getElementPicked' of 'Gui.LinkView' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkViewPy*>(self)->getElementPicked(args);
        if (ret != nullptr)
            static_cast<LinkViewPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getBoundBox() callback and implementer
// PyObject*  LinkViewPy::getBoundBox(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_getBoundBox (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getBoundBox' of 'Gui.LinkView' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkViewPy*>(self)->getBoundBox(args);
        if (ret != nullptr)
            static_cast<LinkViewPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getChildren() callback and implementer
// PyObject*  LinkViewPy::getChildren(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_getChildren (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getChildren' of 'Gui.LinkView' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<LinkViewPy*>(self)->getChildren(args);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// LinkedView() callback and implementer
// PyObject*  LinkViewPy::LinkedView(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_getLinkedView (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<LinkViewPy*>(self)->getLinkedView());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'LinkedView' of object 'LinkView'");
        return nullptr;
    }
}

int LinkViewPy::staticCallback_setLinkedView (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'LinkedView' of object 'LinkView' is read-only");
    return -1;
}

// SubNames() callback and implementer
// PyObject*  LinkViewPy::SubNames(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_getSubNames (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<LinkViewPy*>(self)->getSubNames());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'SubNames' of object 'LinkView'");
        return nullptr;
    }
}

int LinkViewPy::staticCallback_setSubNames (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'SubNames' of object 'LinkView' is read-only");
    return -1;
}

// RootNode() callback and implementer
// PyObject*  LinkViewPy::RootNode(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_getRootNode (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<LinkViewPy*>(self)->getRootNode());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'RootNode' of object 'LinkView'");
        return nullptr;
    }
}

int LinkViewPy::staticCallback_setRootNode (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'RootNode' of object 'LinkView' is read-only");
    return -1;
}

// Owner() callback and implementer
// PyObject*  LinkViewPy::Owner(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_getOwner (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<LinkViewPy*>(self)->getOwner());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Owner' of object 'LinkView'");
        return nullptr;
    }
}

int LinkViewPy::staticCallback_setOwner (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<LinkViewPy*>(self)->setOwner(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Owner' of object 'LinkView'");
        return -1;
    }
}

// Visibilities() callback and implementer
// PyObject*  LinkViewPy::Visibilities(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_getVisibilities (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<LinkViewPy*>(self)->getVisibilities());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Visibilities' of object 'LinkView'");
        return nullptr;
    }
}

int LinkViewPy::staticCallback_setVisibilities (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<LinkViewPy*>(self)->setVisibilities(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Visibilities' of object 'LinkView'");
        return -1;
    }
}

// Count() callback and implementer
// PyObject*  LinkViewPy::Count(PyObject *args){};
// has to be implemented in LinkViewPyImp.cpp
PyObject * LinkViewPy::staticCallback_getCount (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<LinkViewPy*>(self)->getCount());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Count' of object 'LinkView'");
        return nullptr;
    }
}

int LinkViewPy::staticCallback_setCount (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<LinkViewPy*>(self)->setCount(Py::Int(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Count' of object 'LinkView'");
        return -1;
    }
}




//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
LinkViewPy::LinkViewPy(LinkView *pcObject, PyTypeObject *T)
    : BaseClassPy(static_cast<BaseClassPy::PointerType>(pcObject), T)
{
}


//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
LinkViewPy::~LinkViewPy()                                // Everything handled in parent
{
    // delete the handled object when the PyObject dies
    LinkViewPy::PointerType ptr = static_cast<LinkViewPy::PointerType>(_pcTwinPointer);
    delete ptr;
}

//--------------------------------------------------------------------------
// LinkViewPy representation
//--------------------------------------------------------------------------
PyObject *LinkViewPy::_repr()
{
    return Py_BuildValue("s", representation().c_str());
}

//--------------------------------------------------------------------------
// LinkViewPy Attributes
//--------------------------------------------------------------------------
PyObject *LinkViewPy::_getattr(const char *attr)			// __getattr__ function: note only need to handle new state
{
    try {
        // getter method for special Attributes (e.g. dynamic ones)
        PyObject *r = getCustomAttributes(attr);
        if(r) return r;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError,"Unknown C++ exception");
        return nullptr;
    }
#endif

    PyMethodDef *ml = Methods;
    for (; ml->ml_name != nullptr; ml++) {
        if (attr[0] == ml->ml_name[0] &&
            strcmp(attr+1, ml->ml_name+1) == 0)
            return PyCFunction_New(ml, this);
    }

    PyErr_Clear();
    return BaseClassPy::_getattr(attr);
}

int LinkViewPy::_setattr(const char *attr, PyObject *value) // __setattr__ function: note only need to handle new state
{
    try {
        // setter for special Attributes (e.g. dynamic ones)
        int r = setCustomAttributes(attr, value);
        // r = 1: handled
        // r = -1: error
        // r = 0: ignore
        if (r == 1)
            return 0;
        else if (r == -1)
            return -1;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return -1;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return -1;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return -1;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return -1;
    }
#endif

    return BaseClassPy::_setattr(attr, value);
}

LinkView *LinkViewPy::getLinkViewPtr() const
{
    return static_cast<LinkView *>(_pcTwinPointer);
}

#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#if 0
/* From here on come the methods you have to implement, but NOT in this module. Implement in LinkViewPyImp.cpp! This prototypes
 * are just for convenience when you add a new method.
 */

PyObject *LinkViewPy::PyMake(PyTypeObject* /*type*/, PyObject* /*args*/, PyObject* /*kwds*/)
{
    // create a new instance of LinkViewPy and the Twin object
    return new LinkViewPy(new LinkView);
}

// constructor method
int LinkViewPy::PyInit(PyObject* /*args*/, PyObject* /*kwd*/)
{
    return 0;
}


// returns a string which represents the object e.g. when printed in python
std::string LinkViewPy::representation() const
{
    return {"<LinkView object>"};
}

PyObject* LinkViewPy::reset(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkViewPy::setMaterial(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkViewPy::setType(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkViewPy::setTransform(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkViewPy::setChildren(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkViewPy::setLink(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkViewPy::getDetailPath(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkViewPy::getElementPicked(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkViewPy::getBoundBox(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* LinkViewPy::getChildren(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}



Py::Object LinkViewPy::getLinkedView() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object LinkViewPy::getSubNames() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object LinkViewPy::getRootNode() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

Py::Object LinkViewPy::getOwner() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  LinkViewPy::setOwner(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object LinkViewPy::getVisibilities() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  LinkViewPy::setVisibilities(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Int LinkViewPy::getCount() const
{
    //return Py::Int();
    throw Py::AttributeError("Not yet implemented");
}

void  LinkViewPy::setCount(Py::Int arg)
{
    throw Py::AttributeError("Not yet implemented");
}

PyObject *LinkViewPy::getCustomAttributes(const char* /*attr*/) const
{
    return nullptr;
}

int LinkViewPy::setCustomAttributes(const char* /*attr*/, PyObject* /*obj*/)
{
    return 0;
}


#endif



