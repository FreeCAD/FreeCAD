
// This file is generated by src/Tools/generateTemplates/templateClassPyExport.py out of the .XML file
// Every change you make here gets lost in the next full rebuild!
// This File is normally built as an include in MetadataPyImp.cpp! It's not intended to be in a project!

#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/exception.hpp>
#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <CXX/Objects.hxx>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

using Base::streq;
using namespace App;

/// Type structure of MetadataPy
PyTypeObject MetadataPy::Type = {
    PyVarObject_HEAD_INIT(&PyType_Type,0)
    "App.Metadata",     /*tp_name*/
    sizeof(MetadataPy),                       /*tp_basicsize*/
    0,                                                /*tp_itemsize*/
    /* methods */
    PyDestructor,                                     /*tp_dealloc*/
#if PY_VERSION_HEX >= 0x03080000
    0,                                                /*tp_vectorcall_offset*/
#else
    nullptr,                                          /*tp_print*/
#endif
    nullptr,                                          /*tp_getattr*/
    nullptr,                                          /*tp_setattr*/
    nullptr,                                          /*tp_compare*/
    __repr,                                           /*tp_repr*/
    nullptr,                                          /*tp_as_number*/
    nullptr,                                          /*tp_as_sequence*/
    nullptr,                                          /*tp_as_mapping*/
    nullptr,                                          /*tp_hash*/
    nullptr,                                          /*tp_call */
    nullptr,                                          /*tp_str  */
    __getattro,                                       /*tp_getattro*/
    __setattro,                                       /*tp_setattro*/
    /* --- Functions to access object as input/output buffer ---------*/
    nullptr,                                          /* tp_as_buffer */
    /* --- Flags to define presence of optional/expanded features */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT,        /*tp_flags */
    "App.Metadata class.\n"
    "\n"
    "A Metadata object reads an XML-formatted package metadata file and provides\n"
    "read and write access to its contents.\n"
    "\n"
    "The following constructors are supported:\n"
    "\n"
    "Metadata()\n"
    "Empty constructor.\n"
    "\n"
    "Metadata(metadata)\n"
    "Copy constructor.\n"
    "metadata : App.Metadata\n"
    "\n"
    "Metadata(file)\n"
    "Reads the XML file and provides access to the metadata it specifies.\n"
    "file : str\n"
    "    XML file name.\n"
    "\n"
    "Metadata(bytes)\n"
    "Treats the bytes as UTF-8-encoded XML data and provides access to the metadata it specifies.\n"
    "bytes : bytes\n"
    "    Python bytes-like object.",           /*tp_doc */
    nullptr,                                          /*tp_traverse */
    nullptr,                                          /*tp_clear */
    nullptr,                                          /*tp_richcompare */
    0,                                                /*tp_weaklistoffset */
    nullptr,                                          /*tp_iter */
    nullptr,                                          /*tp_iternext */
    App::MetadataPy::Methods,                     /*tp_methods */
    nullptr,                                          /*tp_members */
    App::MetadataPy::GetterSetter,                     /*tp_getset */
    &Base::PyObjectBase::Type,                        /*tp_base */
    nullptr,                                          /*tp_dict */
    nullptr,                                          /*tp_descr_get */
    nullptr,                                          /*tp_descr_set */
    0,                                                /*tp_dictoffset */
    __PyInit,                                         /*tp_init */
    nullptr,                                          /*tp_alloc */
    App::MetadataPy::PyMake,/*tp_new */
    nullptr,                                          /*tp_free   Low-level free-memory routine */
    nullptr,                                          /*tp_is_gc  For PyObject_IS_GC */
    nullptr,                                          /*tp_bases */
    nullptr,                                          /*tp_mro    method resolution order */
    nullptr,                                          /*tp_cache */
    nullptr,                                          /*tp_subclasses */
    nullptr,                                          /*tp_weaklist */
    nullptr,                                          /*tp_del */
    0,                                                /*tp_version_tag */
    nullptr                                           /*tp_finalize */
#if PY_VERSION_HEX >= 0x03090000
    ,nullptr                                          /*tp_vectorcall */
#if PY_VERSION_HEX >= 0x030c0000
    ,0                                                /*tp_watched */
#endif
#elif PY_VERSION_HEX >= 0x03080000
    ,nullptr                                          /*tp_vectorcall */
    /* bpo-37250: kept for backwards compatibility in CPython 3.8 only */
    ,nullptr                                          /*tp_print */
#endif
};

/// Methods structure of MetadataPy
PyMethodDef MetadataPy::Methods[] = {
    {"getLastSupportedFreeCADVersion",
        reinterpret_cast<PyCFunction>( staticCallback_getLastSupportedFreeCADVersion ),
        METH_VARARGS,
        "getLastSupportedFreeCADVersion() -> str or None\n"
        "\n"
        "Search through all content package items, and determine if a maximum supported\n"
        "version of FreeCAD is set.\n"
        "Returns None if no maximum version is set, or if *any* content item fails to\n"
        "provide a maximum version (implying that that content item will work with all\n"
        "known versions)."
    },
    {"getFirstSupportedFreeCADVersion",
        reinterpret_cast<PyCFunction>( staticCallback_getFirstSupportedFreeCADVersion ),
        METH_VARARGS,
        "getFirstSupportedFreeCADVersion() -> str or None\n"
        "\n"
        "Search through all content package items, and determine if a minimum supported\n"
        "version of FreeCAD is set.\n"
        "Returns 0.0 if no minimum version is set, or if *any* content item fails to\n"
        "provide a minimum version (implying that that content item will work with all\n"
        "known versions. Technically limited to 0.20 as the lowest known version since\n"
        "the metadata standard was added then)."
    },
    {"supportsCurrentFreeCAD",
        reinterpret_cast<PyCFunction>( staticCallback_supportsCurrentFreeCAD ),
        METH_VARARGS,
        "supportsCurrentFreeCAD() -> bool\n"
        "\n"
        "Returns False if this metadata object directly indicates that it does not\n"
        "support the current version of FreeCAD, or True if it makes no indication, or\n"
        "specifically indicates that it does support the current version. Does not\n"
        "recurse into Content items."
    },
    {"getGenericMetadata",
        reinterpret_cast<PyCFunction>( staticCallback_getGenericMetadata ),
        METH_VARARGS,
        "getGenericMetadata(name) -> list\n"
        "\n"
        "Get the list of GenericMetadata objects with key 'name'.\n"
        "Generic metadata objects are Python objects with a string 'contents' and a\n"
        "dictionary of strings, 'attributes'. They represent unrecognized simple XML tags\n"
        "in the metadata file."
    },
    {"addContentItem",
        reinterpret_cast<PyCFunction>( staticCallback_addContentItem ),
        METH_VARARGS,
        "addContentItem(content_type,metadata)\n"
        "\n"
        "Add a new content item of type 'content_type' with metadata 'metadata'."
    },
    {"removeContentItem",
        reinterpret_cast<PyCFunction>( staticCallback_removeContentItem ),
        METH_VARARGS,
        "removeContentItem(content_type,name)\n"
        "\n"
        "Remove the content item of type 'content_type' with name 'name'."
    },
    {"addMaintainer",
        reinterpret_cast<PyCFunction>( staticCallback_addMaintainer ),
        METH_VARARGS,
        "addMaintainer(name, email)\n"
        "\n"
        "Add a new Maintainer."
    },
    {"removeMaintainer",
        reinterpret_cast<PyCFunction>( staticCallback_removeMaintainer ),
        METH_VARARGS,
        "removeMaintainer(name, email)\n"
        "\n"
        "Remove the Maintainer."
    },
    {"addLicense",
        reinterpret_cast<PyCFunction>( staticCallback_addLicense ),
        METH_VARARGS,
        "addLicense(short_code,path)\n"
        "\n"
        "Add a new License."
    },
    {"removeLicense",
        reinterpret_cast<PyCFunction>( staticCallback_removeLicense ),
        METH_VARARGS,
        "removeLicense(short_code)\n"
        "\n"
        "Remove the License."
    },
    {"addUrl",
        reinterpret_cast<PyCFunction>( staticCallback_addUrl ),
        METH_VARARGS,
        "addUrl(url_type,url,branch)\n"
        "\n"
        "Add a new Url or type 'url_type' (which should be one of 'repository', 'readme',\n"
        "\n"
        "'bugtracker', 'documentation', or 'webpage') If type is 'repository' you\n"
        "\n"
        "must also specify the 'branch' parameter."
    },
    {"removeUrl",
        reinterpret_cast<PyCFunction>( staticCallback_removeUrl ),
        METH_VARARGS,
        "removeUrl(url_type,url)\n"
        "\n"
        "Remove the Url."
    },
    {"addAuthor",
        reinterpret_cast<PyCFunction>( staticCallback_addAuthor ),
        METH_VARARGS,
        "addAuthor(name, email)\n"
        "\n"
        "Add a new Author with name 'name', and optionally email 'email'."
    },
    {"removeAuthor",
        reinterpret_cast<PyCFunction>( staticCallback_removeAuthor ),
        METH_VARARGS,
        "removeAuthor(name, email)\n"
        "\n"
        "Remove the Author."
    },
    {"addDepend",
        reinterpret_cast<PyCFunction>( staticCallback_addDepend ),
        METH_VARARGS,
        "addDepend(name, kind, optional)\n"
        "\n"
        "Add a new Dependency on package 'name' of kind 'kind' (optional, one of 'auto' (the default),\n"
        "\n"
        "'internal', 'addon', or 'python')."
    },
    {"removeDepend",
        reinterpret_cast<PyCFunction>( staticCallback_removeDepend ),
        METH_VARARGS,
        "removeDepend(name, kind)\n"
        "\n"
        "Remove the Dependency on package 'name' of kind 'kind' (optional - if unspecified any\n"
        "\n"
        "matching name is removed)."
    },
    {"addConflict",
        reinterpret_cast<PyCFunction>( staticCallback_addConflict ),
        METH_VARARGS,
        "addConflict(name, kind)\n"
        "\n"
        "Add a new Conflict. See documentation for addDepend()."
    },
    {"removeConflict",
        reinterpret_cast<PyCFunction>( staticCallback_removeConflict ),
        METH_VARARGS,
        "removeConflict(name, kind)\n"
        "\n"
        "Remove the Conflict. See documentation for removeDepend()."
    },
    {"addReplace",
        reinterpret_cast<PyCFunction>( staticCallback_addReplace ),
        METH_VARARGS,
        "addReplace(name)\n"
        "\n"
        "Add a new Replace."
    },
    {"removeReplace",
        reinterpret_cast<PyCFunction>( staticCallback_removeReplace ),
        METH_VARARGS,
        "removeReplace(name)\n"
        "\n"
        "Remove the Replace."
    },
    {"addTag",
        reinterpret_cast<PyCFunction>( staticCallback_addTag ),
        METH_VARARGS,
        "addTag(tag)\n"
        "\n"
        "Add a new Tag."
    },
    {"removeTag",
        reinterpret_cast<PyCFunction>( staticCallback_removeTag ),
        METH_VARARGS,
        "removeTag(tag)\n"
        "\n"
        "Remove the Tag."
    },
    {"addFile",
        reinterpret_cast<PyCFunction>( staticCallback_addFile ),
        METH_VARARGS,
        "addFile(filename)\n"
        "\n"
        "Add a new File."
    },
    {"removeFile",
        reinterpret_cast<PyCFunction>( staticCallback_removeFile ),
        METH_VARARGS,
        "removeFile(filename)\n"
        "\n"
        "Remove the File."
    },
    {"write",
        reinterpret_cast<PyCFunction>( staticCallback_write ),
        METH_VARARGS,
        "write(filename)\n"
        "\n"
        "Write the metadata to the given file as XML data."
    },
    {nullptr, nullptr, 0, nullptr}		/* Sentinel */
};



/// Attribute structure of MetadataPy
PyGetSetDef MetadataPy::GetterSetter[] = {
    {"Name",
        (getter) staticCallback_getName,
        (setter) staticCallback_setName,
        "String representing the name of this item.",
        nullptr
    },
    {"Version",
        (getter) staticCallback_getVersion,
        (setter) staticCallback_setVersion,
        "String representing the version of this item in semantic triplet format.",
        nullptr
    },
    {"Date",
        (getter) staticCallback_getDate,
        (setter) staticCallback_setDate,
        "String representing the date of this item in YYYY-MM-DD format (format not currently programmatically enforced)",
        nullptr
    },
    {"Type",
        (getter) staticCallback_getType,
        (setter) staticCallback_setType,
        "String representing the type of this item (text only, no markup allowed).",
        nullptr
    },
    {"Description",
        (getter) staticCallback_getDescription,
        (setter) staticCallback_setDescription,
        "String representing the description of this item (text only, no markup allowed).",
        nullptr
    },
    {"Maintainer",
        (getter) staticCallback_getMaintainer,
        (setter) staticCallback_setMaintainer,
        "List of maintainer objects with 'name' and 'email' string attributes.",
        nullptr
    },
    {"License",
        (getter) staticCallback_getLicense,
        (setter) staticCallback_setLicense,
        "List of applicable licenses as objects with 'name' and 'file' string attributes.",
        nullptr
    },
    {"Urls",
        (getter) staticCallback_getUrls,
        (setter) staticCallback_setUrls,
        "List of URLs as objects with 'location' and 'type' string attributes, where type\n"
        "is one of:\n"
        "* website\n"
        "* repository\n"
        "* bugtracker\n"
        "* readme\n"
        "* documentation",
        nullptr
    },
    {"Author",
        (getter) staticCallback_getAuthor,
        (setter) staticCallback_setAuthor,
        "List of author objects, each with a 'name' and a (potentially empty) 'email'\n"
        "string attribute.",
        nullptr
    },
    {"Depend",
        (getter) staticCallback_getDepend,
        (setter) staticCallback_setDepend,
        "List of dependencies, as objects with the following attributes:\n"
        "* package\n"
        "    Required. Must exactly match the contents of the 'name' element in the\n"
        "    referenced package's package.xml file.\n"
        "* version_lt\n"
        "    Optional. The dependency to the package is restricted to versions less than\n"
        "    the stated version number.\n"
        "* version_lte\n"
        "    Optional. The dependency to the package is restricted to versions less or\n"
        "    equal than the stated version number.\n"
        "* version_eq\n"
        "    Optional. The dependency to the package is restricted to a version equal\n"
        "    than the stated version number.\n"
        "* version_gte\n"
        "    Optional. The dependency to the package is restricted to versions greater\n"
        "    or equal than the stated version number.\n"
        "* version_gt\n"
        "    Optional. The dependency to the package is restricted to versions greater\n"
        "    than the stated version number.\n"
        "* condition\n"
        "    Optional. Conditional expression as documented in REP149.",
        nullptr
    },
    {"Conflict",
        (getter) staticCallback_getConflict,
        (setter) staticCallback_setConflict,
        "List of conflicts, format identical to dependencies.",
        nullptr
    },
    {"Replace",
        (getter) staticCallback_getReplace,
        (setter) staticCallback_setReplace,
        "List of things this item is considered by its author to replace. The format is\n"
        "identical to dependencies.",
        nullptr
    },
    {"Tag",
        (getter) staticCallback_getTag,
        (setter) staticCallback_setTag,
        "List of strings.",
        nullptr
    },
    {"Icon",
        (getter) staticCallback_getIcon,
        (setter) staticCallback_setIcon,
        "Relative path to an icon file.",
        nullptr
    },
    {"Classname",
        (getter) staticCallback_getClassname,
        (setter) staticCallback_setClassname,
        "String representing the name of the main Python class this item\n"
        "creates/represents.",
        nullptr
    },
    {"Subdirectory",
        (getter) staticCallback_getSubdirectory,
        (setter) staticCallback_setSubdirectory,
        "String representing the name of the subdirectory this content item is located in.\n"
        "If empty, the item is in a directory named the same as the content item.",
        nullptr
    },
    {"File",
        (getter) staticCallback_getFile,
        (setter) staticCallback_setFile,
        "List of files associated with this item.\n"
        "The meaning of each file is implementation-defined.",
        nullptr
    },
    {"Content",
        (getter) staticCallback_getContent,
        (setter) staticCallback_setContent,
        "Dictionary of lists of content items: defined recursively, each item is itself\n"
        "a Metadata object.\n"
        "See package.xml file format documentation for details.",
        nullptr
    },
    {"FreeCADMin",
        (getter) staticCallback_getFreeCADMin,
        (setter) staticCallback_setFreeCADMin,
        "String representing the minimum version of FreeCAD needed for this item.\n"
        "If unset it will be 0.0.0.",
        nullptr
    },
    {"FreeCADMax",
        (getter) staticCallback_getFreeCADMax,
        (setter) staticCallback_setFreeCADMax,
        "String representing the maximum version of FreeCAD needed for this item.\n"
        "If unset it will be 0.0.0.",
        nullptr
    },
    {"PythonMin",
        (getter) staticCallback_getPythonMin,
        (setter) staticCallback_setPythonMin,
        "String representing the minimum version of Python needed for this item.\n"
        "If unset it will be 0.0.0.",
        nullptr
    },
    {nullptr, nullptr, nullptr, nullptr, nullptr}		/* Sentinel */
};

// getLastSupportedFreeCADVersion() callback and implementer
// PyObject*  MetadataPy::getLastSupportedFreeCADVersion(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getLastSupportedFreeCADVersion (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getLastSupportedFreeCADVersion' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->getLastSupportedFreeCADVersion(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getFirstSupportedFreeCADVersion() callback and implementer
// PyObject*  MetadataPy::getFirstSupportedFreeCADVersion(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getFirstSupportedFreeCADVersion (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getFirstSupportedFreeCADVersion' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->getFirstSupportedFreeCADVersion(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// supportsCurrentFreeCAD() callback and implementer
// PyObject*  MetadataPy::supportsCurrentFreeCAD(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_supportsCurrentFreeCAD (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'supportsCurrentFreeCAD' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->supportsCurrentFreeCAD(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getGenericMetadata() callback and implementer
// PyObject*  MetadataPy::getGenericMetadata(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getGenericMetadata (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getGenericMetadata' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->getGenericMetadata(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addContentItem() callback and implementer
// PyObject*  MetadataPy::addContentItem(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_addContentItem (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addContentItem' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->addContentItem(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeContentItem() callback and implementer
// PyObject*  MetadataPy::removeContentItem(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_removeContentItem (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeContentItem' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->removeContentItem(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addMaintainer() callback and implementer
// PyObject*  MetadataPy::addMaintainer(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_addMaintainer (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addMaintainer' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->addMaintainer(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeMaintainer() callback and implementer
// PyObject*  MetadataPy::removeMaintainer(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_removeMaintainer (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeMaintainer' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->removeMaintainer(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addLicense() callback and implementer
// PyObject*  MetadataPy::addLicense(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_addLicense (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addLicense' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->addLicense(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeLicense() callback and implementer
// PyObject*  MetadataPy::removeLicense(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_removeLicense (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeLicense' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->removeLicense(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addUrl() callback and implementer
// PyObject*  MetadataPy::addUrl(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_addUrl (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addUrl' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->addUrl(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeUrl() callback and implementer
// PyObject*  MetadataPy::removeUrl(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_removeUrl (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeUrl' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->removeUrl(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addAuthor() callback and implementer
// PyObject*  MetadataPy::addAuthor(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_addAuthor (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addAuthor' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->addAuthor(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeAuthor() callback and implementer
// PyObject*  MetadataPy::removeAuthor(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_removeAuthor (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeAuthor' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->removeAuthor(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addDepend() callback and implementer
// PyObject*  MetadataPy::addDepend(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_addDepend (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addDepend' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->addDepend(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeDepend() callback and implementer
// PyObject*  MetadataPy::removeDepend(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_removeDepend (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeDepend' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->removeDepend(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addConflict() callback and implementer
// PyObject*  MetadataPy::addConflict(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_addConflict (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addConflict' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->addConflict(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeConflict() callback and implementer
// PyObject*  MetadataPy::removeConflict(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_removeConflict (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeConflict' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->removeConflict(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addReplace() callback and implementer
// PyObject*  MetadataPy::addReplace(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_addReplace (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addReplace' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->addReplace(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeReplace() callback and implementer
// PyObject*  MetadataPy::removeReplace(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_removeReplace (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeReplace' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->removeReplace(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addTag() callback and implementer
// PyObject*  MetadataPy::addTag(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_addTag (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addTag' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->addTag(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeTag() callback and implementer
// PyObject*  MetadataPy::removeTag(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_removeTag (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeTag' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->removeTag(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// addFile() callback and implementer
// PyObject*  MetadataPy::addFile(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_addFile (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'addFile' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->addFile(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// removeFile() callback and implementer
// PyObject*  MetadataPy::removeFile(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_removeFile (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'removeFile' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->removeFile(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// write() callback and implementer
// PyObject*  MetadataPy::write(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_write (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'write' of 'App.Metadata' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<MetadataPy*>(self)->write(args);
        if (ret != nullptr)
            static_cast<MetadataPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// Name() callback and implementer
// PyObject*  MetadataPy::Name(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getName (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getName());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Name' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setName (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setName(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Name' of object 'Metadata'");
        return -1;
    }
}

// Version() callback and implementer
// PyObject*  MetadataPy::Version(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getVersion (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getVersion());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Version' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setVersion (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setVersion(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Version' of object 'Metadata'");
        return -1;
    }
}

// Date() callback and implementer
// PyObject*  MetadataPy::Date(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getDate (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getDate());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Date' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setDate (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setDate(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Date' of object 'Metadata'");
        return -1;
    }
}

// Type() callback and implementer
// PyObject*  MetadataPy::Type(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getType (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getType());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Type' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setType (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setType(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Type' of object 'Metadata'");
        return -1;
    }
}

// Description() callback and implementer
// PyObject*  MetadataPy::Description(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getDescription (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getDescription());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Description' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setDescription (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setDescription(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Description' of object 'Metadata'");
        return -1;
    }
}

// Maintainer() callback and implementer
// PyObject*  MetadataPy::Maintainer(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getMaintainer (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getMaintainer());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Maintainer' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setMaintainer (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setMaintainer(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Maintainer' of object 'Metadata'");
        return -1;
    }
}

// License() callback and implementer
// PyObject*  MetadataPy::License(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getLicense (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getLicense());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'License' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setLicense (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setLicense(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'License' of object 'Metadata'");
        return -1;
    }
}

// Urls() callback and implementer
// PyObject*  MetadataPy::Urls(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getUrls (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getUrls());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Urls' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setUrls (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setUrls(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Urls' of object 'Metadata'");
        return -1;
    }
}

// Author() callback and implementer
// PyObject*  MetadataPy::Author(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getAuthor (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getAuthor());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Author' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setAuthor (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setAuthor(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Author' of object 'Metadata'");
        return -1;
    }
}

// Depend() callback and implementer
// PyObject*  MetadataPy::Depend(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getDepend (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getDepend());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Depend' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setDepend (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setDepend(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Depend' of object 'Metadata'");
        return -1;
    }
}

// Conflict() callback and implementer
// PyObject*  MetadataPy::Conflict(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getConflict (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getConflict());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Conflict' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setConflict (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setConflict(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Conflict' of object 'Metadata'");
        return -1;
    }
}

// Replace() callback and implementer
// PyObject*  MetadataPy::Replace(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getReplace (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getReplace());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Replace' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setReplace (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setReplace(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Replace' of object 'Metadata'");
        return -1;
    }
}

// Tag() callback and implementer
// PyObject*  MetadataPy::Tag(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getTag (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getTag());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Tag' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setTag (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setTag(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Tag' of object 'Metadata'");
        return -1;
    }
}

// Icon() callback and implementer
// PyObject*  MetadataPy::Icon(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getIcon (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getIcon());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Icon' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setIcon (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setIcon(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Icon' of object 'Metadata'");
        return -1;
    }
}

// Classname() callback and implementer
// PyObject*  MetadataPy::Classname(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getClassname (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getClassname());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Classname' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setClassname (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setClassname(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Classname' of object 'Metadata'");
        return -1;
    }
}

// Subdirectory() callback and implementer
// PyObject*  MetadataPy::Subdirectory(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getSubdirectory (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getSubdirectory());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Subdirectory' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setSubdirectory (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setSubdirectory(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Subdirectory' of object 'Metadata'");
        return -1;
    }
}

// File() callback and implementer
// PyObject*  MetadataPy::File(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getFile (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getFile());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'File' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setFile (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setFile(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'File' of object 'Metadata'");
        return -1;
    }
}

// Content() callback and implementer
// PyObject*  MetadataPy::Content(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getContent (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getContent());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'Content' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setContent (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setContent(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'Content' of object 'Metadata'");
        return -1;
    }
}

// FreeCADMin() callback and implementer
// PyObject*  MetadataPy::FreeCADMin(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getFreeCADMin (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getFreeCADMin());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FreeCADMin' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setFreeCADMin (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setFreeCADMin(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FreeCADMin' of object 'Metadata'");
        return -1;
    }
}

// FreeCADMax() callback and implementer
// PyObject*  MetadataPy::FreeCADMax(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getFreeCADMax (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getFreeCADMax());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'FreeCADMax' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setFreeCADMax (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setFreeCADMax(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'FreeCADMax' of object 'Metadata'");
        return -1;
    }
}

// PythonMin() callback and implementer
// PyObject*  MetadataPy::PythonMin(PyObject *args){};
// has to be implemented in MetadataPyImp.cpp
PyObject * MetadataPy::staticCallback_getPythonMin (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<MetadataPy*>(self)->getPythonMin());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'PythonMin' of object 'Metadata'");
        return nullptr;
    }
}

int MetadataPy::staticCallback_setPythonMin (PyObject *self, PyObject *value, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }
    if (static_cast<PyObjectBase*>(self)->isConst()){
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a method");
        return -1;
    }

    try {
        static_cast<MetadataPy*>(self)->setPythonMin(Py::Object(value,false));
        return 0;
    } catch (const Py::Exception&) {
        // The exception text is already set
        return -1;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while writing attribute 'PythonMin' of object 'Metadata'");
        return -1;
    }
}




//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
MetadataPy::MetadataPy(Metadata *pcObject, PyTypeObject *T)
    : PyObjectBase(static_cast<PyObjectBase::PointerType>(pcObject), T)
{
}


//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
MetadataPy::~MetadataPy()                                // Everything handled in parent
{
    // delete the handled object when the PyObject dies
    MetadataPy::PointerType ptr = static_cast<MetadataPy::PointerType>(_pcTwinPointer);
    delete ptr;
}

//--------------------------------------------------------------------------
// MetadataPy representation
//--------------------------------------------------------------------------
PyObject *MetadataPy::_repr()
{
    return Py_BuildValue("s", representation().c_str());
}

//--------------------------------------------------------------------------
// MetadataPy Attributes
//--------------------------------------------------------------------------
PyObject *MetadataPy::_getattr(const char *attr)			// __getattr__ function: note only need to handle new state
{
    try {
        // getter method for special Attributes (e.g. dynamic ones)
        PyObject *r = getCustomAttributes(attr);
        if(r) return r;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError,"Unknown C++ exception");
        return nullptr;
    }
#endif

    PyMethodDef *ml = Methods;
    for (; ml->ml_name != nullptr; ml++) {
        if (attr[0] == ml->ml_name[0] &&
            strcmp(attr+1, ml->ml_name+1) == 0)
            return PyCFunction_New(ml, this);
    }

    PyErr_Clear();
    return PyObjectBase::_getattr(attr);
}

int MetadataPy::_setattr(const char *attr, PyObject *value) // __setattr__ function: note only need to handle new state
{
    try {
        // setter for special Attributes (e.g. dynamic ones)
        int r = setCustomAttributes(attr, value);
        // r = 1: handled
        // r = -1: error
        // r = 0: ignore
        if (r == 1)
            return 0;
        else if (r == -1)
            return -1;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return -1;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return -1;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return -1;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return -1;
    }
#endif

    return PyObjectBase::_setattr(attr, value);
}

Metadata *MetadataPy::getMetadataPtr() const
{
    return static_cast<Metadata *>(_pcTwinPointer);
}

#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#if 0
/* From here on come the methods you have to implement, but NOT in this module. Implement in MetadataPyImp.cpp! This prototypes
 * are just for convenience when you add a new method.
 */

PyObject *MetadataPy::PyMake(PyTypeObject* /*type*/, PyObject* /*args*/, PyObject* /*kwds*/)
{
    // create a new instance of MetadataPy and the Twin object
    return new MetadataPy(new Metadata);
}

// constructor method
int MetadataPy::PyInit(PyObject* /*args*/, PyObject* /*kwd*/)
{
    return 0;
}


// returns a string which represents the object e.g. when printed in python
std::string MetadataPy::representation() const
{
    return {"<Metadata object>"};
}

PyObject* MetadataPy::getLastSupportedFreeCADVersion(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::getFirstSupportedFreeCADVersion(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::supportsCurrentFreeCAD(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::getGenericMetadata(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::addContentItem(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::removeContentItem(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::addMaintainer(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::removeMaintainer(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::addLicense(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::removeLicense(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::addUrl(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::removeUrl(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::addAuthor(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::removeAuthor(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::addDepend(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::removeDepend(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::addConflict(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::removeConflict(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::addReplace(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::removeReplace(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::addTag(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::removeTag(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::addFile(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::removeFile(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* MetadataPy::write(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}



Py::Object MetadataPy::getName() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setName(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getVersion() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setVersion(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getDate() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setDate(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getType() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setType(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getDescription() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setDescription(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getMaintainer() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setMaintainer(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getLicense() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setLicense(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getUrls() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setUrls(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getAuthor() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setAuthor(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getDepend() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setDepend(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getConflict() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setConflict(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getReplace() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setReplace(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getTag() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setTag(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getIcon() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setIcon(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getClassname() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setClassname(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getSubdirectory() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setSubdirectory(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getFile() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setFile(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getContent() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setContent(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getFreeCADMin() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setFreeCADMin(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getFreeCADMax() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setFreeCADMax(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

Py::Object MetadataPy::getPythonMin() const
{
    //return Py::Object();
    throw Py::AttributeError("Not yet implemented");
}

void  MetadataPy::setPythonMin(Py::Object arg)
{
    throw Py::AttributeError("Not yet implemented");
}

PyObject *MetadataPy::getCustomAttributes(const char* /*attr*/) const
{
    return nullptr;
}

int MetadataPy::setCustomAttributes(const char* /*attr*/, PyObject* /*obj*/)
{
    return 0;
}


#endif



