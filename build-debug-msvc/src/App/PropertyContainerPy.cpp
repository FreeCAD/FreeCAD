
// This file is generated by src/Tools/generateTemplates/templateClassPyExport.py out of the .XML file
// Every change you make here gets lost in the next full rebuild!
// This File is normally built as an include in PropertyContainerPyImp.cpp! It's not intended to be in a project!

#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/exception.hpp>
#include <Base/PyObjectBase.h>
#include <Base/Console.h>
#include <Base/Exception.h>
#include <CXX/Objects.hxx>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

using Base::streq;
using namespace App;

/// Type structure of PropertyContainerPy
PyTypeObject PropertyContainerPy::Type = {
    PyVarObject_HEAD_INIT(&PyType_Type,0)
    "App.PropertyContainer",     /*tp_name*/
    sizeof(PropertyContainerPy),                       /*tp_basicsize*/
    0,                                                /*tp_itemsize*/
    /* methods */
    PyDestructor,                                     /*tp_dealloc*/
#if PY_VERSION_HEX >= 0x03080000
    0,                                                /*tp_vectorcall_offset*/
#else
    nullptr,                                          /*tp_print*/
#endif
    nullptr,                                          /*tp_getattr*/
    nullptr,                                          /*tp_setattr*/
    nullptr,                                          /*tp_compare*/
    __repr,                                           /*tp_repr*/
    nullptr,                                          /*tp_as_number*/
    nullptr,                                          /*tp_as_sequence*/
    nullptr,                                          /*tp_as_mapping*/
    nullptr,                                          /*tp_hash*/
    nullptr,                                          /*tp_call */
    nullptr,                                          /*tp_str  */
    __getattro,                                       /*tp_getattro*/
    __setattro,                                       /*tp_setattro*/
    /* --- Functions to access object as input/output buffer ---------*/
    nullptr,                                          /* tp_as_buffer */
    /* --- Flags to define presence of optional/expanded features */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT,        /*tp_flags */
    "App.PropertyContainer class.",           /*tp_doc */
    nullptr,                                          /*tp_traverse */
    nullptr,                                          /*tp_clear */
    nullptr,                                          /*tp_richcompare */
    0,                                                /*tp_weaklistoffset */
    nullptr,                                          /*tp_iter */
    nullptr,                                          /*tp_iternext */
    App::PropertyContainerPy::Methods,                     /*tp_methods */
    nullptr,                                          /*tp_members */
    App::PropertyContainerPy::GetterSetter,                     /*tp_getset */
    &Base::PersistencePy::Type,                        /*tp_base */
    nullptr,                                          /*tp_dict */
    nullptr,                                          /*tp_descr_get */
    nullptr,                                          /*tp_descr_set */
    0,                                                /*tp_dictoffset */
    __PyInit,                                         /*tp_init */
    nullptr,                                          /*tp_alloc */
    App::PropertyContainerPy::PyMake,/*tp_new */
    nullptr,                                          /*tp_free   Low-level free-memory routine */
    nullptr,                                          /*tp_is_gc  For PyObject_IS_GC */
    nullptr,                                          /*tp_bases */
    nullptr,                                          /*tp_mro    method resolution order */
    nullptr,                                          /*tp_cache */
    nullptr,                                          /*tp_subclasses */
    nullptr,                                          /*tp_weaklist */
    nullptr,                                          /*tp_del */
    0,                                                /*tp_version_tag */
    nullptr                                           /*tp_finalize */
#if PY_VERSION_HEX >= 0x03090000
    ,nullptr                                          /*tp_vectorcall */
#if PY_VERSION_HEX >= 0x030c0000
    ,0                                                /*tp_watched */
#endif
#elif PY_VERSION_HEX >= 0x03080000
    ,nullptr                                          /*tp_vectorcall */
    /* bpo-37250: kept for backwards compatibility in CPython 3.8 only */
    ,nullptr                                          /*tp_print */
#endif
};

/// Methods structure of PropertyContainerPy
PyMethodDef PropertyContainerPy::Methods[] = {
    {"getPropertyByName",
        reinterpret_cast<PyCFunction>( staticCallback_getPropertyByName ),
        METH_VARARGS,
        "getPropertyByName(name, checkOwner=0) -> object or Tuple\n"
        "\n"
        "Returns the value of a named property. Note that the returned property may not\n"
        "always belong to this container (e.g. from a linked object).\n"
        "\n"
        "name : str\n"
        "     Name of the property.\n"
        "checkOwner : int\n"
        "    0: just return the property.\n"
        "    1: raise exception if not found or the property does not belong to this container.\n"
        "    2: return a tuple (owner, propertyValue)."
    },
    {"getPropertyTouchList",
        reinterpret_cast<PyCFunction>( staticCallback_getPropertyTouchList ),
        METH_VARARGS,
        "getPropertyTouchList(name) -> tuple\n"
        "\n"
        "Returns a list of index of touched values for list type properties.\n"
        "\n"
        "name : str\n"
        "    Property name."
    },
    {"getTypeOfProperty",
        reinterpret_cast<PyCFunction>( staticCallback_getTypeOfProperty ),
        METH_VARARGS,
        "getTypeOfProperty(name) -> list\n"
        "\n"
        "Returns the type of a named property. This can be a list conformed by elements in\n"
        "(Hidden, NoRecompute, NoPersist, Output, ReadOnly, Transient).\n"
        "\n"
        "name : str\n"
        "    Property name."
    },
    {"getTypeIdOfProperty",
        reinterpret_cast<PyCFunction>( staticCallback_getTypeIdOfProperty ),
        METH_VARARGS,
        "getTypeIdOfProperty(name) -> str\n"
        "\n"
        "Returns the C++ class name of a named property.\n"
        "\n"
        "name : str\n"
        "    Property name."
    },
    {"setEditorMode",
        reinterpret_cast<PyCFunction>( staticCallback_setEditorMode ),
        METH_VARARGS,
        "setEditorMode(name, type) -> None\n"
        "\n"
        "Set the behaviour of the property in the property editor.\n"
        "\n"
        "name : str\n"
        "    Property name.\n"
        "type : int, sequence of str\n"
        "    Property type.\n"
        "    0: default behaviour. 1: item is ready-only. 2: item is hidden. 3: item is hidden and read-only.\n"
        "    If sequence, the available items are 'ReadOnly' and 'Hidden'."
    },
    {"getEditorMode",
        reinterpret_cast<PyCFunction>( staticCallback_getEditorMode ),
        METH_VARARGS,
        "getEditorMode(name) -> list\n"
        "\n"
        "Get the behaviour of the property in the property editor.\n"
        "It returns a list of strings with the current mode. If the list is empty there are no\n"
        "special restrictions.\n"
        "If the list contains 'ReadOnly' then the item appears in the property editor but is\n"
        "disabled.\n"
        "If the list contains 'Hidden' then the item even doesn't appear in the property editor.\n"
        "\n"
        "name : str\n"
        "    Property name."
    },
    {"getGroupOfProperty",
        reinterpret_cast<PyCFunction>( staticCallback_getGroupOfProperty ),
        METH_VARARGS,
        "getGroupOfProperty(name) -> str\n"
        "\n"
        "Returns the name of the group which the property belongs to in this class.\n"
        "The properties are sorted in different named groups for convenience.\n"
        "\n"
        "name : str\n"
        "    Property name."
    },
    {"setGroupOfProperty",
        reinterpret_cast<PyCFunction>( staticCallback_setGroupOfProperty ),
        METH_VARARGS,
        "setGroupOfProperty(name, group) -> None\n"
        "\n"
        "Set the name of the group of a dynamic property.\n"
        "\n"
        "name : str\n"
        "    Property name.\n"
        "group : str\n"
        "    Group name."
    },
    {"setPropertyStatus",
        reinterpret_cast<PyCFunction>( staticCallback_setPropertyStatus ),
        METH_VARARGS,
        "setPropertyStatus(name, val) -> None\n"
        "\n"
        "Set property status.\n"
        "\n"
        "name : str\n"
        "    Property name.\n"
        "val : int, str, sequence of str or int\n"
        "    Call getPropertyStatus() to get a list of supported text value.\n"
        "    If the text start with '-' or the integer value is negative, then the status is cleared."
    },
    {"getPropertyStatus",
        reinterpret_cast<PyCFunction>( staticCallback_getPropertyStatus ),
        METH_VARARGS,
        "getPropertyStatus(name='') -> list\n"
        "\n"
        "Get property status.\n"
        "\n"
        "name : str\n"
        "    Property name. If empty, returns a list of supported text names of the status."
    },
    {"getDocumentationOfProperty",
        reinterpret_cast<PyCFunction>( staticCallback_getDocumentationOfProperty ),
        METH_VARARGS,
        "getDocumentationOfProperty(name) -> str\n"
        "\n"
        "Returns the documentation string of the property of this class.\n"
        "\n"
        "name : str\n"
        "    Property name."
    },
    {"setDocumentationOfProperty",
        reinterpret_cast<PyCFunction>( staticCallback_setDocumentationOfProperty ),
        METH_VARARGS,
        "setDocumentationOfProperty(name, docstring) -> None\n"
        "\n"
        "Set the documentation string of a dynamic property of this class.\n"
        "\n"
        "name : str\n"
        "    Property name.\n"
        "docstring : str\n"
        "    Documentation string."
    },
    {"getEnumerationsOfProperty",
        reinterpret_cast<PyCFunction>( staticCallback_getEnumerationsOfProperty ),
        METH_VARARGS,
        "getEnumerationsOfProperty(name) -> list or  None\n"
        "\n"
        "Return all enumeration strings of the property of this class or None if not a\n"
        "PropertyEnumeration.\n"
        "\n"
        "name : str\n"
        "    Property name."
    },
    {"dumpPropertyContent",
        reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) ()>( staticCallback_dumpPropertyContent )),
        METH_VARARGS|METH_KEYWORDS,
        "dumpPropertyContent(Property, Compression=3) -> bytearray\n"
        "\n"
        "Dumps the content of the property, both the XML representation and the additional\n"
        "data files required, into a byte representation.\n"
        "\n"
        "Property : str\n"
        "    Property Name.\n"
        "Compression : int\n"
        "    Set the data compression level in the range [0, 9]. Set to 0 for no compression."
    },
    {"restorePropertyContent",
        reinterpret_cast<PyCFunction>( staticCallback_restorePropertyContent ),
        METH_VARARGS,
        "restorePropertyContent(name, obj) -> None\n"
        "\n"
        "Restore the content of the object from a byte representation as stored by `dumpPropertyContent`.\n"
        "It could be restored from any Python object implementing the buffer protocol.\n"
        "\n"
        "name : str\n"
        "    Property name.\n"
        "obj : buffer\n"
        "    Object with buffer protocol support."
    },
    {nullptr, nullptr, 0, nullptr}		/* Sentinel */
};



/// Attribute structure of PropertyContainerPy
PyGetSetDef PropertyContainerPy::GetterSetter[] = {
    {"PropertiesList",
        (getter) staticCallback_getPropertiesList,
        (setter) staticCallback_setPropertiesList,
        "A list of all property names.",
        nullptr
    },
    {nullptr, nullptr, nullptr, nullptr, nullptr}		/* Sentinel */
};

// getPropertyByName() callback and implementer
// PyObject*  PropertyContainerPy::getPropertyByName(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_getPropertyByName (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getPropertyByName' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->getPropertyByName(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getPropertyTouchList() callback and implementer
// PyObject*  PropertyContainerPy::getPropertyTouchList(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_getPropertyTouchList (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getPropertyTouchList' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->getPropertyTouchList(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getTypeOfProperty() callback and implementer
// PyObject*  PropertyContainerPy::getTypeOfProperty(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_getTypeOfProperty (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getTypeOfProperty' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->getTypeOfProperty(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getTypeIdOfProperty() callback and implementer
// PyObject*  PropertyContainerPy::getTypeIdOfProperty(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_getTypeIdOfProperty (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getTypeIdOfProperty' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->getTypeIdOfProperty(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setEditorMode() callback and implementer
// PyObject*  PropertyContainerPy::setEditorMode(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_setEditorMode (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setEditorMode' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->setEditorMode(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getEditorMode() callback and implementer
// PyObject*  PropertyContainerPy::getEditorMode(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_getEditorMode (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getEditorMode' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->getEditorMode(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getGroupOfProperty() callback and implementer
// PyObject*  PropertyContainerPy::getGroupOfProperty(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_getGroupOfProperty (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getGroupOfProperty' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->getGroupOfProperty(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setGroupOfProperty() callback and implementer
// PyObject*  PropertyContainerPy::setGroupOfProperty(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_setGroupOfProperty (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setGroupOfProperty' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->setGroupOfProperty(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setPropertyStatus() callback and implementer
// PyObject*  PropertyContainerPy::setPropertyStatus(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_setPropertyStatus (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setPropertyStatus' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->setPropertyStatus(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getPropertyStatus() callback and implementer
// PyObject*  PropertyContainerPy::getPropertyStatus(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_getPropertyStatus (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getPropertyStatus' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->getPropertyStatus(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getDocumentationOfProperty() callback and implementer
// PyObject*  PropertyContainerPy::getDocumentationOfProperty(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_getDocumentationOfProperty (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getDocumentationOfProperty' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->getDocumentationOfProperty(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// setDocumentationOfProperty() callback and implementer
// PyObject*  PropertyContainerPy::setDocumentationOfProperty(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_setDocumentationOfProperty (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'setDocumentationOfProperty' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->setDocumentationOfProperty(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// getEnumerationsOfProperty() callback and implementer
// PyObject*  PropertyContainerPy::getEnumerationsOfProperty(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_getEnumerationsOfProperty (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'getEnumerationsOfProperty' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->getEnumerationsOfProperty(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// dumpPropertyContent() callback and implementer
// PyObject*  PropertyContainerPy::dumpPropertyContent(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_dumpPropertyContent (PyObject *self, PyObject *args, PyObject * kwd)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'dumpPropertyContent' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }


    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->dumpPropertyContent(args, kwd);
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// restorePropertyContent() callback and implementer
// PyObject*  PropertyContainerPy::restorePropertyContent(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_restorePropertyContent (PyObject *self, PyObject *args)
{
    // make sure that not a null pointer is passed
    if (!self) {
        PyErr_SetString(PyExc_TypeError, "descriptor 'restorePropertyContent' of 'App.PropertyContainer' object needs an argument");
        return nullptr;
    }

    // test if twin object isn't already deleted
    if (!static_cast<PyObjectBase*>(self)->isValid()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    // test if object is set Const
    if (static_cast<PyObjectBase*>(self)->isConst()) {
        PyErr_SetString(PyExc_ReferenceError, "This object is immutable, you can not set any attribute or call a non const method");
        return nullptr;
    }

    try { // catches all exceptions coming up from c++ and generate a python exception
        PyObject* ret = static_cast<PropertyContainerPy*>(self)->restorePropertyContent(args);
        if (ret != nullptr)
            static_cast<PropertyContainerPy*>(self)->startNotify();
        return ret;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return nullptr;
    }
#endif
}

// PropertiesList() callback and implementer
// PyObject*  PropertyContainerPy::PropertiesList(PyObject *args){};
// has to be implemented in PropertyContainerPyImp.cpp
PyObject * PropertyContainerPy::staticCallback_getPropertiesList (PyObject *self, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return nullptr;
    }

    try {
        return Py::new_reference_to(static_cast<PropertyContainerPy*>(self)->getPropertiesList());
    } catch (const Py::Exception&) {
        // The exception text is already set
        return nullptr;
    } catch (...) {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown exception while reading attribute 'PropertiesList' of object 'PropertyContainer'");
        return nullptr;
    }
}

int PropertyContainerPy::staticCallback_setPropertiesList (PyObject *self, PyObject * /*value*/, void * /*closure*/)
{
    if (!static_cast<PyObjectBase*>(self)->isValid()){
        PyErr_SetString(PyExc_ReferenceError, "This object is already deleted most likely through closing a document. This reference is no longer valid!");
        return -1;
    }

    PyErr_SetString(PyExc_AttributeError, "Attribute 'PropertiesList' of object 'PropertyContainer' is read-only");
    return -1;
}




//--------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
PropertyContainerPy::PropertyContainerPy(PropertyContainer *pcObject, PyTypeObject *T)
    : PersistencePy(static_cast<PersistencePy::PointerType>(pcObject), T)
{
    this->setShouldNotify(false);
}

PyObject *PropertyContainerPy::PyMake(PyTypeObject* /*type*/, PyObject* /*args*/, PyObject* /*kwds*/)
{
    // never create such objects with the constructor
    PyErr_SetString(PyExc_RuntimeError, "You cannot create directly an instance of 'PropertyContainerPy'.");

    return nullptr;
}

int PropertyContainerPy::PyInit(PyObject* /*args*/, PyObject* /*kwd*/)
{
    return 0;
}

//--------------------------------------------------------------------------
// destructor
//--------------------------------------------------------------------------
PropertyContainerPy::~PropertyContainerPy()                                // Everything handled in parent
{
}

//--------------------------------------------------------------------------
// PropertyContainerPy representation
//--------------------------------------------------------------------------
PyObject *PropertyContainerPy::_repr()
{
    return Py_BuildValue("s", representation().c_str());
}

//--------------------------------------------------------------------------
// PropertyContainerPy Attributes
//--------------------------------------------------------------------------
PyObject *PropertyContainerPy::_getattr(const char *attr)			// __getattr__ function: note only need to handle new state
{
    try {
        // getter method for special Attributes (e.g. dynamic ones)
        PyObject *r = getCustomAttributes(attr);
        if(r) return r;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return nullptr;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return nullptr;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return nullptr;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError,"Unknown C++ exception");
        return nullptr;
    }
#endif

    PyMethodDef *ml = Methods;
    for (; ml->ml_name != nullptr; ml++) {
        if (attr[0] == ml->ml_name[0] &&
            strcmp(attr+1, ml->ml_name+1) == 0)
            return PyCFunction_New(ml, this);
    }

    PyErr_Clear();
    return PersistencePy::_getattr(attr);
}

int PropertyContainerPy::_setattr(const char *attr, PyObject *value) // __setattr__ function: note only need to handle new state
{
    try {
        // setter for special Attributes (e.g. dynamic ones)
        int r = setCustomAttributes(attr, value);
        // r = 1: handled
        // r = -1: error
        // r = 0: ignore
        if (r == 1)
            return 0;
        else if (r == -1)
            return -1;
    } // Please sync the following catch implementation with PY_CATCH
    catch(Base::Exception &e)
    {
        auto pye = e.getPyExceptionType();
        if(!pye)
            pye = Base::PyExc_FC_GeneralError;
        PyErr_SetObject(pye, e.getPyObject());
        return -1;
    }
    catch(const std::exception &e)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, e.what());
        return -1;
    }
    catch(const Py::Exception&)
    {
        // The exception text is already set
        return -1;
    }
#ifndef DONT_CATCH_CXX_EXCEPTIONS
    catch(...)
    {
        PyErr_SetString(Base::PyExc_FC_GeneralError, "Unknown C++ exception");
        return -1;
    }
#endif

    return PersistencePy::_setattr(attr, value);
}

PropertyContainer *PropertyContainerPy::getPropertyContainerPtr() const
{
    return static_cast<PropertyContainer *>(_pcTwinPointer);
}

#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#if 0
/* From here on come the methods you have to implement, but NOT in this module. Implement in PropertyContainerPyImp.cpp! This prototypes
 * are just for convenience when you add a new method.
 */



// returns a string which represents the object e.g. when printed in python
std::string PropertyContainerPy::representation() const
{
    return {"<PropertyContainer object>"};
}

PyObject* PropertyContainerPy::getPropertyByName(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::getPropertyTouchList(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::getTypeOfProperty(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::getTypeIdOfProperty(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::setEditorMode(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::getEditorMode(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::getGroupOfProperty(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::setGroupOfProperty(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::setPropertyStatus(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::getPropertyStatus(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::getDocumentationOfProperty(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::setDocumentationOfProperty(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::getEnumerationsOfProperty(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::dumpPropertyContent(PyObject *args, PyObject *kwds)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}

PyObject* PropertyContainerPy::restorePropertyContent(PyObject *args)
{
    PyErr_SetString(PyExc_NotImplementedError, "Not yet implemented");
    return nullptr;
}



Py::List PropertyContainerPy::getPropertiesList() const
{
    //return Py::List();
    throw Py::AttributeError("Not yet implemented");
}

PyObject *PropertyContainerPy::getCustomAttributes(const char* /*attr*/) const
{
    return nullptr;
}

int PropertyContainerPy::setCustomAttributes(const char* /*attr*/, PyObject* /*obj*/)
{
    return 0;
}


#endif



